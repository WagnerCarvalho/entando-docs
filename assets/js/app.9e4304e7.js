(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(e){function n(n){for(var a,r,s=n[0],l=n[1],d=n[2],u=0,p=[];u<s.length;u++)r=s[u],Object.prototype.hasOwnProperty.call(o,r)&&o[r]&&p.push(o[r][0]),o[r]=0;for(a in l)Object.prototype.hasOwnProperty.call(l,a)&&(e[a]=l[a]);for(c&&c(n);p.length;)p.shift()();return i.push.apply(i,d||[]),t()}function t(){for(var e,n=0;n<i.length;n++){for(var t=i[n],a=!0,s=1;s<t.length;s++){var l=t[s];0!==o[l]&&(a=!1)}a&&(i.splice(n--,1),e=r(r.s=t[0]))}return e}var a={},o={2:0},i=[];function r(n){if(a[n])return a[n].exports;var t=a[n]={i:n,l:!1,exports:{}};return e[n].call(t.exports,t,t.exports,r),t.l=!0,t.exports}r.e=function(e){var n=[],t=o[e];if(0!==t)if(t)n.push(t[2]);else{var a=new Promise((function(n,a){t=o[e]=[n,a]}));n.push(t[2]=a);var i,s=document.createElement("script");s.charset="utf-8",s.timeout=120,r.nc&&s.setAttribute("nonce",r.nc),s.src=function(e){return r.p+"assets/js/"+({}[e]||e)+"."+{1:"82069f05",3:"8209ebe4",4:"e5f7b8f4",5:"644e9514",6:"9aa9b282",7:"8604e512",8:"6fcae153",9:"ea12e510",10:"33a90d17",11:"01e85948",12:"f8451b05",13:"faa1fa27",14:"cf822c2f",15:"a91805c5",16:"bba86bbf",17:"c5b05827",18:"aa2ea75a",19:"93342049",20:"fb63bd52",21:"7d8df9d0",22:"8bc207fe",23:"a8965105",24:"8ec20e2e",25:"065d77f7",26:"b19a4f9a",27:"72ecc8a9",28:"b0296d01",29:"78eb4038",30:"73b5831a",31:"8ae9f21e",32:"354e02ab",33:"55e59997",34:"8309e32c",35:"01a12024",36:"5d5aca62",37:"a6a19d5d",38:"b0201588",39:"6f61b74b",40:"3641fe75",41:"a6d4a776",42:"04ad1b76",43:"9ef60d39",44:"c28f4b3a",45:"31d6c764",46:"29a27520",47:"4586f6e2",48:"0ec3eb4e",49:"3e3b7bcc",50:"0b9b6d30",51:"f73b7e3f",52:"869c41f2",53:"088a27d6",54:"f9a1de29",55:"3cb92417",56:"6bfc20ec",57:"2d73b01a",58:"a9541877",59:"cdb21175",60:"8369efa1",61:"128c2685",62:"58a997bc",63:"7c1ef0dc",64:"522b3ba5",65:"029a8d04",66:"1a996df4",67:"28f010c0",68:"d765e999",69:"66e4dcf1",70:"7a62c721",71:"972cb564",72:"fc1688dc",73:"6a481265",74:"f14fe38b",75:"30cb57a0",76:"61cacb07",77:"c4b47348",78:"948cdb19",79:"be11682d",80:"0572237b",81:"565d1f46",82:"c87c7436",83:"f50e7265",84:"ea91668c",85:"9cdb88cb",86:"329c86d9",87:"320399bf",88:"ec99339a",89:"d01896f6",90:"31ae1485",91:"cd547e8a",92:"7368fd84",93:"a36c534d",94:"64a1ad48",95:"de187fa9",96:"06f595e1",97:"d0c9957d",98:"b3e5219f",99:"ece436ed",100:"c39af8e7",101:"87646921",102:"286c0d40",103:"4e1ed747",104:"55b8072c",105:"31df4f9d",106:"34f9d68a",107:"52c8ad70",108:"ecc629c9",109:"65240e2d",110:"398b25ad",111:"b11023de",112:"a27c232e",113:"572d2ac9",114:"0742ffd0",115:"0420855c",116:"1fdcdffc",117:"6adb8890",118:"9023ce55",119:"29523d00",120:"336145bb",121:"c26187cf",122:"442fea2d",123:"11a71c03",124:"c7c9df5f",125:"89827b4e",126:"847f329a",127:"c51d5166",128:"1a11c12f",129:"e520b7df",130:"a39fe7d0",131:"0a732a9c",132:"9a93786b",133:"db8d584e",134:"c43ec590",135:"410d2a3d",136:"36257c49",137:"bfdf3174",138:"b9d63c64",139:"b9408602",140:"8de0a5a1",141:"53240f3c",142:"111eb877",143:"5b8070de",144:"281f749f",145:"491a065d",146:"a248a5bd",147:"f009831c",148:"2b412e1b",149:"7d3a32e7",150:"5651ea55",151:"dc5da172",152:"139465af",153:"df58561c",154:"73e74917",155:"1367d633",156:"34a58d81",157:"001648c3",158:"1330bf3e",159:"1a06441c",160:"1445c8bc",161:"1a6cd81d",162:"1f0afa43",163:"1fb221c0",164:"cb4b8ace",165:"91afa081",166:"3a5a5661",167:"a756db7e",168:"5b703ad5",169:"9786f6d7",170:"e668889f",171:"0e036804",172:"5259a510",173:"9272bb98",174:"017b0a7d",175:"06647c7c",176:"1ca78e89",177:"1b063a27",178:"dfcaca98",179:"d86b47f8",180:"7f4777e8",181:"4dfdbee5",182:"4d0702c4",183:"8e0cc6bd",184:"5f7c80ba",185:"fca576bb",186:"e63c4bda",187:"6b704fd7",188:"27b8c0e5",189:"b35d4a14",190:"ee966eb8",191:"4bd0b17d",192:"87accd56",193:"5fd673a8",194:"b052c667",195:"2d094e23",196:"94e2ea19",197:"089a72ce",198:"dd56dd59",199:"e46ff04c",200:"dca5963e",201:"9f532b5d",202:"3ba362d7",203:"9505b044",204:"1d6409cf",205:"4e76f052",206:"afe40c70",207:"37b52f07",208:"d74126af",209:"5e81754f",210:"7a4bb368",211:"0aca7cdc",212:"245fe91d",213:"f3d890d3",214:"38e7babc",215:"10ad9036",216:"b098a8c4",217:"d3f2e49e",218:"9be37271",219:"79237bab",220:"0c7181be",221:"ce2ce1fa",222:"8e8a7ba5",223:"ef482064",224:"6c959df9",225:"af9b0119",226:"e27c6424",227:"e916b68a",228:"6200aa1b",229:"2f29817a",230:"216f9d7e",231:"ced97682",232:"6db073ac",233:"0b9d1397",234:"73c5e396",235:"4aa179e3",236:"fca06bea",237:"f82b1a4b",238:"26a3c20b",239:"3ca6b359",240:"dc229b8b",241:"5d25ebb7",242:"6e442dfd",243:"d276922c",244:"f63f352e",245:"7f12d147",246:"091594df",247:"4ee0a084",248:"66e28f41",249:"2336f6a1",250:"ae8153dc",251:"6d17e26d",252:"c5e29004",253:"6cc6b837",254:"b86ca01c",255:"3b16524b",256:"d0825cad",257:"bd81a58d",258:"a6fa72b1",259:"55bdcc76",260:"f33a5b37",261:"7785e62f",262:"b171f70d",263:"de54effb",264:"e869b520",265:"9adf46d6",266:"838e116b",267:"1005090d",268:"9bac0e09",269:"97796e67",270:"2d18e925",271:"5d7715e4",272:"816a4907",273:"42788a1f",274:"e76660fb",275:"199ba4d5",276:"38b3c50a",277:"68f5e3e6",278:"d4f01341",279:"152b51e9",280:"f40a807c",281:"b92352b6",282:"30a9ffee",283:"75ee6785",284:"4f059627",285:"aec4d914",286:"72c39601",287:"58d3d2ea",288:"bfeb6fb0",289:"7fc0f7f8",290:"44eb51ea",291:"fa8d50f5",292:"a93a1b4a",293:"8a92cca0",294:"06305d5e",295:"af653c60",296:"d859ea3f",297:"1a0c6037",298:"35dfe8f8",299:"3ea625d7",300:"a8575555",301:"e83b0c09",302:"3b5eba47",303:"3ef57352",304:"2d684e99",305:"c0b358ed",306:"d15a8c16",307:"951a9ecb",308:"a99fa664",309:"60dd99db",310:"367591b2",311:"759a7976",312:"400f0f91",313:"2bfaa36f",314:"fbef0c0c",315:"d3a5b87f",316:"81fa825b",317:"d77240cf",318:"263f476e",319:"b3274329",320:"ce396be1",321:"4c38a4d0",322:"7c4cab11",323:"2bfd747d",324:"ad814e90",325:"f39a4189",326:"85d9cdc0",327:"852070e9",328:"68026ad9",329:"8e436886",330:"3114eefb",331:"c42cdaa8",332:"e1fd3997",333:"b620d4b3",334:"0f73a4bb",335:"3618c390",336:"96700425",337:"30d28992",338:"3c38d590",339:"67ef7e78",340:"30e5417b",341:"b90354df",342:"a5e73c43",343:"132e56c0",344:"64b4b62f",345:"b861d7a2",346:"4054a5e9",347:"5373c9ee",348:"fcb9b935",349:"eadeea0b",350:"19aed990",351:"d5d3715a",352:"5d02ad39",353:"0193a0b6",354:"93d39407",355:"4f95a235",356:"cbff63cc",357:"a2e8e5cc",358:"8f04f743",359:"e39f53df",360:"f701d5b8",361:"bf42850d",362:"1c58a454",363:"c0a96772",364:"4cd546fc",365:"9895fddc",366:"b3d09e22",367:"20c2dcbd",368:"e9361d57",369:"aa2438a6",370:"17158a54",371:"1c18680b",372:"1186288a",373:"902b318f",374:"679cb966",375:"c8f3434e",376:"fa119240",377:"816ddbc1",378:"85dfbc55",379:"d56ad5c9",380:"fe43b80e",381:"9c5da155",382:"35b29529",383:"5bd5d1f0",384:"6b4fce29",385:"b6cea476",386:"422448b2",387:"25f85fbf",388:"e76bfcd6",389:"ab4a3ea6",390:"752a4beb",391:"f8484eec",392:"3a92ce8e",393:"5740f1df",394:"04809562",395:"f947a784",396:"0f20710a",397:"6c80caf9",398:"e891ea9b",399:"aa10e39a",400:"a38f3d5b",401:"0a33fcb2",402:"aec7d8f8",403:"ab5e9b4c",404:"1145705c",405:"07f70fa5",406:"189b25c7",407:"300e27da",408:"b54a67b6",409:"cff6c368",410:"c675da5f",411:"9473b9ac",412:"ebe2dedb",413:"23d8e6a6",414:"d6c40401",415:"92875cbc",416:"b381d2c3",417:"431f346d",418:"7dd227e2",419:"8b9fc8e5",420:"13228e35",421:"6baa70fd",422:"df3abdb1",423:"772a7ddd",424:"edd82695",425:"e6c489d3",426:"9a2348de",427:"ede72dbf",428:"1a1514c0",429:"4100f9a7",430:"2b0b2235",431:"6970915c",432:"779e8d2e",433:"5e67b65c",434:"a86e1fee",435:"afa78853",436:"3bafbe18",437:"b5280dfc",438:"b961469d",439:"7edc3ef4",440:"5b26ce72",441:"b381bb08",442:"484c37f5",443:"d02b81d7",444:"886439f3",445:"4e256ef2",446:"401cfca0",447:"045f2057",448:"049e03e1",449:"686b903e",450:"0adbade3",451:"e74d9610",452:"c431b537",453:"8ceee77d",454:"a51de999",455:"84fad9d4",456:"a5d48681",457:"265f1b53",458:"5cfb6184",459:"777de8a1",460:"16cefafb",461:"88ae99e2",462:"4ee0fd80",463:"dfcfc996",464:"dd7a52c4",465:"0f4dbaef",466:"c3e6954f",467:"c60900aa",468:"9ca9ddd6",469:"45708b11",470:"38feb07f",471:"debf32bf",472:"827beeee",473:"3a4adb4e",474:"2ad5ce94",475:"dc6312e1",476:"4b935ef2",477:"83e92f00",478:"04d7e92a",479:"6b8213ea",480:"53778778",481:"20e62328",482:"104e3616",483:"9c584d28",484:"0389bd1a",485:"77fca142",486:"c8a214f5",487:"e928f5ef",488:"8477a2ad",489:"182d94b7",490:"d5d334a6",491:"fd785a93",492:"8b36dd76",493:"3f6b98e8",494:"5d565406",495:"7165e91d",496:"ec8175a8",497:"0c2b1e10",498:"d0b69774",499:"e9483096",500:"c8964451",501:"457ea097",502:"6e324572",503:"aa8cf2e9",504:"10e191ff",505:"74ef29d5",506:"60971465",507:"fe827bcd"}[e]+".js"}(e);var l=new Error;i=function(n){s.onerror=s.onload=null,clearTimeout(d);var t=o[e];if(0!==t){if(t){var a=n&&("load"===n.type?"missing":n.type),i=n&&n.target&&n.target.src;l.message="Loading chunk "+e+" failed.\n("+a+": "+i+")",l.name="ChunkLoadError",l.type=a,l.request=i,t[1](l)}o[e]=void 0}};var d=setTimeout((function(){i({type:"timeout",target:s})}),12e4);s.onerror=s.onload=i,document.head.appendChild(s)}return Promise.all(n)},r.m=e,r.c=a,r.d=function(e,n,t){r.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,n){if(1&n&&(e=r(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(r.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var a in e)r.d(t,a,function(n){return e[n]}.bind(null,a));return t},r.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(n,"a",n),n},r.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},r.p="/entando-docs/",r.oe=function(e){throw console.error(e),e};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=n,s=s.slice();for(var d=0;d<s.length;d++)n(s[d]);var c=l;i.push([205,0]),t()}([function(e,n){var t=function(e){return e&&e.Math==Math&&e};e.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(e,n){var t=Function.prototype,a=t.bind,o=t.call,i=a&&a.bind(o,o);e.exports=a?function(e){return e&&i(e)}:function(e){return e&&function(){return o.apply(e,arguments)}}},function(e,n){e.exports=function(e){try{return!!e()}catch(e){return!0}}},function(e,n,t){var a=t(0),o=t(26).f,i=t(21),r=t(16),s=t(93),l=t(98),d=t(89);e.exports=function(e,n){var t,c,u,p,h,m=e.target,g=e.global,f=e.stat;if(t=g?a:f?a[m]||s(m,{}):(a[m]||{}).prototype)for(c in n){if(p=n[c],u=e.noTargetGet?(h=o(t,c))&&h.value:t[c],!d(g?c:m+(f?".":"#")+c,e.forced)&&void 0!==u){if(typeof p==typeof u)continue;l(p,u)}(e.sham||u&&u.sham)&&i(p,"sham",!0),r(t,c,p,e)}}},function(e,n,t){var a=t(0),o=t(61),i=t(8),r=t(62),s=t(94),l=t(127),d=o("wks"),c=a.Symbol,u=c&&c.for,p=l?c:c&&c.withoutSetter||r;e.exports=function(e){if(!i(d,e)||!s&&"string"!=typeof d[e]){var n="Symbol."+e;s&&i(c,e)?d[e]=c[e]:d[e]=l&&u?u(n):p(n)}return d[e]}},function(e,n){e.exports=function(e){return"function"==typeof e}},function(e,n,t){var a=t(102),o=t(16),i=t(224);a||o(Object.prototype,"toString",i,{unsafe:!0})},function(e,n,t){var a=t(5);e.exports=function(e){return"object"==typeof e?null!==e:a(e)}},function(e,n,t){var a=t(1),o=t(19),i=a({}.hasOwnProperty);e.exports=Object.hasOwn||function(e,n){return i(o(e),n)}},function(e,n,t){var a=t(0),o=t(7),i=a.String,r=a.TypeError;e.exports=function(e){if(o(e))return e;throw r(i(e)+" is not an object")}},function(e,n,t){var a=t(2);e.exports=!a((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(e,n){var t=Function.prototype.call;e.exports=t.bind?t.bind(t):function(){return t.apply(t,arguments)}},function(e,n,t){var a=t(0),o=t(10),i=t(130),r=t(129),s=t(9),l=t(66),d=a.TypeError,c=Object.defineProperty,u=Object.getOwnPropertyDescriptor;n.f=o?r?function(e,n,t){if(s(e),n=l(n),s(t),"function"==typeof e&&"prototype"===n&&"value"in t&&"writable"in t&&!t.writable){var a=u(e,n);a&&a.writable&&(e[n]=t.value,t={configurable:"configurable"in t?t.configurable:a.configurable,enumerable:"enumerable"in t?t.enumerable:a.enumerable,writable:!1})}return c(e,n,t)}:c:function(e,n,t){if(s(e),n=l(n),s(t),i)try{return c(e,n,t)}catch(e){}if("get"in t||"set"in t)throw d("Accessors not supported");return"value"in t&&(e[n]=t.value),e}},function(e,n,t){var a=t(0),o=t(5),i=function(e){return o(e)?e:void 0};e.exports=function(e,n){return arguments.length<2?i(a[e]):a[e]&&a[e][n]}},function(e,n,t){var a=t(60),o=t(28);e.exports=function(e){return a(o(e))}},function(e,n,t){var a=t(0),o=t(74),i=a.String;e.exports=function(e){if("Symbol"===o(e))throw TypeError("Cannot convert a Symbol value to a string");return i(e)}},function(e,n,t){var a=t(0),o=t(5),i=t(8),r=t(21),s=t(93),l=t(72),d=t(34),c=t(88).CONFIGURABLE,u=d.get,p=d.enforce,h=String(String).split("String");(e.exports=function(e,n,t,l){var d,u=!!l&&!!l.unsafe,m=!!l&&!!l.enumerable,g=!!l&&!!l.noTargetGet,f=l&&void 0!==l.name?l.name:n;o(t)&&("Symbol("===String(f).slice(0,7)&&(f="["+String(f).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),(!i(t,"name")||c&&t.name!==f)&&r(t,"name",f),(d=p(t)).source||(d.source=h.join("string"==typeof f?f:""))),e!==a?(u?!g&&e[n]&&(m=!0):delete e[n],m?e[n]=t:r(e,n,t)):m?e[n]=t:s(n,t)})(Function.prototype,"toString",(function(){return o(this)&&u(this).source||l(this)}))},function(e,n,t){"use strict";var a=t(149).charAt,o=t(15),i=t(34),r=t(135),s=i.set,l=i.getterFor("String Iterator");r(String,"String",(function(e){s(this,{type:"String Iterator",string:o(e),index:0})}),(function(){var e,n=l(this),t=n.string,o=n.index;return o>=t.length?{value:void 0,done:!0}:(e=a(t,o),n.index+=e.length,{value:e,done:!1})}))},function(e,n){var t=Array.isArray;e.exports=t},function(e,n,t){var a=t(0),o=t(28),i=a.Object;e.exports=function(e){return i(o(e))}},function(e,n){e.exports=!1},function(e,n,t){var a=t(10),o=t(12),i=t(40);e.exports=a?function(e,n,t){return o.f(e,n,i(1,t))}:function(e,n,t){return e[n]=t,e}},function(e,n,t){var a=t(0),o=t(150),i=t(151),r=t(126),s=t(21),l=t(4),d=l("iterator"),c=l("toStringTag"),u=r.values,p=function(e,n){if(e){if(e[d]!==u)try{s(e,d,u)}catch(n){e[d]=u}if(e[c]||s(e,c,n),o[n])for(var t in r)if(e[t]!==r[t])try{s(e,t,r[t])}catch(n){e[t]=r[t]}}};for(var h in o)p(a[h]&&a[h].prototype,h);p(i,"DOMTokenList")},function(e,n,t){var a=t(161),o="object"==typeof self&&self&&self.Object===Object&&self,i=a||o||Function("return this")();e.exports=i},function(e,n,t){"use strict";var a=t(3),o=t(91);a({target:"RegExp",proto:!0,forced:/./.exec!==o},{exec:o})},function(e,n,t){var a=t(1),o=a({}.toString),i=a("".slice);e.exports=function(e){return i(o(e),8,-1)}},function(e,n,t){var a=t(10),o=t(11),i=t(97),r=t(40),s=t(14),l=t(66),d=t(8),c=t(130),u=Object.getOwnPropertyDescriptor;n.f=a?u:function(e,n){if(e=s(e),n=l(n),c)try{return u(e,n)}catch(e){}if(d(e,n))return r(!o(i.f,e,n),e[n])}},function(e,n,t){var a=t(3),o=t(0),i=t(35),r=t(234),s=o.WebAssembly,l=7!==Error("e",{cause:7}).cause,d=function(e,n){var t={};t[e]=r(e,n,l),a({global:!0,forced:l},t)},c=function(e,n){if(s&&s[e]){var t={};t[e]=r("WebAssembly."+e,n,l),a({target:"WebAssembly",stat:!0,forced:l},t)}};d("Error",(function(e){return function(n){return i(e,this,arguments)}})),d("EvalError",(function(e){return function(n){return i(e,this,arguments)}})),d("RangeError",(function(e){return function(n){return i(e,this,arguments)}})),d("ReferenceError",(function(e){return function(n){return i(e,this,arguments)}})),d("SyntaxError",(function(e){return function(n){return i(e,this,arguments)}})),d("TypeError",(function(e){return function(n){return i(e,this,arguments)}})),d("URIError",(function(e){return function(n){return i(e,this,arguments)}})),c("CompileError",(function(e){return function(n){return i(e,this,arguments)}})),c("LinkError",(function(e){return function(n){return i(e,this,arguments)}})),c("RuntimeError",(function(e){return function(n){return i(e,this,arguments)}}))},function(e,n,t){var a=t(0).TypeError;e.exports=function(e){if(null==e)throw a("Can't call method on "+e);return e}},function(e,n,t){var a=t(1);e.exports=a({}.isPrototypeOf)},function(e,n,t){var a=t(86);e.exports=function(e){return a(e.length)}},function(e,n,t){var a=t(258),o=t(261);e.exports=function(e,n){var t=o(e,n);return a(t)?t:void 0}},function(e,n,t){"use strict";function a(e,n,t,a,o,i,r,s){var l,d="function"==typeof e?e.options:e;if(n&&(d.render=n,d.staticRenderFns=t,d._compiled=!0),a&&(d.functional=!0),i&&(d._scopeId="data-v-"+i),r?(l=function(e){(e=e||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(e=__VUE_SSR_CONTEXT__),o&&o.call(this,e),e&&e._registeredComponents&&e._registeredComponents.add(r)},d._ssrRegister=l):o&&(l=s?function(){o.call(this,(d.functional?this.parent:this).$root.$options.shadowRoot)}:o),l)if(d.functional){d._injectStyles=l;var c=d.render;d.render=function(e,n){return l.call(n),c(e,n)}}else{var u=d.beforeCreate;d.beforeCreate=u?[].concat(u,l):[l]}return{exports:e,options:d}}t.d(n,"a",(function(){return a}))},function(e,n,t){"use strict";var a=t(3),o=t(58).filter;a({target:"Array",proto:!0,forced:!t(78)("filter")},{filter:function(e){return o(this,e,arguments.length>1?arguments[1]:void 0)}})},function(e,n,t){var a,o,i,r=t(207),s=t(0),l=t(1),d=t(7),c=t(21),u=t(8),p=t(92),h=t(71),m=t(45),g=s.TypeError,f=s.WeakMap;if(r||p.state){var b=p.state||(p.state=new f),y=l(b.get),v=l(b.has),w=l(b.set);a=function(e,n){if(v(b,e))throw new g("Object already initialized");return n.facade=e,w(b,e,n),n},o=function(e){return y(b,e)||{}},i=function(e){return v(b,e)}}else{var k=h("state");m[k]=!0,a=function(e,n){if(u(e,k))throw new g("Object already initialized");return n.facade=e,c(e,k,n),n},o=function(e){return u(e,k)?e[k]:{}},i=function(e){return u(e,k)}}e.exports={set:a,get:o,has:i,enforce:function(e){return i(e)?o(e):a(e,{})},getterFor:function(e){return function(n){var t;if(!d(n)||(t=o(n)).type!==e)throw g("Incompatible receiver, "+e+" required");return t}}}},function(e,n){var t=Function.prototype,a=t.apply,o=t.bind,i=t.call;e.exports="object"==typeof Reflect&&Reflect.apply||(o?i.bind(a):function(){return i.apply(a,arguments)})},function(e,n,t){"use strict";var a=t(3),o=t(0),i=t(13),r=t(35),s=t(11),l=t(1),d=t(20),c=t(10),u=t(94),p=t(2),h=t(8),m=t(77),g=t(5),f=t(7),b=t(29),y=t(67),v=t(9),w=t(19),k=t(14),E=t(66),T=t(15),A=t(40),C=t(38),P=t(69),S=t(42),I=t(157),x=t(99),R=t(26),D=t(12),M=t(128),O=t(97),U=t(76),L=t(16),N=t(61),j=t(71),q=t(45),B=t(62),F=t(4),_=t(158),K=t(159),W=t(47),G=t(34),H=t(58).forEach,z=j("hidden"),Y=F("toPrimitive"),V=G.set,J=G.getterFor("Symbol"),X=Object.prototype,Q=o.Symbol,$=Q&&Q.prototype,Z=o.TypeError,ee=o.QObject,ne=i("JSON","stringify"),te=R.f,ae=D.f,oe=I.f,ie=O.f,re=l([].push),se=N("symbols"),le=N("op-symbols"),de=N("string-to-symbol-registry"),ce=N("symbol-to-string-registry"),ue=N("wks"),pe=!ee||!ee.prototype||!ee.prototype.findChild,he=c&&p((function(){return 7!=C(ae({},"a",{get:function(){return ae(this,"a",{value:7}).a}})).a}))?function(e,n,t){var a=te(X,n);a&&delete X[n],ae(e,n,t),a&&e!==X&&ae(X,n,a)}:ae,me=function(e,n){var t=se[e]=C($);return V(t,{type:"Symbol",tag:e,description:n}),c||(t.description=n),t},ge=function(e,n,t){e===X&&ge(le,n,t),v(e);var a=E(n);return v(t),h(se,a)?(t.enumerable?(h(e,z)&&e[z][a]&&(e[z][a]=!1),t=C(t,{enumerable:A(0,!1)})):(h(e,z)||ae(e,z,A(1,{})),e[z][a]=!0),he(e,a,t)):ae(e,a,t)},fe=function(e,n){v(e);var t=k(n),a=P(t).concat(we(t));return H(a,(function(n){c&&!s(be,t,n)||ge(e,n,t[n])})),e},be=function(e){var n=E(e),t=s(ie,this,n);return!(this===X&&h(se,n)&&!h(le,n))&&(!(t||!h(this,n)||!h(se,n)||h(this,z)&&this[z][n])||t)},ye=function(e,n){var t=k(e),a=E(n);if(t!==X||!h(se,a)||h(le,a)){var o=te(t,a);return!o||!h(se,a)||h(t,z)&&t[z][a]||(o.enumerable=!0),o}},ve=function(e){var n=oe(k(e)),t=[];return H(n,(function(e){h(se,e)||h(q,e)||re(t,e)})),t},we=function(e){var n=e===X,t=oe(n?le:k(e)),a=[];return H(t,(function(e){!h(se,e)||n&&!h(X,e)||re(a,se[e])})),a};(u||(L($=(Q=function(){if(b($,this))throw Z("Symbol is not a constructor");var e=arguments.length&&void 0!==arguments[0]?T(arguments[0]):void 0,n=B(e),t=function(e){this===X&&s(t,le,e),h(this,z)&&h(this[z],n)&&(this[z][n]=!1),he(this,n,A(1,e))};return c&&pe&&he(X,n,{configurable:!0,set:t}),me(n,e)}).prototype,"toString",(function(){return J(this).tag})),L(Q,"withoutSetter",(function(e){return me(B(e),e)})),O.f=be,D.f=ge,M.f=fe,R.f=ye,S.f=I.f=ve,x.f=we,_.f=function(e){return me(F(e),e)},c&&(ae($,"description",{configurable:!0,get:function(){return J(this).description}}),d||L(X,"propertyIsEnumerable",be,{unsafe:!0}))),a({global:!0,wrap:!0,forced:!u,sham:!u},{Symbol:Q}),H(P(ue),(function(e){K(e)})),a({target:"Symbol",stat:!0,forced:!u},{for:function(e){var n=T(e);if(h(de,n))return de[n];var t=Q(n);return de[n]=t,ce[t]=n,t},keyFor:function(e){if(!y(e))throw Z(e+" is not a symbol");if(h(ce,e))return ce[e]},useSetter:function(){pe=!0},useSimple:function(){pe=!1}}),a({target:"Object",stat:!0,forced:!u,sham:!c},{create:function(e,n){return void 0===n?C(e):fe(C(e),n)},defineProperty:ge,defineProperties:fe,getOwnPropertyDescriptor:ye}),a({target:"Object",stat:!0,forced:!u},{getOwnPropertyNames:ve,getOwnPropertySymbols:we}),a({target:"Object",stat:!0,forced:p((function(){x.f(1)}))},{getOwnPropertySymbols:function(e){return x.f(w(e))}}),ne)&&a({target:"JSON",stat:!0,forced:!u||p((function(){var e=Q();return"[null]"!=ne([e])||"{}"!=ne({a:e})||"{}"!=ne(Object(e))}))},{stringify:function(e,n,t){var a=U(arguments),o=n;if((f(n)||void 0!==e)&&!y(e))return m(n)||(n=function(e,n){if(g(o)&&(n=s(o,this,e,n)),!y(n))return n}),a[1]=n,r(ne,null,a)}});if(!$[Y]){var ke=$.valueOf;L($,Y,(function(e){return s(ke,this)}))}W(Q,"Symbol"),q[z]=!0},function(e,n){e.exports=function(e){return null!=e&&"object"==typeof e}},function(e,n,t){var a,o=t(9),i=t(128),r=t(96),s=t(45),l=t(134),d=t(65),c=t(71),u=c("IE_PROTO"),p=function(){},h=function(e){return"<script>"+e+"<\/script>"},m=function(e){e.write(h("")),e.close();var n=e.parentWindow.Object;return e=null,n},g=function(){try{a=new ActiveXObject("htmlfile")}catch(e){}var e,n;g="undefined"!=typeof document?document.domain&&a?m(a):((n=d("iframe")).style.display="none",l.appendChild(n),n.src=String("javascript:"),(e=n.contentWindow.document).open(),e.write(h("document.F=Object")),e.close(),e.F):m(a);for(var t=r.length;t--;)delete g.prototype[r[t]];return g()};s[u]=!0,e.exports=Object.create||function(e,n){var t;return null!==e?(p.prototype=o(e),t=new p,p.prototype=null,t[u]=e):t=g(),void 0===n?t:i.f(t,n)}},function(e,n,t){var a=t(0),o=t(5),i=t(68),r=a.TypeError;e.exports=function(e){if(o(e))return e;throw r(i(e)+" is not a function")}},function(e,n){e.exports=function(e,n){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:n}}},function(e,n,t){"use strict";t.d(n,"a",(function(){return o}));t(57),t(6),t(90),t(123),t(17),t(24),t(117);var a=t(53);function o(e,n){if(e){if("string"==typeof e)return Object(a.a)(e,n);var t=Object.prototype.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?Object(a.a)(e,n):void 0}}},function(e,n,t){var a=t(132),o=t(96).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(e){return a(e,o)}},function(e,n,t){"use strict";var a=t(3),o=t(10),i=t(0),r=t(1),s=t(8),l=t(5),d=t(29),c=t(15),u=t(12).f,p=t(98),h=i.Symbol,m=h&&h.prototype;if(o&&l(h)&&(!("description"in m)||void 0!==h().description)){var g={},f=function(){var e=arguments.length<1||void 0===arguments[0]?void 0:c(arguments[0]),n=d(m,this)?new h(e):void 0===e?h():h(e);return""===e&&(g[n]=!0),n};p(f,h),f.prototype=m,m.constructor=f;var b="Symbol(test)"==String(h("test")),y=r(m.toString),v=r(m.valueOf),w=/^Symbol\((.*)\)[^)]+$/,k=r("".replace),E=r("".slice);u(m,"description",{configurable:!0,get:function(){var e=v(this),n=y(e);if(s(g,e))return"";var t=b?E(n,7,-1):k(n,w,"$1");return""===t?void 0:t}}),a({global:!0,forced:!0},{Symbol:f})}},function(e,n,t){var a=t(50),o=t(244),i=t(245),r=a?a.toStringTag:void 0;e.exports=function(e){return null==e?void 0===e?"[object Undefined]":"[object Null]":r&&r in Object(e)?o(e):i(e)}},function(e,n){e.exports={}},function(e,n){e.exports={}},function(e,n,t){var a=t(12).f,o=t(8),i=t(4)("toStringTag");e.exports=function(e,n,t){e&&!t&&(e=e.prototype),e&&!o(e,i)&&a(e,i,{configurable:!0,value:n})}},function(e,n,t){var a=t(1),o=t(39),i=a(a.bind);e.exports=function(e,n){return o(e),void 0===n?e:i?i(e,n):function(){return e.apply(n,arguments)}}},function(e,n,t){"use strict";var a=t(66),o=t(12),i=t(40);e.exports=function(e,n,t){var r=a(n);r in e?o.f(e,r,i(0,t)):e[r]=t}},function(e,n,t){var a=t(23).Symbol;e.exports=a},function(e,n){e.exports=function(e){var n=typeof e;return null!=e&&("object"==n||"function"==n)}},function(e,n,t){"use strict";t.d(n,"a",(function(){return i}));var a=t(53);t(36),t(43),t(6),t(59),t(17),t(22),t(123);var o=t(41);t(27);function i(e){return function(e){if(Array.isArray(e))return Object(a.a)(e)}(e)||function(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}(e)||Object(o.a)(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(e,n,t){"use strict";function a(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=new Array(n);t<n;t++)a[t]=e[t];return a}t.d(n,"a",(function(){return a}))},function(e,n,t){"use strict";var a=t(35),o=t(11),i=t(1),r=t(188),s=t(2),l=t(9),d=t(5),c=t(70),u=t(86),p=t(15),h=t(28),m=t(194),g=t(55),f=t(239),b=t(189),y=t(4)("replace"),v=Math.max,w=Math.min,k=i([].concat),E=i([].push),T=i("".indexOf),A=i("".slice),C="$0"==="a".replace(/./,"$0"),P=!!/./[y]&&""===/./[y]("a","$0");r("replace",(function(e,n,t){var i=P?"$":"$0";return[function(e,t){var a=h(this),i=null==e?void 0:g(e,y);return i?o(i,e,a,t):o(n,p(a),e,t)},function(e,o){var r=l(this),s=p(e);if("string"==typeof o&&-1===T(o,i)&&-1===T(o,"$<")){var h=t(n,r,s,o);if(h.done)return h.value}var g=d(o);g||(o=p(o));var y=r.global;if(y){var C=r.unicode;r.lastIndex=0}for(var P=[];;){var S=b(r,s);if(null===S)break;if(E(P,S),!y)break;""===p(S[0])&&(r.lastIndex=m(s,u(r.lastIndex),C))}for(var I,x="",R=0,D=0;D<P.length;D++){for(var M=p((S=P[D])[0]),O=v(w(c(S.index),s.length),0),U=[],L=1;L<S.length;L++)E(U,void 0===(I=S[L])?I:String(I));var N=S.groups;if(g){var j=k([M],U,O,s);void 0!==N&&E(j,N);var q=p(a(o,void 0,j))}else q=f(M,s,O,U,N,o);O>=R&&(x+=A(s,R,O)+q,R=O+M.length)}return x+A(s,R)}]}),!!s((function(){var e=/./;return e.exec=function(){var e=[];return e.groups={a:"7"},e},"7"!=="".replace(e,"$<a>")}))||!C||P)},function(e,n,t){var a=t(39);e.exports=function(e,n){var t=e[n];return null==t?void 0:a(t)}},function(e,n,t){var a=t(0),o=t(150),i=t(151),r=t(226),s=t(21),l=function(e){if(e&&e.forEach!==r)try{s(e,"forEach",r)}catch(n){e.forEach=r}};for(var d in o)o[d]&&l(a[d]&&a[d].prototype);l(i)},function(e,n,t){"use strict";var a=t(3),o=t(0),i=t(77),r=t(75),s=t(7),l=t(95),d=t(30),c=t(14),u=t(49),p=t(4),h=t(78),m=t(76),g=h("slice"),f=p("species"),b=o.Array,y=Math.max;a({target:"Array",proto:!0,forced:!g},{slice:function(e,n){var t,a,o,p=c(this),h=d(p),g=l(e,h),v=l(void 0===n?h:n,h);if(i(p)&&(t=p.constructor,(r(t)&&(t===b||i(t.prototype))||s(t)&&null===(t=t[f]))&&(t=void 0),t===b||void 0===t))return m(p,g,v);for(a=new(void 0===t?b:t)(y(v-g,0)),o=0;g<v;g++,o++)g in p&&u(a,o,p[g]);return a.length=o,a}})},function(e,n,t){var a=t(48),o=t(1),i=t(60),r=t(19),s=t(30),l=t(152),d=o([].push),c=function(e){var n=1==e,t=2==e,o=3==e,c=4==e,u=6==e,p=7==e,h=5==e||u;return function(m,g,f,b){for(var y,v,w=r(m),k=i(w),E=a(g,f),T=s(k),A=0,C=b||l,P=n?C(m,T):t||p?C(m,0):void 0;T>A;A++)if((h||A in k)&&(v=E(y=k[A],A,w),e))if(n)P[A]=v;else if(v)switch(e){case 3:return!0;case 5:return y;case 6:return A;case 2:d(P,y)}else switch(e){case 4:return!1;case 7:d(P,y)}return u?-1:o||c?c:P}};e.exports={forEach:c(0),map:c(1),filter:c(2),some:c(3),every:c(4),find:c(5),findIndex:c(6),filterReject:c(7)}},function(e,n,t){t(159)("iterator")},function(e,n,t){var a=t(0),o=t(1),i=t(2),r=t(25),s=a.Object,l=o("".split);e.exports=i((function(){return!s("z").propertyIsEnumerable(0)}))?function(e){return"String"==r(e)?l(e,""):s(e)}:s},function(e,n,t){var a=t(20),o=t(92);(e.exports=function(e,n){return o[e]||(o[e]=void 0!==n?n:{})})("versions",[]).push({version:"3.20.2",mode:a?"pure":"global",copyright:"© 2022 Denis Pushkarev (zloirock.ru)"})},function(e,n,t){var a=t(1),o=0,i=Math.random(),r=a(1..toString);e.exports=function(e){return"Symbol("+(void 0===e?"":e)+")_"+r(++o+i,36)}},function(e,n,t){var a,o,i=t(0),r=t(64),s=i.process,l=i.Deno,d=s&&s.versions||l&&l.version,c=d&&d.v8;c&&(o=(a=c.split("."))[0]>0&&a[0]<4?1:+(a[0]+a[1])),!o&&r&&(!(a=r.match(/Edge\/(\d+)/))||a[1]>=74)&&(a=r.match(/Chrome\/(\d+)/))&&(o=+a[1]),e.exports=o},function(e,n,t){var a=t(13);e.exports=a("navigator","userAgent")||""},function(e,n,t){var a=t(0),o=t(7),i=a.document,r=o(i)&&o(i.createElement);e.exports=function(e){return r?i.createElement(e):{}}},function(e,n,t){var a=t(131),o=t(67);e.exports=function(e){var n=a(e,"string");return o(n)?n:n+""}},function(e,n,t){var a=t(0),o=t(13),i=t(5),r=t(29),s=t(127),l=a.Object;e.exports=s?function(e){return"symbol"==typeof e}:function(e){var n=o("Symbol");return i(n)&&r(n.prototype,l(e))}},function(e,n,t){var a=t(0).String;e.exports=function(e){try{return a(e)}catch(e){return"Object"}}},function(e,n,t){var a=t(132),o=t(96);e.exports=Object.keys||function(e){return a(e,o)}},function(e,n){var t=Math.ceil,a=Math.floor;e.exports=function(e){var n=+e;return n!=n||0===n?0:(n>0?a:t)(n)}},function(e,n,t){var a=t(61),o=t(62),i=a("keys");e.exports=function(e){return i[e]||(i[e]=o(e))}},function(e,n,t){var a=t(1),o=t(5),i=t(92),r=a(Function.toString);o(i.inspectSource)||(i.inspectSource=function(e){return r(e)}),e.exports=i.inspectSource},function(e,n,t){var a=t(1),o=t(9),i=t(209);e.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var e,n=!1,t={};try{(e=a(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),n=t instanceof Array}catch(e){}return function(t,a){return o(t),i(a),n?e(t,a):t.__proto__=a,t}}():void 0)},function(e,n,t){var a=t(0),o=t(102),i=t(5),r=t(25),s=t(4)("toStringTag"),l=a.Object,d="Arguments"==r(function(){return arguments}());e.exports=o?r:function(e){var n,t,a;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(t=function(e,n){try{return e[n]}catch(e){}}(n=l(e),s))?t:d?r(n):"Object"==(a=r(n))&&i(n.callee)?"Arguments":a}},function(e,n,t){var a=t(1),o=t(2),i=t(5),r=t(74),s=t(13),l=t(72),d=function(){},c=[],u=s("Reflect","construct"),p=/^\s*(?:class|function)\b/,h=a(p.exec),m=!p.exec(d),g=function(e){if(!i(e))return!1;try{return u(d,c,e),!0}catch(e){return!1}},f=function(e){if(!i(e))return!1;switch(r(e)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}try{return m||!!h(p,l(e))}catch(e){return!0}};f.sham=!0,e.exports=!u||o((function(){var e;return g(g.call)||!g(Object)||!g((function(){e=!0}))||e}))?f:g},function(e,n,t){var a=t(1);e.exports=a([].slice)},function(e,n,t){var a=t(25);e.exports=Array.isArray||function(e){return"Array"==a(e)}},function(e,n,t){var a=t(2),o=t(4),i=t(63),r=o("species");e.exports=function(e){return i>=51||!a((function(){var n=[];return(n.constructor={})[r]=function(){return{foo:1}},1!==n[e](Boolean).foo}))}},function(e,n,t){var a=t(248),o=t(249),i=t(250),r=t(251),s=t(252);function l(e){var n=-1,t=null==e?0:e.length;for(this.clear();++n<t;){var a=e[n];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=o,l.prototype.get=i,l.prototype.has=r,l.prototype.set=s,e.exports=l},function(e,n,t){var a=t(164);e.exports=function(e,n){for(var t=e.length;t--;)if(a(e[t][0],n))return t;return-1}},function(e,n,t){var a=t(31)(Object,"create");e.exports=a},function(e,n,t){var a=t(270);e.exports=function(e,n){var t=e.__data__;return a(n)?t["string"==typeof n?"string":"hash"]:t.map}},function(e,n,t){var a=t(115);e.exports=function(e){if("string"==typeof e||a(e))return e;var n=e+"";return"0"==n&&1/e==-1/0?"-0":n}},function(e,n,t){var a,o;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(o="function"==typeof(a=function(){var e,n,t={version:"0.2.0"},a=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function o(e,n,t){return e<n?n:e>t?t:e}function i(e){return 100*(-1+e)}t.configure=function(e){var n,t;for(n in e)void 0!==(t=e[n])&&e.hasOwnProperty(n)&&(a[n]=t);return this},t.status=null,t.set=function(e){var n=t.isStarted();e=o(e,a.minimum,1),t.status=1===e?null:e;var l=t.render(!n),d=l.querySelector(a.barSelector),c=a.speed,u=a.easing;return l.offsetWidth,r((function(n){""===a.positionUsing&&(a.positionUsing=t.getPositioningCSS()),s(d,function(e,n,t){var o;return(o="translate3d"===a.positionUsing?{transform:"translate3d("+i(e)+"%,0,0)"}:"translate"===a.positionUsing?{transform:"translate("+i(e)+"%,0)"}:{"margin-left":i(e)+"%"}).transition="all "+n+"ms "+t,o}(e,c,u)),1===e?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+c+"ms linear",opacity:0}),setTimeout((function(){t.remove(),n()}),c)}),c)):setTimeout(n,c)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var e=function(){setTimeout((function(){t.status&&(t.trickle(),e())}),a.trickleSpeed)};return a.trickle&&e(),this},t.done=function(e){return e||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(e){var n=t.status;return n?("number"!=typeof e&&(e=(1-n)*o(Math.random()*n,.1,.95)),n=o(n+e,0,.994),t.set(n)):t.start()},t.trickle=function(){return t.inc(Math.random()*a.trickleRate)},e=0,n=0,t.promise=function(a){return a&&"resolved"!==a.state()?(0===n&&t.start(),e++,n++,a.always((function(){0==--n?(e=0,t.done()):t.set((e-n)/e)})),this):this},t.render=function(e){if(t.isRendered())return document.getElementById("nprogress");d(document.documentElement,"nprogress-busy");var n=document.createElement("div");n.id="nprogress",n.innerHTML=a.template;var o,r=n.querySelector(a.barSelector),l=e?"-100":i(t.status||0),c=document.querySelector(a.parent);return s(r,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),a.showSpinner||(o=n.querySelector(a.spinnerSelector))&&p(o),c!=document.body&&d(c,"nprogress-custom-parent"),c.appendChild(n),n},t.remove=function(){c(document.documentElement,"nprogress-busy"),c(document.querySelector(a.parent),"nprogress-custom-parent");var e=document.getElementById("nprogress");e&&p(e)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var e=document.body.style,n="WebkitTransform"in e?"Webkit":"MozTransform"in e?"Moz":"msTransform"in e?"ms":"OTransform"in e?"O":"";return n+"Perspective"in e?"translate3d":n+"Transform"in e?"translate":"margin"};var r=function(){var e=[];function n(){var t=e.shift();t&&t(n)}return function(t){e.push(t),1==e.length&&n()}}(),s=function(){var e=["Webkit","O","Moz","ms"],n={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(e,n){return n.toUpperCase()})),n[t]||(n[t]=function(n){var t=document.body.style;if(n in t)return n;for(var a,o=e.length,i=n.charAt(0).toUpperCase()+n.slice(1);o--;)if((a=e[o]+i)in t)return a;return n}(t))}function a(e,n,a){n=t(n),e.style[n]=a}return function(e,n){var t,o,i=arguments;if(2==i.length)for(t in n)void 0!==(o=n[t])&&n.hasOwnProperty(t)&&a(e,t,o);else a(e,i[1],i[2])}}();function l(e,n){return("string"==typeof e?e:u(e)).indexOf(" "+n+" ")>=0}function d(e,n){var t=u(e),a=t+n;l(t,n)||(e.className=a.substring(1))}function c(e,n){var t,a=u(e);l(e,n)&&(t=a.replace(" "+n+" "," "),e.className=t.substring(1,t.length-1))}function u(e){return(" "+(e.className||"")+" ").replace(/\s+/gi," ")}function p(e){e&&e.parentNode&&e.parentNode.removeChild(e)}return t})?a.call(n,t,n,e):a)||(e.exports=o)},function(e,n,t){"use strict";var a=t(3),o=t(58).map;a({target:"Array",proto:!0,forced:!t(78)("map")},{map:function(e){return o(this,e,arguments.length>1?arguments[1]:void 0)}})},function(e,n,t){var a=t(70),o=Math.min;e.exports=function(e){return e>0?o(a(e),9007199254740991):0}},function(e,n,t){var a=t(3),o=t(19),i=t(69);a({target:"Object",stat:!0,forced:t(2)((function(){i(1)}))},{keys:function(e){return i(o(e))}})},function(e,n,t){var a=t(10),o=t(8),i=Function.prototype,r=a&&Object.getOwnPropertyDescriptor,s=o(i,"name"),l=s&&"something"===function(){}.name,d=s&&(!a||a&&r(i,"name").configurable);e.exports={EXISTS:s,PROPER:l,CONFIGURABLE:d}},function(e,n,t){var a=t(2),o=t(5),i=/#|\.prototype\./,r=function(e,n){var t=l[s(e)];return t==c||t!=d&&(o(n)?a(n):!!n)},s=r.normalize=function(e){return String(e).replace(i,".").toLowerCase()},l=r.data={},d=r.NATIVE="N",c=r.POLYFILL="P";e.exports=r},function(e,n,t){var a=t(10),o=t(88).EXISTS,i=t(1),r=t(12).f,s=Function.prototype,l=i(s.toString),d=/function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/,c=i(d.exec);a&&!o&&r(s,"name",{configurable:!0,get:function(){try{return c(d,l(this))[1]}catch(e){return""}}})},function(e,n,t){"use strict";var a,o,i=t(11),r=t(1),s=t(15),l=t(192),d=t(187),c=t(61),u=t(38),p=t(34).get,h=t(193),m=t(200),g=c("native-string-replace",String.prototype.replace),f=RegExp.prototype.exec,b=f,y=r("".charAt),v=r("".indexOf),w=r("".replace),k=r("".slice),E=(o=/b*/g,i(f,a=/a/,"a"),i(f,o,"a"),0!==a.lastIndex||0!==o.lastIndex),T=d.BROKEN_CARET,A=void 0!==/()??/.exec("")[1];(E||A||T||h||m)&&(b=function(e){var n,t,a,o,r,d,c,h=this,m=p(h),C=s(e),P=m.raw;if(P)return P.lastIndex=h.lastIndex,n=i(b,P,C),h.lastIndex=P.lastIndex,n;var S=m.groups,I=T&&h.sticky,x=i(l,h),R=h.source,D=0,M=C;if(I&&(x=w(x,"y",""),-1===v(x,"g")&&(x+="g"),M=k(C,h.lastIndex),h.lastIndex>0&&(!h.multiline||h.multiline&&"\n"!==y(C,h.lastIndex-1))&&(R="(?: "+R+")",M=" "+M,D++),t=new RegExp("^(?:"+R+")",x)),A&&(t=new RegExp("^"+R+"$(?!\\s)",x)),E&&(a=h.lastIndex),o=i(f,I?t:h,M),I?o?(o.input=k(o.input,D),o[0]=k(o[0],D),o.index=h.lastIndex,h.lastIndex+=o[0].length):h.lastIndex=0:E&&o&&(h.lastIndex=h.global?o.index+o[0].length:a),A&&o&&o.length>1&&i(g,o[0],t,(function(){for(r=1;r<arguments.length-2;r++)void 0===arguments[r]&&(o[r]=void 0)})),o&&S)for(o.groups=d=u(null),r=0;r<S.length;r++)d[(c=S[r])[0]]=o[c[1]];return o}),e.exports=b},function(e,n,t){var a=t(0),o=t(93),i=a["__core-js_shared__"]||o("__core-js_shared__",{});e.exports=i},function(e,n,t){var a=t(0),o=Object.defineProperty;e.exports=function(e,n){try{o(a,e,{value:n,configurable:!0,writable:!0})}catch(t){a[e]=n}return n}},function(e,n,t){var a=t(63),o=t(2);e.exports=!!Object.getOwnPropertySymbols&&!o((function(){var e=Symbol();return!String(e)||!(Object(e)instanceof Symbol)||!Symbol.sham&&a&&a<41}))},function(e,n,t){var a=t(70),o=Math.max,i=Math.min;e.exports=function(e,n){var t=a(e);return t<0?o(t+n,0):i(t,n)}},function(e,n){e.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(e,n,t){"use strict";var a={}.propertyIsEnumerable,o=Object.getOwnPropertyDescriptor,i=o&&!a.call({1:2},1);n.f=i?function(e){var n=o(this,e);return!!n&&n.enumerable}:a},function(e,n,t){var a=t(8),o=t(136),i=t(26),r=t(12);e.exports=function(e,n,t){for(var s=o(n),l=r.f,d=i.f,c=0;c<s.length;c++){var u=s[c];a(e,u)||t&&a(t,u)||l(e,u,d(n,u))}}},function(e,n){n.f=Object.getOwnPropertySymbols},function(e,n,t){var a=t(0),o=t(8),i=t(5),r=t(19),s=t(71),l=t(138),d=s("IE_PROTO"),c=a.Object,u=c.prototype;e.exports=l?c.getPrototypeOf:function(e){var n=r(e);if(o(n,d))return n[d];var t=n.constructor;return i(t)&&n instanceof t?t.prototype:n instanceof c?u:null}},function(e,n,t){var a=t(74),o=t(55),i=t(46),r=t(4)("iterator");e.exports=function(e){if(null!=e)return o(e,r)||o(e,"@@iterator")||i[a(e)]}},function(e,n,t){var a={};a[t(4)("toStringTag")]="z",e.exports="[object z]"===String(a)},function(e,n,t){var a=t(25),o=t(0);e.exports="process"==a(o.process)},function(e,n,t){var a=function(e){"use strict";var n=Object.prototype,t=n.hasOwnProperty,a="function"==typeof Symbol?Symbol:{},o=a.iterator||"@@iterator",i=a.asyncIterator||"@@asyncIterator",r=a.toStringTag||"@@toStringTag";function s(e,n,t){return Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}),e[n]}try{s({},"")}catch(e){s=function(e,n,t){return e[n]=t}}function l(e,n,t,a){var o=n&&n.prototype instanceof u?n:u,i=Object.create(o.prototype),r=new T(a||[]);return i._invoke=function(e,n,t){var a="suspendedStart";return function(o,i){if("executing"===a)throw new Error("Generator is already running");if("completed"===a){if("throw"===o)throw i;return C()}for(t.method=o,t.arg=i;;){var r=t.delegate;if(r){var s=w(r,t);if(s){if(s===c)continue;return s}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if("suspendedStart"===a)throw a="completed",t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);a="executing";var l=d(e,n,t);if("normal"===l.type){if(a=t.done?"completed":"suspendedYield",l.arg===c)continue;return{value:l.arg,done:t.done}}"throw"===l.type&&(a="completed",t.method="throw",t.arg=l.arg)}}}(e,t,r),i}function d(e,n,t){try{return{type:"normal",arg:e.call(n,t)}}catch(e){return{type:"throw",arg:e}}}e.wrap=l;var c={};function u(){}function p(){}function h(){}var m={};s(m,o,(function(){return this}));var g=Object.getPrototypeOf,f=g&&g(g(A([])));f&&f!==n&&t.call(f,o)&&(m=f);var b=h.prototype=u.prototype=Object.create(m);function y(e){["next","throw","return"].forEach((function(n){s(e,n,(function(e){return this._invoke(n,e)}))}))}function v(e,n){var a;this._invoke=function(o,i){function r(){return new n((function(a,r){!function a(o,i,r,s){var l=d(e[o],e,i);if("throw"!==l.type){var c=l.arg,u=c.value;return u&&"object"==typeof u&&t.call(u,"__await")?n.resolve(u.__await).then((function(e){a("next",e,r,s)}),(function(e){a("throw",e,r,s)})):n.resolve(u).then((function(e){c.value=e,r(c)}),(function(e){return a("throw",e,r,s)}))}s(l.arg)}(o,i,a,r)}))}return a=a?a.then(r,r):r()}}function w(e,n){var t=e.iterator[n.method];if(void 0===t){if(n.delegate=null,"throw"===n.method){if(e.iterator.return&&(n.method="return",n.arg=void 0,w(e,n),"throw"===n.method))return c;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return c}var a=d(t,e.iterator,n.arg);if("throw"===a.type)return n.method="throw",n.arg=a.arg,n.delegate=null,c;var o=a.arg;return o?o.done?(n[e.resultName]=o.value,n.next=e.nextLoc,"return"!==n.method&&(n.method="next",n.arg=void 0),n.delegate=null,c):o:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,c)}function k(e){var n={tryLoc:e[0]};1 in e&&(n.catchLoc=e[1]),2 in e&&(n.finallyLoc=e[2],n.afterLoc=e[3]),this.tryEntries.push(n)}function E(e){var n=e.completion||{};n.type="normal",delete n.arg,e.completion=n}function T(e){this.tryEntries=[{tryLoc:"root"}],e.forEach(k,this),this.reset(!0)}function A(e){if(e){var n=e[o];if(n)return n.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var a=-1,i=function n(){for(;++a<e.length;)if(t.call(e,a))return n.value=e[a],n.done=!1,n;return n.value=void 0,n.done=!0,n};return i.next=i}}return{next:C}}function C(){return{value:void 0,done:!0}}return p.prototype=h,s(b,"constructor",h),s(h,"constructor",p),p.displayName=s(h,r,"GeneratorFunction"),e.isGeneratorFunction=function(e){var n="function"==typeof e&&e.constructor;return!!n&&(n===p||"GeneratorFunction"===(n.displayName||n.name))},e.mark=function(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,h):(e.__proto__=h,s(e,r,"GeneratorFunction")),e.prototype=Object.create(b),e},e.awrap=function(e){return{__await:e}},y(v.prototype),s(v.prototype,i,(function(){return this})),e.AsyncIterator=v,e.async=function(n,t,a,o,i){void 0===i&&(i=Promise);var r=new v(l(n,t,a,o),i);return e.isGeneratorFunction(t)?r:r.next().then((function(e){return e.done?e.value:r.next()}))},y(b),s(b,r,"Generator"),s(b,o,(function(){return this})),s(b,"toString",(function(){return"[object Generator]"})),e.keys=function(e){var n=[];for(var t in e)n.push(t);return n.reverse(),function t(){for(;n.length;){var a=n.pop();if(a in e)return t.value=a,t.done=!1,t}return t.done=!0,t}},e.values=A,T.prototype={constructor:T,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(E),!e)for(var n in this)"t"===n.charAt(0)&&t.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=void 0)},stop:function(){this.done=!0;var e=this.tryEntries[0].completion;if("throw"===e.type)throw e.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var n=this;function a(t,a){return r.type="throw",r.arg=e,n.next=t,a&&(n.method="next",n.arg=void 0),!!a}for(var o=this.tryEntries.length-1;o>=0;--o){var i=this.tryEntries[o],r=i.completion;if("root"===i.tryLoc)return a("end");if(i.tryLoc<=this.prev){var s=t.call(i,"catchLoc"),l=t.call(i,"finallyLoc");if(s&&l){if(this.prev<i.catchLoc)return a(i.catchLoc,!0);if(this.prev<i.finallyLoc)return a(i.finallyLoc)}else if(s){if(this.prev<i.catchLoc)return a(i.catchLoc,!0)}else{if(!l)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return a(i.finallyLoc)}}}},abrupt:function(e,n){for(var a=this.tryEntries.length-1;a>=0;--a){var o=this.tryEntries[a];if(o.tryLoc<=this.prev&&t.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var i=o;break}}i&&("break"===e||"continue"===e)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var r=i?i.completion:{};return r.type=e,r.arg=n,i?(this.method="next",this.next=i.finallyLoc,c):this.complete(r)},complete:function(e,n){if("throw"===e.type)throw e.arg;return"break"===e.type||"continue"===e.type?this.next=e.arg:"return"===e.type?(this.rval=this.arg=e.arg,this.method="return",this.next="end"):"normal"===e.type&&n&&(this.next=n),c},finish:function(e){for(var n=this.tryEntries.length-1;n>=0;--n){var t=this.tryEntries[n];if(t.finallyLoc===e)return this.complete(t.completion,t.afterLoc),E(t),c}},catch:function(e){for(var n=this.tryEntries.length-1;n>=0;--n){var t=this.tryEntries[n];if(t.tryLoc===e){var a=t.completion;if("throw"===a.type){var o=a.arg;E(t)}return o}}throw new Error("illegal catch attempt")},delegateYield:function(e,n,t){return this.delegate={iterator:A(e),resultName:n,nextLoc:t},"next"===this.method&&(this.arg=void 0),c}},e}(e.exports);try{regeneratorRuntime=a}catch(e){"object"==typeof globalThis?globalThis.regeneratorRuntime=a:Function("r","regeneratorRuntime = r")(a)}},function(e,n,t){var a=t(243),o=t(37),i=Object.prototype,r=i.hasOwnProperty,s=i.propertyIsEnumerable,l=a(function(){return arguments}())?a:function(e){return o(e)&&r.call(e,"callee")&&!s.call(e,"callee")};e.exports=l},function(e,n,t){var a=t(31)(t(23),"Map");e.exports=a},function(e,n,t){var a=t(44),o=t(51);e.exports=function(e){if(!o(e))return!1;var n=a(e);return"[object Function]"==n||"[object GeneratorFunction]"==n||"[object AsyncFunction]"==n||"[object Proxy]"==n}},function(e,n,t){var a=t(262),o=t(269),i=t(271),r=t(272),s=t(273);function l(e){var n=-1,t=null==e?0:e.length;for(this.clear();++n<t;){var a=e[n];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=o,l.prototype.get=i,l.prototype.has=r,l.prototype.set=s,e.exports=l},function(e,n){e.exports=function(e){var n=-1,t=Array(e.size);return e.forEach((function(e){t[++n]=e})),t}},function(e,n,t){var a=t(287),o=t(293),i=t(172);e.exports=function(e){return i(e)?a(e):o(e)}},function(e,n,t){(function(e){var a=t(23),o=t(289),i=n&&!n.nodeType&&n,r=i&&"object"==typeof e&&e&&!e.nodeType&&e,s=r&&r.exports===i?a.Buffer:void 0,l=(s?s.isBuffer:void 0)||o;e.exports=l}).call(this,t(125)(e))},function(e,n,t){var a=t(290),o=t(291),i=t(292),r=i&&i.isTypedArray,s=r?o(r):a;e.exports=s},function(e,n){e.exports=function(e){return"number"==typeof e&&e>-1&&e%1==0&&e<=9007199254740991}},function(e,n,t){var a=t(18),o=t(115),i=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,r=/^\w*$/;e.exports=function(e,n){if(a(e))return!1;var t=typeof e;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=e&&!o(e))||(r.test(e)||!i.test(e)||null!=n&&e in Object(n))}},function(e,n,t){var a=t(44),o=t(37);e.exports=function(e){return"symbol"==typeof e||o(e)&&"[object Symbol]"==a(e)}},function(e,n){e.exports=function(e){return e}},function(e,n,t){"use strict";t(24);var a,o,i=t(3),r=t(0),s=t(11),l=t(1),d=t(5),c=t(7),u=(a=!1,(o=/[ac]/).exec=function(){return a=!0,/./.exec.apply(this,arguments)},!0===o.test("abc")&&a),p=r.Error,h=l(/./.test);i({target:"RegExp",proto:!0,forced:!u},{test:function(e){var n=this.exec;if(!d(n))return h(this,e);var t=s(n,this,e);if(null!==t&&!c(t))throw new p("RegExp exec method returned something other than an Object or null");return!!t}})},function(e,n,t){"use strict";var a=t(3),o=t(0),i=t(2),r=t(77),s=t(7),l=t(19),d=t(30),c=t(49),u=t(152),p=t(78),h=t(4),m=t(63),g=h("isConcatSpreadable"),f=o.TypeError,b=m>=51||!i((function(){var e=[];return e[g]=!1,e.concat()[0]!==e})),y=p("concat"),v=function(e){if(!s(e))return!1;var n=e[g];return void 0!==n?!!n:r(e)};a({target:"Array",proto:!0,forced:!b||!y},{concat:function(e){var n,t,a,o,i,r=l(this),s=u(r,0),p=0;for(n=-1,a=arguments.length;n<a;n++)if(v(i=-1===n?r:arguments[n])){if(p+(o=d(i))>9007199254740991)throw f("Maximum allowed index exceeded");for(t=0;t<o;t++,p++)t in i&&c(s,p,i[t])}else{if(p>=9007199254740991)throw f("Maximum allowed index exceeded");c(s,p++,i)}return s.length=p,s}})},function(e,n,t){var a=t(4),o=t(38),i=t(12),r=a("unscopables"),s=Array.prototype;null==s[r]&&i.f(s,r,{configurable:!0,value:o(null)}),e.exports=function(e){s[r][e]=!0}},function(e,n,t){var a=t(9),o=t(144),i=t(4)("species");e.exports=function(e,n){var t,r=a(e).constructor;return void 0===r||null==(t=a(r)[i])?n:o(t)}},function(e,n,t){var a=t(0),o=t(191),i=a.TypeError;e.exports=function(e){if(o(e))throw i("The method doesn't accept regular expressions");return e}},function(e,n,t){var a=t(4)("match");e.exports=function(e){var n=/./;try{"/./"[e](n)}catch(t){try{return n[a]=!1,"/./"[e](n)}catch(e){}}return!1}},function(e,n,t){var a=t(3),o=t(232);a({target:"Array",stat:!0,forced:!t(143)((function(e){Array.from(e)}))},{from:o})},function(e,n,t){var a=t(5),o=t(7),i=t(73);e.exports=function(e,n,t){var r,s;return i&&a(r=n.constructor)&&r!==t&&o(s=r.prototype)&&s!==t.prototype&&i(e,s),e}},function(e,n){e.exports=function(e){return e.webpackPolyfill||(e.deprecate=function(){},e.paths=[],e.children||(e.children=[]),Object.defineProperty(e,"loaded",{enumerable:!0,get:function(){return e.l}}),Object.defineProperty(e,"id",{enumerable:!0,get:function(){return e.i}}),e.webpackPolyfill=1),e}},function(e,n,t){"use strict";var a=t(14),o=t(119),i=t(46),r=t(34),s=t(12).f,l=t(135),d=t(20),c=t(10),u=r.set,p=r.getterFor("Array Iterator");e.exports=l(Array,"Array",(function(e,n){u(this,{type:"Array Iterator",target:a(e),index:0,kind:n})}),(function(){var e=p(this),n=e.target,t=e.kind,a=e.index++;return!n||a>=n.length?(e.target=void 0,{value:void 0,done:!0}):"keys"==t?{value:a,done:!1}:"values"==t?{value:n[a],done:!1}:{value:[a,n[a]],done:!1}}),"values");var h=i.Arguments=i.Array;if(o("keys"),o("values"),o("entries"),!d&&c&&"values"!==h.name)try{s(h,"name",{value:"values"})}catch(e){}},function(e,n,t){var a=t(94);e.exports=a&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(e,n,t){var a=t(10),o=t(129),i=t(12),r=t(9),s=t(14),l=t(69);n.f=a&&!o?Object.defineProperties:function(e,n){r(e);for(var t,a=s(n),o=l(n),d=o.length,c=0;d>c;)i.f(e,t=o[c++],a[t]);return e}},function(e,n,t){var a=t(10),o=t(2);e.exports=a&&o((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(e,n,t){var a=t(10),o=t(2),i=t(65);e.exports=!a&&!o((function(){return 7!=Object.defineProperty(i("div"),"a",{get:function(){return 7}}).a}))},function(e,n,t){var a=t(0),o=t(11),i=t(7),r=t(67),s=t(55),l=t(206),d=t(4),c=a.TypeError,u=d("toPrimitive");e.exports=function(e,n){if(!i(e)||r(e))return e;var t,a=s(e,u);if(a){if(void 0===n&&(n="default"),t=o(a,e,n),!i(t)||r(t))return t;throw c("Can't convert object to primitive value")}return void 0===n&&(n="number"),l(e,n)}},function(e,n,t){var a=t(1),o=t(8),i=t(14),r=t(133).indexOf,s=t(45),l=a([].push);e.exports=function(e,n){var t,a=i(e),d=0,c=[];for(t in a)!o(s,t)&&o(a,t)&&l(c,t);for(;n.length>d;)o(a,t=n[d++])&&(~r(c,t)||l(c,t));return c}},function(e,n,t){var a=t(14),o=t(95),i=t(30),r=function(e){return function(n,t,r){var s,l=a(n),d=i(l),c=o(r,d);if(e&&t!=t){for(;d>c;)if((s=l[c++])!=s)return!0}else for(;d>c;c++)if((e||c in l)&&l[c]===t)return e||c||0;return!e&&-1}};e.exports={includes:r(!0),indexOf:r(!1)}},function(e,n,t){var a=t(13);e.exports=a("document","documentElement")},function(e,n,t){"use strict";var a=t(3),o=t(11),i=t(20),r=t(88),s=t(5),l=t(208),d=t(100),c=t(73),u=t(47),p=t(21),h=t(16),m=t(4),g=t(46),f=t(137),b=r.PROPER,y=r.CONFIGURABLE,v=f.IteratorPrototype,w=f.BUGGY_SAFARI_ITERATORS,k=m("iterator"),E=function(){return this};e.exports=function(e,n,t,r,m,f,T){l(t,n,r);var A,C,P,S=function(e){if(e===m&&M)return M;if(!w&&e in R)return R[e];switch(e){case"keys":case"values":case"entries":return function(){return new t(this,e)}}return function(){return new t(this)}},I=n+" Iterator",x=!1,R=e.prototype,D=R[k]||R["@@iterator"]||m&&R[m],M=!w&&D||S(m),O="Array"==n&&R.entries||D;if(O&&(A=d(O.call(new e)))!==Object.prototype&&A.next&&(i||d(A)===v||(c?c(A,v):s(A[k])||h(A,k,E)),u(A,I,!0,!0),i&&(g[I]=E)),b&&"values"==m&&D&&"values"!==D.name&&(!i&&y?p(R,"name","values"):(x=!0,M=function(){return o(D,this)})),m)if(C={values:S("values"),keys:f?M:S("keys"),entries:S("entries")},T)for(P in C)(w||x||!(P in R))&&h(R,P,C[P]);else a({target:n,proto:!0,forced:w||x},C);return i&&!T||R[k]===M||h(R,k,M,{name:m}),g[n]=M,C}},function(e,n,t){var a=t(13),o=t(1),i=t(42),r=t(99),s=t(9),l=o([].concat);e.exports=a("Reflect","ownKeys")||function(e){var n=i.f(s(e)),t=r.f;return t?l(n,t(e)):n}},function(e,n,t){"use strict";var a,o,i,r=t(2),s=t(5),l=t(38),d=t(100),c=t(16),u=t(4),p=t(20),h=u("iterator"),m=!1;[].keys&&("next"in(i=[].keys())?(o=d(d(i)))!==Object.prototype&&(a=o):m=!0),null==a||r((function(){var e={};return a[h].call(e)!==e}))?a={}:p&&(a=l(a)),s(a[h])||c(a,h,(function(){return this})),e.exports={IteratorPrototype:a,BUGGY_SAFARI_ITERATORS:m}},function(e,n,t){var a=t(2);e.exports=!a((function(){function e(){}return e.prototype.constructor=null,Object.getPrototypeOf(new e)!==e.prototype}))},function(e,n,t){var a=t(0);e.exports=a.Promise},function(e,n,t){var a=t(4),o=t(46),i=a("iterator"),r=Array.prototype;e.exports=function(e){return void 0!==e&&(o.Array===e||r[i]===e)}},function(e,n,t){var a=t(0),o=t(11),i=t(39),r=t(9),s=t(68),l=t(101),d=a.TypeError;e.exports=function(e,n){var t=arguments.length<2?l(e):n;if(i(t))return r(o(t,e));throw d(s(e)+" is not iterable")}},function(e,n,t){var a=t(11),o=t(9),i=t(55);e.exports=function(e,n,t){var r,s;o(e);try{if(!(r=i(e,"return"))){if("throw"===n)throw t;return t}r=a(r,e)}catch(e){s=!0,r=e}if("throw"===n)throw t;if(s)throw r;return o(r),t}},function(e,n,t){var a=t(4)("iterator"),o=!1;try{var i=0,r={next:function(){return{done:!!i++}},return:function(){o=!0}};r[a]=function(){return this},Array.from(r,(function(){throw 2}))}catch(e){}e.exports=function(e,n){if(!n&&!o)return!1;var t=!1;try{var i={};i[a]=function(){return{next:function(){return{done:t=!0}}}},e(i)}catch(e){}return t}},function(e,n,t){var a=t(0),o=t(75),i=t(68),r=a.TypeError;e.exports=function(e){if(o(e))return e;throw r(i(e)+" is not a constructor")}},function(e,n,t){var a,o,i,r,s=t(0),l=t(35),d=t(48),c=t(5),u=t(8),p=t(2),h=t(134),m=t(76),g=t(65),f=t(146),b=t(103),y=s.setImmediate,v=s.clearImmediate,w=s.process,k=s.Dispatch,E=s.Function,T=s.MessageChannel,A=s.String,C=0,P={};try{a=s.location}catch(e){}var S=function(e){if(u(P,e)){var n=P[e];delete P[e],n()}},I=function(e){return function(){S(e)}},x=function(e){S(e.data)},R=function(e){s.postMessage(A(e),a.protocol+"//"+a.host)};y&&v||(y=function(e){var n=m(arguments,1);return P[++C]=function(){l(c(e)?e:E(e),void 0,n)},o(C),C},v=function(e){delete P[e]},b?o=function(e){w.nextTick(I(e))}:k&&k.now?o=function(e){k.now(I(e))}:T&&!f?(r=(i=new T).port2,i.port1.onmessage=x,o=d(r.postMessage,r)):s.addEventListener&&c(s.postMessage)&&!s.importScripts&&a&&"file:"!==a.protocol&&!p(R)?(o=R,s.addEventListener("message",x,!1)):o="onreadystatechange"in g("script")?function(e){h.appendChild(g("script")).onreadystatechange=function(){h.removeChild(this),S(e)}}:function(e){setTimeout(I(e),0)}),e.exports={set:y,clear:v}},function(e,n,t){var a=t(64);e.exports=/(?:ipad|iphone|ipod).*applewebkit/i.test(a)},function(e,n,t){var a=t(9),o=t(7),i=t(148);e.exports=function(e,n){if(a(e),o(n)&&n.constructor===e)return n;var t=i.f(e);return(0,t.resolve)(n),t.promise}},function(e,n,t){"use strict";var a=t(39),o=function(e){var n,t;this.promise=new e((function(e,a){if(void 0!==n||void 0!==t)throw TypeError("Bad Promise constructor");n=e,t=a})),this.resolve=a(n),this.reject=a(t)};e.exports.f=function(e){return new o(e)}},function(e,n,t){var a=t(1),o=t(70),i=t(15),r=t(28),s=a("".charAt),l=a("".charCodeAt),d=a("".slice),c=function(e){return function(n,t){var a,c,u=i(r(n)),p=o(t),h=u.length;return p<0||p>=h?e?"":void 0:(a=l(u,p))<55296||a>56319||p+1===h||(c=l(u,p+1))<56320||c>57343?e?s(u,p):a:e?d(u,p,p+2):c-56320+(a-55296<<10)+65536}};e.exports={codeAt:c(!1),charAt:c(!0)}},function(e,n){e.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},function(e,n,t){var a=t(65)("span").classList,o=a&&a.constructor&&a.constructor.prototype;e.exports=o===Object.prototype?void 0:o},function(e,n,t){var a=t(225);e.exports=function(e,n){return new(a(e))(0===n?0:n)}},function(e,n,t){var a=t(3),o=t(10),i=t(136),r=t(14),s=t(26),l=t(49);a({target:"Object",stat:!0,sham:!o},{getOwnPropertyDescriptors:function(e){for(var n,t,a=r(e),o=s.f,d=i(a),c={},u=0;d.length>u;)void 0!==(t=o(a,n=d[u++]))&&l(c,n,t);return c}})},function(e,n,t){var a=t(3),o=t(2),i=t(19),r=t(100),s=t(138);a({target:"Object",stat:!0,forced:o((function(){r(1)})),sham:!s},{getPrototypeOf:function(e){return r(i(e))}})},function(e,n,t){"use strict";var a=t(2);e.exports=function(e,n){var t=[][e];return!!t&&a((function(){t.call(null,n||function(){throw 1},1)}))}},function(e,n,t){var a=t(2);e.exports=!a((function(){return Object.isExtensible(Object.preventExtensions({}))}))},function(e,n,t){var a=t(25),o=t(14),i=t(42).f,r=t(199),s="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];e.exports.f=function(e){return s&&"Window"==a(e)?function(e){try{return i(e)}catch(e){return r(s)}}(e):i(o(e))}},function(e,n,t){var a=t(4);n.f=a},function(e,n,t){var a=t(231),o=t(8),i=t(158),r=t(12).f;e.exports=function(e){var n=a.Symbol||(a.Symbol={});o(n,e)||r(n,e,{value:i.f(e)})}},function(e,n){e.exports=function(e,n){for(var t=-1,a=n.length,o=e.length;++t<a;)e[o+t]=n[t];return e}},function(e,n){var t="object"==typeof global&&global&&global.Object===Object&&global;e.exports=t},function(e,n,t){var a=t(246),o=t(301),i=t(116),r=t(18),s=t(311);e.exports=function(e){return"function"==typeof e?e:null==e?i:"object"==typeof e?r(e)?o(e[0],e[1]):a(e):s(e)}},function(e,n,t){var a=t(79),o=t(253),i=t(254),r=t(255),s=t(256),l=t(257);function d(e){var n=this.__data__=new a(e);this.size=n.size}d.prototype.clear=o,d.prototype.delete=i,d.prototype.get=r,d.prototype.has=s,d.prototype.set=l,e.exports=d},function(e,n){e.exports=function(e,n){return e===n||e!=e&&n!=n}},function(e,n){var t=Function.prototype.toString;e.exports=function(e){if(null!=e){try{return t.call(e)}catch(e){}try{return e+""}catch(e){}}return""}},function(e,n,t){var a=t(274),o=t(37);e.exports=function e(n,t,i,r,s){return n===t||(null==n||null==t||!o(n)&&!o(t)?n!=n&&t!=t:a(n,t,i,r,e,s))}},function(e,n,t){var a=t(168),o=t(277),i=t(169);e.exports=function(e,n,t,r,s,l){var d=1&t,c=e.length,u=n.length;if(c!=u&&!(d&&u>c))return!1;var p=l.get(e),h=l.get(n);if(p&&h)return p==n&&h==e;var m=-1,g=!0,f=2&t?new a:void 0;for(l.set(e,n),l.set(n,e);++m<c;){var b=e[m],y=n[m];if(r)var v=d?r(y,b,m,n,e,l):r(b,y,m,e,n,l);if(void 0!==v){if(v)continue;g=!1;break}if(f){if(!o(n,(function(e,n){if(!i(f,n)&&(b===e||s(b,e,t,r,l)))return f.push(n)}))){g=!1;break}}else if(b!==y&&!s(b,y,t,r,l)){g=!1;break}}return l.delete(e),l.delete(n),g}},function(e,n,t){var a=t(108),o=t(275),i=t(276);function r(e){var n=-1,t=null==e?0:e.length;for(this.__data__=new a;++n<t;)this.add(e[n])}r.prototype.add=r.prototype.push=o,r.prototype.has=i,e.exports=r},function(e,n){e.exports=function(e,n){return e.has(n)}},function(e,n){var t=/^(?:0|[1-9]\d*)$/;e.exports=function(e,n){var a=typeof e;return!!(n=null==n?9007199254740991:n)&&("number"==a||"symbol"!=a&&t.test(e))&&e>-1&&e%1==0&&e<n}},function(e,n){e.exports=function(e,n){return function(t){return e(n(t))}}},function(e,n,t){var a=t(107),o=t(113);e.exports=function(e){return null!=e&&o(e.length)&&!a(e)}},function(e,n,t){var a=t(31)(t(23),"Set");e.exports=a},function(e,n,t){var a=t(51);e.exports=function(e){return e==e&&!a(e)}},function(e,n){e.exports=function(e,n){return function(t){return null!=t&&(t[e]===n&&(void 0!==n||e in Object(t)))}}},function(e,n,t){var a=t(177),o=t(83);e.exports=function(e,n){for(var t=0,i=(n=a(n,e)).length;null!=e&&t<i;)e=e[o(n[t++])];return t&&t==i?e:void 0}},function(e,n,t){var a=t(18),o=t(114),i=t(302),r=t(305);e.exports=function(e,n){return a(e)?e:o(e,n)?[e]:i(r(e))}},function(e,n,t){},function(e,n,t){var a=t(3),o=t(13),i=t(35),r=t(347),s=t(144),l=t(9),d=t(7),c=t(38),u=t(2),p=o("Reflect","construct"),h=Object.prototype,m=[].push,g=u((function(){function e(){}return!(p((function(){}),[],e)instanceof e)})),f=!u((function(){p((function(){}))})),b=g||f;a({target:"Reflect",stat:!0,forced:b,sham:b},{construct:function(e,n){s(e),l(n);var t=arguments.length<3?e:s(arguments[2]);if(f&&!g)return p(e,n,t);if(e==t){switch(n.length){case 0:return new e;case 1:return new e(n[0]);case 2:return new e(n[0],n[1]);case 3:return new e(n[0],n[1],n[2]);case 4:return new e(n[0],n[1],n[2],n[3])}var a=[null];return i(m,a,n),new(i(r,e,a))}var o=t.prototype,u=c(d(o)?o:h),b=i(e,u,n);return d(b)?b:u}})},function(e,n,t){var a=t(3),o=t(0),i=t(47);a({global:!0},{Reflect:{}}),i(o.Reflect,"Reflect",!0)},function(e,n,t){},function(e,n,t){},function(e,n,t){"use strict";t.d(n,"a",(function(){return i}));t(87),t(36),t(33),t(6),t(335),t(56),t(153);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}},function(e,n,t){var a=t(241),o=t(162),i=t(314),r=t(322),s=t(331),l=t(202),d=i((function(e){var n=l(e);return s(n)&&(n=void 0),r(a(e,1,s,!0),o(n,2))}));e.exports=d},function(e,n,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var a=/["'&<>]/;e.exports=function(e){var n,t=""+e,o=a.exec(t);if(!o)return t;var i="",r=0,s=0;for(r=o.index;r<t.length;r++){switch(t.charCodeAt(r)){case 34:n="&quot;";break;case 38:n="&amp;";break;case 39:n="&#39;";break;case 60:n="&lt;";break;case 62:n="&gt;";break;default:continue}s!==r&&(i+=t.substring(s,r)),s=r+1,i+=n}return s!==r?i+t.substring(s,r):i}},function(e,n){var t=/^\s+|\s+$/g,a=/^[-+]0x[0-9a-f]+$/i,o=/^0b[01]+$/i,i=/^0o[0-7]+$/i,r=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,d=s||l||Function("return this")(),c=Object.prototype.toString,u=Math.max,p=Math.min,h=function(){return d.Date.now()};function m(e){var n=typeof e;return!!e&&("object"==n||"function"==n)}function g(e){if("number"==typeof e)return e;if(function(e){return"symbol"==typeof e||function(e){return!!e&&"object"==typeof e}(e)&&"[object Symbol]"==c.call(e)}(e))return NaN;if(m(e)){var n="function"==typeof e.valueOf?e.valueOf():e;e=m(n)?n+"":n}if("string"!=typeof e)return 0===e?e:+e;e=e.replace(t,"");var s=o.test(e);return s||i.test(e)?r(e.slice(2),s?2:8):a.test(e)?NaN:+e}e.exports=function(e,n,t){var a,o,i,r,s,l,d=0,c=!1,f=!1,b=!0;if("function"!=typeof e)throw new TypeError("Expected a function");function y(n){var t=a,i=o;return a=o=void 0,d=n,r=e.apply(i,t)}function v(e){return d=e,s=setTimeout(k,n),c?y(e):r}function w(e){var t=e-l;return void 0===l||t>=n||t<0||f&&e-d>=i}function k(){var e=h();if(w(e))return E(e);s=setTimeout(k,function(e){var t=n-(e-l);return f?p(t,i-(e-d)):t}(e))}function E(e){return s=void 0,b&&a?y(e):(a=o=void 0,r)}function T(){var e=h(),t=w(e);if(a=arguments,o=this,l=e,t){if(void 0===s)return v(l);if(f)return s=setTimeout(k,n),y(l)}return void 0===s&&(s=setTimeout(k,n)),r}return n=g(n)||0,m(t)&&(c=!!t.leading,i=(f="maxWait"in t)?u(g(t.maxWait)||0,n):i,b="trailing"in t?!!t.trailing:b),T.cancel=function(){void 0!==s&&clearTimeout(s),d=0,a=l=o=s=void 0},T.flush=function(){return void 0===s?r:E(h())},T}},function(e,n,t){var a=t(2),o=t(0).RegExp,i=a((function(){var e=o("a","y");return e.lastIndex=2,null!=e.exec("abcd")})),r=i||a((function(){return!o("a","y").sticky})),s=i||a((function(){var e=o("^r","gy");return e.lastIndex=2,null!=e.exec("str")}));e.exports={BROKEN_CARET:s,MISSED_STICKY:r,UNSUPPORTED_Y:i}},function(e,n,t){"use strict";t(24);var a=t(1),o=t(16),i=t(91),r=t(2),s=t(4),l=t(21),d=s("species"),c=RegExp.prototype;e.exports=function(e,n,t,u){var p=s(e),h=!r((function(){var n={};return n[p]=function(){return 7},7!=""[e](n)})),m=h&&!r((function(){var n=!1,t=/a/;return"split"===e&&((t={}).constructor={},t.constructor[d]=function(){return t},t.flags="",t[p]=/./[p]),t.exec=function(){return n=!0,null},t[p](""),!n}));if(!h||!m||t){var g=a(/./[p]),f=n(p,""[e],(function(e,n,t,o,r){var s=a(e),l=n.exec;return l===i||l===c.exec?h&&!r?{done:!0,value:g(n,t,o)}:{done:!0,value:s(t,n,o)}:{done:!1}}));o(String.prototype,e,f[0]),o(c,p,f[1])}u&&l(c[p],"sham",!0)}},function(e,n,t){var a=t(0),o=t(11),i=t(9),r=t(5),s=t(25),l=t(91),d=a.TypeError;e.exports=function(e,n){var t=e.exec;if(r(t)){var a=o(t,e,n);return null!==a&&i(a),a}if("RegExp"===s(e))return o(l,e,n);throw d("RegExp#exec called on incompatible receiver")}},function(e,n,t){"use strict";var a=t(3),o=t(1),i=t(60),r=t(14),s=t(155),l=o([].join),d=i!=Object,c=s("join",",");a({target:"Array",proto:!0,forced:d||!c},{join:function(e){return l(r(this),void 0===e?",":e)}})},function(e,n,t){var a=t(7),o=t(25),i=t(4)("match");e.exports=function(e){var n;return a(e)&&(void 0!==(n=e[i])?!!n:"RegExp"==o(e))}},function(e,n,t){"use strict";var a=t(9);e.exports=function(){var e=a(this),n="";return e.global&&(n+="g"),e.ignoreCase&&(n+="i"),e.multiline&&(n+="m"),e.dotAll&&(n+="s"),e.unicode&&(n+="u"),e.sticky&&(n+="y"),n}},function(e,n,t){var a=t(2),o=t(0).RegExp;e.exports=a((function(){var e=o(".","s");return!(e.dotAll&&e.exec("\n")&&"s"===e.flags)}))},function(e,n,t){"use strict";var a=t(149).charAt;e.exports=function(e,n,t){return n+(t?a(e,n).length:1)}},function(e,n,t){"use strict";var a=t(3),o=t(133).includes,i=t(119);a({target:"Array",proto:!0},{includes:function(e){return o(this,e,arguments.length>1?arguments[1]:void 0)}}),i("includes")},function(e,n,t){"use strict";var a=t(3),o=t(1),i=t(121),r=t(28),s=t(15),l=t(122),d=o("".indexOf);a({target:"String",proto:!0,forced:!l("includes")},{includes:function(e){return!!~d(s(r(this)),s(i(e)),arguments.length>1?arguments[1]:void 0)}})},function(e,n,t){"use strict";var a=t(13),o=t(12),i=t(4),r=t(10),s=i("species");e.exports=function(e){var n=a(e),t=o.f;r&&n&&!n[s]&&t(n,s,{configurable:!0,get:function(){return this}})}},function(e,n,t){"use strict";var a,o=t(3),i=t(1),r=t(26).f,s=t(86),l=t(15),d=t(121),c=t(28),u=t(122),p=t(20),h=i("".startsWith),m=i("".slice),g=Math.min,f=u("startsWith");o({target:"String",proto:!0,forced:!!(p||f||(a=r(String.prototype,"startsWith"),!a||a.writable))&&!f},{startsWith:function(e){var n=l(c(this));d(e);var t=s(g(arguments.length>1?arguments[1]:void 0,n.length)),a=l(e);return h?h(n,a,t):m(n,t,t+a.length)===a}})},function(e,n,t){var a=t(0),o=t(95),i=t(30),r=t(49),s=a.Array,l=Math.max;e.exports=function(e,n,t){for(var a=i(e),d=o(n,a),c=o(void 0===t?a:t,a),u=s(l(c-d,0)),p=0;d<c;d++,p++)r(u,p,e[d]);return u.length=p,u}},function(e,n,t){var a=t(2),o=t(0).RegExp;e.exports=a((function(){var e=o("(?<a>b)","g");return"b"!==e.exec("b").groups.a||"bc"!=="b".replace(e,"$<a>c")}))},function(e,n,t){var a=t(176);e.exports=function(e,n,t){var o=null==e?void 0:a(e,n);return void 0===o?t:o}},function(e,n){e.exports=function(e){var n=null==e?0:e.length;return n?e[n-1]:void 0}},function(e,n,t){var a=t(1),o=t(28),i=t(15),r=t(204),s=a("".replace),l="["+r+"]",d=RegExp("^"+l+l+"*"),c=RegExp(l+l+"*$"),u=function(e){return function(n){var t=i(o(n));return 1&e&&(t=s(t,d,"")),2&e&&(t=s(t,c,"")),t}};e.exports={start:u(1),end:u(2),trim:u(3)}},function(e,n){e.exports="\t\n\v\f\r                　\u2028\u2029\ufeff"},function(e,n,t){e.exports=t(350)},function(e,n,t){var a=t(0),o=t(11),i=t(5),r=t(7),s=a.TypeError;e.exports=function(e,n){var t,a;if("string"===n&&i(t=e.toString)&&!r(a=o(t,e)))return a;if(i(t=e.valueOf)&&!r(a=o(t,e)))return a;if("string"!==n&&i(t=e.toString)&&!r(a=o(t,e)))return a;throw s("Can't convert object to primitive value")}},function(e,n,t){var a=t(0),o=t(5),i=t(72),r=a.WeakMap;e.exports=o(r)&&/native code/.test(i(r))},function(e,n,t){"use strict";var a=t(137).IteratorPrototype,o=t(38),i=t(40),r=t(47),s=t(46),l=function(){return this};e.exports=function(e,n,t,d){var c=n+" Iterator";return e.prototype=o(a,{next:i(+!d,t)}),r(e,c,!1,!0),s[c]=l,e}},function(e,n,t){var a=t(0),o=t(5),i=a.String,r=a.TypeError;e.exports=function(e){if("object"==typeof e||o(e))return e;throw r("Can't set "+i(e)+" as a prototype")}},function(e,n,t){"use strict";var a,o,i,r,s=t(3),l=t(20),d=t(0),c=t(13),u=t(11),p=t(139),h=t(16),m=t(211),g=t(73),f=t(47),b=t(197),y=t(39),v=t(5),w=t(7),k=t(212),E=t(72),T=t(213),A=t(143),C=t(120),P=t(145).set,S=t(214),I=t(147),x=t(217),R=t(148),D=t(218),M=t(219),O=t(34),U=t(89),L=t(4),N=t(220),j=t(103),q=t(63),B=L("species"),F="Promise",_=O.getterFor(F),K=O.set,W=O.getterFor(F),G=p&&p.prototype,H=p,z=G,Y=d.TypeError,V=d.document,J=d.process,X=R.f,Q=X,$=!!(V&&V.createEvent&&d.dispatchEvent),Z=v(d.PromiseRejectionEvent),ee=!1,ne=U(F,(function(){var e=E(H),n=e!==String(H);if(!n&&66===q)return!0;if(l&&!z.finally)return!0;if(q>=51&&/native code/.test(e))return!1;var t=new H((function(e){e(1)})),a=function(e){e((function(){}),(function(){}))};return(t.constructor={})[B]=a,!(ee=t.then((function(){}))instanceof a)||!n&&N&&!Z})),te=ne||!A((function(e){H.all(e).catch((function(){}))})),ae=function(e){var n;return!(!w(e)||!v(n=e.then))&&n},oe=function(e,n){var t,a,o,i=n.value,r=1==n.state,s=r?e.ok:e.fail,l=e.resolve,d=e.reject,c=e.domain;try{s?(r||(2===n.rejection&&de(n),n.rejection=1),!0===s?t=i:(c&&c.enter(),t=s(i),c&&(c.exit(),o=!0)),t===e.promise?d(Y("Promise-chain cycle")):(a=ae(t))?u(a,t,l,d):l(t)):d(i)}catch(e){c&&!o&&c.exit(),d(e)}},ie=function(e,n){e.notified||(e.notified=!0,S((function(){for(var t,a=e.reactions;t=a.get();)oe(t,e);e.notified=!1,n&&!e.rejection&&se(e)})))},re=function(e,n,t){var a,o;$?((a=V.createEvent("Event")).promise=n,a.reason=t,a.initEvent(e,!1,!0),d.dispatchEvent(a)):a={promise:n,reason:t},!Z&&(o=d["on"+e])?o(a):"unhandledrejection"===e&&x("Unhandled promise rejection",t)},se=function(e){u(P,d,(function(){var n,t=e.facade,a=e.value;if(le(e)&&(n=D((function(){j?J.emit("unhandledRejection",a,t):re("unhandledrejection",t,a)})),e.rejection=j||le(e)?2:1,n.error))throw n.value}))},le=function(e){return 1!==e.rejection&&!e.parent},de=function(e){u(P,d,(function(){var n=e.facade;j?J.emit("rejectionHandled",n):re("rejectionhandled",n,e.value)}))},ce=function(e,n,t){return function(a){e(n,a,t)}},ue=function(e,n,t){e.done||(e.done=!0,t&&(e=t),e.value=n,e.state=2,ie(e,!0))},pe=function(e,n,t){if(!e.done){e.done=!0,t&&(e=t);try{if(e.facade===n)throw Y("Promise can't be resolved itself");var a=ae(n);a?S((function(){var t={done:!1};try{u(a,n,ce(pe,t,e),ce(ue,t,e))}catch(n){ue(t,n,e)}})):(e.value=n,e.state=1,ie(e,!1))}catch(n){ue({done:!1},n,e)}}};if(ne&&(z=(H=function(e){k(this,z),y(e),u(a,this);var n=_(this);try{e(ce(pe,n),ce(ue,n))}catch(e){ue(n,e)}}).prototype,(a=function(e){K(this,{type:F,done:!1,notified:!1,parent:!1,reactions:new M,rejection:!1,state:0,value:void 0})}).prototype=m(z,{then:function(e,n){var t=W(this),a=X(C(this,H));return t.parent=!0,a.ok=!v(e)||e,a.fail=v(n)&&n,a.domain=j?J.domain:void 0,0==t.state?t.reactions.add(a):S((function(){oe(a,t)})),a.promise},catch:function(e){return this.then(void 0,e)}}),o=function(){var e=new a,n=_(e);this.promise=e,this.resolve=ce(pe,n),this.reject=ce(ue,n)},R.f=X=function(e){return e===H||e===i?new o(e):Q(e)},!l&&v(p)&&G!==Object.prototype)){r=G.then,ee||(h(G,"then",(function(e,n){var t=this;return new H((function(e,n){u(r,t,e,n)})).then(e,n)}),{unsafe:!0}),h(G,"catch",z.catch,{unsafe:!0}));try{delete G.constructor}catch(e){}g&&g(G,z)}s({global:!0,wrap:!0,forced:ne},{Promise:H}),f(H,F,!1,!0),b(F),i=c(F),s({target:F,stat:!0,forced:ne},{reject:function(e){var n=X(this);return u(n.reject,void 0,e),n.promise}}),s({target:F,stat:!0,forced:l||ne},{resolve:function(e){return I(l&&this===i?H:this,e)}}),s({target:F,stat:!0,forced:te},{all:function(e){var n=this,t=X(n),a=t.resolve,o=t.reject,i=D((function(){var t=y(n.resolve),i=[],r=0,s=1;T(e,(function(e){var l=r++,d=!1;s++,u(t,n,e).then((function(e){d||(d=!0,i[l]=e,--s||a(i))}),o)})),--s||a(i)}));return i.error&&o(i.value),t.promise},race:function(e){var n=this,t=X(n),a=t.reject,o=D((function(){var o=y(n.resolve);T(e,(function(e){u(o,n,e).then(t.resolve,a)}))}));return o.error&&a(o.value),t.promise}})},function(e,n,t){var a=t(16);e.exports=function(e,n,t){for(var o in n)a(e,o,n[o],t);return e}},function(e,n,t){var a=t(0),o=t(29),i=a.TypeError;e.exports=function(e,n){if(o(n,e))return e;throw i("Incorrect invocation")}},function(e,n,t){var a=t(0),o=t(48),i=t(11),r=t(9),s=t(68),l=t(140),d=t(30),c=t(29),u=t(141),p=t(101),h=t(142),m=a.TypeError,g=function(e,n){this.stopped=e,this.result=n},f=g.prototype;e.exports=function(e,n,t){var a,b,y,v,w,k,E,T=t&&t.that,A=!(!t||!t.AS_ENTRIES),C=!(!t||!t.IS_ITERATOR),P=!(!t||!t.INTERRUPTED),S=o(n,T),I=function(e){return a&&h(a,"normal",e),new g(!0,e)},x=function(e){return A?(r(e),P?S(e[0],e[1],I):S(e[0],e[1])):P?S(e,I):S(e)};if(C)a=e;else{if(!(b=p(e)))throw m(s(e)+" is not iterable");if(l(b)){for(y=0,v=d(e);v>y;y++)if((w=x(e[y]))&&c(f,w))return w;return new g(!1)}a=u(e,b)}for(k=a.next;!(E=i(k,a)).done;){try{w=x(E.value)}catch(e){h(a,"throw",e)}if("object"==typeof w&&w&&c(f,w))return w}return new g(!1)}},function(e,n,t){var a,o,i,r,s,l,d,c,u=t(0),p=t(48),h=t(26).f,m=t(145).set,g=t(146),f=t(215),b=t(216),y=t(103),v=u.MutationObserver||u.WebKitMutationObserver,w=u.document,k=u.process,E=u.Promise,T=h(u,"queueMicrotask"),A=T&&T.value;A||(a=function(){var e,n;for(y&&(e=k.domain)&&e.exit();o;){n=o.fn,o=o.next;try{n()}catch(e){throw o?r():i=void 0,e}}i=void 0,e&&e.enter()},g||y||b||!v||!w?!f&&E&&E.resolve?((d=E.resolve(void 0)).constructor=E,c=p(d.then,d),r=function(){c(a)}):y?r=function(){k.nextTick(a)}:(m=p(m,u),r=function(){m(a)}):(s=!0,l=w.createTextNode(""),new v(a).observe(l,{characterData:!0}),r=function(){l.data=s=!s})),e.exports=A||function(e){var n={fn:e,next:void 0};i&&(i.next=n),o||(o=n,r()),i=n}},function(e,n,t){var a=t(64),o=t(0);e.exports=/ipad|iphone|ipod/i.test(a)&&void 0!==o.Pebble},function(e,n,t){var a=t(64);e.exports=/web0s(?!.*chrome)/i.test(a)},function(e,n,t){var a=t(0);e.exports=function(e,n){var t=a.console;t&&t.error&&(1==arguments.length?t.error(e):t.error(e,n))}},function(e,n){e.exports=function(e){try{return{error:!1,value:e()}}catch(e){return{error:!0,value:e}}}},function(e,n){var t=function(){this.head=null,this.tail=null};t.prototype={add:function(e){var n={item:e,next:null};this.head?this.tail.next=n:this.head=n,this.tail=n},get:function(){var e=this.head;if(e)return this.head=e.next,this.tail===e&&(this.tail=null),e.item}},e.exports=t},function(e,n){e.exports="object"==typeof window},function(e,n,t){var a=t(3),o=t(222);a({target:"Object",stat:!0,forced:Object.assign!==o},{assign:o})},function(e,n,t){"use strict";var a=t(10),o=t(1),i=t(11),r=t(2),s=t(69),l=t(99),d=t(97),c=t(19),u=t(60),p=Object.assign,h=Object.defineProperty,m=o([].concat);e.exports=!p||r((function(){if(a&&1!==p({b:1},p(h({},"a",{enumerable:!0,get:function(){h(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var e={},n={},t=Symbol();return e[t]=7,"abcdefghijklmnopqrst".split("").forEach((function(e){n[e]=e})),7!=p({},e)[t]||"abcdefghijklmnopqrst"!=s(p({},n)).join("")}))?function(e,n){for(var t=c(e),o=arguments.length,r=1,p=l.f,h=d.f;o>r;)for(var g,f=u(arguments[r++]),b=p?m(s(f),p(f)):s(f),y=b.length,v=0;y>v;)g=b[v++],a&&!i(h,f,g)||(t[g]=f[g]);return t}:p},function(e,n,t){"use strict";var a=t(3),o=t(20),i=t(139),r=t(2),s=t(13),l=t(5),d=t(120),c=t(147),u=t(16);if(a({target:"Promise",proto:!0,real:!0,forced:!!i&&r((function(){i.prototype.finally.call({then:function(){}},(function(){}))}))},{finally:function(e){var n=d(this,s("Promise")),t=l(e);return this.then(t?function(t){return c(n,e()).then((function(){return t}))}:e,t?function(t){return c(n,e()).then((function(){throw t}))}:e)}}),!o&&l(i)){var p=s("Promise").prototype.finally;i.prototype.finally!==p&&u(i.prototype,"finally",p,{unsafe:!0})}},function(e,n,t){"use strict";var a=t(102),o=t(74);e.exports=a?{}.toString:function(){return"[object "+o(this)+"]"}},function(e,n,t){var a=t(0),o=t(77),i=t(75),r=t(7),s=t(4)("species"),l=a.Array;e.exports=function(e){var n;return o(e)&&(n=e.constructor,(i(n)&&(n===l||o(n.prototype))||r(n)&&null===(n=n[s]))&&(n=void 0)),void 0===n?l:n}},function(e,n,t){"use strict";var a=t(58).forEach,o=t(155)("forEach");e.exports=o?[].forEach:function(e){return a(this,e,arguments.length>1?arguments[1]:void 0)}},function(e,n,t){var a=t(3),o=t(156),i=t(2),r=t(7),s=t(228).onFreeze,l=Object.freeze;a({target:"Object",stat:!0,forced:i((function(){l(1)})),sham:!o},{freeze:function(e){return l&&r(e)?l(s(e)):e}})},function(e,n,t){var a=t(3),o=t(1),i=t(45),r=t(7),s=t(8),l=t(12).f,d=t(42),c=t(157),u=t(229),p=t(62),h=t(156),m=!1,g=p("meta"),f=0,b=function(e){l(e,g,{value:{objectID:"O"+f++,weakData:{}}})},y=e.exports={enable:function(){y.enable=function(){},m=!0;var e=d.f,n=o([].splice),t={};t[g]=1,e(t).length&&(d.f=function(t){for(var a=e(t),o=0,i=a.length;o<i;o++)if(a[o]===g){n(a,o,1);break}return a},a({target:"Object",stat:!0,forced:!0},{getOwnPropertyNames:c.f}))},fastKey:function(e,n){if(!r(e))return"symbol"==typeof e?e:("string"==typeof e?"S":"P")+e;if(!s(e,g)){if(!u(e))return"F";if(!n)return"E";b(e)}return e[g].objectID},getWeakData:function(e,n){if(!s(e,g)){if(!u(e))return!0;if(!n)return!1;b(e)}return e[g].weakData},onFreeze:function(e){return h&&m&&u(e)&&!s(e,g)&&b(e),e}};i[g]=!0},function(e,n,t){var a=t(2),o=t(7),i=t(25),r=t(230),s=Object.isExtensible,l=a((function(){s(1)}));e.exports=l||r?function(e){return!!o(e)&&((!r||"ArrayBuffer"!=i(e))&&(!s||s(e)))}:s},function(e,n,t){var a=t(2);e.exports=a((function(){if("function"==typeof ArrayBuffer){var e=new ArrayBuffer(8);Object.isExtensible(e)&&Object.defineProperty(e,"a",{value:8})}}))},function(e,n,t){var a=t(0);e.exports=a},function(e,n,t){"use strict";var a=t(0),o=t(48),i=t(11),r=t(19),s=t(233),l=t(140),d=t(75),c=t(30),u=t(49),p=t(141),h=t(101),m=a.Array;e.exports=function(e){var n=r(e),t=d(this),a=arguments.length,g=a>1?arguments[1]:void 0,f=void 0!==g;f&&(g=o(g,a>2?arguments[2]:void 0));var b,y,v,w,k,E,T=h(n),A=0;if(!T||this==m&&l(T))for(b=c(n),y=t?new this(b):m(b);b>A;A++)E=f?g(n[A],A):n[A],u(y,A,E);else for(k=(w=p(n,T)).next,y=t?new this:[];!(v=i(k,w)).done;A++)E=f?s(w,g,[v.value,A],!0):v.value,u(y,A,E);return y.length=A,y}},function(e,n,t){var a=t(9),o=t(142);e.exports=function(e,n,t,i){try{return i?n(a(t)[0],t[1]):n(t)}catch(n){o(e,"throw",n)}}},function(e,n,t){"use strict";var a=t(13),o=t(8),i=t(21),r=t(29),s=t(73),l=t(98),d=t(124),c=t(235),u=t(236),p=t(237),h=t(238),m=t(20);e.exports=function(e,n,t,g){var f=g?2:1,b=e.split("."),y=b[b.length-1],v=a.apply(null,b);if(v){var w=v.prototype;if(!m&&o(w,"cause")&&delete w.cause,!t)return v;var k=a("Error"),E=n((function(e,n){var t=c(g?n:e,void 0),a=g?new v(e):new v;return void 0!==t&&i(a,"message",t),h&&i(a,"stack",p(a.stack,2)),this&&r(w,this)&&d(a,this,E),arguments.length>f&&u(a,arguments[f]),a}));if(E.prototype=w,"Error"!==y&&(s?s(E,k):l(E,k,{name:!0})),l(E,v),!m)try{w.name!==y&&i(w,"name",y),w.constructor=E}catch(e){}return E}}},function(e,n,t){var a=t(15);e.exports=function(e,n){return void 0===e?arguments.length<2?"":n:a(e)}},function(e,n,t){var a=t(7),o=t(21);e.exports=function(e,n){a(n)&&"cause"in n&&o(e,"cause",n.cause)}},function(e,n,t){var a=t(1)("".replace),o=String(Error("zxcasd").stack),i=/\n\s*at [^:]*:[^\n]*/,r=i.test(o);e.exports=function(e,n){if(r&&"string"==typeof e)for(;n--;)e=a(e,i,"");return e}},function(e,n,t){var a=t(2),o=t(40);e.exports=!a((function(){var e=Error("a");return!("stack"in e)||(Object.defineProperty(e,"stack",o(1,7)),7!==e.stack)}))},function(e,n,t){var a=t(1),o=t(19),i=Math.floor,r=a("".charAt),s=a("".replace),l=a("".slice),d=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,c=/\$([$&'`]|\d{1,2})/g;e.exports=function(e,n,t,a,u,p){var h=t+e.length,m=a.length,g=c;return void 0!==u&&(u=o(u),g=d),s(p,g,(function(o,s){var d;switch(r(s,0)){case"$":return"$";case"&":return e;case"`":return l(n,0,t);case"'":return l(n,h);case"<":d=u[l(s,1,-1)];break;default:var c=+s;if(0===c)return o;if(c>m){var p=i(c/10);return 0===p?o:p<=m?void 0===a[p-1]?r(s,1):a[p-1]+r(s,1):o}d=a[c-1]}return void 0===d?"":d}))}},function(e,n,t){var a=t(3),o=t(0),i=t(13),r=t(35),s=t(1),l=t(2),d=o.Array,c=i("JSON","stringify"),u=s(/./.exec),p=s("".charAt),h=s("".charCodeAt),m=s("".replace),g=s(1..toString),f=/[\uD800-\uDFFF]/g,b=/^[\uD800-\uDBFF]$/,y=/^[\uDC00-\uDFFF]$/,v=function(e,n,t){var a=p(t,n-1),o=p(t,n+1);return u(b,e)&&!u(y,o)||u(y,e)&&!u(b,a)?"\\u"+g(h(e,0),16):e},w=l((function(){return'"\\udf06\\ud834"'!==c("\udf06\ud834")||'"\\udead"'!==c("\udead")}));c&&a({target:"JSON",stat:!0,forced:w},{stringify:function(e,n,t){for(var a=0,o=arguments.length,i=d(o);a<o;a++)i[a]=arguments[a];var s=r(c,null,i);return"string"==typeof s?m(s,f,v):s}})},function(e,n,t){var a=t(160),o=t(242);e.exports=function e(n,t,i,r,s){var l=-1,d=n.length;for(i||(i=o),s||(s=[]);++l<d;){var c=n[l];t>0&&i(c)?t>1?e(c,t-1,i,r,s):a(s,c):r||(s[s.length]=c)}return s}},function(e,n,t){var a=t(50),o=t(105),i=t(18),r=a?a.isConcatSpreadable:void 0;e.exports=function(e){return i(e)||o(e)||!!(r&&e&&e[r])}},function(e,n,t){var a=t(44),o=t(37);e.exports=function(e){return o(e)&&"[object Arguments]"==a(e)}},function(e,n,t){var a=t(50),o=Object.prototype,i=o.hasOwnProperty,r=o.toString,s=a?a.toStringTag:void 0;e.exports=function(e){var n=i.call(e,s),t=e[s];try{e[s]=void 0;var a=!0}catch(e){}var o=r.call(e);return a&&(n?e[s]=t:delete e[s]),o}},function(e,n){var t=Object.prototype.toString;e.exports=function(e){return t.call(e)}},function(e,n,t){var a=t(247),o=t(300),i=t(175);e.exports=function(e){var n=o(e);return 1==n.length&&n[0][2]?i(n[0][0],n[0][1]):function(t){return t===e||a(t,e,n)}}},function(e,n,t){var a=t(163),o=t(166);e.exports=function(e,n,t,i){var r=t.length,s=r,l=!i;if(null==e)return!s;for(e=Object(e);r--;){var d=t[r];if(l&&d[2]?d[1]!==e[d[0]]:!(d[0]in e))return!1}for(;++r<s;){var c=(d=t[r])[0],u=e[c],p=d[1];if(l&&d[2]){if(void 0===u&&!(c in e))return!1}else{var h=new a;if(i)var m=i(u,p,c,e,n,h);if(!(void 0===m?o(p,u,3,i,h):m))return!1}}return!0}},function(e,n){e.exports=function(){this.__data__=[],this.size=0}},function(e,n,t){var a=t(80),o=Array.prototype.splice;e.exports=function(e){var n=this.__data__,t=a(n,e);return!(t<0)&&(t==n.length-1?n.pop():o.call(n,t,1),--this.size,!0)}},function(e,n,t){var a=t(80);e.exports=function(e){var n=this.__data__,t=a(n,e);return t<0?void 0:n[t][1]}},function(e,n,t){var a=t(80);e.exports=function(e){return a(this.__data__,e)>-1}},function(e,n,t){var a=t(80);e.exports=function(e,n){var t=this.__data__,o=a(t,e);return o<0?(++this.size,t.push([e,n])):t[o][1]=n,this}},function(e,n,t){var a=t(79);e.exports=function(){this.__data__=new a,this.size=0}},function(e,n){e.exports=function(e){var n=this.__data__,t=n.delete(e);return this.size=n.size,t}},function(e,n){e.exports=function(e){return this.__data__.get(e)}},function(e,n){e.exports=function(e){return this.__data__.has(e)}},function(e,n,t){var a=t(79),o=t(106),i=t(108);e.exports=function(e,n){var t=this.__data__;if(t instanceof a){var r=t.__data__;if(!o||r.length<199)return r.push([e,n]),this.size=++t.size,this;t=this.__data__=new i(r)}return t.set(e,n),this.size=t.size,this}},function(e,n,t){var a=t(107),o=t(259),i=t(51),r=t(165),s=/^\[object .+?Constructor\]$/,l=Function.prototype,d=Object.prototype,c=l.toString,u=d.hasOwnProperty,p=RegExp("^"+c.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");e.exports=function(e){return!(!i(e)||o(e))&&(a(e)?p:s).test(r(e))}},function(e,n,t){var a,o=t(260),i=(a=/[^.]+$/.exec(o&&o.keys&&o.keys.IE_PROTO||""))?"Symbol(src)_1."+a:"";e.exports=function(e){return!!i&&i in e}},function(e,n,t){var a=t(23)["__core-js_shared__"];e.exports=a},function(e,n){e.exports=function(e,n){return null==e?void 0:e[n]}},function(e,n,t){var a=t(263),o=t(79),i=t(106);e.exports=function(){this.size=0,this.__data__={hash:new a,map:new(i||o),string:new a}}},function(e,n,t){var a=t(264),o=t(265),i=t(266),r=t(267),s=t(268);function l(e){var n=-1,t=null==e?0:e.length;for(this.clear();++n<t;){var a=e[n];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=o,l.prototype.get=i,l.prototype.has=r,l.prototype.set=s,e.exports=l},function(e,n,t){var a=t(81);e.exports=function(){this.__data__=a?a(null):{},this.size=0}},function(e,n){e.exports=function(e){var n=this.has(e)&&delete this.__data__[e];return this.size-=n?1:0,n}},function(e,n,t){var a=t(81),o=Object.prototype.hasOwnProperty;e.exports=function(e){var n=this.__data__;if(a){var t=n[e];return"__lodash_hash_undefined__"===t?void 0:t}return o.call(n,e)?n[e]:void 0}},function(e,n,t){var a=t(81),o=Object.prototype.hasOwnProperty;e.exports=function(e){var n=this.__data__;return a?void 0!==n[e]:o.call(n,e)}},function(e,n,t){var a=t(81);e.exports=function(e,n){var t=this.__data__;return this.size+=this.has(e)?0:1,t[e]=a&&void 0===n?"__lodash_hash_undefined__":n,this}},function(e,n,t){var a=t(82);e.exports=function(e){var n=a(this,e).delete(e);return this.size-=n?1:0,n}},function(e,n){e.exports=function(e){var n=typeof e;return"string"==n||"number"==n||"symbol"==n||"boolean"==n?"__proto__"!==e:null===e}},function(e,n,t){var a=t(82);e.exports=function(e){return a(this,e).get(e)}},function(e,n,t){var a=t(82);e.exports=function(e){return a(this,e).has(e)}},function(e,n,t){var a=t(82);e.exports=function(e,n){var t=a(this,e),o=t.size;return t.set(e,n),this.size+=t.size==o?0:1,this}},function(e,n,t){var a=t(163),o=t(167),i=t(278),r=t(281),s=t(296),l=t(18),d=t(111),c=t(112),u="[object Object]",p=Object.prototype.hasOwnProperty;e.exports=function(e,n,t,h,m,g){var f=l(e),b=l(n),y=f?"[object Array]":s(e),v=b?"[object Array]":s(n),w=(y="[object Arguments]"==y?u:y)==u,k=(v="[object Arguments]"==v?u:v)==u,E=y==v;if(E&&d(e)){if(!d(n))return!1;f=!0,w=!1}if(E&&!w)return g||(g=new a),f||c(e)?o(e,n,t,h,m,g):i(e,n,y,t,h,m,g);if(!(1&t)){var T=w&&p.call(e,"__wrapped__"),A=k&&p.call(n,"__wrapped__");if(T||A){var C=T?e.value():e,P=A?n.value():n;return g||(g=new a),m(C,P,t,h,g)}}return!!E&&(g||(g=new a),r(e,n,t,h,m,g))}},function(e,n){e.exports=function(e){return this.__data__.set(e,"__lodash_hash_undefined__"),this}},function(e,n){e.exports=function(e){return this.__data__.has(e)}},function(e,n){e.exports=function(e,n){for(var t=-1,a=null==e?0:e.length;++t<a;)if(n(e[t],t,e))return!0;return!1}},function(e,n,t){var a=t(50),o=t(279),i=t(164),r=t(167),s=t(280),l=t(109),d=a?a.prototype:void 0,c=d?d.valueOf:void 0;e.exports=function(e,n,t,a,d,u,p){switch(t){case"[object DataView]":if(e.byteLength!=n.byteLength||e.byteOffset!=n.byteOffset)return!1;e=e.buffer,n=n.buffer;case"[object ArrayBuffer]":return!(e.byteLength!=n.byteLength||!u(new o(e),new o(n)));case"[object Boolean]":case"[object Date]":case"[object Number]":return i(+e,+n);case"[object Error]":return e.name==n.name&&e.message==n.message;case"[object RegExp]":case"[object String]":return e==n+"";case"[object Map]":var h=s;case"[object Set]":var m=1&a;if(h||(h=l),e.size!=n.size&&!m)return!1;var g=p.get(e);if(g)return g==n;a|=2,p.set(e,n);var f=r(h(e),h(n),a,d,u,p);return p.delete(e),f;case"[object Symbol]":if(c)return c.call(e)==c.call(n)}return!1}},function(e,n,t){var a=t(23).Uint8Array;e.exports=a},function(e,n){e.exports=function(e){var n=-1,t=Array(e.size);return e.forEach((function(e,a){t[++n]=[a,e]})),t}},function(e,n,t){var a=t(282),o=Object.prototype.hasOwnProperty;e.exports=function(e,n,t,i,r,s){var l=1&t,d=a(e),c=d.length;if(c!=a(n).length&&!l)return!1;for(var u=c;u--;){var p=d[u];if(!(l?p in n:o.call(n,p)))return!1}var h=s.get(e),m=s.get(n);if(h&&m)return h==n&&m==e;var g=!0;s.set(e,n),s.set(n,e);for(var f=l;++u<c;){var b=e[p=d[u]],y=n[p];if(i)var v=l?i(y,b,p,n,e,s):i(b,y,p,e,n,s);if(!(void 0===v?b===y||r(b,y,t,i,s):v)){g=!1;break}f||(f="constructor"==p)}if(g&&!f){var w=e.constructor,k=n.constructor;w==k||!("constructor"in e)||!("constructor"in n)||"function"==typeof w&&w instanceof w&&"function"==typeof k&&k instanceof k||(g=!1)}return s.delete(e),s.delete(n),g}},function(e,n,t){var a=t(283),o=t(284),i=t(110);e.exports=function(e){return a(e,i,o)}},function(e,n,t){var a=t(160),o=t(18);e.exports=function(e,n,t){var i=n(e);return o(e)?i:a(i,t(e))}},function(e,n,t){var a=t(285),o=t(286),i=Object.prototype.propertyIsEnumerable,r=Object.getOwnPropertySymbols,s=r?function(e){return null==e?[]:(e=Object(e),a(r(e),(function(n){return i.call(e,n)})))}:o;e.exports=s},function(e,n){e.exports=function(e,n){for(var t=-1,a=null==e?0:e.length,o=0,i=[];++t<a;){var r=e[t];n(r,t,e)&&(i[o++]=r)}return i}},function(e,n){e.exports=function(){return[]}},function(e,n,t){var a=t(288),o=t(105),i=t(18),r=t(111),s=t(170),l=t(112),d=Object.prototype.hasOwnProperty;e.exports=function(e,n){var t=i(e),c=!t&&o(e),u=!t&&!c&&r(e),p=!t&&!c&&!u&&l(e),h=t||c||u||p,m=h?a(e.length,String):[],g=m.length;for(var f in e)!n&&!d.call(e,f)||h&&("length"==f||u&&("offset"==f||"parent"==f)||p&&("buffer"==f||"byteLength"==f||"byteOffset"==f)||s(f,g))||m.push(f);return m}},function(e,n){e.exports=function(e,n){for(var t=-1,a=Array(e);++t<e;)a[t]=n(t);return a}},function(e,n){e.exports=function(){return!1}},function(e,n,t){var a=t(44),o=t(113),i=t(37),r={};r["[object Float32Array]"]=r["[object Float64Array]"]=r["[object Int8Array]"]=r["[object Int16Array]"]=r["[object Int32Array]"]=r["[object Uint8Array]"]=r["[object Uint8ClampedArray]"]=r["[object Uint16Array]"]=r["[object Uint32Array]"]=!0,r["[object Arguments]"]=r["[object Array]"]=r["[object ArrayBuffer]"]=r["[object Boolean]"]=r["[object DataView]"]=r["[object Date]"]=r["[object Error]"]=r["[object Function]"]=r["[object Map]"]=r["[object Number]"]=r["[object Object]"]=r["[object RegExp]"]=r["[object Set]"]=r["[object String]"]=r["[object WeakMap]"]=!1,e.exports=function(e){return i(e)&&o(e.length)&&!!r[a(e)]}},function(e,n){e.exports=function(e){return function(n){return e(n)}}},function(e,n,t){(function(e){var a=t(161),o=n&&!n.nodeType&&n,i=o&&"object"==typeof e&&e&&!e.nodeType&&e,r=i&&i.exports===o&&a.process,s=function(){try{var e=i&&i.require&&i.require("util").types;return e||r&&r.binding&&r.binding("util")}catch(e){}}();e.exports=s}).call(this,t(125)(e))},function(e,n,t){var a=t(294),o=t(295),i=Object.prototype.hasOwnProperty;e.exports=function(e){if(!a(e))return o(e);var n=[];for(var t in Object(e))i.call(e,t)&&"constructor"!=t&&n.push(t);return n}},function(e,n){var t=Object.prototype;e.exports=function(e){var n=e&&e.constructor;return e===("function"==typeof n&&n.prototype||t)}},function(e,n,t){var a=t(171)(Object.keys,Object);e.exports=a},function(e,n,t){var a=t(297),o=t(106),i=t(298),r=t(173),s=t(299),l=t(44),d=t(165),c=d(a),u=d(o),p=d(i),h=d(r),m=d(s),g=l;(a&&"[object DataView]"!=g(new a(new ArrayBuffer(1)))||o&&"[object Map]"!=g(new o)||i&&"[object Promise]"!=g(i.resolve())||r&&"[object Set]"!=g(new r)||s&&"[object WeakMap]"!=g(new s))&&(g=function(e){var n=l(e),t="[object Object]"==n?e.constructor:void 0,a=t?d(t):"";if(a)switch(a){case c:return"[object DataView]";case u:return"[object Map]";case p:return"[object Promise]";case h:return"[object Set]";case m:return"[object WeakMap]"}return n}),e.exports=g},function(e,n,t){var a=t(31)(t(23),"DataView");e.exports=a},function(e,n,t){var a=t(31)(t(23),"Promise");e.exports=a},function(e,n,t){var a=t(31)(t(23),"WeakMap");e.exports=a},function(e,n,t){var a=t(174),o=t(110);e.exports=function(e){for(var n=o(e),t=n.length;t--;){var i=n[t],r=e[i];n[t]=[i,r,a(r)]}return n}},function(e,n,t){var a=t(166),o=t(201),i=t(308),r=t(114),s=t(174),l=t(175),d=t(83);e.exports=function(e,n){return r(e)&&s(n)?l(d(e),n):function(t){var r=o(t,e);return void 0===r&&r===n?i(t,e):a(n,r,3)}}},function(e,n,t){var a=t(303),o=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,i=/\\(\\)?/g,r=a((function(e){var n=[];return 46===e.charCodeAt(0)&&n.push(""),e.replace(o,(function(e,t,a,o){n.push(a?o.replace(i,"$1"):t||e)})),n}));e.exports=r},function(e,n,t){var a=t(304);e.exports=function(e){var n=a(e,(function(e){return 500===t.size&&t.clear(),e})),t=n.cache;return n}},function(e,n,t){var a=t(108);function o(e,n){if("function"!=typeof e||null!=n&&"function"!=typeof n)throw new TypeError("Expected a function");var t=function(){var a=arguments,o=n?n.apply(this,a):a[0],i=t.cache;if(i.has(o))return i.get(o);var r=e.apply(this,a);return t.cache=i.set(o,r)||i,r};return t.cache=new(o.Cache||a),t}o.Cache=a,e.exports=o},function(e,n,t){var a=t(306);e.exports=function(e){return null==e?"":a(e)}},function(e,n,t){var a=t(50),o=t(307),i=t(18),r=t(115),s=a?a.prototype:void 0,l=s?s.toString:void 0;e.exports=function e(n){if("string"==typeof n)return n;if(i(n))return o(n,e)+"";if(r(n))return l?l.call(n):"";var t=n+"";return"0"==t&&1/n==-1/0?"-0":t}},function(e,n){e.exports=function(e,n){for(var t=-1,a=null==e?0:e.length,o=Array(a);++t<a;)o[t]=n(e[t],t,e);return o}},function(e,n,t){var a=t(309),o=t(310);e.exports=function(e,n){return null!=e&&o(e,n,a)}},function(e,n){e.exports=function(e,n){return null!=e&&n in Object(e)}},function(e,n,t){var a=t(177),o=t(105),i=t(18),r=t(170),s=t(113),l=t(83);e.exports=function(e,n,t){for(var d=-1,c=(n=a(n,e)).length,u=!1;++d<c;){var p=l(n[d]);if(!(u=null!=e&&t(e,p)))break;e=e[p]}return u||++d!=c?u:!!(c=null==e?0:e.length)&&s(c)&&r(p,c)&&(i(e)||o(e))}},function(e,n,t){var a=t(312),o=t(313),i=t(114),r=t(83);e.exports=function(e){return i(e)?a(r(e)):o(e)}},function(e,n){e.exports=function(e){return function(n){return null==n?void 0:n[e]}}},function(e,n,t){var a=t(176);e.exports=function(e){return function(n){return a(n,e)}}},function(e,n,t){var a=t(116),o=t(315),i=t(317);e.exports=function(e,n){return i(o(e,n,a),e+"")}},function(e,n,t){var a=t(316),o=Math.max;e.exports=function(e,n,t){return n=o(void 0===n?e.length-1:n,0),function(){for(var i=arguments,r=-1,s=o(i.length-n,0),l=Array(s);++r<s;)l[r]=i[n+r];r=-1;for(var d=Array(n+1);++r<n;)d[r]=i[r];return d[n]=t(l),a(e,this,d)}}},function(e,n){e.exports=function(e,n,t){switch(t.length){case 0:return e.call(n);case 1:return e.call(n,t[0]);case 2:return e.call(n,t[0],t[1]);case 3:return e.call(n,t[0],t[1],t[2])}return e.apply(n,t)}},function(e,n,t){var a=t(318),o=t(321)(a);e.exports=o},function(e,n,t){var a=t(319),o=t(320),i=t(116),r=o?function(e,n){return o(e,"toString",{configurable:!0,enumerable:!1,value:a(n),writable:!0})}:i;e.exports=r},function(e,n){e.exports=function(e){return function(){return e}}},function(e,n,t){var a=t(31),o=function(){try{var e=a(Object,"defineProperty");return e({},"",{}),e}catch(e){}}();e.exports=o},function(e,n){var t=Date.now;e.exports=function(e){var n=0,a=0;return function(){var o=t(),i=16-(o-a);if(a=o,i>0){if(++n>=800)return arguments[0]}else n=0;return e.apply(void 0,arguments)}}},function(e,n,t){var a=t(168),o=t(323),i=t(328),r=t(169),s=t(329),l=t(109);e.exports=function(e,n,t){var d=-1,c=o,u=e.length,p=!0,h=[],m=h;if(t)p=!1,c=i;else if(u>=200){var g=n?null:s(e);if(g)return l(g);p=!1,c=r,m=new a}else m=n?[]:h;e:for(;++d<u;){var f=e[d],b=n?n(f):f;if(f=t||0!==f?f:0,p&&b==b){for(var y=m.length;y--;)if(m[y]===b)continue e;n&&m.push(b),h.push(f)}else c(m,b,t)||(m!==h&&m.push(b),h.push(f))}return h}},function(e,n,t){var a=t(324);e.exports=function(e,n){return!!(null==e?0:e.length)&&a(e,n,0)>-1}},function(e,n,t){var a=t(325),o=t(326),i=t(327);e.exports=function(e,n,t){return n==n?i(e,n,t):a(e,o,t)}},function(e,n){e.exports=function(e,n,t,a){for(var o=e.length,i=t+(a?1:-1);a?i--:++i<o;)if(n(e[i],i,e))return i;return-1}},function(e,n){e.exports=function(e){return e!=e}},function(e,n){e.exports=function(e,n,t){for(var a=t-1,o=e.length;++a<o;)if(e[a]===n)return a;return-1}},function(e,n){e.exports=function(e,n,t){for(var a=-1,o=null==e?0:e.length;++a<o;)if(t(n,e[a]))return!0;return!1}},function(e,n,t){var a=t(173),o=t(330),i=t(109),r=a&&1/i(new a([,-0]))[1]==1/0?function(e){return new a(e)}:o;e.exports=r},function(e,n){e.exports=function(){}},function(e,n,t){var a=t(172),o=t(37);e.exports=function(e){return o(e)&&a(e)}},function(e,n,t){"use strict";var a=t(10),o=t(0),i=t(1),r=t(89),s=t(16),l=t(8),d=t(124),c=t(29),u=t(67),p=t(131),h=t(2),m=t(42).f,g=t(26).f,f=t(12).f,b=t(333),y=t(203).trim,v=o.Number,w=v.prototype,k=o.TypeError,E=i("".slice),T=i("".charCodeAt),A=function(e){var n=p(e,"number");return"bigint"==typeof n?n:C(n)},C=function(e){var n,t,a,o,i,r,s,l,d=p(e,"number");if(u(d))throw k("Cannot convert a Symbol value to a number");if("string"==typeof d&&d.length>2)if(d=y(d),43===(n=T(d,0))||45===n){if(88===(t=T(d,2))||120===t)return NaN}else if(48===n){switch(T(d,1)){case 66:case 98:a=2,o=49;break;case 79:case 111:a=8,o=55;break;default:return+d}for(r=(i=E(d,2)).length,s=0;s<r;s++)if((l=T(i,s))<48||l>o)return NaN;return parseInt(i,a)}return+d};if(r("Number",!v(" 0o1")||!v("0b1")||v("+0x1"))){for(var P,S=function(e){var n=arguments.length<1?0:v(A(e)),t=this;return c(w,t)&&h((function(){b(t)}))?d(Object(n),t,S):n},I=a?m(v):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","),x=0;I.length>x;x++)l(v,P=I[x])&&!l(S,P)&&f(S,P,g(v,P));S.prototype=w,w.constructor=S,s(o,"Number",S)}},function(e,n,t){var a=t(1);e.exports=a(1..valueOf)},function(e,n,t){},function(e,n,t){var a=t(3),o=t(2),i=t(14),r=t(26).f,s=t(10),l=o((function(){r(1)}));a({target:"Object",stat:!0,forced:!s||l,sham:!s},{getOwnPropertyDescriptor:function(e,n){return r(i(e),n)}})},function(e,n,t){"use strict";t(178)},function(e,n,t){},function(e,n,t){},function(e,n,t){},function(e,n,t){var a=t(341),o=t(342),i=t(343),r=t(162),s=t(346),l=t(18),d=t(111),c=t(107),u=t(51),p=t(112);e.exports=function(e,n,t){var h=l(e),m=h||d(e)||p(e);if(n=r(n,4),null==t){var g=e&&e.constructor;t=m?h?new g:[]:u(e)&&c(g)?o(s(e)):{}}return(m?a:i)(e,(function(e,a,o){return n(t,e,a,o)})),t}},function(e,n){e.exports=function(e,n){for(var t=-1,a=null==e?0:e.length;++t<a&&!1!==n(e[t],t,e););return e}},function(e,n,t){var a=t(51),o=Object.create,i=function(){function e(){}return function(n){if(!a(n))return{};if(o)return o(n);e.prototype=n;var t=new e;return e.prototype=void 0,t}}();e.exports=i},function(e,n,t){var a=t(344),o=t(110);e.exports=function(e,n){return e&&a(e,n,o)}},function(e,n,t){var a=t(345)();e.exports=a},function(e,n){e.exports=function(e){return function(n,t,a){for(var o=-1,i=Object(n),r=a(n),s=r.length;s--;){var l=r[e?s:++o];if(!1===t(i[l],l,i))break}return n}}},function(e,n,t){var a=t(171)(Object.getPrototypeOf,Object);e.exports=a},function(e,n,t){"use strict";var a=t(0),o=t(1),i=t(39),r=t(7),s=t(8),l=t(76),d=a.Function,c=o([].concat),u=o([].join),p={},h=function(e,n,t){if(!s(p,n)){for(var a=[],o=0;o<n;o++)a[o]="a["+o+"]";p[n]=d("C,a","return new C("+u(a,",")+")")}return p[n](e,t)};e.exports=d.bind||function(e){var n=i(this),t=n.prototype,a=l(arguments,1),o=function(){var t=c(a,l(arguments));return this instanceof o?h(n,t.length,t):n.apply(e,t)};return r(t)&&(o.prototype=t),o}},function(e,n,t){"use strict";t(181)},function(e,n,t){"use strict";t(182)},function(e,n,t){"use strict";t.r(n);t(126),t(210),t(221),t(223),t(6);function a(e,n,t,a,o,i,r){try{var s=e[i](r),l=s.value}catch(e){return void t(e)}s.done?n(l):Promise.resolve(l).then(a,o)}function o(e){return function(){var n=this,t=arguments;return new Promise((function(o,i){var r=e.apply(n,t);function s(e){a(r,o,i,s,l,"next",e)}function l(e){a(r,o,i,s,l,"throw",e)}s(void 0)}))}}t(104),t(57),t(17),t(22),t(85),t(33);var i=Object.freeze({});function r(e){return null==e}function s(e){return null!=e}function l(e){return!0===e}function d(e){return"string"==typeof e||"number"==typeof e||"symbol"==typeof e||"boolean"==typeof e}function c(e){return null!==e&&"object"==typeof e}var u=Object.prototype.toString;function p(e){return"[object Object]"===u.call(e)}function h(e){return"[object RegExp]"===u.call(e)}function m(e){var n=parseFloat(String(e));return n>=0&&Math.floor(n)===n&&isFinite(e)}function g(e){return s(e)&&"function"==typeof e.then&&"function"==typeof e.catch}function f(e){return null==e?"":Array.isArray(e)||p(e)&&e.toString===u?JSON.stringify(e,null,2):String(e)}function b(e){var n=parseFloat(e);return isNaN(n)?e:n}function y(e,n){for(var t=Object.create(null),a=e.split(","),o=0;o<a.length;o++)t[a[o]]=!0;return n?function(e){return t[e.toLowerCase()]}:function(e){return t[e]}}y("slot,component",!0);var v=y("key,ref,slot,slot-scope,is");function w(e,n){if(e.length){var t=e.indexOf(n);if(t>-1)return e.splice(t,1)}}var k=Object.prototype.hasOwnProperty;function E(e,n){return k.call(e,n)}function T(e){var n=Object.create(null);return function(t){return n[t]||(n[t]=e(t))}}var A=/-(\w)/g,C=T((function(e){return e.replace(A,(function(e,n){return n?n.toUpperCase():""}))})),P=T((function(e){return e.charAt(0).toUpperCase()+e.slice(1)})),S=/\B([A-Z])/g,I=T((function(e){return e.replace(S,"-$1").toLowerCase()}));var x=Function.prototype.bind?function(e,n){return e.bind(n)}:function(e,n){function t(t){var a=arguments.length;return a?a>1?e.apply(n,arguments):e.call(n,t):e.call(n)}return t._length=e.length,t};function R(e,n){n=n||0;for(var t=e.length-n,a=new Array(t);t--;)a[t]=e[t+n];return a}function D(e,n){for(var t in n)e[t]=n[t];return e}function M(e){for(var n={},t=0;t<e.length;t++)e[t]&&D(n,e[t]);return n}function O(e,n,t){}var U=function(e,n,t){return!1},L=function(e){return e};function N(e,n){if(e===n)return!0;var t=c(e),a=c(n);if(!t||!a)return!t&&!a&&String(e)===String(n);try{var o=Array.isArray(e),i=Array.isArray(n);if(o&&i)return e.length===n.length&&e.every((function(e,t){return N(e,n[t])}));if(e instanceof Date&&n instanceof Date)return e.getTime()===n.getTime();if(o||i)return!1;var r=Object.keys(e),s=Object.keys(n);return r.length===s.length&&r.every((function(t){return N(e[t],n[t])}))}catch(e){return!1}}function j(e,n){for(var t=0;t<e.length;t++)if(N(e[t],n))return t;return-1}function q(e){var n=!1;return function(){n||(n=!0,e.apply(this,arguments))}}var B=["component","directive","filter"],F=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],_={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:U,isReservedAttr:U,isUnknownElement:U,getTagNamespace:O,parsePlatformTagName:L,mustUseProp:U,async:!0,_lifecycleHooks:F},K=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function W(e,n,t,a){Object.defineProperty(e,n,{value:t,enumerable:!!a,writable:!0,configurable:!0})}var G=new RegExp("[^"+K.source+".$_\\d]");var H,z="__proto__"in{},Y="undefined"!=typeof window,V="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,J=V&&WXEnvironment.platform.toLowerCase(),X=Y&&window.navigator.userAgent.toLowerCase(),Q=X&&/msie|trident/.test(X),$=X&&X.indexOf("msie 9.0")>0,Z=X&&X.indexOf("edge/")>0,ee=(X&&X.indexOf("android"),X&&/iphone|ipad|ipod|ios/.test(X)||"ios"===J),ne=(X&&/chrome\/\d+/.test(X),X&&/phantomjs/.test(X),X&&X.match(/firefox\/(\d+)/)),te={}.watch,ae=!1;if(Y)try{var oe={};Object.defineProperty(oe,"passive",{get:function(){ae=!0}}),window.addEventListener("test-passive",null,oe)}catch(e){}var ie=function(){return void 0===H&&(H=!Y&&!V&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),H},re=Y&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function se(e){return"function"==typeof e&&/native code/.test(e.toString())}var le,de="undefined"!=typeof Symbol&&se(Symbol)&&"undefined"!=typeof Reflect&&se(Reflect.ownKeys);le="undefined"!=typeof Set&&se(Set)?Set:function(){function e(){this.set=Object.create(null)}return e.prototype.has=function(e){return!0===this.set[e]},e.prototype.add=function(e){this.set[e]=!0},e.prototype.clear=function(){this.set=Object.create(null)},e}();var ce=O,ue=0,pe=function(){this.id=ue++,this.subs=[]};pe.prototype.addSub=function(e){this.subs.push(e)},pe.prototype.removeSub=function(e){w(this.subs,e)},pe.prototype.depend=function(){pe.target&&pe.target.addDep(this)},pe.prototype.notify=function(){var e=this.subs.slice();for(var n=0,t=e.length;n<t;n++)e[n].update()},pe.target=null;var he=[];function me(e){he.push(e),pe.target=e}function ge(){he.pop(),pe.target=he[he.length-1]}var fe=function(e,n,t,a,o,i,r,s){this.tag=e,this.data=n,this.children=t,this.text=a,this.elm=o,this.ns=void 0,this.context=i,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=n&&n.key,this.componentOptions=r,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},be={child:{configurable:!0}};be.child.get=function(){return this.componentInstance},Object.defineProperties(fe.prototype,be);var ye=function(e){void 0===e&&(e="");var n=new fe;return n.text=e,n.isComment=!0,n};function ve(e){return new fe(void 0,void 0,void 0,String(e))}function we(e){var n=new fe(e.tag,e.data,e.children&&e.children.slice(),e.text,e.elm,e.context,e.componentOptions,e.asyncFactory);return n.ns=e.ns,n.isStatic=e.isStatic,n.key=e.key,n.isComment=e.isComment,n.fnContext=e.fnContext,n.fnOptions=e.fnOptions,n.fnScopeId=e.fnScopeId,n.asyncMeta=e.asyncMeta,n.isCloned=!0,n}var ke=Array.prototype,Ee=Object.create(ke);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(e){var n=ke[e];W(Ee,e,(function(){for(var t=[],a=arguments.length;a--;)t[a]=arguments[a];var o,i=n.apply(this,t),r=this.__ob__;switch(e){case"push":case"unshift":o=t;break;case"splice":o=t.slice(2)}return o&&r.observeArray(o),r.dep.notify(),i}))}));var Te=Object.getOwnPropertyNames(Ee),Ae=!0;function Ce(e){Ae=e}var Pe=function(e){this.value=e,this.dep=new pe,this.vmCount=0,W(e,"__ob__",this),Array.isArray(e)?(z?function(e,n){e.__proto__=n}(e,Ee):function(e,n,t){for(var a=0,o=t.length;a<o;a++){var i=t[a];W(e,i,n[i])}}(e,Ee,Te),this.observeArray(e)):this.walk(e)};function Se(e,n){var t;if(c(e)&&!(e instanceof fe))return E(e,"__ob__")&&e.__ob__ instanceof Pe?t=e.__ob__:Ae&&!ie()&&(Array.isArray(e)||p(e))&&Object.isExtensible(e)&&!e._isVue&&(t=new Pe(e)),n&&t&&t.vmCount++,t}function Ie(e,n,t,a,o){var i=new pe,r=Object.getOwnPropertyDescriptor(e,n);if(!r||!1!==r.configurable){var s=r&&r.get,l=r&&r.set;s&&!l||2!==arguments.length||(t=e[n]);var d=!o&&Se(t);Object.defineProperty(e,n,{enumerable:!0,configurable:!0,get:function(){var n=s?s.call(e):t;return pe.target&&(i.depend(),d&&(d.dep.depend(),Array.isArray(n)&&De(n))),n},set:function(n){var a=s?s.call(e):t;n===a||n!=n&&a!=a||s&&!l||(l?l.call(e,n):t=n,d=!o&&Se(n),i.notify())}})}}function xe(e,n,t){if(Array.isArray(e)&&m(n))return e.length=Math.max(e.length,n),e.splice(n,1,t),t;if(n in e&&!(n in Object.prototype))return e[n]=t,t;var a=e.__ob__;return e._isVue||a&&a.vmCount?t:a?(Ie(a.value,n,t),a.dep.notify(),t):(e[n]=t,t)}function Re(e,n){if(Array.isArray(e)&&m(n))e.splice(n,1);else{var t=e.__ob__;e._isVue||t&&t.vmCount||E(e,n)&&(delete e[n],t&&t.dep.notify())}}function De(e){for(var n=void 0,t=0,a=e.length;t<a;t++)(n=e[t])&&n.__ob__&&n.__ob__.dep.depend(),Array.isArray(n)&&De(n)}Pe.prototype.walk=function(e){for(var n=Object.keys(e),t=0;t<n.length;t++)Ie(e,n[t])},Pe.prototype.observeArray=function(e){for(var n=0,t=e.length;n<t;n++)Se(e[n])};var Me=_.optionMergeStrategies;function Oe(e,n){if(!n)return e;for(var t,a,o,i=de?Reflect.ownKeys(n):Object.keys(n),r=0;r<i.length;r++)"__ob__"!==(t=i[r])&&(a=e[t],o=n[t],E(e,t)?a!==o&&p(a)&&p(o)&&Oe(a,o):xe(e,t,o));return e}function Ue(e,n,t){return t?function(){var a="function"==typeof n?n.call(t,t):n,o="function"==typeof e?e.call(t,t):e;return a?Oe(a,o):o}:n?e?function(){return Oe("function"==typeof n?n.call(this,this):n,"function"==typeof e?e.call(this,this):e)}:n:e}function Le(e,n){var t=n?e?e.concat(n):Array.isArray(n)?n:[n]:e;return t?function(e){for(var n=[],t=0;t<e.length;t++)-1===n.indexOf(e[t])&&n.push(e[t]);return n}(t):t}function Ne(e,n,t,a){var o=Object.create(e||null);return n?D(o,n):o}Me.data=function(e,n,t){return t?Ue(e,n,t):n&&"function"!=typeof n?e:Ue(e,n)},F.forEach((function(e){Me[e]=Le})),B.forEach((function(e){Me[e+"s"]=Ne})),Me.watch=function(e,n,t,a){if(e===te&&(e=void 0),n===te&&(n=void 0),!n)return Object.create(e||null);if(!e)return n;var o={};for(var i in D(o,e),n){var r=o[i],s=n[i];r&&!Array.isArray(r)&&(r=[r]),o[i]=r?r.concat(s):Array.isArray(s)?s:[s]}return o},Me.props=Me.methods=Me.inject=Me.computed=function(e,n,t,a){if(!e)return n;var o=Object.create(null);return D(o,e),n&&D(o,n),o},Me.provide=Ue;var je=function(e,n){return void 0===n?e:n};function qe(e,n,t){if("function"==typeof n&&(n=n.options),function(e,n){var t=e.props;if(t){var a,o,i={};if(Array.isArray(t))for(a=t.length;a--;)"string"==typeof(o=t[a])&&(i[C(o)]={type:null});else if(p(t))for(var r in t)o=t[r],i[C(r)]=p(o)?o:{type:o};else 0;e.props=i}}(n),function(e,n){var t=e.inject;if(t){var a=e.inject={};if(Array.isArray(t))for(var o=0;o<t.length;o++)a[t[o]]={from:t[o]};else if(p(t))for(var i in t){var r=t[i];a[i]=p(r)?D({from:i},r):{from:r}}else 0}}(n),function(e){var n=e.directives;if(n)for(var t in n){var a=n[t];"function"==typeof a&&(n[t]={bind:a,update:a})}}(n),!n._base&&(n.extends&&(e=qe(e,n.extends,t)),n.mixins))for(var a=0,o=n.mixins.length;a<o;a++)e=qe(e,n.mixins[a],t);var i,r={};for(i in e)s(i);for(i in n)E(e,i)||s(i);function s(a){var o=Me[a]||je;r[a]=o(e[a],n[a],t,a)}return r}function Be(e,n,t,a){if("string"==typeof t){var o=e[n];if(E(o,t))return o[t];var i=C(t);if(E(o,i))return o[i];var r=P(i);return E(o,r)?o[r]:o[t]||o[i]||o[r]}}function Fe(e,n,t,a){var o=n[e],i=!E(t,e),r=t[e],s=Ge(Boolean,o.type);if(s>-1)if(i&&!E(o,"default"))r=!1;else if(""===r||r===I(e)){var l=Ge(String,o.type);(l<0||s<l)&&(r=!0)}if(void 0===r){r=function(e,n,t){if(!E(n,"default"))return;var a=n.default;0;if(e&&e.$options.propsData&&void 0===e.$options.propsData[t]&&void 0!==e._props[t])return e._props[t];return"function"==typeof a&&"Function"!==Ke(n.type)?a.call(e):a}(a,o,e);var d=Ae;Ce(!0),Se(r),Ce(d)}return r}var _e=/^\s*function (\w+)/;function Ke(e){var n=e&&e.toString().match(_e);return n?n[1]:""}function We(e,n){return Ke(e)===Ke(n)}function Ge(e,n){if(!Array.isArray(n))return We(n,e)?0:-1;for(var t=0,a=n.length;t<a;t++)if(We(n[t],e))return t;return-1}function He(e,n,t){me();try{if(n)for(var a=n;a=a.$parent;){var o=a.$options.errorCaptured;if(o)for(var i=0;i<o.length;i++)try{if(!1===o[i].call(a,e,n,t))return}catch(e){Ye(e,a,"errorCaptured hook")}}Ye(e,n,t)}finally{ge()}}function ze(e,n,t,a,o){var i;try{(i=t?e.apply(n,t):e.call(n))&&!i._isVue&&g(i)&&!i._handled&&(i.catch((function(e){return He(e,a,o+" (Promise/async)")})),i._handled=!0)}catch(e){He(e,a,o)}return i}function Ye(e,n,t){if(_.errorHandler)try{return _.errorHandler.call(null,e,n,t)}catch(n){n!==e&&Ve(n,null,"config.errorHandler")}Ve(e,n,t)}function Ve(e,n,t){if(!Y&&!V||"undefined"==typeof console)throw e;console.error(e)}var Je,Xe=!1,Qe=[],$e=!1;function Ze(){$e=!1;var e=Qe.slice(0);Qe.length=0;for(var n=0;n<e.length;n++)e[n]()}if("undefined"!=typeof Promise&&se(Promise)){var en=Promise.resolve();Je=function(){en.then(Ze),ee&&setTimeout(O)},Xe=!0}else if(Q||"undefined"==typeof MutationObserver||!se(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Je="undefined"!=typeof setImmediate&&se(setImmediate)?function(){setImmediate(Ze)}:function(){setTimeout(Ze,0)};else{var nn=1,tn=new MutationObserver(Ze),an=document.createTextNode(String(nn));tn.observe(an,{characterData:!0}),Je=function(){nn=(nn+1)%2,an.data=String(nn)},Xe=!0}function on(e,n){var t;if(Qe.push((function(){if(e)try{e.call(n)}catch(e){He(e,n,"nextTick")}else t&&t(n)})),$e||($e=!0,Je()),!e&&"undefined"!=typeof Promise)return new Promise((function(e){t=e}))}var rn=new le;function sn(e){!function e(n,t){var a,o,i=Array.isArray(n);if(!i&&!c(n)||Object.isFrozen(n)||n instanceof fe)return;if(n.__ob__){var r=n.__ob__.dep.id;if(t.has(r))return;t.add(r)}if(i)for(a=n.length;a--;)e(n[a],t);else for(o=Object.keys(n),a=o.length;a--;)e(n[o[a]],t)}(e,rn),rn.clear()}var ln=T((function(e){var n="&"===e.charAt(0),t="~"===(e=n?e.slice(1):e).charAt(0),a="!"===(e=t?e.slice(1):e).charAt(0);return{name:e=a?e.slice(1):e,once:t,capture:a,passive:n}}));function dn(e,n){function t(){var e=arguments,a=t.fns;if(!Array.isArray(a))return ze(a,null,arguments,n,"v-on handler");for(var o=a.slice(),i=0;i<o.length;i++)ze(o[i],null,e,n,"v-on handler")}return t.fns=e,t}function cn(e,n,t,a,o,i){var s,d,c,u;for(s in e)d=e[s],c=n[s],u=ln(s),r(d)||(r(c)?(r(d.fns)&&(d=e[s]=dn(d,i)),l(u.once)&&(d=e[s]=o(u.name,d,u.capture)),t(u.name,d,u.capture,u.passive,u.params)):d!==c&&(c.fns=d,e[s]=c));for(s in n)r(e[s])&&a((u=ln(s)).name,n[s],u.capture)}function un(e,n,t){var a;e instanceof fe&&(e=e.data.hook||(e.data.hook={}));var o=e[n];function i(){t.apply(this,arguments),w(a.fns,i)}r(o)?a=dn([i]):s(o.fns)&&l(o.merged)?(a=o).fns.push(i):a=dn([o,i]),a.merged=!0,e[n]=a}function pn(e,n,t,a,o){if(s(n)){if(E(n,t))return e[t]=n[t],o||delete n[t],!0;if(E(n,a))return e[t]=n[a],o||delete n[a],!0}return!1}function hn(e){return d(e)?[ve(e)]:Array.isArray(e)?function e(n,t){var a,o,i,c,u=[];for(a=0;a<n.length;a++)r(o=n[a])||"boolean"==typeof o||(i=u.length-1,c=u[i],Array.isArray(o)?o.length>0&&(mn((o=e(o,(t||"")+"_"+a))[0])&&mn(c)&&(u[i]=ve(c.text+o[0].text),o.shift()),u.push.apply(u,o)):d(o)?mn(c)?u[i]=ve(c.text+o):""!==o&&u.push(ve(o)):mn(o)&&mn(c)?u[i]=ve(c.text+o.text):(l(n._isVList)&&s(o.tag)&&r(o.key)&&s(t)&&(o.key="__vlist"+t+"_"+a+"__"),u.push(o)));return u}(e):void 0}function mn(e){return s(e)&&s(e.text)&&!1===e.isComment}function gn(e,n){if(e){for(var t=Object.create(null),a=de?Reflect.ownKeys(e):Object.keys(e),o=0;o<a.length;o++){var i=a[o];if("__ob__"!==i){for(var r=e[i].from,s=n;s;){if(s._provided&&E(s._provided,r)){t[i]=s._provided[r];break}s=s.$parent}if(!s)if("default"in e[i]){var l=e[i].default;t[i]="function"==typeof l?l.call(n):l}else 0}}return t}}function fn(e,n){if(!e||!e.length)return{};for(var t={},a=0,o=e.length;a<o;a++){var i=e[a],r=i.data;if(r&&r.attrs&&r.attrs.slot&&delete r.attrs.slot,i.context!==n&&i.fnContext!==n||!r||null==r.slot)(t.default||(t.default=[])).push(i);else{var s=r.slot,l=t[s]||(t[s]=[]);"template"===i.tag?l.push.apply(l,i.children||[]):l.push(i)}}for(var d in t)t[d].every(bn)&&delete t[d];return t}function bn(e){return e.isComment&&!e.asyncFactory||" "===e.text}function yn(e){return e.isComment&&e.asyncFactory}function vn(e,n,t){var a,o=Object.keys(n).length>0,r=e?!!e.$stable:!o,s=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(r&&t&&t!==i&&s===t.$key&&!o&&!t.$hasNormal)return t;for(var l in a={},e)e[l]&&"$"!==l[0]&&(a[l]=wn(n,l,e[l]))}else a={};for(var d in n)d in a||(a[d]=kn(n,d));return e&&Object.isExtensible(e)&&(e._normalized=a),W(a,"$stable",r),W(a,"$key",s),W(a,"$hasNormal",o),a}function wn(e,n,t){var a=function(){var e=arguments.length?t.apply(null,arguments):t({}),n=(e=e&&"object"==typeof e&&!Array.isArray(e)?[e]:hn(e))&&e[0];return e&&(!n||1===e.length&&n.isComment&&!yn(n))?void 0:e};return t.proxy&&Object.defineProperty(e,n,{get:a,enumerable:!0,configurable:!0}),a}function kn(e,n){return function(){return e[n]}}function En(e,n){var t,a,o,i,r;if(Array.isArray(e)||"string"==typeof e)for(t=new Array(e.length),a=0,o=e.length;a<o;a++)t[a]=n(e[a],a);else if("number"==typeof e)for(t=new Array(e),a=0;a<e;a++)t[a]=n(a+1,a);else if(c(e))if(de&&e[Symbol.iterator]){t=[];for(var l=e[Symbol.iterator](),d=l.next();!d.done;)t.push(n(d.value,t.length)),d=l.next()}else for(i=Object.keys(e),t=new Array(i.length),a=0,o=i.length;a<o;a++)r=i[a],t[a]=n(e[r],r,a);return s(t)||(t=[]),t._isVList=!0,t}function Tn(e,n,t,a){var o,i=this.$scopedSlots[e];i?(t=t||{},a&&(t=D(D({},a),t)),o=i(t)||("function"==typeof n?n():n)):o=this.$slots[e]||("function"==typeof n?n():n);var r=t&&t.slot;return r?this.$createElement("template",{slot:r},o):o}function An(e){return Be(this.$options,"filters",e)||L}function Cn(e,n){return Array.isArray(e)?-1===e.indexOf(n):e!==n}function Pn(e,n,t,a,o){var i=_.keyCodes[n]||t;return o&&a&&!_.keyCodes[n]?Cn(o,a):i?Cn(i,e):a?I(a)!==n:void 0===e}function Sn(e,n,t,a,o){if(t)if(c(t)){var i;Array.isArray(t)&&(t=M(t));var r=function(r){if("class"===r||"style"===r||v(r))i=e;else{var s=e.attrs&&e.attrs.type;i=a||_.mustUseProp(n,s,r)?e.domProps||(e.domProps={}):e.attrs||(e.attrs={})}var l=C(r),d=I(r);l in i||d in i||(i[r]=t[r],o&&((e.on||(e.on={}))["update:"+r]=function(e){t[r]=e}))};for(var s in t)r(s)}else;return e}function In(e,n){var t=this._staticTrees||(this._staticTrees=[]),a=t[e];return a&&!n||Rn(a=t[e]=this.$options.staticRenderFns[e].call(this._renderProxy,null,this),"__static__"+e,!1),a}function xn(e,n,t){return Rn(e,"__once__"+n+(t?"_"+t:""),!0),e}function Rn(e,n,t){if(Array.isArray(e))for(var a=0;a<e.length;a++)e[a]&&"string"!=typeof e[a]&&Dn(e[a],n+"_"+a,t);else Dn(e,n,t)}function Dn(e,n,t){e.isStatic=!0,e.key=n,e.isOnce=t}function Mn(e,n){if(n)if(p(n)){var t=e.on=e.on?D({},e.on):{};for(var a in n){var o=t[a],i=n[a];t[a]=o?[].concat(o,i):i}}else;return e}function On(e,n,t,a){n=n||{$stable:!t};for(var o=0;o<e.length;o++){var i=e[o];Array.isArray(i)?On(i,n,t):i&&(i.proxy&&(i.fn.proxy=!0),n[i.key]=i.fn)}return a&&(n.$key=a),n}function Un(e,n){for(var t=0;t<n.length;t+=2){var a=n[t];"string"==typeof a&&a&&(e[n[t]]=n[t+1])}return e}function Ln(e,n){return"string"==typeof e?n+e:e}function Nn(e){e._o=xn,e._n=b,e._s=f,e._l=En,e._t=Tn,e._q=N,e._i=j,e._m=In,e._f=An,e._k=Pn,e._b=Sn,e._v=ve,e._e=ye,e._u=On,e._g=Mn,e._d=Un,e._p=Ln}function jn(e,n,t,a,o){var r,s=this,d=o.options;E(a,"_uid")?(r=Object.create(a))._original=a:(r=a,a=a._original);var c=l(d._compiled),u=!c;this.data=e,this.props=n,this.children=t,this.parent=a,this.listeners=e.on||i,this.injections=gn(d.inject,a),this.slots=function(){return s.$slots||vn(e.scopedSlots,s.$slots=fn(t,a)),s.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return vn(e.scopedSlots,this.slots())}}),c&&(this.$options=d,this.$slots=this.slots(),this.$scopedSlots=vn(e.scopedSlots,this.$slots)),d._scopeId?this._c=function(e,n,t,o){var i=Gn(r,e,n,t,o,u);return i&&!Array.isArray(i)&&(i.fnScopeId=d._scopeId,i.fnContext=a),i}:this._c=function(e,n,t,a){return Gn(r,e,n,t,a,u)}}function qn(e,n,t,a,o){var i=we(e);return i.fnContext=t,i.fnOptions=a,n.slot&&((i.data||(i.data={})).slot=n.slot),i}function Bn(e,n){for(var t in n)e[C(t)]=n[t]}Nn(jn.prototype);var Fn={init:function(e,n){if(e.componentInstance&&!e.componentInstance._isDestroyed&&e.data.keepAlive){var t=e;Fn.prepatch(t,t)}else{(e.componentInstance=function(e,n){var t={_isComponent:!0,_parentVnode:e,parent:n},a=e.data.inlineTemplate;s(a)&&(t.render=a.render,t.staticRenderFns=a.staticRenderFns);return new e.componentOptions.Ctor(t)}(e,Zn)).$mount(n?e.elm:void 0,n)}},prepatch:function(e,n){var t=n.componentOptions;!function(e,n,t,a,o){0;var r=a.data.scopedSlots,s=e.$scopedSlots,l=!!(r&&!r.$stable||s!==i&&!s.$stable||r&&e.$scopedSlots.$key!==r.$key||!r&&e.$scopedSlots.$key),d=!!(o||e.$options._renderChildren||l);e.$options._parentVnode=a,e.$vnode=a,e._vnode&&(e._vnode.parent=a);if(e.$options._renderChildren=o,e.$attrs=a.data.attrs||i,e.$listeners=t||i,n&&e.$options.props){Ce(!1);for(var c=e._props,u=e.$options._propKeys||[],p=0;p<u.length;p++){var h=u[p],m=e.$options.props;c[h]=Fe(h,m,n,e)}Ce(!0),e.$options.propsData=n}t=t||i;var g=e.$options._parentListeners;e.$options._parentListeners=t,$n(e,t,g),d&&(e.$slots=fn(o,a.context),e.$forceUpdate());0}(n.componentInstance=e.componentInstance,t.propsData,t.listeners,n,t.children)},insert:function(e){var n,t=e.context,a=e.componentInstance;a._isMounted||(a._isMounted=!0,at(a,"mounted")),e.data.keepAlive&&(t._isMounted?((n=a)._inactive=!1,it.push(n)):tt(a,!0))},destroy:function(e){var n=e.componentInstance;n._isDestroyed||(e.data.keepAlive?function e(n,t){if(t&&(n._directInactive=!0,nt(n)))return;if(!n._inactive){n._inactive=!0;for(var a=0;a<n.$children.length;a++)e(n.$children[a]);at(n,"deactivated")}}(n,!0):n.$destroy())}},_n=Object.keys(Fn);function Kn(e,n,t,a,o){if(!r(e)){var d=t.$options._base;if(c(e)&&(e=d.extend(e)),"function"==typeof e){var u;if(r(e.cid)&&void 0===(e=function(e,n){if(l(e.error)&&s(e.errorComp))return e.errorComp;if(s(e.resolved))return e.resolved;var t=zn;t&&s(e.owners)&&-1===e.owners.indexOf(t)&&e.owners.push(t);if(l(e.loading)&&s(e.loadingComp))return e.loadingComp;if(t&&!s(e.owners)){var a=e.owners=[t],o=!0,i=null,d=null;t.$on("hook:destroyed",(function(){return w(a,t)}));var u=function(e){for(var n=0,t=a.length;n<t;n++)a[n].$forceUpdate();e&&(a.length=0,null!==i&&(clearTimeout(i),i=null),null!==d&&(clearTimeout(d),d=null))},p=q((function(t){e.resolved=Yn(t,n),o?a.length=0:u(!0)})),h=q((function(n){s(e.errorComp)&&(e.error=!0,u(!0))})),m=e(p,h);return c(m)&&(g(m)?r(e.resolved)&&m.then(p,h):g(m.component)&&(m.component.then(p,h),s(m.error)&&(e.errorComp=Yn(m.error,n)),s(m.loading)&&(e.loadingComp=Yn(m.loading,n),0===m.delay?e.loading=!0:i=setTimeout((function(){i=null,r(e.resolved)&&r(e.error)&&(e.loading=!0,u(!1))}),m.delay||200)),s(m.timeout)&&(d=setTimeout((function(){d=null,r(e.resolved)&&h(null)}),m.timeout)))),o=!1,e.loading?e.loadingComp:e.resolved}}(u=e,d)))return function(e,n,t,a,o){var i=ye();return i.asyncFactory=e,i.asyncMeta={data:n,context:t,children:a,tag:o},i}(u,n,t,a,o);n=n||{},Ct(e),s(n.model)&&function(e,n){var t=e.model&&e.model.prop||"value",a=e.model&&e.model.event||"input";(n.attrs||(n.attrs={}))[t]=n.model.value;var o=n.on||(n.on={}),i=o[a],r=n.model.callback;s(i)?(Array.isArray(i)?-1===i.indexOf(r):i!==r)&&(o[a]=[r].concat(i)):o[a]=r}(e.options,n);var p=function(e,n,t){var a=n.options.props;if(!r(a)){var o={},i=e.attrs,l=e.props;if(s(i)||s(l))for(var d in a){var c=I(d);pn(o,l,d,c,!0)||pn(o,i,d,c,!1)}return o}}(n,e);if(l(e.options.functional))return function(e,n,t,a,o){var r=e.options,l={},d=r.props;if(s(d))for(var c in d)l[c]=Fe(c,d,n||i);else s(t.attrs)&&Bn(l,t.attrs),s(t.props)&&Bn(l,t.props);var u=new jn(t,l,o,a,e),p=r.render.call(null,u._c,u);if(p instanceof fe)return qn(p,t,u.parent,r,u);if(Array.isArray(p)){for(var h=hn(p)||[],m=new Array(h.length),g=0;g<h.length;g++)m[g]=qn(h[g],t,u.parent,r,u);return m}}(e,p,n,t,a);var h=n.on;if(n.on=n.nativeOn,l(e.options.abstract)){var m=n.slot;n={},m&&(n.slot=m)}!function(e){for(var n=e.hook||(e.hook={}),t=0;t<_n.length;t++){var a=_n[t],o=n[a],i=Fn[a];o===i||o&&o._merged||(n[a]=o?Wn(i,o):i)}}(n);var f=e.options.name||o;return new fe("vue-component-"+e.cid+(f?"-"+f:""),n,void 0,void 0,void 0,t,{Ctor:e,propsData:p,listeners:h,tag:o,children:a},u)}}}function Wn(e,n){var t=function(t,a){e(t,a),n(t,a)};return t._merged=!0,t}function Gn(e,n,t,a,o,i){return(Array.isArray(t)||d(t))&&(o=a,a=t,t=void 0),l(i)&&(o=2),function(e,n,t,a,o){if(s(t)&&s(t.__ob__))return ye();s(t)&&s(t.is)&&(n=t.is);if(!n)return ye();0;Array.isArray(a)&&"function"==typeof a[0]&&((t=t||{}).scopedSlots={default:a[0]},a.length=0);2===o?a=hn(a):1===o&&(a=function(e){for(var n=0;n<e.length;n++)if(Array.isArray(e[n]))return Array.prototype.concat.apply([],e);return e}(a));var i,d;if("string"==typeof n){var u;d=e.$vnode&&e.$vnode.ns||_.getTagNamespace(n),i=_.isReservedTag(n)?new fe(_.parsePlatformTagName(n),t,a,void 0,void 0,e):t&&t.pre||!s(u=Be(e.$options,"components",n))?new fe(n,t,a,void 0,void 0,e):Kn(u,t,e,a,n)}else i=Kn(n,t,e,a);return Array.isArray(i)?i:s(i)?(s(d)&&function e(n,t,a){n.ns=t,"foreignObject"===n.tag&&(t=void 0,a=!0);if(s(n.children))for(var o=0,i=n.children.length;o<i;o++){var d=n.children[o];s(d.tag)&&(r(d.ns)||l(a)&&"svg"!==d.tag)&&e(d,t,a)}}(i,d),s(t)&&function(e){c(e.style)&&sn(e.style);c(e.class)&&sn(e.class)}(t),i):ye()}(e,n,t,a,o)}var Hn,zn=null;function Yn(e,n){return(e.__esModule||de&&"Module"===e[Symbol.toStringTag])&&(e=e.default),c(e)?n.extend(e):e}function Vn(e){if(Array.isArray(e))for(var n=0;n<e.length;n++){var t=e[n];if(s(t)&&(s(t.componentOptions)||yn(t)))return t}}function Jn(e,n){Hn.$on(e,n)}function Xn(e,n){Hn.$off(e,n)}function Qn(e,n){var t=Hn;return function a(){var o=n.apply(null,arguments);null!==o&&t.$off(e,a)}}function $n(e,n,t){Hn=e,cn(n,t||{},Jn,Xn,Qn,e),Hn=void 0}var Zn=null;function et(e){var n=Zn;return Zn=e,function(){Zn=n}}function nt(e){for(;e&&(e=e.$parent);)if(e._inactive)return!0;return!1}function tt(e,n){if(n){if(e._directInactive=!1,nt(e))return}else if(e._directInactive)return;if(e._inactive||null===e._inactive){e._inactive=!1;for(var t=0;t<e.$children.length;t++)tt(e.$children[t]);at(e,"activated")}}function at(e,n){me();var t=e.$options[n],a=n+" hook";if(t)for(var o=0,i=t.length;o<i;o++)ze(t[o],e,null,e,a);e._hasHookEvent&&e.$emit("hook:"+n),ge()}var ot=[],it=[],rt={},st=!1,lt=!1,dt=0;var ct=0,ut=Date.now;if(Y&&!Q){var pt=window.performance;pt&&"function"==typeof pt.now&&ut()>document.createEvent("Event").timeStamp&&(ut=function(){return pt.now()})}function ht(){var e,n;for(ct=ut(),lt=!0,ot.sort((function(e,n){return e.id-n.id})),dt=0;dt<ot.length;dt++)(e=ot[dt]).before&&e.before(),n=e.id,rt[n]=null,e.run();var t=it.slice(),a=ot.slice();dt=ot.length=it.length=0,rt={},st=lt=!1,function(e){for(var n=0;n<e.length;n++)e[n]._inactive=!0,tt(e[n],!0)}(t),function(e){var n=e.length;for(;n--;){var t=e[n],a=t.vm;a._watcher===t&&a._isMounted&&!a._isDestroyed&&at(a,"updated")}}(a),re&&_.devtools&&re.emit("flush")}var mt=0,gt=function(e,n,t,a,o){this.vm=e,o&&(e._watcher=this),e._watchers.push(this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++mt,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new le,this.newDepIds=new le,this.expression="","function"==typeof n?this.getter=n:(this.getter=function(e){if(!G.test(e)){var n=e.split(".");return function(e){for(var t=0;t<n.length;t++){if(!e)return;e=e[n[t]]}return e}}}(n),this.getter||(this.getter=O)),this.value=this.lazy?void 0:this.get()};gt.prototype.get=function(){var e;me(this);var n=this.vm;try{e=this.getter.call(n,n)}catch(e){if(!this.user)throw e;He(e,n,'getter for watcher "'+this.expression+'"')}finally{this.deep&&sn(e),ge(),this.cleanupDeps()}return e},gt.prototype.addDep=function(e){var n=e.id;this.newDepIds.has(n)||(this.newDepIds.add(n),this.newDeps.push(e),this.depIds.has(n)||e.addSub(this))},gt.prototype.cleanupDeps=function(){for(var e=this.deps.length;e--;){var n=this.deps[e];this.newDepIds.has(n.id)||n.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},gt.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(e){var n=e.id;if(null==rt[n]){if(rt[n]=!0,lt){for(var t=ot.length-1;t>dt&&ot[t].id>e.id;)t--;ot.splice(t+1,0,e)}else ot.push(e);st||(st=!0,on(ht))}}(this)},gt.prototype.run=function(){if(this.active){var e=this.get();if(e!==this.value||c(e)||this.deep){var n=this.value;if(this.value=e,this.user){var t='callback for watcher "'+this.expression+'"';ze(this.cb,this.vm,[e,n],this.vm,t)}else this.cb.call(this.vm,e,n)}}},gt.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},gt.prototype.depend=function(){for(var e=this.deps.length;e--;)this.deps[e].depend()},gt.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||w(this.vm._watchers,this);for(var e=this.deps.length;e--;)this.deps[e].removeSub(this);this.active=!1}};var ft={enumerable:!0,configurable:!0,get:O,set:O};function bt(e,n,t){ft.get=function(){return this[n][t]},ft.set=function(e){this[n][t]=e},Object.defineProperty(e,t,ft)}function yt(e){e._watchers=[];var n=e.$options;n.props&&function(e,n){var t=e.$options.propsData||{},a=e._props={},o=e.$options._propKeys=[];e.$parent&&Ce(!1);var i=function(i){o.push(i);var r=Fe(i,n,t,e);Ie(a,i,r),i in e||bt(e,"_props",i)};for(var r in n)i(r);Ce(!0)}(e,n.props),n.methods&&function(e,n){e.$options.props;for(var t in n)e[t]="function"!=typeof n[t]?O:x(n[t],e)}(e,n.methods),n.data?function(e){var n=e.$options.data;p(n=e._data="function"==typeof n?function(e,n){me();try{return e.call(n,n)}catch(e){return He(e,n,"data()"),{}}finally{ge()}}(n,e):n||{})||(n={});var t=Object.keys(n),a=e.$options.props,o=(e.$options.methods,t.length);for(;o--;){var i=t[o];0,a&&E(a,i)||(r=void 0,36!==(r=(i+"").charCodeAt(0))&&95!==r&&bt(e,"_data",i))}var r;Se(n,!0)}(e):Se(e._data={},!0),n.computed&&function(e,n){var t=e._computedWatchers=Object.create(null),a=ie();for(var o in n){var i=n[o],r="function"==typeof i?i:i.get;0,a||(t[o]=new gt(e,r||O,O,vt)),o in e||wt(e,o,i)}}(e,n.computed),n.watch&&n.watch!==te&&function(e,n){for(var t in n){var a=n[t];if(Array.isArray(a))for(var o=0;o<a.length;o++)Tt(e,t,a[o]);else Tt(e,t,a)}}(e,n.watch)}var vt={lazy:!0};function wt(e,n,t){var a=!ie();"function"==typeof t?(ft.get=a?kt(n):Et(t),ft.set=O):(ft.get=t.get?a&&!1!==t.cache?kt(n):Et(t.get):O,ft.set=t.set||O),Object.defineProperty(e,n,ft)}function kt(e){return function(){var n=this._computedWatchers&&this._computedWatchers[e];if(n)return n.dirty&&n.evaluate(),pe.target&&n.depend(),n.value}}function Et(e){return function(){return e.call(this,this)}}function Tt(e,n,t,a){return p(t)&&(a=t,t=t.handler),"string"==typeof t&&(t=e[t]),e.$watch(n,t,a)}var At=0;function Ct(e){var n=e.options;if(e.super){var t=Ct(e.super);if(t!==e.superOptions){e.superOptions=t;var a=function(e){var n,t=e.options,a=e.sealedOptions;for(var o in t)t[o]!==a[o]&&(n||(n={}),n[o]=t[o]);return n}(e);a&&D(e.extendOptions,a),(n=e.options=qe(t,e.extendOptions)).name&&(n.components[n.name]=e)}}return n}function Pt(e){this._init(e)}function St(e){e.cid=0;var n=1;e.extend=function(e){e=e||{};var t=this,a=t.cid,o=e._Ctor||(e._Ctor={});if(o[a])return o[a];var i=e.name||t.options.name;var r=function(e){this._init(e)};return(r.prototype=Object.create(t.prototype)).constructor=r,r.cid=n++,r.options=qe(t.options,e),r.super=t,r.options.props&&function(e){var n=e.options.props;for(var t in n)bt(e.prototype,"_props",t)}(r),r.options.computed&&function(e){var n=e.options.computed;for(var t in n)wt(e.prototype,t,n[t])}(r),r.extend=t.extend,r.mixin=t.mixin,r.use=t.use,B.forEach((function(e){r[e]=t[e]})),i&&(r.options.components[i]=r),r.superOptions=t.options,r.extendOptions=e,r.sealedOptions=D({},r.options),o[a]=r,r}}function It(e){return e&&(e.Ctor.options.name||e.tag)}function xt(e,n){return Array.isArray(e)?e.indexOf(n)>-1:"string"==typeof e?e.split(",").indexOf(n)>-1:!!h(e)&&e.test(n)}function Rt(e,n){var t=e.cache,a=e.keys,o=e._vnode;for(var i in t){var r=t[i];if(r){var s=r.name;s&&!n(s)&&Dt(t,i,a,o)}}}function Dt(e,n,t,a){var o=e[n];!o||a&&o.tag===a.tag||o.componentInstance.$destroy(),e[n]=null,w(t,n)}Pt.prototype._init=function(e){var n=this;n._uid=At++,n._isVue=!0,e&&e._isComponent?function(e,n){var t=e.$options=Object.create(e.constructor.options),a=n._parentVnode;t.parent=n.parent,t._parentVnode=a;var o=a.componentOptions;t.propsData=o.propsData,t._parentListeners=o.listeners,t._renderChildren=o.children,t._componentTag=o.tag,n.render&&(t.render=n.render,t.staticRenderFns=n.staticRenderFns)}(n,e):n.$options=qe(Ct(n.constructor),e||{},n),n._renderProxy=n,n._self=n,function(e){var n=e.$options,t=n.parent;if(t&&!n.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(e)}e.$parent=t,e.$root=t?t.$root:e,e.$children=[],e.$refs={},e._watcher=null,e._inactive=null,e._directInactive=!1,e._isMounted=!1,e._isDestroyed=!1,e._isBeingDestroyed=!1}(n),function(e){e._events=Object.create(null),e._hasHookEvent=!1;var n=e.$options._parentListeners;n&&$n(e,n)}(n),function(e){e._vnode=null,e._staticTrees=null;var n=e.$options,t=e.$vnode=n._parentVnode,a=t&&t.context;e.$slots=fn(n._renderChildren,a),e.$scopedSlots=i,e._c=function(n,t,a,o){return Gn(e,n,t,a,o,!1)},e.$createElement=function(n,t,a,o){return Gn(e,n,t,a,o,!0)};var o=t&&t.data;Ie(e,"$attrs",o&&o.attrs||i,null,!0),Ie(e,"$listeners",n._parentListeners||i,null,!0)}(n),at(n,"beforeCreate"),function(e){var n=gn(e.$options.inject,e);n&&(Ce(!1),Object.keys(n).forEach((function(t){Ie(e,t,n[t])})),Ce(!0))}(n),yt(n),function(e){var n=e.$options.provide;n&&(e._provided="function"==typeof n?n.call(e):n)}(n),at(n,"created"),n.$options.el&&n.$mount(n.$options.el)},function(e){var n={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(e.prototype,"$data",n),Object.defineProperty(e.prototype,"$props",t),e.prototype.$set=xe,e.prototype.$delete=Re,e.prototype.$watch=function(e,n,t){if(p(n))return Tt(this,e,n,t);(t=t||{}).user=!0;var a=new gt(this,e,n,t);if(t.immediate){var o='callback for immediate watcher "'+a.expression+'"';me(),ze(n,this,[a.value],this,o),ge()}return function(){a.teardown()}}}(Pt),function(e){var n=/^hook:/;e.prototype.$on=function(e,t){var a=this;if(Array.isArray(e))for(var o=0,i=e.length;o<i;o++)a.$on(e[o],t);else(a._events[e]||(a._events[e]=[])).push(t),n.test(e)&&(a._hasHookEvent=!0);return a},e.prototype.$once=function(e,n){var t=this;function a(){t.$off(e,a),n.apply(t,arguments)}return a.fn=n,t.$on(e,a),t},e.prototype.$off=function(e,n){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(Array.isArray(e)){for(var a=0,o=e.length;a<o;a++)t.$off(e[a],n);return t}var i,r=t._events[e];if(!r)return t;if(!n)return t._events[e]=null,t;for(var s=r.length;s--;)if((i=r[s])===n||i.fn===n){r.splice(s,1);break}return t},e.prototype.$emit=function(e){var n=this,t=n._events[e];if(t){t=t.length>1?R(t):t;for(var a=R(arguments,1),o='event handler for "'+e+'"',i=0,r=t.length;i<r;i++)ze(t[i],n,a,n,o)}return n}}(Pt),function(e){e.prototype._update=function(e,n){var t=this,a=t.$el,o=t._vnode,i=et(t);t._vnode=e,t.$el=o?t.__patch__(o,e):t.__patch__(t.$el,e,n,!1),i(),a&&(a.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},e.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},e.prototype.$destroy=function(){var e=this;if(!e._isBeingDestroyed){at(e,"beforeDestroy"),e._isBeingDestroyed=!0;var n=e.$parent;!n||n._isBeingDestroyed||e.$options.abstract||w(n.$children,e),e._watcher&&e._watcher.teardown();for(var t=e._watchers.length;t--;)e._watchers[t].teardown();e._data.__ob__&&e._data.__ob__.vmCount--,e._isDestroyed=!0,e.__patch__(e._vnode,null),at(e,"destroyed"),e.$off(),e.$el&&(e.$el.__vue__=null),e.$vnode&&(e.$vnode.parent=null)}}}(Pt),function(e){Nn(e.prototype),e.prototype.$nextTick=function(e){return on(e,this)},e.prototype._render=function(){var e,n=this,t=n.$options,a=t.render,o=t._parentVnode;o&&(n.$scopedSlots=vn(o.data.scopedSlots,n.$slots,n.$scopedSlots)),n.$vnode=o;try{zn=n,e=a.call(n._renderProxy,n.$createElement)}catch(t){He(t,n,"render"),e=n._vnode}finally{zn=null}return Array.isArray(e)&&1===e.length&&(e=e[0]),e instanceof fe||(e=ye()),e.parent=o,e}}(Pt);var Mt=[String,RegExp,Array],Ot={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Mt,exclude:Mt,max:[String,Number]},methods:{cacheVNode:function(){var e=this.cache,n=this.keys,t=this.vnodeToCache,a=this.keyToCache;if(t){var o=t.tag,i=t.componentInstance,r=t.componentOptions;e[a]={name:It(r),tag:o,componentInstance:i},n.push(a),this.max&&n.length>parseInt(this.max)&&Dt(e,n[0],n,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var e in this.cache)Dt(this.cache,e,this.keys)},mounted:function(){var e=this;this.cacheVNode(),this.$watch("include",(function(n){Rt(e,(function(e){return xt(n,e)}))})),this.$watch("exclude",(function(n){Rt(e,(function(e){return!xt(n,e)}))}))},updated:function(){this.cacheVNode()},render:function(){var e=this.$slots.default,n=Vn(e),t=n&&n.componentOptions;if(t){var a=It(t),o=this.include,i=this.exclude;if(o&&(!a||!xt(o,a))||i&&a&&xt(i,a))return n;var r=this.cache,s=this.keys,l=null==n.key?t.Ctor.cid+(t.tag?"::"+t.tag:""):n.key;r[l]?(n.componentInstance=r[l].componentInstance,w(s,l),s.push(l)):(this.vnodeToCache=n,this.keyToCache=l),n.data.keepAlive=!0}return n||e&&e[0]}}};!function(e){var n={get:function(){return _}};Object.defineProperty(e,"config",n),e.util={warn:ce,extend:D,mergeOptions:qe,defineReactive:Ie},e.set=xe,e.delete=Re,e.nextTick=on,e.observable=function(e){return Se(e),e},e.options=Object.create(null),B.forEach((function(n){e.options[n+"s"]=Object.create(null)})),e.options._base=e,D(e.options.components,Ot),function(e){e.use=function(e){var n=this._installedPlugins||(this._installedPlugins=[]);if(n.indexOf(e)>-1)return this;var t=R(arguments,1);return t.unshift(this),"function"==typeof e.install?e.install.apply(e,t):"function"==typeof e&&e.apply(null,t),n.push(e),this}}(e),function(e){e.mixin=function(e){return this.options=qe(this.options,e),this}}(e),St(e),function(e){B.forEach((function(n){e[n]=function(e,t){return t?("component"===n&&p(t)&&(t.name=t.name||e,t=this.options._base.extend(t)),"directive"===n&&"function"==typeof t&&(t={bind:t,update:t}),this.options[n+"s"][e]=t,t):this.options[n+"s"][e]}}))}(e)}(Pt),Object.defineProperty(Pt.prototype,"$isServer",{get:ie}),Object.defineProperty(Pt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Pt,"FunctionalRenderContext",{value:jn}),Pt.version="2.6.14";var Ut=y("style,class"),Lt=y("input,textarea,option,select,progress"),Nt=y("contenteditable,draggable,spellcheck"),jt=y("events,caret,typing,plaintext-only"),qt=y("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),Bt="http://www.w3.org/1999/xlink",Ft=function(e){return":"===e.charAt(5)&&"xlink"===e.slice(0,5)},_t=function(e){return Ft(e)?e.slice(6,e.length):""},Kt=function(e){return null==e||!1===e};function Wt(e){for(var n=e.data,t=e,a=e;s(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(n=Gt(a.data,n));for(;s(t=t.parent);)t&&t.data&&(n=Gt(n,t.data));return function(e,n){if(s(e)||s(n))return Ht(e,zt(n));return""}(n.staticClass,n.class)}function Gt(e,n){return{staticClass:Ht(e.staticClass,n.staticClass),class:s(e.class)?[e.class,n.class]:n.class}}function Ht(e,n){return e?n?e+" "+n:e:n||""}function zt(e){return Array.isArray(e)?function(e){for(var n,t="",a=0,o=e.length;a<o;a++)s(n=zt(e[a]))&&""!==n&&(t&&(t+=" "),t+=n);return t}(e):c(e)?function(e){var n="";for(var t in e)e[t]&&(n&&(n+=" "),n+=t);return n}(e):"string"==typeof e?e:""}var Yt={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Vt=y("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Jt=y("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Xt=function(e){return Vt(e)||Jt(e)};var Qt=Object.create(null);var $t=y("text,number,password,search,email,tel,url");var Zt=Object.freeze({createElement:function(e,n){var t=document.createElement(e);return"select"!==e||n.data&&n.data.attrs&&void 0!==n.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(e,n){return document.createElementNS(Yt[e],n)},createTextNode:function(e){return document.createTextNode(e)},createComment:function(e){return document.createComment(e)},insertBefore:function(e,n,t){e.insertBefore(n,t)},removeChild:function(e,n){e.removeChild(n)},appendChild:function(e,n){e.appendChild(n)},parentNode:function(e){return e.parentNode},nextSibling:function(e){return e.nextSibling},tagName:function(e){return e.tagName},setTextContent:function(e,n){e.textContent=n},setStyleScope:function(e,n){e.setAttribute(n,"")}}),ea={create:function(e,n){na(n)},update:function(e,n){e.data.ref!==n.data.ref&&(na(e,!0),na(n))},destroy:function(e){na(e,!0)}};function na(e,n){var t=e.data.ref;if(s(t)){var a=e.context,o=e.componentInstance||e.elm,i=a.$refs;n?Array.isArray(i[t])?w(i[t],o):i[t]===o&&(i[t]=void 0):e.data.refInFor?Array.isArray(i[t])?i[t].indexOf(o)<0&&i[t].push(o):i[t]=[o]:i[t]=o}}var ta=new fe("",{},[]),aa=["create","activate","update","remove","destroy"];function oa(e,n){return e.key===n.key&&e.asyncFactory===n.asyncFactory&&(e.tag===n.tag&&e.isComment===n.isComment&&s(e.data)===s(n.data)&&function(e,n){if("input"!==e.tag)return!0;var t,a=s(t=e.data)&&s(t=t.attrs)&&t.type,o=s(t=n.data)&&s(t=t.attrs)&&t.type;return a===o||$t(a)&&$t(o)}(e,n)||l(e.isAsyncPlaceholder)&&r(n.asyncFactory.error))}function ia(e,n,t){var a,o,i={};for(a=n;a<=t;++a)s(o=e[a].key)&&(i[o]=a);return i}var ra={create:sa,update:sa,destroy:function(e){sa(e,ta)}};function sa(e,n){(e.data.directives||n.data.directives)&&function(e,n){var t,a,o,i=e===ta,r=n===ta,s=da(e.data.directives,e.context),l=da(n.data.directives,n.context),d=[],c=[];for(t in l)a=s[t],o=l[t],a?(o.oldValue=a.value,o.oldArg=a.arg,ua(o,"update",n,e),o.def&&o.def.componentUpdated&&c.push(o)):(ua(o,"bind",n,e),o.def&&o.def.inserted&&d.push(o));if(d.length){var u=function(){for(var t=0;t<d.length;t++)ua(d[t],"inserted",n,e)};i?un(n,"insert",u):u()}c.length&&un(n,"postpatch",(function(){for(var t=0;t<c.length;t++)ua(c[t],"componentUpdated",n,e)}));if(!i)for(t in s)l[t]||ua(s[t],"unbind",e,e,r)}(e,n)}var la=Object.create(null);function da(e,n){var t,a,o=Object.create(null);if(!e)return o;for(t=0;t<e.length;t++)(a=e[t]).modifiers||(a.modifiers=la),o[ca(a)]=a,a.def=Be(n.$options,"directives",a.name);return o}function ca(e){return e.rawName||e.name+"."+Object.keys(e.modifiers||{}).join(".")}function ua(e,n,t,a,o){var i=e.def&&e.def[n];if(i)try{i(t.elm,e,t,a,o)}catch(a){He(a,t.context,"directive "+e.name+" "+n+" hook")}}var pa=[ea,ra];function ha(e,n){var t=n.componentOptions;if(!(s(t)&&!1===t.Ctor.options.inheritAttrs||r(e.data.attrs)&&r(n.data.attrs))){var a,o,i=n.elm,l=e.data.attrs||{},d=n.data.attrs||{};for(a in s(d.__ob__)&&(d=n.data.attrs=D({},d)),d)o=d[a],l[a]!==o&&ma(i,a,o,n.data.pre);for(a in(Q||Z)&&d.value!==l.value&&ma(i,"value",d.value),l)r(d[a])&&(Ft(a)?i.removeAttributeNS(Bt,_t(a)):Nt(a)||i.removeAttribute(a))}}function ma(e,n,t,a){a||e.tagName.indexOf("-")>-1?ga(e,n,t):qt(n)?Kt(t)?e.removeAttribute(n):(t="allowfullscreen"===n&&"EMBED"===e.tagName?"true":n,e.setAttribute(n,t)):Nt(n)?e.setAttribute(n,function(e,n){return Kt(n)||"false"===n?"false":"contenteditable"===e&&jt(n)?n:"true"}(n,t)):Ft(n)?Kt(t)?e.removeAttributeNS(Bt,_t(n)):e.setAttributeNS(Bt,n,t):ga(e,n,t)}function ga(e,n,t){if(Kt(t))e.removeAttribute(n);else{if(Q&&!$&&"TEXTAREA"===e.tagName&&"placeholder"===n&&""!==t&&!e.__ieph){var a=function(n){n.stopImmediatePropagation(),e.removeEventListener("input",a)};e.addEventListener("input",a),e.__ieph=!0}e.setAttribute(n,t)}}var fa={create:ha,update:ha};function ba(e,n){var t=n.elm,a=n.data,o=e.data;if(!(r(a.staticClass)&&r(a.class)&&(r(o)||r(o.staticClass)&&r(o.class)))){var i=Wt(n),l=t._transitionClasses;s(l)&&(i=Ht(i,zt(l))),i!==t._prevClass&&(t.setAttribute("class",i),t._prevClass=i)}}var ya,va={create:ba,update:ba};function wa(e,n,t){var a=ya;return function o(){var i=n.apply(null,arguments);null!==i&&Ta(e,o,t,a)}}var ka=Xe&&!(ne&&Number(ne[1])<=53);function Ea(e,n,t,a){if(ka){var o=ct,i=n;n=i._wrapper=function(e){if(e.target===e.currentTarget||e.timeStamp>=o||e.timeStamp<=0||e.target.ownerDocument!==document)return i.apply(this,arguments)}}ya.addEventListener(e,n,ae?{capture:t,passive:a}:t)}function Ta(e,n,t,a){(a||ya).removeEventListener(e,n._wrapper||n,t)}function Aa(e,n){if(!r(e.data.on)||!r(n.data.on)){var t=n.data.on||{},a=e.data.on||{};ya=n.elm,function(e){if(s(e.__r)){var n=Q?"change":"input";e[n]=[].concat(e.__r,e[n]||[]),delete e.__r}s(e.__c)&&(e.change=[].concat(e.__c,e.change||[]),delete e.__c)}(t),cn(t,a,Ea,Ta,wa,n.context),ya=void 0}}var Ca,Pa={create:Aa,update:Aa};function Sa(e,n){if(!r(e.data.domProps)||!r(n.data.domProps)){var t,a,o=n.elm,i=e.data.domProps||{},l=n.data.domProps||{};for(t in s(l.__ob__)&&(l=n.data.domProps=D({},l)),i)t in l||(o[t]="");for(t in l){if(a=l[t],"textContent"===t||"innerHTML"===t){if(n.children&&(n.children.length=0),a===i[t])continue;1===o.childNodes.length&&o.removeChild(o.childNodes[0])}if("value"===t&&"PROGRESS"!==o.tagName){o._value=a;var d=r(a)?"":String(a);Ia(o,d)&&(o.value=d)}else if("innerHTML"===t&&Jt(o.tagName)&&r(o.innerHTML)){(Ca=Ca||document.createElement("div")).innerHTML="<svg>"+a+"</svg>";for(var c=Ca.firstChild;o.firstChild;)o.removeChild(o.firstChild);for(;c.firstChild;)o.appendChild(c.firstChild)}else if(a!==i[t])try{o[t]=a}catch(e){}}}}function Ia(e,n){return!e.composing&&("OPTION"===e.tagName||function(e,n){var t=!0;try{t=document.activeElement!==e}catch(e){}return t&&e.value!==n}(e,n)||function(e,n){var t=e.value,a=e._vModifiers;if(s(a)){if(a.number)return b(t)!==b(n);if(a.trim)return t.trim()!==n.trim()}return t!==n}(e,n))}var xa={create:Sa,update:Sa},Ra=T((function(e){var n={},t=/:(.+)/;return e.split(/;(?![^(]*\))/g).forEach((function(e){if(e){var a=e.split(t);a.length>1&&(n[a[0].trim()]=a[1].trim())}})),n}));function Da(e){var n=Ma(e.style);return e.staticStyle?D(e.staticStyle,n):n}function Ma(e){return Array.isArray(e)?M(e):"string"==typeof e?Ra(e):e}var Oa,Ua=/^--/,La=/\s*!important$/,Na=function(e,n,t){if(Ua.test(n))e.style.setProperty(n,t);else if(La.test(t))e.style.setProperty(I(n),t.replace(La,""),"important");else{var a=qa(n);if(Array.isArray(t))for(var o=0,i=t.length;o<i;o++)e.style[a]=t[o];else e.style[a]=t}},ja=["Webkit","Moz","ms"],qa=T((function(e){if(Oa=Oa||document.createElement("div").style,"filter"!==(e=C(e))&&e in Oa)return e;for(var n=e.charAt(0).toUpperCase()+e.slice(1),t=0;t<ja.length;t++){var a=ja[t]+n;if(a in Oa)return a}}));function Ba(e,n){var t=n.data,a=e.data;if(!(r(t.staticStyle)&&r(t.style)&&r(a.staticStyle)&&r(a.style))){var o,i,l=n.elm,d=a.staticStyle,c=a.normalizedStyle||a.style||{},u=d||c,p=Ma(n.data.style)||{};n.data.normalizedStyle=s(p.__ob__)?D({},p):p;var h=function(e,n){var t,a={};if(n)for(var o=e;o.componentInstance;)(o=o.componentInstance._vnode)&&o.data&&(t=Da(o.data))&&D(a,t);(t=Da(e.data))&&D(a,t);for(var i=e;i=i.parent;)i.data&&(t=Da(i.data))&&D(a,t);return a}(n,!0);for(i in u)r(h[i])&&Na(l,i,"");for(i in h)(o=h[i])!==u[i]&&Na(l,i,null==o?"":o)}}var Fa={create:Ba,update:Ba},_a=/\s+/;function Ka(e,n){if(n&&(n=n.trim()))if(e.classList)n.indexOf(" ")>-1?n.split(_a).forEach((function(n){return e.classList.add(n)})):e.classList.add(n);else{var t=" "+(e.getAttribute("class")||"")+" ";t.indexOf(" "+n+" ")<0&&e.setAttribute("class",(t+n).trim())}}function Wa(e,n){if(n&&(n=n.trim()))if(e.classList)n.indexOf(" ")>-1?n.split(_a).forEach((function(n){return e.classList.remove(n)})):e.classList.remove(n),e.classList.length||e.removeAttribute("class");else{for(var t=" "+(e.getAttribute("class")||"")+" ",a=" "+n+" ";t.indexOf(a)>=0;)t=t.replace(a," ");(t=t.trim())?e.setAttribute("class",t):e.removeAttribute("class")}}function Ga(e){if(e){if("object"==typeof e){var n={};return!1!==e.css&&D(n,Ha(e.name||"v")),D(n,e),n}return"string"==typeof e?Ha(e):void 0}}var Ha=T((function(e){return{enterClass:e+"-enter",enterToClass:e+"-enter-to",enterActiveClass:e+"-enter-active",leaveClass:e+"-leave",leaveToClass:e+"-leave-to",leaveActiveClass:e+"-leave-active"}})),za=Y&&!$,Ya="transition",Va="transitionend",Ja="animation",Xa="animationend";za&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Ya="WebkitTransition",Va="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Ja="WebkitAnimation",Xa="webkitAnimationEnd"));var Qa=Y?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(e){return e()};function $a(e){Qa((function(){Qa(e)}))}function Za(e,n){var t=e._transitionClasses||(e._transitionClasses=[]);t.indexOf(n)<0&&(t.push(n),Ka(e,n))}function eo(e,n){e._transitionClasses&&w(e._transitionClasses,n),Wa(e,n)}function no(e,n,t){var a=ao(e,n),o=a.type,i=a.timeout,r=a.propCount;if(!o)return t();var s="transition"===o?Va:Xa,l=0,d=function(){e.removeEventListener(s,c),t()},c=function(n){n.target===e&&++l>=r&&d()};setTimeout((function(){l<r&&d()}),i+1),e.addEventListener(s,c)}var to=/\b(transform|all)(,|$)/;function ao(e,n){var t,a=window.getComputedStyle(e),o=(a[Ya+"Delay"]||"").split(", "),i=(a[Ya+"Duration"]||"").split(", "),r=oo(o,i),s=(a[Ja+"Delay"]||"").split(", "),l=(a[Ja+"Duration"]||"").split(", "),d=oo(s,l),c=0,u=0;return"transition"===n?r>0&&(t="transition",c=r,u=i.length):"animation"===n?d>0&&(t="animation",c=d,u=l.length):u=(t=(c=Math.max(r,d))>0?r>d?"transition":"animation":null)?"transition"===t?i.length:l.length:0,{type:t,timeout:c,propCount:u,hasTransform:"transition"===t&&to.test(a[Ya+"Property"])}}function oo(e,n){for(;e.length<n.length;)e=e.concat(e);return Math.max.apply(null,n.map((function(n,t){return io(n)+io(e[t])})))}function io(e){return 1e3*Number(e.slice(0,-1).replace(",","."))}function ro(e,n){var t=e.elm;s(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var a=Ga(e.data.transition);if(!r(a)&&!s(t._enterCb)&&1===t.nodeType){for(var o=a.css,i=a.type,l=a.enterClass,d=a.enterToClass,u=a.enterActiveClass,p=a.appearClass,h=a.appearToClass,m=a.appearActiveClass,g=a.beforeEnter,f=a.enter,y=a.afterEnter,v=a.enterCancelled,w=a.beforeAppear,k=a.appear,E=a.afterAppear,T=a.appearCancelled,A=a.duration,C=Zn,P=Zn.$vnode;P&&P.parent;)C=P.context,P=P.parent;var S=!C._isMounted||!e.isRootInsert;if(!S||k||""===k){var I=S&&p?p:l,x=S&&m?m:u,R=S&&h?h:d,D=S&&w||g,M=S&&"function"==typeof k?k:f,O=S&&E||y,U=S&&T||v,L=b(c(A)?A.enter:A);0;var N=!1!==o&&!$,j=co(M),B=t._enterCb=q((function(){N&&(eo(t,R),eo(t,x)),B.cancelled?(N&&eo(t,I),U&&U(t)):O&&O(t),t._enterCb=null}));e.data.show||un(e,"insert",(function(){var n=t.parentNode,a=n&&n._pending&&n._pending[e.key];a&&a.tag===e.tag&&a.elm._leaveCb&&a.elm._leaveCb(),M&&M(t,B)})),D&&D(t),N&&(Za(t,I),Za(t,x),$a((function(){eo(t,I),B.cancelled||(Za(t,R),j||(lo(L)?setTimeout(B,L):no(t,i,B)))}))),e.data.show&&(n&&n(),M&&M(t,B)),N||j||B()}}}function so(e,n){var t=e.elm;s(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var a=Ga(e.data.transition);if(r(a)||1!==t.nodeType)return n();if(!s(t._leaveCb)){var o=a.css,i=a.type,l=a.leaveClass,d=a.leaveToClass,u=a.leaveActiveClass,p=a.beforeLeave,h=a.leave,m=a.afterLeave,g=a.leaveCancelled,f=a.delayLeave,y=a.duration,v=!1!==o&&!$,w=co(h),k=b(c(y)?y.leave:y);0;var E=t._leaveCb=q((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[e.key]=null),v&&(eo(t,d),eo(t,u)),E.cancelled?(v&&eo(t,l),g&&g(t)):(n(),m&&m(t)),t._leaveCb=null}));f?f(T):T()}function T(){E.cancelled||(!e.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[e.key]=e),p&&p(t),v&&(Za(t,l),Za(t,u),$a((function(){eo(t,l),E.cancelled||(Za(t,d),w||(lo(k)?setTimeout(E,k):no(t,i,E)))}))),h&&h(t,E),v||w||E())}}function lo(e){return"number"==typeof e&&!isNaN(e)}function co(e){if(r(e))return!1;var n=e.fns;return s(n)?co(Array.isArray(n)?n[0]:n):(e._length||e.length)>1}function uo(e,n){!0!==n.data.show&&ro(n)}var po=function(e){var n,t,a={},o=e.modules,i=e.nodeOps;for(n=0;n<aa.length;++n)for(a[aa[n]]=[],t=0;t<o.length;++t)s(o[t][aa[n]])&&a[aa[n]].push(o[t][aa[n]]);function c(e){var n=i.parentNode(e);s(n)&&i.removeChild(n,e)}function u(e,n,t,o,r,d,c){if(s(e.elm)&&s(d)&&(e=d[c]=we(e)),e.isRootInsert=!r,!function(e,n,t,o){var i=e.data;if(s(i)){var r=s(e.componentInstance)&&i.keepAlive;if(s(i=i.hook)&&s(i=i.init)&&i(e,!1),s(e.componentInstance))return p(e,n),h(t,e.elm,o),l(r)&&function(e,n,t,o){var i,r=e;for(;r.componentInstance;)if(r=r.componentInstance._vnode,s(i=r.data)&&s(i=i.transition)){for(i=0;i<a.activate.length;++i)a.activate[i](ta,r);n.push(r);break}h(t,e.elm,o)}(e,n,t,o),!0}}(e,n,t,o)){var u=e.data,g=e.children,y=e.tag;s(y)?(e.elm=e.ns?i.createElementNS(e.ns,y):i.createElement(y,e),b(e),m(e,g,n),s(u)&&f(e,n),h(t,e.elm,o)):l(e.isComment)?(e.elm=i.createComment(e.text),h(t,e.elm,o)):(e.elm=i.createTextNode(e.text),h(t,e.elm,o))}}function p(e,n){s(e.data.pendingInsert)&&(n.push.apply(n,e.data.pendingInsert),e.data.pendingInsert=null),e.elm=e.componentInstance.$el,g(e)?(f(e,n),b(e)):(na(e),n.push(e))}function h(e,n,t){s(e)&&(s(t)?i.parentNode(t)===e&&i.insertBefore(e,n,t):i.appendChild(e,n))}function m(e,n,t){if(Array.isArray(n)){0;for(var a=0;a<n.length;++a)u(n[a],t,e.elm,null,!0,n,a)}else d(e.text)&&i.appendChild(e.elm,i.createTextNode(String(e.text)))}function g(e){for(;e.componentInstance;)e=e.componentInstance._vnode;return s(e.tag)}function f(e,t){for(var o=0;o<a.create.length;++o)a.create[o](ta,e);s(n=e.data.hook)&&(s(n.create)&&n.create(ta,e),s(n.insert)&&t.push(e))}function b(e){var n;if(s(n=e.fnScopeId))i.setStyleScope(e.elm,n);else for(var t=e;t;)s(n=t.context)&&s(n=n.$options._scopeId)&&i.setStyleScope(e.elm,n),t=t.parent;s(n=Zn)&&n!==e.context&&n!==e.fnContext&&s(n=n.$options._scopeId)&&i.setStyleScope(e.elm,n)}function v(e,n,t,a,o,i){for(;a<=o;++a)u(t[a],i,e,n,!1,t,a)}function w(e){var n,t,o=e.data;if(s(o))for(s(n=o.hook)&&s(n=n.destroy)&&n(e),n=0;n<a.destroy.length;++n)a.destroy[n](e);if(s(n=e.children))for(t=0;t<e.children.length;++t)w(e.children[t])}function k(e,n,t){for(;n<=t;++n){var a=e[n];s(a)&&(s(a.tag)?(E(a),w(a)):c(a.elm))}}function E(e,n){if(s(n)||s(e.data)){var t,o=a.remove.length+1;for(s(n)?n.listeners+=o:n=function(e,n){function t(){0==--t.listeners&&c(e)}return t.listeners=n,t}(e.elm,o),s(t=e.componentInstance)&&s(t=t._vnode)&&s(t.data)&&E(t,n),t=0;t<a.remove.length;++t)a.remove[t](e,n);s(t=e.data.hook)&&s(t=t.remove)?t(e,n):n()}else c(e.elm)}function T(e,n,t,a){for(var o=t;o<a;o++){var i=n[o];if(s(i)&&oa(e,i))return o}}function A(e,n,t,o,d,c){if(e!==n){s(n.elm)&&s(o)&&(n=o[d]=we(n));var p=n.elm=e.elm;if(l(e.isAsyncPlaceholder))s(n.asyncFactory.resolved)?S(e.elm,n,t):n.isAsyncPlaceholder=!0;else if(l(n.isStatic)&&l(e.isStatic)&&n.key===e.key&&(l(n.isCloned)||l(n.isOnce)))n.componentInstance=e.componentInstance;else{var h,m=n.data;s(m)&&s(h=m.hook)&&s(h=h.prepatch)&&h(e,n);var f=e.children,b=n.children;if(s(m)&&g(n)){for(h=0;h<a.update.length;++h)a.update[h](e,n);s(h=m.hook)&&s(h=h.update)&&h(e,n)}r(n.text)?s(f)&&s(b)?f!==b&&function(e,n,t,a,o){var l,d,c,p=0,h=0,m=n.length-1,g=n[0],f=n[m],b=t.length-1,y=t[0],w=t[b],E=!o;for(0;p<=m&&h<=b;)r(g)?g=n[++p]:r(f)?f=n[--m]:oa(g,y)?(A(g,y,a,t,h),g=n[++p],y=t[++h]):oa(f,w)?(A(f,w,a,t,b),f=n[--m],w=t[--b]):oa(g,w)?(A(g,w,a,t,b),E&&i.insertBefore(e,g.elm,i.nextSibling(f.elm)),g=n[++p],w=t[--b]):oa(f,y)?(A(f,y,a,t,h),E&&i.insertBefore(e,f.elm,g.elm),f=n[--m],y=t[++h]):(r(l)&&(l=ia(n,p,m)),r(d=s(y.key)?l[y.key]:T(y,n,p,m))?u(y,a,e,g.elm,!1,t,h):oa(c=n[d],y)?(A(c,y,a,t,h),n[d]=void 0,E&&i.insertBefore(e,c.elm,g.elm)):u(y,a,e,g.elm,!1,t,h),y=t[++h]);p>m?v(e,r(t[b+1])?null:t[b+1].elm,t,h,b,a):h>b&&k(n,p,m)}(p,f,b,t,c):s(b)?(s(e.text)&&i.setTextContent(p,""),v(p,null,b,0,b.length-1,t)):s(f)?k(f,0,f.length-1):s(e.text)&&i.setTextContent(p,""):e.text!==n.text&&i.setTextContent(p,n.text),s(m)&&s(h=m.hook)&&s(h=h.postpatch)&&h(e,n)}}}function C(e,n,t){if(l(t)&&s(e.parent))e.parent.data.pendingInsert=n;else for(var a=0;a<n.length;++a)n[a].data.hook.insert(n[a])}var P=y("attrs,class,staticClass,staticStyle,key");function S(e,n,t,a){var o,i=n.tag,r=n.data,d=n.children;if(a=a||r&&r.pre,n.elm=e,l(n.isComment)&&s(n.asyncFactory))return n.isAsyncPlaceholder=!0,!0;if(s(r)&&(s(o=r.hook)&&s(o=o.init)&&o(n,!0),s(o=n.componentInstance)))return p(n,t),!0;if(s(i)){if(s(d))if(e.hasChildNodes())if(s(o=r)&&s(o=o.domProps)&&s(o=o.innerHTML)){if(o!==e.innerHTML)return!1}else{for(var c=!0,u=e.firstChild,h=0;h<d.length;h++){if(!u||!S(u,d[h],t,a)){c=!1;break}u=u.nextSibling}if(!c||u)return!1}else m(n,d,t);if(s(r)){var g=!1;for(var b in r)if(!P(b)){g=!0,f(n,t);break}!g&&r.class&&sn(r.class)}}else e.data!==n.text&&(e.data=n.text);return!0}return function(e,n,t,o){if(!r(n)){var d,c=!1,p=[];if(r(e))c=!0,u(n,p);else{var h=s(e.nodeType);if(!h&&oa(e,n))A(e,n,p,null,null,o);else{if(h){if(1===e.nodeType&&e.hasAttribute("data-server-rendered")&&(e.removeAttribute("data-server-rendered"),t=!0),l(t)&&S(e,n,p))return C(n,p,!0),e;d=e,e=new fe(i.tagName(d).toLowerCase(),{},[],void 0,d)}var m=e.elm,f=i.parentNode(m);if(u(n,p,m._leaveCb?null:f,i.nextSibling(m)),s(n.parent))for(var b=n.parent,y=g(n);b;){for(var v=0;v<a.destroy.length;++v)a.destroy[v](b);if(b.elm=n.elm,y){for(var E=0;E<a.create.length;++E)a.create[E](ta,b);var T=b.data.hook.insert;if(T.merged)for(var P=1;P<T.fns.length;P++)T.fns[P]()}else na(b);b=b.parent}s(f)?k([e],0,0):s(e.tag)&&w(e)}}return C(n,p,c),n.elm}s(e)&&w(e)}}({nodeOps:Zt,modules:[fa,va,Pa,xa,Fa,Y?{create:uo,activate:uo,remove:function(e,n){!0!==e.data.show?so(e,n):n()}}:{}].concat(pa)});$&&document.addEventListener("selectionchange",(function(){var e=document.activeElement;e&&e.vmodel&&wo(e,"input")}));var ho={inserted:function(e,n,t,a){"select"===t.tag?(a.elm&&!a.elm._vOptions?un(t,"postpatch",(function(){ho.componentUpdated(e,n,t)})):mo(e,n,t.context),e._vOptions=[].map.call(e.options,bo)):("textarea"===t.tag||$t(e.type))&&(e._vModifiers=n.modifiers,n.modifiers.lazy||(e.addEventListener("compositionstart",yo),e.addEventListener("compositionend",vo),e.addEventListener("change",vo),$&&(e.vmodel=!0)))},componentUpdated:function(e,n,t){if("select"===t.tag){mo(e,n,t.context);var a=e._vOptions,o=e._vOptions=[].map.call(e.options,bo);if(o.some((function(e,n){return!N(e,a[n])})))(e.multiple?n.value.some((function(e){return fo(e,o)})):n.value!==n.oldValue&&fo(n.value,o))&&wo(e,"change")}}};function mo(e,n,t){go(e,n,t),(Q||Z)&&setTimeout((function(){go(e,n,t)}),0)}function go(e,n,t){var a=n.value,o=e.multiple;if(!o||Array.isArray(a)){for(var i,r,s=0,l=e.options.length;s<l;s++)if(r=e.options[s],o)i=j(a,bo(r))>-1,r.selected!==i&&(r.selected=i);else if(N(bo(r),a))return void(e.selectedIndex!==s&&(e.selectedIndex=s));o||(e.selectedIndex=-1)}}function fo(e,n){return n.every((function(n){return!N(n,e)}))}function bo(e){return"_value"in e?e._value:e.value}function yo(e){e.target.composing=!0}function vo(e){e.target.composing&&(e.target.composing=!1,wo(e.target,"input"))}function wo(e,n){var t=document.createEvent("HTMLEvents");t.initEvent(n,!0,!0),e.dispatchEvent(t)}function ko(e){return!e.componentInstance||e.data&&e.data.transition?e:ko(e.componentInstance._vnode)}var Eo={model:ho,show:{bind:function(e,n,t){var a=n.value,o=(t=ko(t)).data&&t.data.transition,i=e.__vOriginalDisplay="none"===e.style.display?"":e.style.display;a&&o?(t.data.show=!0,ro(t,(function(){e.style.display=i}))):e.style.display=a?i:"none"},update:function(e,n,t){var a=n.value;!a!=!n.oldValue&&((t=ko(t)).data&&t.data.transition?(t.data.show=!0,a?ro(t,(function(){e.style.display=e.__vOriginalDisplay})):so(t,(function(){e.style.display="none"}))):e.style.display=a?e.__vOriginalDisplay:"none")},unbind:function(e,n,t,a,o){o||(e.style.display=e.__vOriginalDisplay)}}},To={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Ao(e){var n=e&&e.componentOptions;return n&&n.Ctor.options.abstract?Ao(Vn(n.children)):e}function Co(e){var n={},t=e.$options;for(var a in t.propsData)n[a]=e[a];var o=t._parentListeners;for(var i in o)n[C(i)]=o[i];return n}function Po(e,n){if(/\d-keep-alive$/.test(n.tag))return e("keep-alive",{props:n.componentOptions.propsData})}var So=function(e){return e.tag||yn(e)},Io=function(e){return"show"===e.name},xo={name:"transition",props:To,abstract:!0,render:function(e){var n=this,t=this.$slots.default;if(t&&(t=t.filter(So)).length){0;var a=this.mode;0;var o=t[0];if(function(e){for(;e=e.parent;)if(e.data.transition)return!0}(this.$vnode))return o;var i=Ao(o);if(!i)return o;if(this._leaving)return Po(e,o);var r="__transition-"+this._uid+"-";i.key=null==i.key?i.isComment?r+"comment":r+i.tag:d(i.key)?0===String(i.key).indexOf(r)?i.key:r+i.key:i.key;var s=(i.data||(i.data={})).transition=Co(this),l=this._vnode,c=Ao(l);if(i.data.directives&&i.data.directives.some(Io)&&(i.data.show=!0),c&&c.data&&!function(e,n){return n.key===e.key&&n.tag===e.tag}(i,c)&&!yn(c)&&(!c.componentInstance||!c.componentInstance._vnode.isComment)){var u=c.data.transition=D({},s);if("out-in"===a)return this._leaving=!0,un(u,"afterLeave",(function(){n._leaving=!1,n.$forceUpdate()})),Po(e,o);if("in-out"===a){if(yn(i))return l;var p,h=function(){p()};un(s,"afterEnter",h),un(s,"enterCancelled",h),un(u,"delayLeave",(function(e){p=e}))}}return o}}},Ro=D({tag:String,moveClass:String},To);function Do(e){e.elm._moveCb&&e.elm._moveCb(),e.elm._enterCb&&e.elm._enterCb()}function Mo(e){e.data.newPos=e.elm.getBoundingClientRect()}function Oo(e){var n=e.data.pos,t=e.data.newPos,a=n.left-t.left,o=n.top-t.top;if(a||o){e.data.moved=!0;var i=e.elm.style;i.transform=i.WebkitTransform="translate("+a+"px,"+o+"px)",i.transitionDuration="0s"}}delete Ro.mode;var Uo={Transition:xo,TransitionGroup:{props:Ro,beforeMount:function(){var e=this,n=this._update;this._update=function(t,a){var o=et(e);e.__patch__(e._vnode,e.kept,!1,!0),e._vnode=e.kept,o(),n.call(e,t,a)}},render:function(e){for(var n=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),a=this.prevChildren=this.children,o=this.$slots.default||[],i=this.children=[],r=Co(this),s=0;s<o.length;s++){var l=o[s];if(l.tag)if(null!=l.key&&0!==String(l.key).indexOf("__vlist"))i.push(l),t[l.key]=l,(l.data||(l.data={})).transition=r;else;}if(a){for(var d=[],c=[],u=0;u<a.length;u++){var p=a[u];p.data.transition=r,p.data.pos=p.elm.getBoundingClientRect(),t[p.key]?d.push(p):c.push(p)}this.kept=e(n,null,d),this.removed=c}return e(n,null,i)},updated:function(){var e=this.prevChildren,n=this.moveClass||(this.name||"v")+"-move";e.length&&this.hasMove(e[0].elm,n)&&(e.forEach(Do),e.forEach(Mo),e.forEach(Oo),this._reflow=document.body.offsetHeight,e.forEach((function(e){if(e.data.moved){var t=e.elm,a=t.style;Za(t,n),a.transform=a.WebkitTransform=a.transitionDuration="",t.addEventListener(Va,t._moveCb=function e(a){a&&a.target!==t||a&&!/transform$/.test(a.propertyName)||(t.removeEventListener(Va,e),t._moveCb=null,eo(t,n))})}})))},methods:{hasMove:function(e,n){if(!za)return!1;if(this._hasMove)return this._hasMove;var t=e.cloneNode();e._transitionClasses&&e._transitionClasses.forEach((function(e){Wa(t,e)})),Ka(t,n),t.style.display="none",this.$el.appendChild(t);var a=ao(t);return this.$el.removeChild(t),this._hasMove=a.hasTransform}}}};Pt.config.mustUseProp=function(e,n,t){return"value"===t&&Lt(e)&&"button"!==n||"selected"===t&&"option"===e||"checked"===t&&"input"===e||"muted"===t&&"video"===e},Pt.config.isReservedTag=Xt,Pt.config.isReservedAttr=Ut,Pt.config.getTagNamespace=function(e){return Jt(e)?"svg":"math"===e?"math":void 0},Pt.config.isUnknownElement=function(e){if(!Y)return!0;if(Xt(e))return!1;if(e=e.toLowerCase(),null!=Qt[e])return Qt[e];var n=document.createElement(e);return e.indexOf("-")>-1?Qt[e]=n.constructor===window.HTMLUnknownElement||n.constructor===window.HTMLElement:Qt[e]=/HTMLUnknownElement/.test(n.toString())},D(Pt.options.directives,Eo),D(Pt.options.components,Uo),Pt.prototype.__patch__=Y?po:O,Pt.prototype.$mount=function(e,n){return function(e,n,t){var a;return e.$el=n,e.$options.render||(e.$options.render=ye),at(e,"beforeMount"),a=function(){e._update(e._render(),t)},new gt(e,a,O,{before:function(){e._isMounted&&!e._isDestroyed&&at(e,"beforeUpdate")}},!0),t=!1,null==e.$vnode&&(e._isMounted=!0,at(e,"mounted")),e}(this,e=e&&Y?function(e){if("string"==typeof e){var n=document.querySelector(e);return n||document.createElement("div")}return e}(e):void 0,n)},Y&&setTimeout((function(){_.devtools&&re&&re.emit("init",Pt)}),0);var Lo=Pt;
/*!
  * vue-router v3.5.3
  * (c) 2021 Evan You
  * @license MIT
  */function No(e,n){for(var t in n)e[t]=n[t];return e}var jo=/[!'()*]/g,qo=function(e){return"%"+e.charCodeAt(0).toString(16)},Bo=/%2C/g,Fo=function(e){return encodeURIComponent(e).replace(jo,qo).replace(Bo,",")};function _o(e){try{return decodeURIComponent(e)}catch(e){0}return e}var Ko=function(e){return null==e||"object"==typeof e?e:String(e)};function Wo(e){var n={};return(e=e.trim().replace(/^(\?|#|&)/,""))?(e.split("&").forEach((function(e){var t=e.replace(/\+/g," ").split("="),a=_o(t.shift()),o=t.length>0?_o(t.join("=")):null;void 0===n[a]?n[a]=o:Array.isArray(n[a])?n[a].push(o):n[a]=[n[a],o]})),n):n}function Go(e){var n=e?Object.keys(e).map((function(n){var t=e[n];if(void 0===t)return"";if(null===t)return Fo(n);if(Array.isArray(t)){var a=[];return t.forEach((function(e){void 0!==e&&(null===e?a.push(Fo(n)):a.push(Fo(n)+"="+Fo(e)))})),a.join("&")}return Fo(n)+"="+Fo(t)})).filter((function(e){return e.length>0})).join("&"):null;return n?"?"+n:""}var Ho=/\/?$/;function zo(e,n,t,a){var o=a&&a.options.stringifyQuery,i=n.query||{};try{i=Yo(i)}catch(e){}var r={name:n.name||e&&e.name,meta:e&&e.meta||{},path:n.path||"/",hash:n.hash||"",query:i,params:n.params||{},fullPath:Xo(n,o),matched:e?Jo(e):[]};return t&&(r.redirectedFrom=Xo(t,o)),Object.freeze(r)}function Yo(e){if(Array.isArray(e))return e.map(Yo);if(e&&"object"==typeof e){var n={};for(var t in e)n[t]=Yo(e[t]);return n}return e}var Vo=zo(null,{path:"/"});function Jo(e){for(var n=[];e;)n.unshift(e),e=e.parent;return n}function Xo(e,n){var t=e.path,a=e.query;void 0===a&&(a={});var o=e.hash;return void 0===o&&(o=""),(t||"/")+(n||Go)(a)+o}function Qo(e,n,t){return n===Vo?e===n:!!n&&(e.path&&n.path?e.path.replace(Ho,"")===n.path.replace(Ho,"")&&(t||e.hash===n.hash&&$o(e.query,n.query)):!(!e.name||!n.name)&&(e.name===n.name&&(t||e.hash===n.hash&&$o(e.query,n.query)&&$o(e.params,n.params))))}function $o(e,n){if(void 0===e&&(e={}),void 0===n&&(n={}),!e||!n)return e===n;var t=Object.keys(e).sort(),a=Object.keys(n).sort();return t.length===a.length&&t.every((function(t,o){var i=e[t];if(a[o]!==t)return!1;var r=n[t];return null==i||null==r?i===r:"object"==typeof i&&"object"==typeof r?$o(i,r):String(i)===String(r)}))}function Zo(e){for(var n=0;n<e.matched.length;n++){var t=e.matched[n];for(var a in t.instances){var o=t.instances[a],i=t.enteredCbs[a];if(o&&i){delete t.enteredCbs[a];for(var r=0;r<i.length;r++)o._isBeingDestroyed||i[r](o)}}}}var ei={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(e,n){var t=n.props,a=n.children,o=n.parent,i=n.data;i.routerView=!0;for(var r=o.$createElement,s=t.name,l=o.$route,d=o._routerViewCache||(o._routerViewCache={}),c=0,u=!1;o&&o._routerRoot!==o;){var p=o.$vnode?o.$vnode.data:{};p.routerView&&c++,p.keepAlive&&o._directInactive&&o._inactive&&(u=!0),o=o.$parent}if(i.routerViewDepth=c,u){var h=d[s],m=h&&h.component;return m?(h.configProps&&ni(m,i,h.route,h.configProps),r(m,i,a)):r()}var g=l.matched[c],f=g&&g.components[s];if(!g||!f)return d[s]=null,r();d[s]={component:f},i.registerRouteInstance=function(e,n){var t=g.instances[s];(n&&t!==e||!n&&t===e)&&(g.instances[s]=n)},(i.hook||(i.hook={})).prepatch=function(e,n){g.instances[s]=n.componentInstance},i.hook.init=function(e){e.data.keepAlive&&e.componentInstance&&e.componentInstance!==g.instances[s]&&(g.instances[s]=e.componentInstance),Zo(l)};var b=g.props&&g.props[s];return b&&(No(d[s],{route:l,configProps:b}),ni(f,i,l,b)),r(f,i,a)}};function ni(e,n,t,a){var o=n.props=function(e,n){switch(typeof n){case"undefined":return;case"object":return n;case"function":return n(e);case"boolean":return n?e.params:void 0;default:0}}(t,a);if(o){o=n.props=No({},o);var i=n.attrs=n.attrs||{};for(var r in o)e.props&&r in e.props||(i[r]=o[r],delete o[r])}}function ti(e,n,t){var a=e.charAt(0);if("/"===a)return e;if("?"===a||"#"===a)return n+e;var o=n.split("/");t&&o[o.length-1]||o.pop();for(var i=e.replace(/^\//,"").split("/"),r=0;r<i.length;r++){var s=i[r];".."===s?o.pop():"."!==s&&o.push(s)}return""!==o[0]&&o.unshift(""),o.join("/")}function ai(e){return e.replace(/\/+/g,"/")}var oi=Array.isArray||function(e){return"[object Array]"==Object.prototype.toString.call(e)},ii=vi,ri=ui,si=function(e,n){return hi(ui(e,n),n)},li=hi,di=yi,ci=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function ui(e,n){for(var t,a=[],o=0,i=0,r="",s=n&&n.delimiter||"/";null!=(t=ci.exec(e));){var l=t[0],d=t[1],c=t.index;if(r+=e.slice(i,c),i=c+l.length,d)r+=d[1];else{var u=e[i],p=t[2],h=t[3],m=t[4],g=t[5],f=t[6],b=t[7];r&&(a.push(r),r="");var y=null!=p&&null!=u&&u!==p,v="+"===f||"*"===f,w="?"===f||"*"===f,k=t[2]||s,E=m||g;a.push({name:h||o++,prefix:p||"",delimiter:k,optional:w,repeat:v,partial:y,asterisk:!!b,pattern:E?gi(E):b?".*":"[^"+mi(k)+"]+?"})}}return i<e.length&&(r+=e.substr(i)),r&&a.push(r),a}function pi(e){return encodeURI(e).replace(/[\/?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function hi(e,n){for(var t=new Array(e.length),a=0;a<e.length;a++)"object"==typeof e[a]&&(t[a]=new RegExp("^(?:"+e[a].pattern+")$",bi(n)));return function(n,a){for(var o="",i=n||{},r=(a||{}).pretty?pi:encodeURIComponent,s=0;s<e.length;s++){var l=e[s];if("string"!=typeof l){var d,c=i[l.name];if(null==c){if(l.optional){l.partial&&(o+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(oi(c)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(c)+"`");if(0===c.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var u=0;u<c.length;u++){if(d=r(c[u]),!t[s].test(d))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(d)+"`");o+=(0===u?l.prefix:l.delimiter)+d}}else{if(d=l.asterisk?encodeURI(c).replace(/[?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()})):r(c),!t[s].test(d))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+d+'"');o+=l.prefix+d}}else o+=l}return o}}function mi(e){return e.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function gi(e){return e.replace(/([=!:$\/()])/g,"\\$1")}function fi(e,n){return e.keys=n,e}function bi(e){return e&&e.sensitive?"":"i"}function yi(e,n,t){oi(n)||(t=n||t,n=[]);for(var a=(t=t||{}).strict,o=!1!==t.end,i="",r=0;r<e.length;r++){var s=e[r];if("string"==typeof s)i+=mi(s);else{var l=mi(s.prefix),d="(?:"+s.pattern+")";n.push(s),s.repeat&&(d+="(?:"+l+d+")*"),i+=d=s.optional?s.partial?l+"("+d+")?":"(?:"+l+"("+d+"))?":l+"("+d+")"}}var c=mi(t.delimiter||"/"),u=i.slice(-c.length)===c;return a||(i=(u?i.slice(0,-c.length):i)+"(?:"+c+"(?=$))?"),i+=o?"$":a&&u?"":"(?="+c+"|$)",fi(new RegExp("^"+i,bi(t)),n)}function vi(e,n,t){return oi(n)||(t=n||t,n=[]),t=t||{},e instanceof RegExp?function(e,n){var t=e.source.match(/\((?!\?)/g);if(t)for(var a=0;a<t.length;a++)n.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return fi(e,n)}(e,n):oi(e)?function(e,n,t){for(var a=[],o=0;o<e.length;o++)a.push(vi(e[o],n,t).source);return fi(new RegExp("(?:"+a.join("|")+")",bi(t)),n)}(e,n,t):function(e,n,t){return yi(ui(e,t),n,t)}(e,n,t)}ii.parse=ri,ii.compile=si,ii.tokensToFunction=li,ii.tokensToRegExp=di;var wi=Object.create(null);function ki(e,n,t){n=n||{};try{var a=wi[e]||(wi[e]=ii.compile(e));return"string"==typeof n.pathMatch&&(n[0]=n.pathMatch),a(n,{pretty:!0})}catch(e){return""}finally{delete n[0]}}function Ei(e,n,t,a){var o="string"==typeof e?{path:e}:e;if(o._normalized)return o;if(o.name){var i=(o=No({},e)).params;return i&&"object"==typeof i&&(o.params=No({},i)),o}if(!o.path&&o.params&&n){(o=No({},o))._normalized=!0;var r=No(No({},n.params),o.params);if(n.name)o.name=n.name,o.params=r;else if(n.matched.length){var s=n.matched[n.matched.length-1].path;o.path=ki(s,r,n.path)}else 0;return o}var l=function(e){var n="",t="",a=e.indexOf("#");a>=0&&(n=e.slice(a),e=e.slice(0,a));var o=e.indexOf("?");return o>=0&&(t=e.slice(o+1),e=e.slice(0,o)),{path:e,query:t,hash:n}}(o.path||""),d=n&&n.path||"/",c=l.path?ti(l.path,d,t||o.append):d,u=function(e,n,t){void 0===n&&(n={});var a,o=t||Wo;try{a=o(e||"")}catch(e){a={}}for(var i in n){var r=n[i];a[i]=Array.isArray(r)?r.map(Ko):Ko(r)}return a}(l.query,o.query,a&&a.options.parseQuery),p=o.hash||l.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:c,query:u,hash:p}}var Ti,Ai=function(){},Ci={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(e){var n=this,t=this.$router,a=this.$route,o=t.resolve(this.to,a,this.append),i=o.location,r=o.route,s=o.href,l={},d=t.options.linkActiveClass,c=t.options.linkExactActiveClass,u=null==d?"router-link-active":d,p=null==c?"router-link-exact-active":c,h=null==this.activeClass?u:this.activeClass,m=null==this.exactActiveClass?p:this.exactActiveClass,g=r.redirectedFrom?zo(null,Ei(r.redirectedFrom),null,t):r;l[m]=Qo(a,g,this.exactPath),l[h]=this.exact||this.exactPath?l[m]:function(e,n){return 0===e.path.replace(Ho,"/").indexOf(n.path.replace(Ho,"/"))&&(!n.hash||e.hash===n.hash)&&function(e,n){for(var t in n)if(!(t in e))return!1;return!0}(e.query,n.query)}(a,g);var f=l[m]?this.ariaCurrentValue:null,b=function(e){Pi(e)&&(n.replace?t.replace(i,Ai):t.push(i,Ai))},y={click:Pi};Array.isArray(this.event)?this.event.forEach((function(e){y[e]=b})):y[this.event]=b;var v={class:l},w=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:r,navigate:b,isActive:l[h],isExactActive:l[m]});if(w){if(1===w.length)return w[0];if(w.length>1||!w.length)return 0===w.length?e():e("span",{},w)}if("a"===this.tag)v.on=y,v.attrs={href:s,"aria-current":f};else{var k=function e(n){var t;if(n)for(var a=0;a<n.length;a++){if("a"===(t=n[a]).tag)return t;if(t.children&&(t=e(t.children)))return t}}(this.$slots.default);if(k){k.isStatic=!1;var E=k.data=No({},k.data);for(var T in E.on=E.on||{},E.on){var A=E.on[T];T in y&&(E.on[T]=Array.isArray(A)?A:[A])}for(var C in y)C in E.on?E.on[C].push(y[C]):E.on[C]=b;var P=k.data.attrs=No({},k.data.attrs);P.href=s,P["aria-current"]=f}else v.on=y}return e(this.tag,v,this.$slots.default)}};function Pi(e){if(!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey||e.defaultPrevented||void 0!==e.button&&0!==e.button)){if(e.currentTarget&&e.currentTarget.getAttribute){var n=e.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(n))return}return e.preventDefault&&e.preventDefault(),!0}}var Si="undefined"!=typeof window;function Ii(e,n,t,a,o){var i=n||[],r=t||Object.create(null),s=a||Object.create(null);e.forEach((function(e){!function e(n,t,a,o,i,r){var s=o.path,l=o.name;0;var d=o.pathToRegexpOptions||{},c=function(e,n,t){t||(e=e.replace(/\/$/,""));if("/"===e[0])return e;if(null==n)return e;return ai(n.path+"/"+e)}(s,i,d.strict);"boolean"==typeof o.caseSensitive&&(d.sensitive=o.caseSensitive);var u={path:c,regex:xi(c,d),components:o.components||{default:o.component},alias:o.alias?"string"==typeof o.alias?[o.alias]:o.alias:[],instances:{},enteredCbs:{},name:l,parent:i,matchAs:r,redirect:o.redirect,beforeEnter:o.beforeEnter,meta:o.meta||{},props:null==o.props?{}:o.components?o.props:{default:o.props}};o.children&&o.children.forEach((function(o){var i=r?ai(r+"/"+o.path):void 0;e(n,t,a,o,u,i)}));t[u.path]||(n.push(u.path),t[u.path]=u);if(void 0!==o.alias)for(var p=Array.isArray(o.alias)?o.alias:[o.alias],h=0;h<p.length;++h){0;var m={path:p[h],children:o.children};e(n,t,a,m,i,u.path||"/")}l&&(a[l]||(a[l]=u))}(i,r,s,e,o)}));for(var l=0,d=i.length;l<d;l++)"*"===i[l]&&(i.push(i.splice(l,1)[0]),d--,l--);return{pathList:i,pathMap:r,nameMap:s}}function xi(e,n){return ii(e,[],n)}function Ri(e,n){var t=Ii(e),a=t.pathList,o=t.pathMap,i=t.nameMap;function r(e,t,r){var s=Ei(e,t,!1,n),d=s.name;if(d){var c=i[d];if(!c)return l(null,s);var u=c.regex.keys.filter((function(e){return!e.optional})).map((function(e){return e.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in s.params)&&u.indexOf(p)>-1&&(s.params[p]=t.params[p]);return s.path=ki(c.path,s.params),l(c,s,r)}if(s.path){s.params={};for(var h=0;h<a.length;h++){var m=a[h],g=o[m];if(Di(g.regex,s.path,s.params))return l(g,s,r)}}return l(null,s)}function s(e,t){var a=e.redirect,o="function"==typeof a?a(zo(e,t,null,n)):a;if("string"==typeof o&&(o={path:o}),!o||"object"!=typeof o)return l(null,t);var s=o,d=s.name,c=s.path,u=t.query,p=t.hash,h=t.params;if(u=s.hasOwnProperty("query")?s.query:u,p=s.hasOwnProperty("hash")?s.hash:p,h=s.hasOwnProperty("params")?s.params:h,d){i[d];return r({_normalized:!0,name:d,query:u,hash:p,params:h},void 0,t)}if(c){var m=function(e,n){return ti(e,n.parent?n.parent.path:"/",!0)}(c,e);return r({_normalized:!0,path:ki(m,h),query:u,hash:p},void 0,t)}return l(null,t)}function l(e,t,a){return e&&e.redirect?s(e,a||t):e&&e.matchAs?function(e,n,t){var a=r({_normalized:!0,path:ki(t,n.params)});if(a){var o=a.matched,i=o[o.length-1];return n.params=a.params,l(i,n)}return l(null,n)}(0,t,e.matchAs):zo(e,t,a,n)}return{match:r,addRoute:function(e,n){var t="object"!=typeof e?i[e]:void 0;Ii([n||e],a,o,i,t),t&&t.alias.length&&Ii(t.alias.map((function(e){return{path:e,children:[n]}})),a,o,i,t)},getRoutes:function(){return a.map((function(e){return o[e]}))},addRoutes:function(e){Ii(e,a,o,i)}}}function Di(e,n,t){var a=n.match(e);if(!a)return!1;if(!t)return!0;for(var o=1,i=a.length;o<i;++o){var r=e.keys[o-1];r&&(t[r.name||"pathMatch"]="string"==typeof a[o]?_o(a[o]):a[o])}return!0}var Mi=Si&&window.performance&&window.performance.now?window.performance:Date;function Oi(){return Mi.now().toFixed(3)}var Ui=Oi();function Li(){return Ui}function Ni(e){return Ui=e}var ji=Object.create(null);function qi(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var e=window.location.protocol+"//"+window.location.host,n=window.location.href.replace(e,""),t=No({},window.history.state);return t.key=Li(),window.history.replaceState(t,"",n),window.addEventListener("popstate",_i),function(){window.removeEventListener("popstate",_i)}}function Bi(e,n,t,a){if(e.app){var o=e.options.scrollBehavior;o&&e.app.$nextTick((function(){var i=function(){var e=Li();if(e)return ji[e]}(),r=o.call(e,n,t,a?i:null);r&&("function"==typeof r.then?r.then((function(e){zi(e,i)})).catch((function(e){0})):zi(r,i))}))}}function Fi(){var e=Li();e&&(ji[e]={x:window.pageXOffset,y:window.pageYOffset})}function _i(e){Fi(),e.state&&e.state.key&&Ni(e.state.key)}function Ki(e){return Gi(e.x)||Gi(e.y)}function Wi(e){return{x:Gi(e.x)?e.x:window.pageXOffset,y:Gi(e.y)?e.y:window.pageYOffset}}function Gi(e){return"number"==typeof e}var Hi=/^#\d/;function zi(e,n){var t,a="object"==typeof e;if(a&&"string"==typeof e.selector){var o=Hi.test(e.selector)?document.getElementById(e.selector.slice(1)):document.querySelector(e.selector);if(o){var i=e.offset&&"object"==typeof e.offset?e.offset:{};n=function(e,n){var t=document.documentElement.getBoundingClientRect(),a=e.getBoundingClientRect();return{x:a.left-t.left-n.x,y:a.top-t.top-n.y}}(o,i={x:Gi((t=i).x)?t.x:0,y:Gi(t.y)?t.y:0})}else Ki(e)&&(n=Wi(e))}else a&&Ki(e)&&(n=Wi(e));n&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:n.x,top:n.y,behavior:e.behavior}):window.scrollTo(n.x,n.y))}var Yi,Vi=Si&&((-1===(Yi=window.navigator.userAgent).indexOf("Android 2.")&&-1===Yi.indexOf("Android 4.0")||-1===Yi.indexOf("Mobile Safari")||-1!==Yi.indexOf("Chrome")||-1!==Yi.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function Ji(e,n){Fi();var t=window.history;try{if(n){var a=No({},t.state);a.key=Li(),t.replaceState(a,"",e)}else t.pushState({key:Ni(Oi())},"",e)}catch(t){window.location[n?"replace":"assign"](e)}}function Xi(e){Ji(e,!0)}function Qi(e,n,t){var a=function(o){o>=e.length?t():e[o]?n(e[o],(function(){a(o+1)})):a(o+1)};a(0)}var $i={redirected:2,aborted:4,cancelled:8,duplicated:16};function Zi(e,n){return nr(e,n,$i.redirected,'Redirected when going from "'+e.fullPath+'" to "'+function(e){if("string"==typeof e)return e;if("path"in e)return e.path;var n={};return tr.forEach((function(t){t in e&&(n[t]=e[t])})),JSON.stringify(n,null,2)}(n)+'" via a navigation guard.')}function er(e,n){return nr(e,n,$i.cancelled,'Navigation cancelled from "'+e.fullPath+'" to "'+n.fullPath+'" with a new navigation.')}function nr(e,n,t,a){var o=new Error(a);return o._isRouter=!0,o.from=e,o.to=n,o.type=t,o}var tr=["params","query","hash"];function ar(e){return Object.prototype.toString.call(e).indexOf("Error")>-1}function or(e,n){return ar(e)&&e._isRouter&&(null==n||e.type===n)}function ir(e){return function(n,t,a){var o=!1,i=0,r=null;rr(e,(function(e,n,t,s){if("function"==typeof e&&void 0===e.cid){o=!0,i++;var l,d=dr((function(n){var o;((o=n).__esModule||lr&&"Module"===o[Symbol.toStringTag])&&(n=n.default),e.resolved="function"==typeof n?n:Ti.extend(n),t.components[s]=n,--i<=0&&a()})),c=dr((function(e){var n="Failed to resolve async component "+s+": "+e;r||(r=ar(e)?e:new Error(n),a(r))}));try{l=e(d,c)}catch(e){c(e)}if(l)if("function"==typeof l.then)l.then(d,c);else{var u=l.component;u&&"function"==typeof u.then&&u.then(d,c)}}})),o||a()}}function rr(e,n){return sr(e.map((function(e){return Object.keys(e.components).map((function(t){return n(e.components[t],e.instances[t],e,t)}))})))}function sr(e){return Array.prototype.concat.apply([],e)}var lr="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function dr(e){var n=!1;return function(){for(var t=[],a=arguments.length;a--;)t[a]=arguments[a];if(!n)return n=!0,e.apply(this,t)}}var cr=function(e,n){this.router=e,this.base=function(e){if(!e)if(Si){var n=document.querySelector("base");e=(e=n&&n.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else e="/";"/"!==e.charAt(0)&&(e="/"+e);return e.replace(/\/$/,"")}(n),this.current=Vo,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function ur(e,n,t,a){var o=rr(e,(function(e,a,o,i){var r=function(e,n){"function"!=typeof e&&(e=Ti.extend(e));return e.options[n]}(e,n);if(r)return Array.isArray(r)?r.map((function(e){return t(e,a,o,i)})):t(r,a,o,i)}));return sr(a?o.reverse():o)}function pr(e,n){if(n)return function(){return e.apply(n,arguments)}}cr.prototype.listen=function(e){this.cb=e},cr.prototype.onReady=function(e,n){this.ready?e():(this.readyCbs.push(e),n&&this.readyErrorCbs.push(n))},cr.prototype.onError=function(e){this.errorCbs.push(e)},cr.prototype.transitionTo=function(e,n,t){var a,o=this;try{a=this.router.match(e,this.current)}catch(e){throw this.errorCbs.forEach((function(n){n(e)})),e}var i=this.current;this.confirmTransition(a,(function(){o.updateRoute(a),n&&n(a),o.ensureURL(),o.router.afterHooks.forEach((function(e){e&&e(a,i)})),o.ready||(o.ready=!0,o.readyCbs.forEach((function(e){e(a)})))}),(function(e){t&&t(e),e&&!o.ready&&(or(e,$i.redirected)&&i===Vo||(o.ready=!0,o.readyErrorCbs.forEach((function(n){n(e)}))))}))},cr.prototype.confirmTransition=function(e,n,t){var a=this,o=this.current;this.pending=e;var i,r,s=function(e){!or(e)&&ar(e)&&(a.errorCbs.length?a.errorCbs.forEach((function(n){n(e)})):console.error(e)),t&&t(e)},l=e.matched.length-1,d=o.matched.length-1;if(Qo(e,o)&&l===d&&e.matched[l]===o.matched[d])return this.ensureURL(),e.hash&&Bi(this.router,o,e,!1),s(((r=nr(i=o,e,$i.duplicated,'Avoided redundant navigation to current location: "'+i.fullPath+'".')).name="NavigationDuplicated",r));var c=function(e,n){var t,a=Math.max(e.length,n.length);for(t=0;t<a&&e[t]===n[t];t++);return{updated:n.slice(0,t),activated:n.slice(t),deactivated:e.slice(t)}}(this.current.matched,e.matched),u=c.updated,p=c.deactivated,h=c.activated,m=[].concat(function(e){return ur(e,"beforeRouteLeave",pr,!0)}(p),this.router.beforeHooks,function(e){return ur(e,"beforeRouteUpdate",pr)}(u),h.map((function(e){return e.beforeEnter})),ir(h)),g=function(n,t){if(a.pending!==e)return s(er(o,e));try{n(e,o,(function(n){!1===n?(a.ensureURL(!0),s(function(e,n){return nr(e,n,$i.aborted,'Navigation aborted from "'+e.fullPath+'" to "'+n.fullPath+'" via a navigation guard.')}(o,e))):ar(n)?(a.ensureURL(!0),s(n)):"string"==typeof n||"object"==typeof n&&("string"==typeof n.path||"string"==typeof n.name)?(s(Zi(o,e)),"object"==typeof n&&n.replace?a.replace(n):a.push(n)):t(n)}))}catch(e){s(e)}};Qi(m,g,(function(){Qi(function(e){return ur(e,"beforeRouteEnter",(function(e,n,t,a){return function(e,n,t){return function(a,o,i){return e(a,o,(function(e){"function"==typeof e&&(n.enteredCbs[t]||(n.enteredCbs[t]=[]),n.enteredCbs[t].push(e)),i(e)}))}}(e,t,a)}))}(h).concat(a.router.resolveHooks),g,(function(){if(a.pending!==e)return s(er(o,e));a.pending=null,n(e),a.router.app&&a.router.app.$nextTick((function(){Zo(e)}))}))}))},cr.prototype.updateRoute=function(e){this.current=e,this.cb&&this.cb(e)},cr.prototype.setupListeners=function(){},cr.prototype.teardown=function(){this.listeners.forEach((function(e){e()})),this.listeners=[],this.current=Vo,this.pending=null};var hr=function(e){function n(n,t){e.call(this,n,t),this._startLocation=mr(this.base)}return e&&(n.__proto__=e),n.prototype=Object.create(e&&e.prototype),n.prototype.constructor=n,n.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var n=this.router,t=n.options.scrollBehavior,a=Vi&&t;a&&this.listeners.push(qi());var o=function(){var t=e.current,o=mr(e.base);e.current===Vo&&o===e._startLocation||e.transitionTo(o,(function(e){a&&Bi(n,e,t,!0)}))};window.addEventListener("popstate",o),this.listeners.push((function(){window.removeEventListener("popstate",o)}))}},n.prototype.go=function(e){window.history.go(e)},n.prototype.push=function(e,n,t){var a=this,o=this.current;this.transitionTo(e,(function(e){Ji(ai(a.base+e.fullPath)),Bi(a.router,e,o,!1),n&&n(e)}),t)},n.prototype.replace=function(e,n,t){var a=this,o=this.current;this.transitionTo(e,(function(e){Xi(ai(a.base+e.fullPath)),Bi(a.router,e,o,!1),n&&n(e)}),t)},n.prototype.ensureURL=function(e){if(mr(this.base)!==this.current.fullPath){var n=ai(this.base+this.current.fullPath);e?Ji(n):Xi(n)}},n.prototype.getCurrentLocation=function(){return mr(this.base)},n}(cr);function mr(e){var n=window.location.pathname,t=n.toLowerCase(),a=e.toLowerCase();return!e||t!==a&&0!==t.indexOf(ai(a+"/"))||(n=n.slice(e.length)),(n||"/")+window.location.search+window.location.hash}var gr=function(e){function n(n,t,a){e.call(this,n,t),a&&function(e){var n=mr(e);if(!/^\/#/.test(n))return window.location.replace(ai(e+"/#"+n)),!0}(this.base)||fr()}return e&&(n.__proto__=e),n.prototype=Object.create(e&&e.prototype),n.prototype.constructor=n,n.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var n=this.router.options.scrollBehavior,t=Vi&&n;t&&this.listeners.push(qi());var a=function(){var n=e.current;fr()&&e.transitionTo(br(),(function(a){t&&Bi(e.router,a,n,!0),Vi||wr(a.fullPath)}))},o=Vi?"popstate":"hashchange";window.addEventListener(o,a),this.listeners.push((function(){window.removeEventListener(o,a)}))}},n.prototype.push=function(e,n,t){var a=this,o=this.current;this.transitionTo(e,(function(e){vr(e.fullPath),Bi(a.router,e,o,!1),n&&n(e)}),t)},n.prototype.replace=function(e,n,t){var a=this,o=this.current;this.transitionTo(e,(function(e){wr(e.fullPath),Bi(a.router,e,o,!1),n&&n(e)}),t)},n.prototype.go=function(e){window.history.go(e)},n.prototype.ensureURL=function(e){var n=this.current.fullPath;br()!==n&&(e?vr(n):wr(n))},n.prototype.getCurrentLocation=function(){return br()},n}(cr);function fr(){var e=br();return"/"===e.charAt(0)||(wr("/"+e),!1)}function br(){var e=window.location.href,n=e.indexOf("#");return n<0?"":e=e.slice(n+1)}function yr(e){var n=window.location.href,t=n.indexOf("#");return(t>=0?n.slice(0,t):n)+"#"+e}function vr(e){Vi?Ji(yr(e)):window.location.hash=e}function wr(e){Vi?Xi(yr(e)):window.location.replace(yr(e))}var kr=function(e){function n(n,t){e.call(this,n,t),this.stack=[],this.index=-1}return e&&(n.__proto__=e),n.prototype=Object.create(e&&e.prototype),n.prototype.constructor=n,n.prototype.push=function(e,n,t){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index+1).concat(e),a.index++,n&&n(e)}),t)},n.prototype.replace=function(e,n,t){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index).concat(e),n&&n(e)}),t)},n.prototype.go=function(e){var n=this,t=this.index+e;if(!(t<0||t>=this.stack.length)){var a=this.stack[t];this.confirmTransition(a,(function(){var e=n.current;n.index=t,n.updateRoute(a),n.router.afterHooks.forEach((function(n){n&&n(a,e)}))}),(function(e){or(e,$i.duplicated)&&(n.index=t)}))}},n.prototype.getCurrentLocation=function(){var e=this.stack[this.stack.length-1];return e?e.fullPath:"/"},n.prototype.ensureURL=function(){},n}(cr),Er=function(e){void 0===e&&(e={}),this.app=null,this.apps=[],this.options=e,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Ri(e.routes||[],this);var n=e.mode||"hash";switch(this.fallback="history"===n&&!Vi&&!1!==e.fallback,this.fallback&&(n="hash"),Si||(n="abstract"),this.mode=n,n){case"history":this.history=new hr(this,e.base);break;case"hash":this.history=new gr(this,e.base,this.fallback);break;case"abstract":this.history=new kr(this,e.base);break;default:0}},Tr={currentRoute:{configurable:!0}};function Ar(e,n){return e.push(n),function(){var t=e.indexOf(n);t>-1&&e.splice(t,1)}}Er.prototype.match=function(e,n,t){return this.matcher.match(e,n,t)},Tr.currentRoute.get=function(){return this.history&&this.history.current},Er.prototype.init=function(e){var n=this;if(this.apps.push(e),e.$once("hook:destroyed",(function(){var t=n.apps.indexOf(e);t>-1&&n.apps.splice(t,1),n.app===e&&(n.app=n.apps[0]||null),n.app||n.history.teardown()})),!this.app){this.app=e;var t=this.history;if(t instanceof hr||t instanceof gr){var a=function(e){t.setupListeners(),function(e){var a=t.current,o=n.options.scrollBehavior;Vi&&o&&"fullPath"in e&&Bi(n,e,a,!1)}(e)};t.transitionTo(t.getCurrentLocation(),a,a)}t.listen((function(e){n.apps.forEach((function(n){n._route=e}))}))}},Er.prototype.beforeEach=function(e){return Ar(this.beforeHooks,e)},Er.prototype.beforeResolve=function(e){return Ar(this.resolveHooks,e)},Er.prototype.afterEach=function(e){return Ar(this.afterHooks,e)},Er.prototype.onReady=function(e,n){this.history.onReady(e,n)},Er.prototype.onError=function(e){this.history.onError(e)},Er.prototype.push=function(e,n,t){var a=this;if(!n&&!t&&"undefined"!=typeof Promise)return new Promise((function(n,t){a.history.push(e,n,t)}));this.history.push(e,n,t)},Er.prototype.replace=function(e,n,t){var a=this;if(!n&&!t&&"undefined"!=typeof Promise)return new Promise((function(n,t){a.history.replace(e,n,t)}));this.history.replace(e,n,t)},Er.prototype.go=function(e){this.history.go(e)},Er.prototype.back=function(){this.go(-1)},Er.prototype.forward=function(){this.go(1)},Er.prototype.getMatchedComponents=function(e){var n=e?e.matched?e:this.resolve(e).route:this.currentRoute;return n?[].concat.apply([],n.matched.map((function(e){return Object.keys(e.components).map((function(n){return e.components[n]}))}))):[]},Er.prototype.resolve=function(e,n,t){var a=Ei(e,n=n||this.history.current,t,this),o=this.match(a,n),i=o.redirectedFrom||o.fullPath;return{location:a,route:o,href:function(e,n,t){var a="hash"===t?"#"+n:n;return e?ai(e+"/"+a):a}(this.history.base,i,this.mode),normalizedTo:a,resolved:o}},Er.prototype.getRoutes=function(){return this.matcher.getRoutes()},Er.prototype.addRoute=function(e,n){this.matcher.addRoute(e,n),this.history.current!==Vo&&this.history.transitionTo(this.history.getCurrentLocation())},Er.prototype.addRoutes=function(e){this.matcher.addRoutes(e),this.history.current!==Vo&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Er.prototype,Tr),Er.install=function e(n){if(!e.installed||Ti!==n){e.installed=!0,Ti=n;var t=function(e){return void 0!==e},a=function(e,n){var a=e.$options._parentVnode;t(a)&&t(a=a.data)&&t(a=a.registerRouteInstance)&&a(e,n)};n.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),n.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(n.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(n.prototype,"$route",{get:function(){return this._routerRoot._route}}),n.component("RouterView",ei),n.component("RouterLink",Ci);var o=n.config.optionMergeStrategies;o.beforeRouteEnter=o.beforeRouteLeave=o.beforeRouteUpdate=o.created}},Er.version="3.5.3",Er.isNavigationFailure=or,Er.NavigationFailureType=$i,Er.START_LOCATION=Vo,Si&&window.Vue&&window.Vue.use(Er);var Cr=Er;t(153),t(154),t(87),t(198),t(56),t(227);function Pr(e){e.locales&&Object.keys(e.locales).forEach((function(n){e.locales[n].path=n})),Object.freeze(e)}t(36),t(43),t(59);function Sr(e){return(Sr="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}var Ir=t(52),xr=(t(24),t(54),t(195),t(196),t(27),{NotFound:function(){return t.e(186).then(t.bind(null,948))},Layout:function(){return Promise.all([t.e(0),t.e(1),t.e(3),t.e(38)]).then(t.bind(null,949))}}),Rr={"v-6105f836":function(){return t.e(188).then(t.bind(null,955))},"v-8f9ecbbc":function(){return t.e(187).then(t.bind(null,956))},"v-33b5fb82":function(){return t.e(190).then(t.bind(null,957))},"v-f5704990":function(){return t.e(189).then(t.bind(null,958))},"v-6f3b39b2":function(){return t.e(110).then(t.bind(null,959))},"v-374a5768":function(){return t.e(191).then(t.bind(null,960))},"v-32f0d168":function(){return t.e(71).then(t.bind(null,961))},"v-af1249b0":function(){return t.e(192).then(t.bind(null,962))},"v-30e9b340":function(){return t.e(72).then(t.bind(null,963))},"v-494daa6c":function(){return t.e(193).then(t.bind(null,964))},"v-b2f788ac":function(){return t.e(111).then(t.bind(null,965))},"v-4ba5aba2":function(){return t.e(112).then(t.bind(null,966))},"v-c8b7e2a8":function(){return t.e(43).then(t.bind(null,967))},"v-fc879dc8":function(){return t.e(195).then(t.bind(null,968))},"v-c542c3e0":function(){return t.e(194).then(t.bind(null,969))},"v-b18ee374":function(){return t.e(197).then(t.bind(null,970))},"v-6bdf789c":function(){return t.e(196).then(t.bind(null,971))},"v-75e450fc":function(){return t.e(198).then(t.bind(null,972))},"v-7ccd90a6":function(){return t.e(113).then(t.bind(null,973))},"v-55c921f4":function(){return t.e(115).then(t.bind(null,974))},"v-72897874":function(){return t.e(199).then(t.bind(null,975))},"v-674bd9c6":function(){return t.e(55).then(t.bind(null,976))},"v-2d64c0b4":function(){return t.e(114).then(t.bind(null,977))},"v-7e983c10":function(){return t.e(200).then(t.bind(null,978))},"v-dee87a08":function(){return t.e(201).then(t.bind(null,979))},"v-7a0a0434":function(){return t.e(116).then(t.bind(null,980))},"v-5263095c":function(){return t.e(202).then(t.bind(null,981))},"v-13a593e8":function(){return t.e(56).then(t.bind(null,982))},"v-77fc0840":function(){return t.e(117).then(t.bind(null,983))},"v-d4bd3f66":function(){return t.e(73).then(t.bind(null,984))},"v-4f033390":function(){return t.e(44).then(t.bind(null,985))},"v-9fd918ac":function(){return t.e(119).then(t.bind(null,986))},"v-c5890230":function(){return t.e(118).then(t.bind(null,987))},"v-7bc2fb4c":function(){return t.e(203).then(t.bind(null,988))},"v-d1257868":function(){return t.e(204).then(t.bind(null,989))},"v-8f8b9fb6":function(){return t.e(209).then(t.bind(null,990))},"v-7fd3ecd6":function(){return t.e(207).then(t.bind(null,991))},"v-63e6ea8c":function(){return t.e(205).then(t.bind(null,992))},"v-0d268fa8":function(){return t.e(208).then(t.bind(null,993))},"v-357745d0":function(){return Promise.all([t.e(0),t.e(74)]).then(t.bind(null,994))},"v-d62d0140":function(){return t.e(75).then(t.bind(null,995))},"v-a4229f80":function(){return t.e(210).then(t.bind(null,996))},"v-05ac7de0":function(){return t.e(39).then(t.bind(null,997))},"v-5e4809c0":function(){return t.e(20).then(t.bind(null,998))},"v-592245a0":function(){return t.e(211).then(t.bind(null,999))},"v-1793e788":function(){return t.e(212).then(t.bind(null,1e3))},"v-c90a8f02":function(){return t.e(206).then(t.bind(null,1001))},"v-4412ada8":function(){return t.e(12).then(t.bind(null,1002))},"v-5eae31e0":function(){return t.e(21).then(t.bind(null,1003))},"v-3a0d543c":function(){return t.e(213).then(t.bind(null,1004))},"v-2b5d3579":function(){return t.e(76).then(t.bind(null,1005))},"v-eec44296":function(){return t.e(214).then(t.bind(null,1006))},"v-9d2da6ce":function(){return t.e(77).then(t.bind(null,1007))},"v-f9d0080e":function(){return t.e(215).then(t.bind(null,1008))},"v-aa13396a":function(){return t.e(216).then(t.bind(null,1009))},"v-22e9e3da":function(){return t.e(120).then(t.bind(null,1010))},"v-7b7a2191":function(){return t.e(217).then(t.bind(null,1011))},"v-a7dae2b6":function(){return t.e(218).then(t.bind(null,1012))},"v-05ca4e63":function(){return t.e(121).then(t.bind(null,1013))},"v-65ebad25":function(){return t.e(4).then(t.bind(null,1014))},"v-280a3933":function(){return t.e(219).then(t.bind(null,1015))},"v-78a28bda":function(){return t.e(220).then(t.bind(null,1016))},"v-2f907ba6":function(){return t.e(221).then(t.bind(null,1017))},"v-4dafff61":function(){return t.e(223).then(t.bind(null,1018))},"v-85e64d9a":function(){return t.e(222).then(t.bind(null,1019))},"v-e4593a78":function(){return t.e(224).then(t.bind(null,1020))},"v-6cf1a96e":function(){return t.e(225).then(t.bind(null,1021))},"v-d5729320":function(){return t.e(122).then(t.bind(null,1022))},"v-424dcb66":function(){return t.e(227).then(t.bind(null,1023))},"v-7d14b320":function(){return t.e(226).then(t.bind(null,1024))},"v-5ff106e2":function(){return t.e(228).then(t.bind(null,1025))},"v-222d4c1e":function(){return t.e(231).then(t.bind(null,1026))},"v-e569c6f4":function(){return t.e(229).then(t.bind(null,1027))},"v-5500b462":function(){return t.e(123).then(t.bind(null,1028))},"v-27500614":function(){return t.e(233).then(t.bind(null,1029))},"v-9b561e74":function(){return t.e(232).then(t.bind(null,1030))},"v-ad8a3fa8":function(){return t.e(230).then(t.bind(null,1031))},"v-07fe8602":function(){return t.e(236).then(t.bind(null,1032))},"v-8f854294":function(){return t.e(234).then(t.bind(null,1033))},"v-62081954":function(){return t.e(235).then(t.bind(null,1034))},"v-eddb4118":function(){return t.e(237).then(t.bind(null,1035))},"v-f55e16e8":function(){return t.e(238).then(t.bind(null,1036))},"v-d7817940":function(){return t.e(241).then(t.bind(null,1037))},"v-fae665e0":function(){return t.e(239).then(t.bind(null,1038))},"v-80517bb0":function(){return t.e(240).then(t.bind(null,1039))},"v-2f689e20":function(){return t.e(242).then(t.bind(null,1040))},"v-cb6fc90c":function(){return t.e(243).then(t.bind(null,1041))},"v-e707fb34":function(){return t.e(45).then(t.bind(null,1042))},"v-3f00ca34":function(){return t.e(22).then(t.bind(null,1043))},"v-8adc6c34":function(){return t.e(5).then(t.bind(null,1044))},"v-27bb2d68":function(){return t.e(124).then(t.bind(null,1045))},"v-4ec0b1a8":function(){return t.e(46).then(t.bind(null,1046))},"v-087c5f39":function(){return t.e(245).then(t.bind(null,1047))},"v-ff78147a":function(){return t.e(246).then(t.bind(null,1048))},"v-5c97d4f4":function(){return t.e(244).then(t.bind(null,1049))},"v-6696675c":function(){return t.e(125).then(t.bind(null,1050))},"v-674ce676":function(){return t.e(13).then(t.bind(null,1051))},"v-43768dc5":function(){return t.e(57).then(t.bind(null,1052))},"v-7a0c5c26":function(){return t.e(126).then(t.bind(null,1053))},"v-68d2c0e6":function(){return t.e(247).then(t.bind(null,1054))},"v-3469f1cc":function(){return t.e(249).then(t.bind(null,1055))},"v-9e5cc7e8":function(){return t.e(248).then(t.bind(null,1056))},"v-65cd12ed":function(){return t.e(78).then(t.bind(null,1057))},"v-2fb94430":function(){return t.e(250).then(t.bind(null,1058))},"v-5787385a":function(){return t.e(251).then(t.bind(null,1059))},"v-4678a3b6":function(){return t.e(254).then(t.bind(null,1060))},"v-3c0fba7f":function(){return t.e(252).then(t.bind(null,1061))},"v-d6de65ec":function(){return t.e(127).then(t.bind(null,1062))},"v-c8257a16":function(){return t.e(253).then(t.bind(null,1063))},"v-81742dfa":function(){return t.e(256).then(t.bind(null,1064))},"v-5c03f9d0":function(){return Promise.all([t.e(0),t.e(79)]).then(t.bind(null,1065))},"v-55cdae2c":function(){return t.e(58).then(t.bind(null,1066))},"v-81215fb4":function(){return t.e(255).then(t.bind(null,1067))},"v-126467b2":function(){return t.e(257).then(t.bind(null,1068))},"v-5815c43c":function(){return t.e(14).then(t.bind(null,1069))},"v-4ed657b8":function(){return t.e(259).then(t.bind(null,1070))},"v-1f495540":function(){return t.e(23).then(t.bind(null,1071))},"v-2982c900":function(){return t.e(24).then(t.bind(null,1072))},"v-8794784e":function(){return t.e(261).then(t.bind(null,1073))},"v-1d83e0c0":function(){return t.e(258).then(t.bind(null,1074))},"v-2992138f":function(){return t.e(262).then(t.bind(null,1075))},"v-e9938dda":function(){return t.e(263).then(t.bind(null,1076))},"v-026f84c4":function(){return t.e(10).then(t.bind(null,1077))},"v-1f32e193":function(){return t.e(264).then(t.bind(null,1078))},"v-a91812da":function(){return t.e(265).then(t.bind(null,1079))},"v-974b2b74":function(){return t.e(260).then(t.bind(null,1080))},"v-be7b3b00":function(){return t.e(268).then(t.bind(null,1081))},"v-77f92ebc":function(){return t.e(270).then(t.bind(null,1082))},"v-61a61646":function(){return t.e(271).then(t.bind(null,1083))},"v-5009a1de":function(){return t.e(269).then(t.bind(null,1084))},"v-23af9480":function(){return t.e(266).then(t.bind(null,1085))},"v-07300966":function(){return t.e(275).then(t.bind(null,1086))},"v-39cda378":function(){return t.e(267).then(t.bind(null,1087))},"v-beeab77c":function(){return t.e(276).then(t.bind(null,1088))},"v-63176564":function(){return t.e(273).then(t.bind(null,1089))},"v-069d34da":function(){return t.e(272).then(t.bind(null,1090))},"v-5ca42bd6":function(){return t.e(274).then(t.bind(null,1091))},"v-197d46c4":function(){return t.e(277).then(t.bind(null,1092))},"v-43de24f2":function(){return t.e(278).then(t.bind(null,1093))},"v-5ba28d60":function(){return t.e(279).then(t.bind(null,1094))},"v-7ab73f40":function(){return t.e(130).then(t.bind(null,1095))},"v-5ccc0800":function(){return t.e(129).then(t.bind(null,1096))},"v-861cc580":function(){return t.e(128).then(t.bind(null,1097))},"v-176c11e4":function(){return t.e(280).then(t.bind(null,1098))},"v-580c2f40":function(){return t.e(281).then(t.bind(null,1099))},"v-ddda39c0":function(){return t.e(131).then(t.bind(null,1100))},"v-cd20d140":function(){return t.e(282).then(t.bind(null,1101))},"v-af750026":function(){return t.e(283).then(t.bind(null,1102))},"v-be5aa166":function(){return t.e(285).then(t.bind(null,1103))},"v-1df409ed":function(){return t.e(284).then(t.bind(null,1104))},"v-09fe236b":function(){return t.e(286).then(t.bind(null,1105))},"v-7329955e":function(){return t.e(289).then(t.bind(null,1106))},"v-2bb0591c":function(){return t.e(287).then(t.bind(null,1107))},"v-3b0f49bc":function(){return t.e(80).then(t.bind(null,1108))},"v-2c5a4dbe":function(){return t.e(290).then(t.bind(null,1109))},"v-ca77df0c":function(){return t.e(288).then(t.bind(null,1110))},"v-b07a18da":function(){return t.e(132).then(t.bind(null,1111))},"v-092b0aad":function(){return t.e(133).then(t.bind(null,1112))},"v-64e83e2d":function(){return t.e(291).then(t.bind(null,1113))},"v-c73e25e6":function(){return t.e(134).then(t.bind(null,1114))},"v-76dcebcd":function(){return t.e(293).then(t.bind(null,1115))},"v-4381b4cd":function(){return t.e(135).then(t.bind(null,1116))},"v-4a3a209f":function(){return t.e(292).then(t.bind(null,1117))},"v-1316b766":function(){return t.e(294).then(t.bind(null,1118))},"v-5c95a127":function(){return t.e(136).then(t.bind(null,1119))},"v-25348330":function(){return t.e(81).then(t.bind(null,1120))},"v-62808372":function(){return t.e(82).then(t.bind(null,1121))},"v-3aec1854":function(){return t.e(137).then(t.bind(null,1122))},"v-696f6946":function(){return t.e(296).then(t.bind(null,1123))},"v-415409a8":function(){return t.e(295).then(t.bind(null,1124))},"v-82dc7c74":function(){return t.e(297).then(t.bind(null,1125))},"v-80ada3b6":function(){return t.e(59).then(t.bind(null,1126))},"v-1699d844":function(){return t.e(60).then(t.bind(null,1127))},"v-606945f4":function(){return t.e(138).then(t.bind(null,1128))},"v-498cc790":function(){return t.e(298).then(t.bind(null,1129))},"v-76c4832a":function(){return t.e(139).then(t.bind(null,1130))},"v-677a6224":function(){return t.e(300).then(t.bind(null,1131))},"v-65ff98cc":function(){return t.e(299).then(t.bind(null,1132))},"v-1e6c858c":function(){return t.e(301).then(t.bind(null,1133))},"v-492826e8":function(){return t.e(141).then(t.bind(null,1134))},"v-4a485be8":function(){return t.e(140).then(t.bind(null,1135))},"v-0f23bca8":function(){return t.e(302).then(t.bind(null,1136))},"v-26ff67a8":function(){return t.e(303).then(t.bind(null,1137))},"v-3118c32c":function(){return t.e(304).then(t.bind(null,1138))},"v-16600c28":function(){return t.e(305).then(t.bind(null,1139))},"v-64f145d0":function(){return t.e(306).then(t.bind(null,1140))},"v-7e970e22":function(){return t.e(83).then(t.bind(null,1141))},"v-3cd17670":function(){return t.e(142).then(t.bind(null,1142))},"v-71f160b3":function(){return t.e(308).then(t.bind(null,1143))},"v-a7953bc2":function(){return t.e(307).then(t.bind(null,1144))},"v-7b34316c":function(){return t.e(143).then(t.bind(null,1145))},"v-25510810":function(){return Promise.all([t.e(0),t.e(84)]).then(t.bind(null,1146))},"v-58f64e85":function(){return t.e(309).then(t.bind(null,1147))},"v-17045d64":function(){return t.e(311).then(t.bind(null,1148))},"v-866830ac":function(){return t.e(310).then(t.bind(null,1149))},"v-6478fde6":function(){return t.e(312).then(t.bind(null,1150))},"v-8bb9a4fe":function(){return t.e(313).then(t.bind(null,1151))},"v-6e1ce060":function(){return t.e(85).then(t.bind(null,1152))},"v-1cd37820":function(){return t.e(15).then(t.bind(null,1153))},"v-cf987aa0":function(){return t.e(314).then(t.bind(null,1154))},"v-66e5dae0":function(){return t.e(35).then(t.bind(null,1155))},"v-0cb4fbc8":function(){return t.e(11).then(t.bind(null,1156))},"v-737fcee0":function(){return t.e(315).then(t.bind(null,1157))},"v-2bc8a194":function(){return t.e(316).then(t.bind(null,1158))},"v-413a89a0":function(){return t.e(16).then(t.bind(null,1159))},"v-1c9022e6":function(){return t.e(317).then(t.bind(null,1160))},"v-c350580e":function(){return t.e(318).then(t.bind(null,1161))},"v-19281c9a":function(){return t.e(319).then(t.bind(null,1162))},"v-8585111a":function(){return t.e(320).then(t.bind(null,1163))},"v-e4d3f29a":function(){return t.e(321).then(t.bind(null,1164))},"v-5503dfd0":function(){return t.e(322).then(t.bind(null,1165))},"v-1bf60ac0":function(){return t.e(323).then(t.bind(null,1166))},"v-69b9a4cc":function(){return t.e(327).then(t.bind(null,1167))},"v-012cd40c":function(){return t.e(325).then(t.bind(null,1168))},"v-65da4ddc":function(){return t.e(324).then(t.bind(null,1169))},"v-5d8b05c6":function(){return t.e(329).then(t.bind(null,1170))},"v-46bd5ad0":function(){return t.e(326).then(t.bind(null,1171))},"v-2659ff40":function(){return t.e(330).then(t.bind(null,1172))},"v-102cf958":function(){return t.e(328).then(t.bind(null,1173))},"v-73e5ec98":function(){return t.e(333).then(t.bind(null,1174))},"v-75704160":function(){return t.e(332).then(t.bind(null,1175))},"v-0f16da74":function(){return t.e(338).then(t.bind(null,1176))},"v-a13cc134":function(){return t.e(334).then(t.bind(null,1177))},"v-07622a2a":function(){return t.e(336).then(t.bind(null,1178))},"v-6fa3d88a":function(){return t.e(331).then(t.bind(null,1179))},"v-536a5526":function(){return t.e(335).then(t.bind(null,1180))},"v-43efab4d":function(){return t.e(342).then(t.bind(null,1181))},"v-ab0e5bc0":function(){return t.e(339).then(t.bind(null,1182))},"v-6e9a7bb4":function(){return t.e(337).then(t.bind(null,1183))},"v-701e8b40":function(){return t.e(340).then(t.bind(null,1184))},"v-3d12ebad":function(){return t.e(341).then(t.bind(null,1185))},"v-ebd258e6":function(){return t.e(343).then(t.bind(null,1186))},"v-23fbd1b8":function(){return t.e(346).then(t.bind(null,1187))},"v-6847b620":function(){return t.e(86).then(t.bind(null,1188))},"v-27be8b6a":function(){return t.e(344).then(t.bind(null,1189))},"v-4486ad80":function(){return t.e(345).then(t.bind(null,1190))},"v-7bef863e":function(){return t.e(347).then(t.bind(null,1191))},"v-67b9aca6":function(){return t.e(87).then(t.bind(null,1192))},"v-07879720":function(){return t.e(348).then(t.bind(null,1193))},"v-8c1a0244":function(){return t.e(144).then(t.bind(null,1194))},"v-4ce7f388":function(){return t.e(350).then(t.bind(null,1195))},"v-765adacc":function(){return t.e(349).then(t.bind(null,1196))},"v-5ea0ec18":function(){return t.e(89).then(t.bind(null,1197))},"v-6e997a68":function(){return t.e(88).then(t.bind(null,1198))},"v-6602b914":function(){return t.e(146).then(t.bind(null,1199))},"v-389f9c04":function(){return t.e(145).then(t.bind(null,1200))},"v-6af9f52c":function(){return t.e(351).then(t.bind(null,1201))},"v-b827ee28":function(){return t.e(47).then(t.bind(null,1202))},"v-4cd51ca4":function(){return t.e(352).then(t.bind(null,1203))},"v-cca1d5a0":function(){return t.e(354).then(t.bind(null,1204))},"v-a482b5a0":function(){return t.e(353).then(t.bind(null,1205))},"v-42f24850":function(){return t.e(356).then(t.bind(null,1206))},"v-a0fbe934":function(){return t.e(147).then(t.bind(null,1207))},"v-004ce474":function(){return t.e(355).then(t.bind(null,1208))},"v-35511046":function(){return t.e(357).then(t.bind(null,1209))},"v-73954b74":function(){return t.e(61).then(t.bind(null,1210))},"v-f24b9bf4":function(){return t.e(149).then(t.bind(null,1211))},"v-64e64a66":function(){return t.e(148).then(t.bind(null,1212))},"v-e60aa460":function(){return t.e(359).then(t.bind(null,1213))},"v-11e12530":function(){return t.e(360).then(t.bind(null,1214))},"v-2f6dd8e4":function(){return t.e(358).then(t.bind(null,1215))},"v-cb52bfb4":function(){return t.e(150).then(t.bind(null,1216))},"v-ceedd9b8":function(){return t.e(48).then(t.bind(null,1217))},"v-65dad879":function(){return t.e(90).then(t.bind(null,1218))},"v-e669d918":function(){return t.e(151).then(t.bind(null,1219))},"v-199e73e8":function(){return t.e(361).then(t.bind(null,1220))},"v-686eeb8c":function(){return t.e(62).then(t.bind(null,1221))},"v-18d45c68":function(){return t.e(362).then(t.bind(null,1222))},"v-64e2fc7c":function(){return t.e(91).then(t.bind(null,1223))},"v-78763ecc":function(){return t.e(363).then(t.bind(null,1224))},"v-78ffa47e":function(){return t.e(152).then(t.bind(null,1225))},"v-12c4b8e8":function(){return t.e(364).then(t.bind(null,1226))},"v-43cc5a82":function(){return t.e(365).then(t.bind(null,1227))},"v-5940cbec":function(){return t.e(367).then(t.bind(null,1228))},"v-63ebbea9":function(){return t.e(366).then(t.bind(null,1229))},"v-31b33280":function(){return t.e(369).then(t.bind(null,1230))},"v-c5bccc36":function(){return t.e(368).then(t.bind(null,1231))},"v-7f1d8120":function(){return t.e(93).then(t.bind(null,1232))},"v-7b1bc340":function(){return t.e(25).then(t.bind(null,1233))},"v-c5488050":function(){return Promise.all([t.e(0),t.e(92)]).then(t.bind(null,1234))},"v-737e16c0":function(){return t.e(40).then(t.bind(null,1235))},"v-a3f44c40":function(){return t.e(370).then(t.bind(null,1236))},"v-52142e80":function(){return t.e(26).then(t.bind(null,1237))},"v-3dbf2024":function(){return t.e(36).then(t.bind(null,1238))},"v-59b51a1c":function(){return t.e(372).then(t.bind(null,1239))},"v-740775e4":function(){return t.e(373).then(t.bind(null,1240))},"v-d415568e":function(){return t.e(375).then(t.bind(null,1241))},"v-de156dce":function(){return t.e(95).then(t.bind(null,1242))},"v-9c365042":function(){return t.e(376).then(t.bind(null,1243))},"v-7038fda5":function(){return t.e(377).then(t.bind(null,1244))},"v-f96fb7da":function(){return t.e(153).then(t.bind(null,1245))},"v-5718e2e0":function(){return t.e(371).then(t.bind(null,1246))},"v-58aa9db9":function(){return t.e(378).then(t.bind(null,1247))},"v-29922bb7":function(){return t.e(154).then(t.bind(null,1248))},"v-1aaaa2b9":function(){return t.e(94).then(t.bind(null,1249))},"v-4fb9ceee":function(){return t.e(374).then(t.bind(null,1250))},"v-ce9e808e":function(){return t.e(6).then(t.bind(null,1251))},"v-0dd48473":function(){return t.e(379).then(t.bind(null,1252))},"v-49bccbda":function(){return t.e(380).then(t.bind(null,1253))},"v-9c20f87e":function(){return t.e(381).then(t.bind(null,1254))},"v-ca832c1a":function(){return t.e(382).then(t.bind(null,1255))},"v-b440bc16":function(){return t.e(383).then(t.bind(null,1256))},"v-6cfa5998":function(){return t.e(384).then(t.bind(null,1257))},"v-67bc2474":function(){return t.e(386).then(t.bind(null,1258))},"v-f04502fc":function(){return t.e(385).then(t.bind(null,1259))},"v-0d653d78":function(){return t.e(155).then(t.bind(null,1260))},"v-4eda8cf6":function(){return t.e(388).then(t.bind(null,1261))},"v-62cf23f6":function(){return t.e(156).then(t.bind(null,1262))},"v-2cd5b326":function(){return t.e(387).then(t.bind(null,1263))},"v-13a01900":function(){return t.e(390).then(t.bind(null,1264))},"v-3fc45506":function(){return t.e(389).then(t.bind(null,1265))},"v-f28b3930":function(){return t.e(392).then(t.bind(null,1266))},"v-94205374":function(){return t.e(391).then(t.bind(null,1267))},"v-9ce1dd6c":function(){return t.e(393).then(t.bind(null,1268))},"v-3b785c2c":function(){return t.e(394).then(t.bind(null,1269))},"v-92f180c0":function(){return t.e(395).then(t.bind(null,1270))},"v-9bcd09c0":function(){return t.e(398).then(t.bind(null,1271))},"v-27a911b8":function(){return t.e(396).then(t.bind(null,1272))},"v-3686193c":function(){return t.e(397).then(t.bind(null,1273))},"v-531d2164":function(){return t.e(399).then(t.bind(null,1274))},"v-7cf9c1f4":function(){return t.e(401).then(t.bind(null,1275))},"v-37b585ce":function(){return t.e(400).then(t.bind(null,1276))},"v-3f492b08":function(){return t.e(50).then(t.bind(null,1277))},"v-1230c726":function(){return t.e(27).then(t.bind(null,1278))},"v-332e7fa6":function(){return t.e(49).then(t.bind(null,1279))},"v-4d12f6f4":function(){return t.e(402).then(t.bind(null,1280))},"v-7b0a15b4":function(){return t.e(7).then(t.bind(null,1281))},"v-2f87b6a0":function(){return t.e(157).then(t.bind(null,1282))},"v-adb93754":function(){return t.e(158).then(t.bind(null,1283))},"v-6729fcec":function(){return t.e(17).then(t.bind(null,1284))},"v-4120e3f8":function(){return t.e(404).then(t.bind(null,1285))},"v-3514fc0c":function(){return t.e(403).then(t.bind(null,1286))},"v-b64319e8":function(){return t.e(405).then(t.bind(null,1287))},"v-64ee1b00":function(){return t.e(159).then(t.bind(null,1288))},"v-3bdbce85":function(){return t.e(63).then(t.bind(null,1289))},"v-dcd8b7f4":function(){return t.e(406).then(t.bind(null,1290))},"v-7901b1b4":function(){return t.e(408).then(t.bind(null,1291))},"v-1450c2a6":function(){return t.e(407).then(t.bind(null,1292))},"v-258a5de6":function(){return t.e(160).then(t.bind(null,1293))},"v-80e62764":function(){return t.e(409).then(t.bind(null,1294))},"v-6ab3389c":function(){return t.e(64).then(t.bind(null,1295))},"v-0cf3f5ec":function(){return t.e(410).then(t.bind(null,1296))},"v-00077730":function(){return t.e(161).then(t.bind(null,1297))},"v-65aa6b28":function(){return t.e(411).then(t.bind(null,1298))},"v-5899f08a":function(){return t.e(162).then(t.bind(null,1299))},"v-19e7e228":function(){return t.e(412).then(t.bind(null,1300))},"v-516c114a":function(){return t.e(163).then(t.bind(null,1301))},"v-8852b36c":function(){return t.e(164).then(t.bind(null,1302))},"v-1b9bdef1":function(){return t.e(96).then(t.bind(null,1303))},"v-400aa74c":function(){return t.e(413).then(t.bind(null,1304))},"v-6a3fd5e8":function(){return t.e(414).then(t.bind(null,1305))},"v-3723c578":function(){return t.e(97).then(t.bind(null,1306))},"v-efcc73e8":function(){return t.e(415).then(t.bind(null,1307))},"v-2e9dbc86":function(){return t.e(165).then(t.bind(null,1308))},"v-438781d6":function(){return t.e(416).then(t.bind(null,1309))},"v-98694d68":function(){return t.e(417).then(t.bind(null,1310))},"v-1c5b09bf":function(){return t.e(418).then(t.bind(null,1311))},"v-55ae2236":function(){return t.e(421).then(t.bind(null,1312))},"v-47f57e71":function(){return t.e(419).then(t.bind(null,1313))},"v-6a6e256c":function(){return t.e(420).then(t.bind(null,1314))},"v-4fd3bacc":function(){return t.e(166).then(t.bind(null,1315))},"v-08b0f4d8":function(){return Promise.all([t.e(0),t.e(98)]).then(t.bind(null,1316))},"v-6e996aa2":function(){return t.e(167).then(t.bind(null,1317))},"v-5076a886":function(){return t.e(422).then(t.bind(null,1318))},"v-346e3ce6":function(){return t.e(168).then(t.bind(null,1319))},"v-037f6074":function(){return t.e(423).then(t.bind(null,1320))},"v-95ff1c02":function(){return t.e(424).then(t.bind(null,1321))},"v-77ce6300":function(){return t.e(99).then(t.bind(null,1322))},"v-72927900":function(){return t.e(28).then(t.bind(null,1323))},"v-7b427e40":function(){return t.e(425).then(t.bind(null,1324))},"v-a2fb3f00":function(){return t.e(41).then(t.bind(null,1325))},"v-d071ee00":function(){return t.e(426).then(t.bind(null,1326))},"v-16fa72cc":function(){return t.e(29).then(t.bind(null,1327))},"v-0980427e":function(){return t.e(37).then(t.bind(null,1328))},"v-f24c0590":function(){return t.e(429).then(t.bind(null,1329))},"v-f53df298":function(){return t.e(427).then(t.bind(null,1330))},"v-712e7cb8":function(){return t.e(428).then(t.bind(null,1331))},"v-9ab51f54":function(){return t.e(430).then(t.bind(null,1332))},"v-04fefc4a":function(){return t.e(431).then(t.bind(null,1333))},"v-d9a24a5c":function(){return t.e(432).then(t.bind(null,1334))},"v-9833fbb4":function(){return t.e(433).then(t.bind(null,1335))},"v-846210da":function(){return t.e(100).then(t.bind(null,1336))},"v-a7ad4b84":function(){return t.e(434).then(t.bind(null,1337))},"v-10c1b3bc":function(){return t.e(436).then(t.bind(null,1338))},"v-1b846906":function(){return t.e(438).then(t.bind(null,1339))},"v-151998f0":function(){return t.e(435).then(t.bind(null,1340))},"v-80e5c274":function(){return t.e(439).then(t.bind(null,1341))},"v-483bee76":function(){return t.e(437).then(t.bind(null,1342))},"v-b6142aea":function(){return t.e(440).then(t.bind(null,1343))},"v-a2a432b4":function(){return t.e(441).then(t.bind(null,1344))},"v-1f0dbe86":function(){return t.e(442).then(t.bind(null,1345))},"v-856d3940":function(){return t.e(443).then(t.bind(null,1346))},"v-58d00a40":function(){return t.e(444).then(t.bind(null,1347))},"v-69699fc0":function(){return t.e(446).then(t.bind(null,1348))},"v-3a7efb40":function(){return t.e(445).then(t.bind(null,1349))},"v-8df458c0":function(){return t.e(447).then(t.bind(null,1350))},"v-08f2d46c":function(){return t.e(448).then(t.bind(null,1351))},"v-63795daa":function(){return t.e(449).then(t.bind(null,1352))},"v-23d1ddc4":function(){return t.e(101).then(t.bind(null,1353))},"v-a598da14":function(){return t.e(451).then(t.bind(null,1354))},"v-cafac8c0":function(){return t.e(450).then(t.bind(null,1355))},"v-f69511c4":function(){return t.e(452).then(t.bind(null,1356))},"v-3be4ca38":function(){return t.e(102).then(t.bind(null,1357))},"v-1c11d3d2":function(){return t.e(169).then(t.bind(null,1358))},"v-59f43a00":function(){return t.e(453).then(t.bind(null,1359))},"v-73f90d08":function(){return t.e(455).then(t.bind(null,1360))},"v-bd433584":function(){return t.e(30).then(t.bind(null,1361))},"v-15da424c":function(){return t.e(454).then(t.bind(null,1362))},"v-055df94c":function(){return t.e(103).then(t.bind(null,1363))},"v-08a2e18a":function(){return t.e(170).then(t.bind(null,1364))},"v-49a9cc40":function(){return t.e(104).then(t.bind(null,1365))},"v-1727dd82":function(){return t.e(171).then(t.bind(null,1366))},"v-2bcbdf28":function(){return t.e(456).then(t.bind(null,1367))},"v-013efea8":function(){return t.e(51).then(t.bind(null,1368))},"v-092f5bf0":function(){return t.e(457).then(t.bind(null,1369))},"v-384a5208":function(){return t.e(458).then(t.bind(null,1370))},"v-4e900774":function(){return t.e(460).then(t.bind(null,1371))},"v-3761aa7c":function(){return t.e(459).then(t.bind(null,1372))},"v-32a2b2dc":function(){return t.e(461).then(t.bind(null,1373))},"v-0f8a9c74":function(){return t.e(462).then(t.bind(null,1374))},"v-1acd0da6":function(){return t.e(173).then(t.bind(null,1375))},"v-e897f2b4":function(){return t.e(172).then(t.bind(null,1376))},"v-ce697074":function(){return t.e(65).then(t.bind(null,1377))},"v-3b569df0":function(){return t.e(463).then(t.bind(null,1378))},"v-862815f4":function(){return t.e(174).then(t.bind(null,1379))},"v-4aeaf8dc":function(){return t.e(464).then(t.bind(null,1380))},"v-619bf73c":function(){return t.e(465).then(t.bind(null,1381))},"v-170b2834":function(){return t.e(175).then(t.bind(null,1382))},"v-10f101c0":function(){return t.e(176).then(t.bind(null,1383))},"v-498b9a6d":function(){return t.e(105).then(t.bind(null,1384))},"v-59320970":function(){return t.e(52).then(t.bind(null,1385))},"v-85a297e8":function(){return t.e(66).then(t.bind(null,1386))},"v-a7172670":function(){return t.e(177).then(t.bind(null,1387))},"v-6cd1d58a":function(){return t.e(178).then(t.bind(null,1388))},"v-42c4794c":function(){return t.e(466).then(t.bind(null,1389))},"v-9378b468":function(){return t.e(467).then(t.bind(null,1390))},"v-04b3508c":function(){return t.e(468).then(t.bind(null,1391))},"v-6d775b02":function(){return t.e(469).then(t.bind(null,1392))},"v-61834b18":function(){return Promise.all([t.e(0),t.e(106)]).then(t.bind(null,1393))},"v-2b5ccb75":function(){return t.e(470).then(t.bind(null,1394))},"v-662a322c":function(){return t.e(471).then(t.bind(null,1395))},"v-cac5d3b6":function(){return t.e(472).then(t.bind(null,1396))},"v-407b1dc0":function(){return t.e(31).then(t.bind(null,1397))},"v-26c50960":function(){return t.e(107).then(t.bind(null,1398))},"v-1aac2a40":function(){return t.e(473).then(t.bind(null,1399))},"v-7d1effe0":function(){return t.e(42).then(t.bind(null,1400))},"v-5875d3a0":function(){return t.e(474).then(t.bind(null,1401))},"v-575b6d30":function(){return t.e(475).then(t.bind(null,1402))},"v-2ae5af0c":function(){return t.e(18).then(t.bind(null,1403))},"v-4a508620":function(){return t.e(32).then(t.bind(null,1404))},"v-d238dffc":function(){return t.e(476).then(t.bind(null,1405))},"v-79cc9f79":function(){return t.e(108).then(t.bind(null,1406))},"v-455c4095":function(){return t.e(477).then(t.bind(null,1407))},"v-dc031c0e":function(){return t.e(478).then(t.bind(null,1408))},"v-52359299":function(){return t.e(109).then(t.bind(null,1409))},"v-10352daa":function(){return t.e(479).then(t.bind(null,1410))},"v-2f589b71":function(){return t.e(480).then(t.bind(null,1411))},"v-06f2bc13":function(){return t.e(179).then(t.bind(null,1412))},"v-17e34c85":function(){return t.e(481).then(t.bind(null,1413))},"v-15033c43":function(){return t.e(180).then(t.bind(null,1414))},"v-5f395013":function(){return t.e(483).then(t.bind(null,1415))},"v-5ad381f6":function(){return t.e(8).then(t.bind(null,1416))},"v-54e2540d":function(){return t.e(484).then(t.bind(null,1417))},"v-55d3d333":function(){return t.e(482).then(t.bind(null,1418))},"v-b645419a":function(){return t.e(485).then(t.bind(null,1419))},"v-c5e75eb8":function(){return t.e(487).then(t.bind(null,1420))},"v-cac1f57e":function(){return t.e(486).then(t.bind(null,1421))},"v-29b00b4e":function(){return t.e(488).then(t.bind(null,1422))},"v-2e351e00":function(){return t.e(489).then(t.bind(null,1423))},"v-01f14850":function(){return t.e(181).then(t.bind(null,1424))},"v-473b1d34":function(){return t.e(490).then(t.bind(null,1425))},"v-6a1fdcc2":function(){return t.e(491).then(t.bind(null,1426))},"v-08df2e42":function(){return t.e(182).then(t.bind(null,1427))},"v-2c5c21fe":function(){return t.e(494).then(t.bind(null,1428))},"v-992c93e8":function(){return t.e(493).then(t.bind(null,1429))},"v-751ba286":function(){return t.e(492).then(t.bind(null,1430))},"v-00c45ac6":function(){return t.e(495).then(t.bind(null,1431))},"v-49a30018":function(){return t.e(496).then(t.bind(null,1432))},"v-240e1c96":function(){return t.e(497).then(t.bind(null,1433))},"v-173773e2":function(){return t.e(499).then(t.bind(null,1434))},"v-1e637d54":function(){return t.e(500).then(t.bind(null,1435))},"v-3accb136":function(){return t.e(498).then(t.bind(null,1436))},"v-dc748a20":function(){return t.e(502).then(t.bind(null,1437))},"v-261acd60":function(){return t.e(504).then(t.bind(null,1438))},"v-392f6e6c":function(){return t.e(501).then(t.bind(null,1439))},"v-61df9ff0":function(){return t.e(503).then(t.bind(null,1440))},"v-f7011000":function(){return t.e(505).then(t.bind(null,1441))},"v-06f2ad5a":function(){return t.e(506).then(t.bind(null,1442))},"v-84091f34":function(){return t.e(53).then(t.bind(null,1443))},"v-2133de34":function(){return t.e(33).then(t.bind(null,1444))},"v-32044be6":function(){return t.e(9).then(t.bind(null,1445))},"v-f7ea08f0":function(){return t.e(54).then(t.bind(null,1446))},"v-ce94d8f4":function(){return t.e(507).then(t.bind(null,1447))},"v-ae3e69a8":function(){return t.e(183).then(t.bind(null,1448))},"v-c6d19f54":function(){return t.e(19).then(t.bind(null,1449))}};function Dr(e){var n=Object.create(null);return function(t){return n[t]||(n[t]=e(t))}}var Mr=/-(\w)/g,Or=Dr((function(e){return e.replace(Mr,(function(e,n){return n?n.toUpperCase():""}))})),Ur=/\B([A-Z])/g,Lr=Dr((function(e){return e.replace(Ur,"-$1").toLowerCase()})),Nr=Dr((function(e){return e.charAt(0).toUpperCase()+e.slice(1)}));function jr(e,n){if(n)return e(n)?e(n):n.includes("-")?e(Nr(Or(n))):e(Nr(n))||e(Lr(n))}var qr=Object.assign({},xr,Rr),Br=function(e){return qr[e]},Fr=function(e){return Rr[e]},_r=function(e){return xr[e]},Kr=function(e){return Lo.component(e)};function Wr(e){return jr(Fr,e)}function Gr(e){return jr(_r,e)}function Hr(e){return jr(Br,e)}function zr(e){return jr(Kr,e)}function Yr(){for(var e=arguments.length,n=new Array(e),t=0;t<e;t++)n[t]=arguments[t];return Promise.all(n.filter((function(e){return e})).map(function(){var e=o(regeneratorRuntime.mark((function e(n){var t;return regeneratorRuntime.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(zr(n)||!Hr(n)){e.next=5;break}return e.next=3,Hr(n)();case 3:t=e.sent,Lo.component(n,t.default);case 5:case"end":return e.stop()}}),e)})));return function(n){return e.apply(this,arguments)}}()))}function Vr(e,n){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[e]=n)}var Jr=t(41);function Xr(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=t){var a,o,i=[],r=!0,s=!1;try{for(t=t.call(e);!(r=(a=t.next()).done)&&(i.push(a.value),!n||i.length!==n);r=!0);}catch(e){s=!0,o=e}finally{try{r||null==t.return||t.return()}finally{if(s)throw o}}return i}}(e,n)||Object(Jr.a)(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}t(240),t(190),t(118);var Qr=t(184),$r=t.n(Qr),Zr=t(185),es=t.n(Zr),ns={created:function(){if(this.siteMeta=this.$site.headTags.filter((function(e){return"meta"===Xr(e,1)[0]})).map((function(e){var n=Xr(e,2);n[0];return n[1]})),this.$ssrContext){var e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map((function(e){var n="<meta";return Object.keys(e).forEach((function(t){n+=" ".concat(t,'="').concat(es()(e[t]),'"')})),n+">"})).join("\n    "):"",this.$ssrContext.canonicalLink=as(this.$canonicalUrl)}var n},mounted:function(){this.currentMetaTags=Object(Ir.a)(document.querySelectorAll("meta")),this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta:function(){document.title=this.$title,document.documentElement.lang=this.$lang;var e=this.getMergedMetaTags();this.currentMetaTags=os(e,this.currentMetaTags)},getMergedMetaTags:function(){var e=this.$page.frontmatter.meta||[];return $r()([{name:"description",content:this.$description}],e,this.siteMeta,is)},updateCanonicalLink:function(){ts(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",as(this.$canonicalUrl))}},watch:{$page:function(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy:function(){os(null,this.currentMetaTags),ts()}};function ts(){var e=document.querySelector("link[rel='canonical']");e&&e.remove()}function as(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return e?'<link href="'.concat(e,'" rel="canonical" />'):""}function os(e,n){if(n&&Object(Ir.a)(n).filter((function(e){return e.parentNode===document.head})).forEach((function(e){return document.head.removeChild(e)})),e)return e.map((function(e){var n=document.createElement("meta");return Object.keys(e).forEach((function(t){n.setAttribute(t,e[t])})),document.head.appendChild(n),n}))}function is(e){for(var n=0,t=["name","property","itemprop"];n<t.length;n++){var a=t[n];if(e.hasOwnProperty(a))return e[a]+a}return JSON.stringify(e)}var rs=t(186),ss={mounted:function(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(rs)()((function(){this.setActiveHash()}),300),setActiveHash:function(){for(var e=this,n=[].slice.call(document.querySelectorAll(".sidebar-link")),t=[].slice.call(document.querySelectorAll(".header-anchor")).filter((function(e){return n.some((function(n){return n.hash===e.hash}))})),a=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),o=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),i=window.innerHeight+a,r=0;r<t.length;r++){var s=t[r],l=t[r+1],d=0===r&&0===a||a>=s.parentElement.offsetTop+10&&(!l||a<l.parentElement.offsetTop-10),c=decodeURIComponent(this.$route.hash);if(d&&c!==decodeURIComponent(s.hash)){var u=s;if(i===o)for(var p=r+1;p<t.length;p++)if(c===decodeURIComponent(t[p].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(u.hash),(function(){e.$nextTick((function(){e.$vuepress.$set("disableScrollBehavior",!1)}))}))}}}},beforeDestroy:function(){window.removeEventListener("scroll",this.onScroll)}},ls=(t(90),t(84)),ds=t.n(ls),cs={mounted:function(){var e=this;ds.a.configure({showSpinner:!1}),this.$router.beforeEach((function(e,n,t){e.path===n.path||Lo.component(e.name)||ds.a.start(),t()})),this.$router.afterEach((function(){ds.a.done(),e.isSidebarOpen=!1}))}};function us(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function ps(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}function hs(e,n,t){return n&&ps(e.prototype,n),t&&ps(e,t),Object.defineProperty(e,"prototype",{writable:!1}),e}t(332);
/*! medium-zoom 1.0.6 | MIT License | https://github.com/francoischalifour/medium-zoom */var ms=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},gs=function(e){return"IMG"===e.tagName},fs=function(e){return e&&1===e.nodeType},bs=function(e){return".svg"===(e.currentSrc||e.src).substr(-4).toLowerCase()},ys=function(e){try{return Array.isArray(e)?e.filter(gs):function(e){return NodeList.prototype.isPrototypeOf(e)}(e)?[].slice.call(e).filter(gs):fs(e)?[e].filter(gs):"string"==typeof e?[].slice.call(document.querySelectorAll(e)).filter(gs):[]}catch(e){throw new TypeError("The provided selector is invalid.\nExpects a CSS selector, a Node element, a NodeList or an array.\nSee: https://github.com/francoischalifour/medium-zoom")}},vs=function(e){var n=document.createElement("div");return n.classList.add("medium-zoom-overlay"),n.style.background=e,n},ws=function(e){var n=e.getBoundingClientRect(),t=n.top,a=n.left,o=n.width,i=n.height,r=e.cloneNode(),s=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,l=window.pageXOffset||document.documentElement.scrollLeft||document.body.scrollLeft||0;return r.removeAttribute("id"),r.style.position="absolute",r.style.top=t+s+"px",r.style.left=a+l+"px",r.style.width=o+"px",r.style.height=i+"px",r.style.transform="",r},ks=function(e,n){var t=ms({bubbles:!1,cancelable:!1,detail:void 0},n);if("function"==typeof window.CustomEvent)return new CustomEvent(e,t);var a=document.createEvent("CustomEvent");return a.initCustomEvent(e,t.bubbles,t.cancelable,t.detail),a};!function(e,n){void 0===n&&(n={});var t=n.insertAt;if(e&&"undefined"!=typeof document){var a=document.head||document.getElementsByTagName("head")[0],o=document.createElement("style");o.type="text/css","top"===t&&a.firstChild?a.insertBefore(o,a.firstChild):a.appendChild(o),o.styleSheet?o.styleSheet.cssText=e:o.appendChild(document.createTextNode(e))}}(".medium-zoom-overlay{position:fixed;top:0;right:0;bottom:0;left:0;opacity:0;transition:opacity .3s;will-change:opacity}.medium-zoom--opened .medium-zoom-overlay{cursor:pointer;cursor:zoom-out;opacity:1}.medium-zoom-image{cursor:pointer;cursor:zoom-in;transition:transform .3s cubic-bezier(.2,0,.2,1)!important}.medium-zoom-image--hidden{visibility:hidden}.medium-zoom-image--opened{position:relative;cursor:pointer;cursor:zoom-out;will-change:transform}");var Es=function e(n){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},a=window.Promise||function(e){function n(){}e(n,n)},o=function(e){var n=e.target;n!==C?-1!==v.indexOf(n)&&g({target:n}):m()},i=function(){if(!k&&A.original){var e=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0;Math.abs(E-e)>T.scrollOffset&&setTimeout(m,150)}},r=function(e){var n=e.key||e.keyCode;"Escape"!==n&&"Esc"!==n&&27!==n||m()},s=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=e;if(e.background&&(C.style.background=e.background),e.container&&e.container instanceof Object&&(n.container=ms({},T.container,e.container)),e.template){var t=fs(e.template)?e.template:document.querySelector(e.template);n.template=t}return T=ms({},T,n),v.forEach((function(e){e.dispatchEvent(ks("medium-zoom:update",{detail:{zoom:P}}))})),P},l=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return e(ms({},T,n))},d=function(){for(var e=arguments.length,n=Array(e),t=0;t<e;t++)n[t]=arguments[t];var a=n.reduce((function(e,n){return[].concat(e,ys(n))}),[]);return a.filter((function(e){return-1===v.indexOf(e)})).forEach((function(e){v.push(e),e.classList.add("medium-zoom-image")})),w.forEach((function(e){var n=e.type,t=e.listener,o=e.options;a.forEach((function(e){e.addEventListener(n,t,o)}))})),P},c=function(){for(var e=arguments.length,n=Array(e),t=0;t<e;t++)n[t]=arguments[t];A.zoomed&&m();var a=n.length>0?n.reduce((function(e,n){return[].concat(e,ys(n))}),[]):v;return a.forEach((function(e){e.classList.remove("medium-zoom-image"),e.dispatchEvent(ks("medium-zoom:detach",{detail:{zoom:P}}))})),v=v.filter((function(e){return-1===a.indexOf(e)})),P},u=function(e,n){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return v.forEach((function(a){a.addEventListener("medium-zoom:"+e,n,t)})),w.push({type:"medium-zoom:"+e,listener:n,options:t}),P},p=function(e,n){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return v.forEach((function(a){a.removeEventListener("medium-zoom:"+e,n,t)})),w=w.filter((function(t){return!(t.type==="medium-zoom:"+e&&t.listener.toString()===n.toString())})),P},h=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=e.target,t=function(){var e={width:document.documentElement.clientWidth,height:document.documentElement.clientHeight,left:0,top:0,right:0,bottom:0},n=void 0,t=void 0;if(T.container)if(T.container instanceof Object)n=(e=ms({},e,T.container)).width-e.left-e.right-2*T.margin,t=e.height-e.top-e.bottom-2*T.margin;else{var a=(fs(T.container)?T.container:document.querySelector(T.container)).getBoundingClientRect(),o=a.width,i=a.height,r=a.left,s=a.top;e=ms({},e,{width:o,height:i,left:r,top:s})}n=n||e.width-2*T.margin,t=t||e.height-2*T.margin;var l=A.zoomedHd||A.original,d=bs(l)?n:l.naturalWidth||n,c=bs(l)?t:l.naturalHeight||t,u=l.getBoundingClientRect(),p=u.top,h=u.left,m=u.width,g=u.height,f=Math.min(d,n)/m,b=Math.min(c,t)/g,y=Math.min(f,b),v="scale("+y+") translate3d("+((n-m)/2-h+T.margin+e.left)/y+"px, "+((t-g)/2-p+T.margin+e.top)/y+"px, 0)";A.zoomed.style.transform=v,A.zoomedHd&&(A.zoomedHd.style.transform=v)};return new a((function(e){if(n&&-1===v.indexOf(n))e(P);else{if(A.zoomed)e(P);else{if(n)A.original=n;else{if(!(v.length>0))return void e(P);var a=v;A.original=a[0]}if(A.original.dispatchEvent(ks("medium-zoom:open",{detail:{zoom:P}})),E=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,k=!0,A.zoomed=ws(A.original),document.body.appendChild(C),T.template){var o=fs(T.template)?T.template:document.querySelector(T.template);A.template=document.createElement("div"),A.template.appendChild(o.content.cloneNode(!0)),document.body.appendChild(A.template)}if(document.body.appendChild(A.zoomed),window.requestAnimationFrame((function(){document.body.classList.add("medium-zoom--opened")})),A.original.classList.add("medium-zoom-image--hidden"),A.zoomed.classList.add("medium-zoom-image--opened"),A.zoomed.addEventListener("click",m),A.zoomed.addEventListener("transitionend",(function n(){k=!1,A.zoomed.removeEventListener("transitionend",n),A.original.dispatchEvent(ks("medium-zoom:opened",{detail:{zoom:P}})),e(P)})),A.original.getAttribute("data-zoom-src")){A.zoomedHd=A.zoomed.cloneNode(),A.zoomedHd.removeAttribute("srcset"),A.zoomedHd.removeAttribute("sizes"),A.zoomedHd.src=A.zoomed.getAttribute("data-zoom-src"),A.zoomedHd.onerror=function(){clearInterval(i),console.warn("Unable to reach the zoom image target "+A.zoomedHd.src),A.zoomedHd=null,t()};var i=setInterval((function(){A.zoomedHd.complete&&(clearInterval(i),A.zoomedHd.classList.add("medium-zoom-image--opened"),A.zoomedHd.addEventListener("click",m),document.body.appendChild(A.zoomedHd),t())}),10)}else if(A.original.hasAttribute("srcset")){A.zoomedHd=A.zoomed.cloneNode(),A.zoomedHd.removeAttribute("sizes"),A.zoomedHd.removeAttribute("loading");var r=A.zoomedHd.addEventListener("load",(function(){A.zoomedHd.removeEventListener("load",r),A.zoomedHd.classList.add("medium-zoom-image--opened"),A.zoomedHd.addEventListener("click",m),document.body.appendChild(A.zoomedHd),t()}))}else t()}}}))},m=function(){return new a((function(e){if(!k&&A.original){k=!0,document.body.classList.remove("medium-zoom--opened"),A.zoomed.style.transform="",A.zoomedHd&&(A.zoomedHd.style.transform=""),A.template&&(A.template.style.transition="opacity 150ms",A.template.style.opacity=0),A.original.dispatchEvent(ks("medium-zoom:close",{detail:{zoom:P}})),A.zoomed.addEventListener("transitionend",(function n(){A.original.classList.remove("medium-zoom-image--hidden"),document.body.removeChild(A.zoomed),A.zoomedHd&&document.body.removeChild(A.zoomedHd),document.body.removeChild(C),A.zoomed.classList.remove("medium-zoom-image--opened"),A.template&&document.body.removeChild(A.template),k=!1,A.zoomed.removeEventListener("transitionend",n),A.original.dispatchEvent(ks("medium-zoom:closed",{detail:{zoom:P}})),A.original=null,A.zoomed=null,A.zoomedHd=null,A.template=null,e(P)}))}else e(P)}))},g=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=e.target;return A.original?m():h({target:n})},f=function(){return T},b=function(){return v},y=function(){return A.original},v=[],w=[],k=!1,E=0,T=t,A={original:null,zoomed:null,zoomedHd:null,template:null};"[object Object]"===Object.prototype.toString.call(n)?T=n:(n||"string"==typeof n)&&d(n),T=ms({margin:0,background:"#fff",scrollOffset:40,container:null,template:null},T);var C=vs(T.background);document.addEventListener("click",o),document.addEventListener("keyup",r),document.addEventListener("scroll",i),window.addEventListener("resize",m);var P={open:h,close:m,toggle:g,update:s,clone:l,attach:d,detach:c,on:u,off:p,getOptions:f,getImages:b,getZoomedImage:y};return P},Ts=".theme-default-content img",As=JSON.parse("{}"),Cs=Number("500"),Ps=function(){function e(){us(this,e),this.instance=null}return hs(e,[{key:"update",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Ts;"undefined"!=typeof window&&(null===this.instance?this.instance=Es(e,As):(this.instance.detach(),this.instance.attach(e)))}},{key:"updateDelay",value:function(){var e=this,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Ts,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Cs;setTimeout((function(){return e.update(n)}),t)}}]),e}(),Ss=(t(334),{watch:{"$page.path":function(){void 0!==this.$vuepress.mediumZoom&&this.$vuepress.mediumZoom.updateDelay()}},mounted:function(){this.$vuepress.mediumZoom=new Ps,this.$vuepress.mediumZoom.updateDelay()}}),Is=t(183),xs={props:{parent:Object,code:String,options:{align:String,color:String,backgroundTransition:Boolean,backgroundColor:String,successText:String,staticIcon:Boolean}},data:function(){return{success:!1,originalBackground:null,originalTransition:null}},computed:{alignStyle:function(){var e={};return e[this.options.align]="7.5px",e},iconClass:function(){return this.options.staticIcon?"":"hover"}},mounted:function(){this.originalTransition=this.parent.style.transition,this.originalBackground=this.parent.style.background},beforeDestroy:function(){this.parent.style.transition=this.originalTransition,this.parent.style.background=this.originalBackground},methods:{hexToRgb:function(e){var n=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);return n?{r:parseInt(n[1],16),g:parseInt(n[2],16),b:parseInt(n[3],16)}:null},copyToClipboard:function(e){var n=this;if(navigator.clipboard)navigator.clipboard.writeText(this.code).then((function(){n.setSuccessTransitions()}),(function(){}));else{var t=document.createElement("textarea");document.body.appendChild(t),t.value=this.code,t.select(),document.execCommand("Copy"),t.remove(),this.setSuccessTransitions()}},setSuccessTransitions:function(){var e=this;if(clearTimeout(this.successTimeout),this.options.backgroundTransition){this.parent.style.transition="background 350ms";var n=this.hexToRgb(this.options.backgroundColor);this.parent.style.background="rgba(".concat(n.r,", ").concat(n.g,", ").concat(n.b,", 0.1)")}this.success=!0,this.successTimeout=setTimeout((function(){e.options.backgroundTransition&&(e.parent.style.background=e.originalBackground,e.parent.style.transition=e.originalTransition),e.success=!1}),500)}}},Rs=(t(336),t(32)),Ds=Object(Rs.a)(xs,(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"code-copy"},[t("svg",{class:e.iconClass,style:e.alignStyle,attrs:{xmlns:"http://www.w3.org/2000/svg",width:"24",height:"24",viewBox:"0 0 24 24"},on:{click:e.copyToClipboard}},[t("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),e._v(" "),t("path",{attrs:{fill:e.options.color,d:"M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm-1 4l6 6v10c0 1.1-.9 2-2 2H7.99C6.89 23 6 22.1 6 21l.01-14c0-1.1.89-2 1.99-2h7zm-1 7h5.5L14 6.5V12z"}})]),e._v(" "),t("span",{class:e.success?"success":"",style:e.alignStyle},[e._v("\n        "+e._s(e.options.successText)+"\n    ")])])}),[],!1,null,"49140617",null).exports,Ms=(t(337),[ns,ss,cs,Ss,{updated:function(){this.update()},methods:{update:function(){setTimeout((function(){document.querySelectorAll('div[class*="language-"] pre').forEach((function(e){if(!e.classList.contains("code-copy-added")){var n=new(Lo.extend(Ds));n.options=Object(Is.a)({},{align:"bottom",color:"#27b1ff",backgroundTransition:!0,backgroundColor:"#0075b8",successText:"Copied!",staticIcon:!1}),n.code=e.innerText,n.parent=e,n.$mount(),e.classList.add("code-copy-added"),e.appendChild(n.$el)}}))}),100)}}}]),Os={name:"GlobalLayout",computed:{layout:function(){var e=this.getLayout();return Vr("layout",e),Lo.component(e)}},methods:{getLayout:function(){if(this.$page.path){var e=this.$page.frontmatter.layout;return e&&(this.$vuepress.getLayoutAsyncComponent(e)||this.$vuepress.getVueComponent(e))?e:"Layout"}return"NotFound"}}},Us=Object(Rs.a)(Os,(function(){var e=this.$createElement;return(this._self._c||e)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(e,n,t){var a;switch(n){case"components":e[n]||(e[n]={}),Object.assign(e[n],t);break;case"mixins":e[n]||(e[n]=[]),(a=e[n]).push.apply(a,Object(Ir.a)(t));break;default:throw new Error("Unknown option name.")}}(Us,"mixins",Ms);var Ls=[{name:"v-6105f836",path:"/docs/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-6105f836").then(t)}},{path:"/docs/index.html",redirect:"/docs/"},{name:"v-8f9ecbbc",path:"/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-8f9ecbbc").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-33b5fb82",path:"/jhipster.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-33b5fb82").then(t)}},{name:"v-f5704990",path:"/docs/getting-started/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-f5704990").then(t)}},{path:"/docs/getting-started/index.html",redirect:"/docs/getting-started/"},{name:"v-6f3b39b2",path:"/next/docs/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-6f3b39b2").then(t)}},{path:"/next/docs/index.html",redirect:"/next/docs/"},{name:"v-374a5768",path:"/next/docs/community/code-of-conduct.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-374a5768").then(t)}},{name:"v-32f0d168",path:"/next/docs/compose/app-builder.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-32f0d168").then(t)}},{name:"v-af1249b0",path:"/next/docs/community/contributing.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-af1249b0").then(t)}},{name:"v-30e9b340",path:"/next/docs/compose/ecm-overview.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-30e9b340").then(t)}},{name:"v-494daa6c",path:"/next/docs/consume/accessibility.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-494daa6c").then(t)}},{name:"v-b2f788ac",path:"/next/docs/compose/ecr-overview.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-b2f788ac").then(t)}},{name:"v-4ba5aba2",path:"/next/docs/compose/welcome-wizard.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-4ba5aba2").then(t)}},{name:"v-c8b7e2a8",path:"/next/docs/consume/identity-management.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-c8b7e2a8").then(t)}},{name:"v-fc879dc8",path:"/next/docs/consume/entando-apis.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-fc879dc8").then(t)}},{name:"v-c542c3e0",path:"/next/docs/consume/custom-resources.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-c542c3e0").then(t)}},{name:"v-b18ee374",path:"/next/docs/create/blueprint-features.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-b18ee374").then(t)}},{name:"v-6bdf789c",path:"/next/docs/consume/operator-intro.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-6bdf789c").then(t)}},{name:"v-75e450fc",path:"/next/docs/create/component-gen-customize.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-75e450fc").then(t)}},{name:"v-7ccd90a6",path:"/next/docs/create/component-gen-overview.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-7ccd90a6").then(t)}},{name:"v-55c921f4",path:"/next/docs/curate/ecr-bundle-presentation-config.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-55c921f4").then(t)}},{name:"v-72897874",path:"/next/docs/create/component-gen-tech.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-72897874").then(t)}},{name:"v-674bd9c6",path:"/next/docs/curate/ecr-bundle-filters.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-674bd9c6").then(t)}},{name:"v-2d64c0b4",path:"/next/docs/curate/ecr-bundle-details.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-2d64c0b4").then(t)}},{name:"v-7e983c10",path:"/next/docs/curate/ecr-bundle-versions-faq.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-7e983c10").then(t)}},{name:"v-dee87a08",path:"/next/docs/curate/ecr-how-microservices-connect-to-apps.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-dee87a08").then(t)}},{name:"v-7a0a0434",path:"/next/docs/curate/ecr-uninstall-flow.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-7a0a0434").then(t)}},{name:"v-5263095c",path:"/next/docs/curate/ecr-troubleshooting-guide.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-5263095c").then(t)}},{name:"v-13a593e8",path:"/next/docs/getting-started/concepts-overview.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-13a593e8").then(t)}},{name:"v-77fc0840",path:"/next/docs/getting-started/development-concepts.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-77fc0840").then(t)}},{name:"v-d4bd3f66",path:"/next/docs/getting-started/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-d4bd3f66").then(t)}},{path:"/next/docs/getting-started/index.html",redirect:"/next/docs/getting-started/"},{name:"v-4f033390",path:"/next/docs/getting-started/landing-page.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-4f033390").then(t)}},{name:"v-9fd918ac",path:"/next/docs/reference/deployment-structure.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-9fd918ac").then(t)}},{name:"v-c5890230",path:"/next/docs/reference/caching-and-clustering.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-c5890230").then(t)}},{name:"v-7bc2fb4c",path:"/next/docs/reference/cluster-resource-limits.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-7bc2fb4c").then(t)}},{name:"v-d1257868",path:"/next/docs/reference/databases.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-d1257868").then(t)}},{name:"v-8f8b9fb6",path:"/next/docs/releases/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-8f8b9fb6").then(t)}},{path:"/next/docs/releases/index.html",redirect:"/next/docs/releases/"},{name:"v-7fd3ecd6",path:"/next/docs/reference/freemarker-tags/freemarker-core-tags.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-7fd3ecd6").then(t)}},{name:"v-63e6ea8c",path:"/next/docs/reference/entando-cli.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-63e6ea8c").then(t)}},{name:"v-0d268fa8",path:"/next/docs/reference/local-tips-and-tricks.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-0d268fa8").then(t)}},{name:"v-357745d0",path:"/next/tutorials/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-357745d0").then(t)}},{path:"/next/tutorials/index.html",redirect:"/next/tutorials/"},{name:"v-d62d0140",path:"/next/tutorials/compose/content-templates-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-d62d0140").then(t)}},{name:"v-a4229f80",path:"/next/tutorials/compose/content-attributes.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-a4229f80").then(t)}},{name:"v-05ac7de0",path:"/next/tutorials/compose/content-types-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-05ac7de0").then(t)}},{name:"v-5e4809c0",path:"/next/tutorials/compose/content-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-5e4809c0").then(t)}},{name:"v-592245a0",path:"/next/tutorials/compose/creating-protected-resources.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-592245a0").then(t)}},{name:"v-1793e788",path:"/next/tutorials/compose/widgets-fragments.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-1793e788").then(t)}},{name:"v-c90a8f02",path:"/next/docs/reference/freemarker-tags/freemarker-JACMS-tags.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-c90a8f02").then(t)}},{name:"v-4412ada8",path:"/next/tutorials/compose/digital-assets-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-4412ada8").then(t)}},{name:"v-5eae31e0",path:"/next/tutorials/compose/page-management.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-5eae31e0").then(t)}},{name:"v-3a0d543c",path:"/next/tutorials/create/mfe/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-3a0d543c").then(t)}},{path:"/next/tutorials/create/mfe/index.html",redirect:"/next/tutorials/create/mfe/"},{name:"v-2b5d3579",path:"/next/tutorials/create/mfe/angular.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-2b5d3579").then(t)}},{name:"v-eec44296",path:"/next/tutorials/create/mfe/authentication.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-eec44296").then(t)}},{name:"v-9d2da6ce",path:"/next/tutorials/create/mfe/react.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-9d2da6ce").then(t)}},{name:"v-f9d0080e",path:"/next/tutorials/create/mfe/communication.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-f9d0080e").then(t)}},{name:"v-aa13396a",path:"/next/tutorials/create/mfe/widget-configuration.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-aa13396a").then(t)}},{name:"v-22e9e3da",path:"/next/tutorials/create/ms/generate-microservices-and-micro-frontends.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-22e9e3da").then(t)}},{name:"v-7b7a2191",path:"/next/tutorials/create/ms/add-access-controls.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-7b7a2191").then(t)}},{name:"v-a7dae2b6",path:"/next/tutorials/create/ms/run-local.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-a7dae2b6").then(t)}},{name:"v-05ca4e63",path:"/next/tutorials/create/ms/update-data-model.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-05ca4e63").then(t)}},{name:"v-65ebad25",path:"/next/tutorials/create/ms/use-postman-with-oauth2.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-65ebad25").then(t)}},{name:"v-280a3933",path:"/next/tutorials/create/pb/deploy-components-without-bundle.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-280a3933").then(t)}},{name:"v-78a28bda",path:"/next/tutorials/create/pb/export-bundle-from-application.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-78a28bda").then(t)}},{name:"v-2f907ba6",path:"/next/tutorials/create/pb/github-actions-workflow.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-2f907ba6").then(t)}},{name:"v-4dafff61",path:"/next/tutorials/create/pb/publish-simple-bundle.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-4dafff61").then(t)}},{name:"v-85e64d9a",path:"/next/tutorials/create/pb/publish-project-bundle.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-85e64d9a").then(t)}},{name:"v-e4593a78",path:"/next/tutorials/curate/ecr-private-git-repo.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-e4593a78").then(t)}},{name:"v-6cf1a96e",path:"/next/tutorials/curate/ecr-private-images.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-6cf1a96e").then(t)}},{name:"v-d5729320",path:"/next/tutorials/devops/backing-restoring-keycloak.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-d5729320").then(t)}},{name:"v-424dcb66",path:"/next/tutorials/devops/backing-up-and-restoring-your-environment.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-424dcb66").then(t)}},{name:"v-7d14b320",path:"/next/tutorials/devops/add-rest-api.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-7d14b320").then(t)}},{name:"v-5ff106e2",path:"/next/tutorials/devops/build-core-image.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-5ff106e2").then(t)}},{name:"v-222d4c1e",path:"/next/tutorials/devops/entando-operator.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-222d4c1e").then(t)}},{name:"v-e569c6f4",path:"/next/tutorials/devops/change-default-datasource.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-e569c6f4").then(t)}},{name:"v-5500b462",path:"/next/tutorials/devops/caching-and-clustering.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-5500b462").then(t)}},{name:"v-27500614",path:"/next/tutorials/devops/external-id-management.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-27500614").then(t)}},{name:"v-9b561e74",path:"/next/tutorials/devops/external-db.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-9b561e74").then(t)}},{name:"v-ad8a3fa8",path:"/next/tutorials/devops/default-database.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-ad8a3fa8").then(t)}},{name:"v-07fe8602",path:"/next/tutorials/devops/plugin-configuration.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-07fe8602").then(t)}},{name:"v-8f854294",path:"/next/tutorials/devops/invoking-api.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-8f854294").then(t)}},{name:"v-62081954",path:"/next/tutorials/devops/manage-nginx.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-62081954").then(t)}},{name:"v-eddb4118",path:"/next/tutorials/devops/plugin-environment-variables.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-eddb4118").then(t)}},{name:"v-f55e16e8",path:"/next/tutorials/getting-started/azure-install.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-f55e16e8").then(t)}},{name:"v-d7817940",path:"/next/tutorials/getting-started/kubernetes-install.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-d7817940").then(t)}},{name:"v-fae665e0",path:"/next/tutorials/getting-started/eks-install.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-fae665e0").then(t)}},{name:"v-80517bb0",path:"/next/tutorials/getting-started/gke-install.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-80517bb0").then(t)}},{name:"v-2f689e20",path:"/next/tutorials/getting-started/openshift-install-by-operator.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-2f689e20").then(t)}},{name:"v-cb6fc90c",path:"/next/tutorials/getting-started/openshift-install.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-cb6fc90c").then(t)}},{name:"v-e707fb34",path:"/next/tutorials/solution/entando-hub.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-e707fb34").then(t)}},{name:"v-3f00ca34",path:"/next/tutorials/solution/customer-portal.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-3f00ca34").then(t)}},{name:"v-8adc6c34",path:"/next/tutorials/solution/install-standard-demo.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-8adc6c34").then(t)}},{name:"v-27bb2d68",path:"/next/tutorials/solution/pda-architecture.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-27bb2d68").then(t)}},{name:"v-4ec0b1a8",path:"/next/tutorials/solution/landing-page.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-4ec0b1a8").then(t)}},{name:"v-087c5f39",path:"/openshift.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-087c5f39").then(t)}},{name:"v-ff78147a",path:"/tutorials/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-ff78147a").then(t)}},{path:"/tutorials/index.html",redirect:"/tutorials/"},{name:"v-5c97d4f4",path:"/next/tutorials/solution/pda-technical-guide.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-5c97d4f4").then(t)}},{name:"v-6696675c",path:"/v6.1/docs/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-6696675c").then(t)}},{path:"/v6.1/docs/index.html",redirect:"/v6.1/docs/"},{name:"v-674ce676",path:"/next/tutorials/solution/pda-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-674ce676").then(t)}},{name:"v-43768dc5",path:"/v6.1/docs/concepts/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-43768dc5").then(t)}},{path:"/v6.1/docs/concepts/index.html",redirect:"/v6.1/docs/concepts/"},{name:"v-7a0c5c26",path:"/v6.1/docs/concepts/pda-architecture.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-7a0c5c26").then(t)}},{name:"v-68d2c0e6",path:"/v6.1/docs/concepts/custom-resources.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-68d2c0e6").then(t)}},{name:"v-3469f1cc",path:"/v6.1/docs/reference/add_datasource_to_eap_image.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-3469f1cc").then(t)}},{name:"v-9e5cc7e8",path:"/v6.1/docs/getting-started/quick-reference.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-9e5cc7e8").then(t)}},{name:"v-65cd12ed",path:"/v6.1/docs/getting-started/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-65cd12ed").then(t)}},{path:"/v6.1/docs/getting-started/index.html",redirect:"/v6.1/docs/getting-started/"},{name:"v-2fb94430",path:"/v6.1/docs/reference/core-swagger.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-2fb94430").then(t)}},{name:"v-5787385a",path:"/v6.1/docs/reference/entando-apis.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-5787385a").then(t)}},{name:"v-4678a3b6",path:"/v6.1/docs/releases/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-4678a3b6").then(t)}},{path:"/v6.1/docs/releases/index.html",redirect:"/v6.1/docs/releases/"},{name:"v-3c0fba7f",path:"/v6.1/docs/reference/freemarker-tags/freemarker-JACMS-tags.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-3c0fba7f").then(t)}},{name:"v-d6de65ec",path:"/v6.1/docs/reference/deployment-structure.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-d6de65ec").then(t)}},{name:"v-c8257a16",path:"/v6.1/docs/reference/freemarker-tags/freemarker-core-tags.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-c8257a16").then(t)}},{name:"v-81742dfa",path:"/v6.1/tutorials/cms/app-builder/hello-world.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-81742dfa").then(t)}},{name:"v-5c03f9d0",path:"/v6.1/tutorials/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-5c03f9d0").then(t)}},{path:"/v6.1/tutorials/index.html",redirect:"/v6.1/tutorials/"},{name:"v-55cdae2c",path:"/v6.1/tutorials/cms/content-models-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-55cdae2c").then(t)}},{name:"v-81215fb4",path:"/v6.1/tutorials/backend-developers/generate-microservices-and-micro-frontends.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-81215fb4").then(t)}},{name:"v-126467b2",path:"/v6.1/tutorials/cms/custom-html-widgets.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-126467b2").then(t)}},{name:"v-5815c43c",path:"/v6.1/tutorials/cms/contents-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-5815c43c").then(t)}},{name:"v-4ed657b8",path:"/v6.1/tutorials/customize-the-platform/add-rest-api.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-4ed657b8").then(t)}},{name:"v-1f495540",path:"/v6.1/tutorials/cms/content-types-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-1f495540").then(t)}},{name:"v-2982c900",path:"/v6.1/tutorials/cms/publish-a-content-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-2982c900").then(t)}},{name:"v-8794784e",path:"/v6.1/tutorials/customize-the-platform/app-builder/hello-world.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-8794784e").then(t)}},{name:"v-1d83e0c0",path:"/v6.1/tutorials/cms/list-of-Content-attributes.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-1d83e0c0").then(t)}},{name:"v-2992138f",path:"/v6.1/tutorials/customize-the-platform/app-builder/tutorial-extending-app-builder.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-2992138f").then(t)}},{name:"v-e9938dda",path:"/v6.1/tutorials/customize-the-platform/app-engine/build-core-image.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-e9938dda").then(t)}},{name:"v-026f84c4",path:"/v6.1/tutorials/cms/digital-assets-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-026f84c4").then(t)}},{name:"v-1f32e193",path:"/v6.1/tutorials/customize-the-platform/app-engine/building-prepackaged-image.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-1f32e193").then(t)}},{name:"v-a91812da",path:"/v6.1/tutorials/customize-the-platform/app-engine/core-swagger.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-a91812da").then(t)}},{name:"v-974b2b74",path:"/v6.1/tutorials/customize-the-platform/add_datasource_to_eap_image.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-974b2b74").then(t)}},{name:"v-be7b3b00",path:"/v6.1/tutorials/customize-the-platform/change-default-datasources-and-connections/tutorials/how-to-configure-custom-datasource.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-be7b3b00").then(t)}},{name:"v-77f92ebc",path:"/v6.1/tutorials/customize-the-platform/connecting-external-db.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-77f92ebc").then(t)}},{name:"v-61a61646",path:"/v6.1/tutorials/customize-the-platform/databases.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-61a61646").then(t)}},{name:"v-5009a1de",path:"/v6.1/tutorials/customize-the-platform/change-default-datasources-and-connections/tutorials/how-to-connect-to-external-keycloak.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-5009a1de").then(t)}},{name:"v-23af9480",path:"/v6.1/tutorials/customize-the-platform/app-engine/tutorials/invoking-api.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-23af9480").then(t)}},{name:"v-07300966",path:"/v6.1/tutorials/devops/backing-up-and-restoring-your-environment.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-07300966").then(t)}},{name:"v-39cda378",path:"/v6.1/tutorials/customize-the-platform/change-default-datasources-and-connections/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-39cda378").then(t)}},{path:"/v6.1/tutorials/customize-the-platform/change-default-datasources-and-connections/index.html",redirect:"/v6.1/tutorials/customize-the-platform/change-default-datasources-and-connections/"},{name:"v-beeab77c",path:"/v6.1/tutorials/devops/build-core-image.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-beeab77c").then(t)}},{name:"v-63176564",path:"/v6.1/tutorials/customize-the-platform/invoking-api.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-63176564").then(t)}},{name:"v-069d34da",path:"/v6.1/tutorials/customize-the-platform/extend-app-builder.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-069d34da").then(t)}},{name:"v-5ca42bd6",path:"/v6.1/tutorials/customize-the-platform/pda-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-5ca42bd6").then(t)}},{name:"v-197d46c4",path:"/v6.1/tutorials/devops/external-database/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-197d46c4").then(t)}},{path:"/v6.1/tutorials/devops/external-database/index.html",redirect:"/v6.1/tutorials/devops/external-database/"},{name:"v-43de24f2",path:"/v6.1/tutorials/devops/external-keycloak/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-43de24f2").then(t)}},{path:"/v6.1/tutorials/devops/external-keycloak/index.html",redirect:"/v6.1/tutorials/devops/external-keycloak/"},{name:"v-5ba28d60",path:"/v6.1/tutorials/ecr/ecr-bundle-details.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-5ba28d60").then(t)}},{name:"v-7ab73f40",path:"/v6.1/tutorials/ecr/ecr-overview.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-7ab73f40").then(t)}},{name:"v-5ccc0800",path:"/v6.1/tutorials/ecr/ecr-bundle-presentation-config.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-5ccc0800").then(t)}},{name:"v-861cc580",path:"/v6.1/tutorials/ecr/ecr-bundle-filters.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-861cc580").then(t)}},{name:"v-176c11e4",path:"/v6.1/tutorials/ecr/ecr-troubleshooting-guide.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-176c11e4").then(t)}},{name:"v-580c2f40",path:"/v6.1/tutorials/ecr/how-to-create-local-npm-registry.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-580c2f40").then(t)}},{name:"v-ddda39c0",path:"/v6.1/tutorials/ecr/ecr-uninstall-flow.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-ddda39c0").then(t)}},{name:"v-cd20d140",path:"/v6.1/tutorials/ecr/how-to-setup-nexus-on-kubernetes-cluster.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-cd20d140").then(t)}},{name:"v-af750026",path:"/v6.1/tutorials/ecr/tutorials/create-ecr-bundle-from-npm.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-af750026").then(t)}},{name:"v-be5aa166",path:"/v6.1/tutorials/ecr/tutorials/from-blueprint-to-de.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-be5aa166").then(t)}},{name:"v-1df409ed",path:"/v6.1/tutorials/ecr/tutorials/ecr-deploy-use-plugin-and-mfe-without-bundle.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-1df409ed").then(t)}},{name:"v-09fe236b",path:"/v6.1/tutorials/micro-frontends/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-09fe236b").then(t)}},{path:"/v6.1/tutorials/micro-frontends/index.html",redirect:"/v6.1/tutorials/micro-frontends/"},{name:"v-7329955e",path:"/v6.1/tutorials/micro-frontends/generate-micro-frontends-from-a-database-entity/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-7329955e").then(t)}},{path:"/v6.1/tutorials/micro-frontends/generate-micro-frontends-from-a-database-entity/index.html",redirect:"/v6.1/tutorials/micro-frontends/generate-micro-frontends-from-a-database-entity/"},{name:"v-2bb0591c",path:"/v6.1/tutorials/micro-frontends/authentication/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-2bb0591c").then(t)}},{path:"/v6.1/tutorials/micro-frontends/authentication/index.html",redirect:"/v6.1/tutorials/micro-frontends/authentication/"},{name:"v-3b0f49bc",path:"/v6.1/tutorials/micro-frontends/angular.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-3b0f49bc").then(t)}},{name:"v-2c5a4dbe",path:"/v6.1/tutorials/micro-frontends/micro-frontends/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-2c5a4dbe").then(t)}},{path:"/v6.1/tutorials/micro-frontends/micro-frontends/index.html",redirect:"/v6.1/tutorials/micro-frontends/micro-frontends/"},{name:"v-ca77df0c",path:"/v6.1/tutorials/micro-frontends/communication.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-ca77df0c").then(t)}},{name:"v-b07a18da",path:"/v6.1/tutorials/micro-frontends/micro-frontends/create-angular-microfrontend-widget.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-b07a18da").then(t)}},{name:"v-092b0aad",path:"/v6.1/tutorials/micro-frontends/micro-frontends/create-config-screen-for-appbuilder-widget.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-092b0aad").then(t)}},{name:"v-64e83e2d",path:"/v6.1/tutorials/micro-frontends/micro-frontends/authentication.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-64e83e2d").then(t)}},{name:"v-c73e25e6",path:"/v6.1/tutorials/micro-frontends/micro-frontends/create-react-microfrontend-widget.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-c73e25e6").then(t)}},{name:"v-76dcebcd",path:"/v6.1/tutorials/micro-frontends/micro-frontends/mixed-widget-communication.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-76dcebcd").then(t)}},{name:"v-4381b4cd",path:"/v6.1/tutorials/micro-frontends/micro-frontends/display-widget-config-data.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-4381b4cd").then(t)}},{name:"v-4a3a209f",path:"/v6.1/tutorials/micro-frontends/micro-frontends/generated-widgets.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-4a3a209f").then(t)}},{name:"v-1316b766",path:"/v6.1/tutorials/micro-frontends/micro-frontends/widget-communication.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-1316b766").then(t)}},{name:"v-5c95a127",path:"/v6.1/tutorials/micro-frontends/widget-configuration/display-widget-config-data.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-5c95a127").then(t)}},{name:"v-25348330",path:"/v6.1/tutorials/micro-frontends/react.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-25348330").then(t)}},{name:"v-62808372",path:"/v6.1/tutorials/micro-frontends/widget-configuration/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-62808372").then(t)}},{path:"/v6.1/tutorials/micro-frontends/widget-configuration/index.html",redirect:"/v6.1/tutorials/micro-frontends/widget-configuration/"},{name:"v-3aec1854",path:"/v6.2/docs/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-3aec1854").then(t)}},{path:"/v6.2/docs/index.html",redirect:"/v6.2/docs/"},{name:"v-696f6946",path:"/v6.2/docs/community/contributing.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-696f6946").then(t)}},{name:"v-415409a8",path:"/v6.2/docs/community/code-of-conduct.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-415409a8").then(t)}},{name:"v-82dc7c74",path:"/v6.2/docs/concepts/custom-resources.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-82dc7c74").then(t)}},{name:"v-80ada3b6",path:"/v6.2/docs/concepts/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-80ada3b6").then(t)}},{path:"/v6.2/docs/concepts/index.html",redirect:"/v6.2/docs/concepts/"},{name:"v-1699d844",path:"/v6.2/docs/ecr/ecr-bundle-filters.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-1699d844").then(t)}},{name:"v-606945f4",path:"/v6.2/docs/concepts/pda-architecture.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-606945f4").then(t)}},{name:"v-498cc790",path:"/v6.2/docs/ecr/ecr-bundle-details.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-498cc790").then(t)}},{name:"v-76c4832a",path:"/v6.2/docs/ecr/ecr-bundle-presentation-config.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-76c4832a").then(t)}},{name:"v-677a6224",path:"/v6.2/docs/ecr/ecr-how-microservices-connects-to-apps.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-677a6224").then(t)}},{name:"v-65ff98cc",path:"/v6.2/docs/ecr/ecr-bundle-versions-faq.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-65ff98cc").then(t)}},{name:"v-1e6c858c",path:"/v6.2/docs/ecr/ecr-troubleshooting-guide.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-1e6c858c").then(t)}},{name:"v-492826e8",path:"/v6.2/docs/ecr/ecr-uninstall-flow.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-492826e8").then(t)}},{name:"v-4a485be8",path:"/v6.2/docs/ecr/ecr-overview.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-4a485be8").then(t)}},{name:"v-0f23bca8",path:"/v6.2/docs/getting-started/quick-reference.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-0f23bca8").then(t)}},{name:"v-26ff67a8",path:"/v6.2/docs/reference/add_datasource_to_eap_image.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-26ff67a8").then(t)}},{name:"v-3118c32c",path:"/v6.2/docs/reference/cluster-resource-limits.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-3118c32c").then(t)}},{name:"v-16600c28",path:"/v6.2/docs/reference/databases.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-16600c28").then(t)}},{name:"v-64f145d0",path:"/v6.2/docs/reference/entando-apis.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-64f145d0").then(t)}},{name:"v-7e970e22",path:"/v6.2/docs/getting-started/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-7e970e22").then(t)}},{path:"/v6.2/docs/getting-started/index.html",redirect:"/v6.2/docs/getting-started/"},{name:"v-3cd17670",path:"/v6.2/docs/reference/deployment-structure.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-3cd17670").then(t)}},{name:"v-71f160b3",path:"/v6.2/docs/reference/freemarker-tags/freemarker-core-tags.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-71f160b3").then(t)}},{name:"v-a7953bc2",path:"/v6.2/docs/reference/freemarker-tags/freemarker-JACMS-tags.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-a7953bc2").then(t)}},{name:"v-7b34316c",path:"/v6.2/docs/reference/identity-management.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-7b34316c").then(t)}},{name:"v-25510810",path:"/v6.2/tutorials/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-25510810").then(t)}},{path:"/v6.2/tutorials/index.html",redirect:"/v6.2/tutorials/"},{name:"v-58f64e85",path:"/v6.2/docs/releases/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-58f64e85").then(t)}},{path:"/v6.2/docs/releases/index.html",redirect:"/v6.2/docs/releases/"},{name:"v-17045d64",path:"/v6.2/tutorials/backend-developers/generate-microservices-and-micro-frontends.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-17045d64").then(t)}},{name:"v-866830ac",path:"/v6.2/tutorials/backend-developers/build-and-deploy.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-866830ac").then(t)}},{name:"v-6478fde6",path:"/v6.2/tutorials/backend-developers/run-local.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-6478fde6").then(t)}},{name:"v-8bb9a4fe",path:"/v6.2/tutorials/cms/app-builder/hello-world.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-8bb9a4fe").then(t)}},{name:"v-6e1ce060",path:"/v6.2/tutorials/cms/content-templates-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-6e1ce060").then(t)}},{name:"v-1cd37820",path:"/v6.2/tutorials/cms/content-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-1cd37820").then(t)}},{name:"v-cf987aa0",path:"/v6.2/tutorials/cms/custom-html-widgets.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-cf987aa0").then(t)}},{name:"v-66e5dae0",path:"/v6.2/tutorials/cms/content-types-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-66e5dae0").then(t)}},{name:"v-0cb4fbc8",path:"/v6.2/tutorials/cms/digital-assets-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-0cb4fbc8").then(t)}},{name:"v-737fcee0",path:"/v6.2/tutorials/cms/list-of-Content-attributes.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-737fcee0").then(t)}},{name:"v-2bc8a194",path:"/v6.2/tutorials/customize-the-platform/add-rest-api.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-2bc8a194").then(t)}},{name:"v-413a89a0",path:"/v6.2/tutorials/cms/publish-a-content-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-413a89a0").then(t)}},{name:"v-1c9022e6",path:"/v6.2/tutorials/customize-the-platform/add_datasource_to_eap_image.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-1c9022e6").then(t)}},{name:"v-c350580e",path:"/v6.2/tutorials/customize-the-platform/app-builder/hello-world.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-c350580e").then(t)}},{name:"v-19281c9a",path:"/v6.2/tutorials/customize-the-platform/app-engine/build-core-image.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-19281c9a").then(t)}},{name:"v-8585111a",path:"/v6.2/tutorials/customize-the-platform/app-engine/building-prepackaged-image.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-8585111a").then(t)}},{name:"v-e4d3f29a",path:"/v6.2/tutorials/customize-the-platform/app-engine/core-swagger.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-e4d3f29a").then(t)}},{name:"v-5503dfd0",path:"/v6.2/tutorials/customize-the-platform/change-default-datasources-and-connections/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-5503dfd0").then(t)}},{path:"/v6.2/tutorials/customize-the-platform/change-default-datasources-and-connections/index.html",redirect:"/v6.2/tutorials/customize-the-platform/change-default-datasources-and-connections/"},{name:"v-1bf60ac0",path:"/v6.2/tutorials/customize-the-platform/change-default-datasources-and-connections/tutorials/how-to-configure-custom-datasource.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-1bf60ac0").then(t)}},{name:"v-69b9a4cc",path:"/v6.2/tutorials/customize-the-platform/invoking-api.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-69b9a4cc").then(t)}},{name:"v-012cd40c",path:"/v6.2/tutorials/customize-the-platform/connecting-external-db.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-012cd40c").then(t)}},{name:"v-65da4ddc",path:"/v6.2/tutorials/customize-the-platform/change-default-datasources-and-connections/tutorials/how-to-connect-to-external-keycloak.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-65da4ddc").then(t)}},{name:"v-5d8b05c6",path:"/v6.2/tutorials/devops/backing-up-and-restoring-your-environment.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-5d8b05c6").then(t)}},{name:"v-46bd5ad0",path:"/v6.2/tutorials/customize-the-platform/extend-app-builder.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-46bd5ad0").then(t)}},{name:"v-2659ff40",path:"/v6.2/tutorials/devops/build-core-image.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-2659ff40").then(t)}},{name:"v-102cf958",path:"/v6.2/tutorials/customize-the-platform/pda-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-102cf958").then(t)}},{name:"v-73e5ec98",path:"/v6.2/tutorials/devops/external-keycloak/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-73e5ec98").then(t)}},{path:"/v6.2/tutorials/devops/external-keycloak/index.html",redirect:"/v6.2/tutorials/devops/external-keycloak/"},{name:"v-75704160",path:"/v6.2/tutorials/devops/external-database/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-75704160").then(t)}},{path:"/v6.2/tutorials/devops/external-database/index.html",redirect:"/v6.2/tutorials/devops/external-database/"},{name:"v-0f16da74",path:"/v6.2/tutorials/devops/local-tips-and-tricks.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-0f16da74").then(t)}},{name:"v-a13cc134",path:"/v6.2/tutorials/devops/installation/azure-kubernetes-service/azure-install.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-a13cc134").then(t)}},{name:"v-07622a2a",path:"/v6.2/tutorials/devops/installation/google-cloud-platform/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-07622a2a").then(t)}},{path:"/v6.2/tutorials/devops/installation/google-cloud-platform/index.html",redirect:"/v6.2/tutorials/devops/installation/google-cloud-platform/"},{name:"v-6fa3d88a",path:"/v6.2/tutorials/devops/default-database.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-6fa3d88a").then(t)}},{name:"v-536a5526",path:"/v6.2/tutorials/devops/installation/elastic-kubernetes-service/eks-install.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-536a5526").then(t)}},{name:"v-43efab4d",path:"/v6.2/tutorials/ecr/tutorials/create-ecr-bundle-from-npm.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-43efab4d").then(t)}},{name:"v-ab0e5bc0",path:"/v6.2/tutorials/ecr/how-to-create-local-npm-registry.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-ab0e5bc0").then(t)}},{name:"v-6e9a7bb4",path:"/v6.2/tutorials/devops/installation/open-shift/openshift-install.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-6e9a7bb4").then(t)}},{name:"v-701e8b40",path:"/v6.2/tutorials/ecr/how-to-setup-nexus-on-kubernetes-cluster.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-701e8b40").then(t)}},{name:"v-3d12ebad",path:"/v6.2/tutorials/ecr/tutorials/create-ecr-bundle-from-git.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-3d12ebad").then(t)}},{name:"v-ebd258e6",path:"/v6.2/tutorials/ecr/tutorials/ecr-deploy-use-plugin-and-mfe-without-bundle.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-ebd258e6").then(t)}},{name:"v-23fbd1b8",path:"/v6.2/tutorials/micro-frontends/communication.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-23fbd1b8").then(t)}},{name:"v-6847b620",path:"/v6.2/tutorials/micro-frontends/angular.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-6847b620").then(t)}},{name:"v-27be8b6a",path:"/v6.2/tutorials/micro-frontends/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-27be8b6a").then(t)}},{path:"/v6.2/tutorials/micro-frontends/index.html",redirect:"/v6.2/tutorials/micro-frontends/"},{name:"v-4486ad80",path:"/v6.2/tutorials/micro-frontends/authentication.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-4486ad80").then(t)}},{name:"v-7bef863e",path:"/v6.2/tutorials/micro-frontends/generate-micro-frontends-from-a-database-entity/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-7bef863e").then(t)}},{path:"/v6.2/tutorials/micro-frontends/generate-micro-frontends-from-a-database-entity/index.html",redirect:"/v6.2/tutorials/micro-frontends/generate-micro-frontends-from-a-database-entity/"},{name:"v-67b9aca6",path:"/v6.2/tutorials/micro-frontends/react.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-67b9aca6").then(t)}},{name:"v-07879720",path:"/v6.2/tutorials/micro-frontends/widget-configuration.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-07879720").then(t)}},{name:"v-8c1a0244",path:"/v6.3.2/docs/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-8c1a0244").then(t)}},{path:"/v6.3.2/docs/index.html",redirect:"/v6.3.2/docs/"},{name:"v-4ce7f388",path:"/v6.3.2/docs/community/contributing.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-4ce7f388").then(t)}},{name:"v-765adacc",path:"/v6.3.2/docs/community/code-of-conduct.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-765adacc").then(t)}},{name:"v-5ea0ec18",path:"/v6.3.2/docs/compose/ecm-overview.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-5ea0ec18").then(t)}},{name:"v-6e997a68",path:"/v6.3.2/docs/compose/app-builder.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-6e997a68").then(t)}},{name:"v-6602b914",path:"/v6.3.2/docs/compose/welcome-wizard.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-6602b914").then(t)}},{name:"v-389f9c04",path:"/v6.3.2/docs/compose/ecr-overview.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-389f9c04").then(t)}},{name:"v-6af9f52c",path:"/v6.3.2/docs/consume/accessibility.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-6af9f52c").then(t)}},{name:"v-b827ee28",path:"/v6.3.2/docs/consume/identity-management.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-b827ee28").then(t)}},{name:"v-4cd51ca4",path:"/v6.3.2/docs/consume/custom-resources.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-4cd51ca4").then(t)}},{name:"v-cca1d5a0",path:"/v6.3.2/docs/consume/operator-intro.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-cca1d5a0").then(t)}},{name:"v-a482b5a0",path:"/v6.3.2/docs/consume/entando-apis.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-a482b5a0").then(t)}},{name:"v-42f24850",path:"/v6.3.2/docs/create/component-gen-customize.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-42f24850").then(t)}},{name:"v-a0fbe934",path:"/v6.3.2/docs/create/component-gen-overview.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-a0fbe934").then(t)}},{name:"v-004ce474",path:"/v6.3.2/docs/create/blueprint-features.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-004ce474").then(t)}},{name:"v-35511046",path:"/v6.3.2/docs/create/component-gen-tech.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-35511046").then(t)}},{name:"v-73954b74",path:"/v6.3.2/docs/curate/ecr-bundle-filters.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-73954b74").then(t)}},{name:"v-f24b9bf4",path:"/v6.3.2/docs/curate/ecr-bundle-presentation-config.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-f24b9bf4").then(t)}},{name:"v-64e64a66",path:"/v6.3.2/docs/curate/ecr-bundle-details.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-64e64a66").then(t)}},{name:"v-e60aa460",path:"/v6.3.2/docs/curate/ecr-how-microservices-connect-to-apps.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-e60aa460").then(t)}},{name:"v-11e12530",path:"/v6.3.2/docs/curate/ecr-troubleshooting-guide.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-11e12530").then(t)}},{name:"v-2f6dd8e4",path:"/v6.3.2/docs/curate/ecr-bundle-versions-faq.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-2f6dd8e4").then(t)}},{name:"v-cb52bfb4",path:"/v6.3.2/docs/curate/ecr-uninstall-flow.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-cb52bfb4").then(t)}},{name:"v-ceedd9b8",path:"/v6.3.2/docs/getting-started/landing-page.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-ceedd9b8").then(t)}},{name:"v-65dad879",path:"/v6.3.2/docs/getting-started/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-65dad879").then(t)}},{path:"/v6.3.2/docs/getting-started/index.html",redirect:"/v6.3.2/docs/getting-started/"},{name:"v-e669d918",path:"/v6.3.2/docs/getting-started/development-concepts.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-e669d918").then(t)}},{name:"v-199e73e8",path:"/v6.3.2/docs/getting-started/quick-reference.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-199e73e8").then(t)}},{name:"v-686eeb8c",path:"/v6.3.2/docs/getting-started/concepts-overview.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-686eeb8c").then(t)}},{name:"v-18d45c68",path:"/v6.3.2/docs/reference/cluster-resource-limits.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-18d45c68").then(t)}},{name:"v-64e2fc7c",path:"/v6.3.2/docs/reference/caching-and-clustering.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-64e2fc7c").then(t)}},{name:"v-78763ecc",path:"/v6.3.2/docs/reference/databases.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-78763ecc").then(t)}},{name:"v-78ffa47e",path:"/v6.3.2/docs/reference/deployment-structure.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-78ffa47e").then(t)}},{name:"v-12c4b8e8",path:"/v6.3.2/docs/reference/entando-cli.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-12c4b8e8").then(t)}},{name:"v-43cc5a82",path:"/v6.3.2/docs/reference/freemarker-tags/freemarker-JACMS-tags.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-43cc5a82").then(t)}},{name:"v-5940cbec",path:"/v6.3.2/docs/reference/local-tips-and-tricks.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-5940cbec").then(t)}},{name:"v-63ebbea9",path:"/v6.3.2/docs/reference/freemarker-tags/freemarker-core-tags.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-63ebbea9").then(t)}},{name:"v-31b33280",path:"/v6.3.2/tutorials/compose/content-attributes.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-31b33280").then(t)}},{name:"v-c5bccc36",path:"/v6.3.2/docs/releases/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-c5bccc36").then(t)}},{path:"/v6.3.2/docs/releases/index.html",redirect:"/v6.3.2/docs/releases/"},{name:"v-7f1d8120",path:"/v6.3.2/tutorials/compose/content-templates-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-7f1d8120").then(t)}},{name:"v-7b1bc340",path:"/v6.3.2/tutorials/compose/content-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-7b1bc340").then(t)}},{name:"v-c5488050",path:"/v6.3.2/tutorials/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-c5488050").then(t)}},{path:"/v6.3.2/tutorials/index.html",redirect:"/v6.3.2/tutorials/"},{name:"v-737e16c0",path:"/v6.3.2/tutorials/compose/content-types-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-737e16c0").then(t)}},{name:"v-a3f44c40",path:"/v6.3.2/tutorials/compose/creating-protected-resources.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-a3f44c40").then(t)}},{name:"v-52142e80",path:"/v6.3.2/tutorials/compose/digital-assets-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-52142e80").then(t)}},{name:"v-3dbf2024",path:"/v6.3.2/tutorials/compose/page-management.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-3dbf2024").then(t)}},{name:"v-59b51a1c",path:"/v6.3.2/tutorials/compose/widgets-fragments.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-59b51a1c").then(t)}},{name:"v-740775e4",path:"/v6.3.2/tutorials/create/mfe/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-740775e4").then(t)}},{path:"/v6.3.2/tutorials/create/mfe/index.html",redirect:"/v6.3.2/tutorials/create/mfe/"},{name:"v-d415568e",path:"/v6.3.2/tutorials/create/mfe/communication.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-d415568e").then(t)}},{name:"v-de156dce",path:"/v6.3.2/tutorials/create/mfe/react.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-de156dce").then(t)}},{name:"v-9c365042",path:"/v6.3.2/tutorials/create/mfe/widget-configuration.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-9c365042").then(t)}},{name:"v-7038fda5",path:"/v6.3.2/tutorials/create/ms/add-access-controls.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-7038fda5").then(t)}},{name:"v-f96fb7da",path:"/v6.3.2/tutorials/create/ms/generate-microservices-and-micro-frontends.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-f96fb7da").then(t)}},{name:"v-5718e2e0",path:"/v6.3.2/tutorials/compose/extend-app-builder.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-5718e2e0").then(t)}},{name:"v-58aa9db9",path:"/v6.3.2/tutorials/create/ms/run-local.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-58aa9db9").then(t)}},{name:"v-29922bb7",path:"/v6.3.2/tutorials/create/ms/update-data-model.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-29922bb7").then(t)}},{name:"v-1aaaa2b9",path:"/v6.3.2/tutorials/create/mfe/angular.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-1aaaa2b9").then(t)}},{name:"v-4fb9ceee",path:"/v6.3.2/tutorials/create/mfe/authentication.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-4fb9ceee").then(t)}},{name:"v-ce9e808e",path:"/v6.3.2/tutorials/create/ms/use-postman-with-oauth2.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-ce9e808e").then(t)}},{name:"v-0dd48473",path:"/v6.3.2/tutorials/create/pb/deploy-components-without-bundle.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-0dd48473").then(t)}},{name:"v-49bccbda",path:"/v6.3.2/tutorials/create/pb/export-bundle-from-application.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-49bccbda").then(t)}},{name:"v-9c20f87e",path:"/v6.3.2/tutorials/create/pb/github-actions-workflow.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-9c20f87e").then(t)}},{name:"v-ca832c1a",path:"/v6.3.2/tutorials/create/pb/publish-project-bundle.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-ca832c1a").then(t)}},{name:"v-b440bc16",path:"/v6.3.2/tutorials/create/pb/publish-simple-bundle.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-b440bc16").then(t)}},{name:"v-6cfa5998",path:"/v6.3.2/tutorials/curate/ecr-private-git-repo.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-6cfa5998").then(t)}},{name:"v-67bc2474",path:"/v6.3.2/tutorials/devops/add-rest-api.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-67bc2474").then(t)}},{name:"v-f04502fc",path:"/v6.3.2/tutorials/curate/ecr-private-images.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-f04502fc").then(t)}},{name:"v-0d653d78",path:"/v6.3.2/tutorials/devops/backing-restoring-keycloak.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-0d653d78").then(t)}},{name:"v-4eda8cf6",path:"/v6.3.2/tutorials/devops/build-core-image.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-4eda8cf6").then(t)}},{name:"v-62cf23f6",path:"/v6.3.2/tutorials/devops/caching-and-clustering.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-62cf23f6").then(t)}},{name:"v-2cd5b326",path:"/v6.3.2/tutorials/devops/backing-up-and-restoring-your-environment.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-2cd5b326").then(t)}},{name:"v-13a01900",path:"/v6.3.2/tutorials/devops/default-database.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-13a01900").then(t)}},{name:"v-3fc45506",path:"/v6.3.2/tutorials/devops/change-default-datasource.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-3fc45506").then(t)}},{name:"v-f28b3930",path:"/v6.3.2/tutorials/devops/external-id-management.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-f28b3930").then(t)}},{name:"v-94205374",path:"/v6.3.2/tutorials/devops/external-db.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-94205374").then(t)}},{name:"v-9ce1dd6c",path:"/v6.3.2/tutorials/devops/invoking-api.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-9ce1dd6c").then(t)}},{name:"v-3b785c2c",path:"/v6.3.2/tutorials/devops/manage-nginx.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-3b785c2c").then(t)}},{name:"v-92f180c0",path:"/v6.3.2/tutorials/getting-started/azure-install.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-92f180c0").then(t)}},{name:"v-9bcd09c0",path:"/v6.3.2/tutorials/getting-started/kubernetes-install.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-9bcd09c0").then(t)}},{name:"v-27a911b8",path:"/v6.3.2/tutorials/getting-started/eks-install.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-27a911b8").then(t)}},{name:"v-3686193c",path:"/v6.3.2/tutorials/getting-started/gke-install.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-3686193c").then(t)}},{name:"v-531d2164",path:"/v6.3.2/tutorials/getting-started/openshift-install-by-operator-hub.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-531d2164").then(t)}},{name:"v-7cf9c1f4",path:"/v6.3.2/tutorials/getting-started/tanzu-install.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-7cf9c1f4").then(t)}},{name:"v-37b585ce",path:"/v6.3.2/tutorials/getting-started/openshift-install.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-37b585ce").then(t)}},{name:"v-3f492b08",path:"/v6.3.2/tutorials/solution/landing-page.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-3f492b08").then(t)}},{name:"v-1230c726",path:"/v6.3.2/tutorials/solution/customer-portal.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-1230c726").then(t)}},{name:"v-332e7fa6",path:"/v6.3.2/tutorials/solution/entando-hub.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-332e7fa6").then(t)}},{name:"v-4d12f6f4",path:"/v6.3.2/tutorials/solution/pda-technical-guide.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-4d12f6f4").then(t)}},{name:"v-7b0a15b4",path:"/v6.3.2/tutorials/solution/install-standard-demo.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-7b0a15b4").then(t)}},{name:"v-2f87b6a0",path:"/v6.3.2/tutorials/solution/pda-architecture.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-2f87b6a0").then(t)}},{name:"v-adb93754",path:"/v6.3/docs/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-adb93754").then(t)}},{path:"/v6.3/docs/index.html",redirect:"/v6.3/docs/"},{name:"v-6729fcec",path:"/v6.3.2/tutorials/solution/pda-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-6729fcec").then(t)}},{name:"v-4120e3f8",path:"/v6.3/docs/community/contributing.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-4120e3f8").then(t)}},{name:"v-3514fc0c",path:"/v6.3/docs/community/code-of-conduct.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-3514fc0c").then(t)}},{name:"v-b64319e8",path:"/v6.3/docs/component-generator/component-gen-customize.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-b64319e8").then(t)}},{name:"v-64ee1b00",path:"/v6.3/docs/component-generator/component-gen-overview.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-64ee1b00").then(t)}},{name:"v-3bdbce85",path:"/v6.3/docs/concepts/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-3bdbce85").then(t)}},{path:"/v6.3/docs/concepts/index.html",redirect:"/v6.3/docs/concepts/"},{name:"v-dcd8b7f4",path:"/v6.3/docs/component-generator/component-gen-tech.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-dcd8b7f4").then(t)}},{name:"v-7901b1b4",path:"/v6.3/docs/concepts/operator-intro.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-7901b1b4").then(t)}},{name:"v-1450c2a6",path:"/v6.3/docs/concepts/custom-resources.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-1450c2a6").then(t)}},{name:"v-258a5de6",path:"/v6.3/docs/concepts/pda-architecture.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-258a5de6").then(t)}},{name:"v-80e62764",path:"/v6.3/docs/ecr/ecr-bundle-details.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-80e62764").then(t)}},{name:"v-6ab3389c",path:"/v6.3/docs/ecr/ecr-bundle-filters.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-6ab3389c").then(t)}},{name:"v-0cf3f5ec",path:"/v6.3/docs/ecr/ecr-bundle-versions-faq.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-0cf3f5ec").then(t)}},{name:"v-00077730",path:"/v6.3/docs/ecr/ecr-bundle-presentation-config.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-00077730").then(t)}},{name:"v-65aa6b28",path:"/v6.3/docs/ecr/ecr-how-microservices-connect-to-apps.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-65aa6b28").then(t)}},{name:"v-5899f08a",path:"/v6.3/docs/ecr/ecr-overview.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-5899f08a").then(t)}},{name:"v-19e7e228",path:"/v6.3/docs/ecr/ecr-troubleshooting-guide.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-19e7e228").then(t)}},{name:"v-516c114a",path:"/v6.3/docs/ecr/ecr-uninstall-flow.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-516c114a").then(t)}},{name:"v-8852b36c",path:"/v6.3/docs/getting-started/welcome-wizard.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-8852b36c").then(t)}},{name:"v-1b9bdef1",path:"/v6.3/docs/getting-started/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-1b9bdef1").then(t)}},{path:"/v6.3/docs/getting-started/index.html",redirect:"/v6.3/docs/getting-started/"},{name:"v-400aa74c",path:"/v6.3/docs/getting-started/quick-reference.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-400aa74c").then(t)}},{name:"v-6a3fd5e8",path:"/v6.3/docs/reference/cluster-resource-limits.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-6a3fd5e8").then(t)}},{name:"v-3723c578",path:"/v6.3/docs/reference/caching-and-clustering.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-3723c578").then(t)}},{name:"v-efcc73e8",path:"/v6.3/docs/reference/databases.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-efcc73e8").then(t)}},{name:"v-2e9dbc86",path:"/v6.3/docs/reference/deployment-structure.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-2e9dbc86").then(t)}},{name:"v-438781d6",path:"/v6.3/docs/reference/entando-apis.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-438781d6").then(t)}},{name:"v-98694d68",path:"/v6.3/docs/reference/entando-cli.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-98694d68").then(t)}},{name:"v-1c5b09bf",path:"/v6.3/docs/reference/freemarker-tags/freemarker-JACMS-tags.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-1c5b09bf").then(t)}},{name:"v-55ae2236",path:"/v6.3/docs/releases/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-55ae2236").then(t)}},{path:"/v6.3/docs/releases/index.html",redirect:"/v6.3/docs/releases/"},{name:"v-47f57e71",path:"/v6.3/docs/reference/freemarker-tags/freemarker-core-tags.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-47f57e71").then(t)}},{name:"v-6a6e256c",path:"/v6.3/docs/reference/local-tips-and-tricks.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-6a6e256c").then(t)}},{name:"v-4fd3bacc",path:"/v6.3/docs/reference/identity-management.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-4fd3bacc").then(t)}},{name:"v-08b0f4d8",path:"/v6.3/tutorials/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-08b0f4d8").then(t)}},{path:"/v6.3/tutorials/index.html",redirect:"/v6.3/tutorials/"},{name:"v-6e996aa2",path:"/v6.3/tutorials/backend-developers/generate-microservices-and-micro-frontends.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-6e996aa2").then(t)}},{name:"v-5076a886",path:"/v6.3/tutorials/backend-developers/add-access-controls.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-5076a886").then(t)}},{name:"v-346e3ce6",path:"/v6.3/tutorials/backend-developers/update-data-model.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-346e3ce6").then(t)}},{name:"v-037f6074",path:"/v6.3/tutorials/backend-developers/run-local.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-037f6074").then(t)}},{name:"v-95ff1c02",path:"/v6.3/tutorials/cms/app-builder/hello-world.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-95ff1c02").then(t)}},{name:"v-77ce6300",path:"/v6.3/tutorials/cms/content-templates-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-77ce6300").then(t)}},{name:"v-72927900",path:"/v6.3/tutorials/cms/content-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-72927900").then(t)}},{name:"v-7b427e40",path:"/v6.3/tutorials/cms/content-attributes.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-7b427e40").then(t)}},{name:"v-a2fb3f00",path:"/v6.3/tutorials/cms/content-types-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-a2fb3f00").then(t)}},{name:"v-d071ee00",path:"/v6.3/tutorials/cms/creating-protected-resources.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-d071ee00").then(t)}},{name:"v-16fa72cc",path:"/v6.3/tutorials/cms/digital-assets-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-16fa72cc").then(t)}},{name:"v-0980427e",path:"/v6.3/tutorials/cms/page-management.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-0980427e").then(t)}},{name:"v-f24c0590",path:"/v6.3/tutorials/customize-the-platform/connecting-external-db.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-f24c0590").then(t)}},{name:"v-f53df298",path:"/v6.3/tutorials/customize-the-platform/add-rest-api.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-f53df298").then(t)}},{name:"v-712e7cb8",path:"/v6.3/tutorials/customize-the-platform/change-default-datasources-and-connections/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-712e7cb8").then(t)}},{path:"/v6.3/tutorials/customize-the-platform/change-default-datasources-and-connections/index.html",redirect:"/v6.3/tutorials/customize-the-platform/change-default-datasources-and-connections/"},{name:"v-9ab51f54",path:"/v6.3/tutorials/customize-the-platform/extend-app-builder.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-9ab51f54").then(t)}},{name:"v-04fefc4a",path:"/v6.3/tutorials/customize-the-platform/invoking-api.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-04fefc4a").then(t)}},{name:"v-d9a24a5c",path:"/v6.3/tutorials/customize-the-platform/pda-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-d9a24a5c").then(t)}},{name:"v-9833fbb4",path:"/v6.3/tutorials/devops/backing-up-and-restoring-your-environment.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-9833fbb4").then(t)}},{name:"v-846210da",path:"/v6.3/tutorials/devops/clustering-caching/caching-and-clustering.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-846210da").then(t)}},{name:"v-a7ad4b84",path:"/v6.3/tutorials/devops/build-core-image.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-a7ad4b84").then(t)}},{name:"v-10c1b3bc",path:"/v6.3/tutorials/devops/external-database/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-10c1b3bc").then(t)}},{path:"/v6.3/tutorials/devops/external-database/index.html",redirect:"/v6.3/tutorials/devops/external-database/"},{name:"v-1b846906",path:"/v6.3/tutorials/devops/installation/azure-kubernetes-service/azure-install.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-1b846906").then(t)}},{name:"v-151998f0",path:"/v6.3/tutorials/devops/default-database.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-151998f0").then(t)}},{name:"v-80e5c274",path:"/v6.3/tutorials/devops/installation/elastic-kubernetes-service/eks-install.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-80e5c274").then(t)}},{name:"v-483bee76",path:"/v6.3/tutorials/devops/external-keycloak/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-483bee76").then(t)}},{path:"/v6.3/tutorials/devops/external-keycloak/index.html",redirect:"/v6.3/tutorials/devops/external-keycloak/"},{name:"v-b6142aea",path:"/v6.3/tutorials/devops/installation/google-cloud-platform/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-b6142aea").then(t)}},{path:"/v6.3/tutorials/devops/installation/google-cloud-platform/index.html",redirect:"/v6.3/tutorials/devops/installation/google-cloud-platform/"},{name:"v-a2a432b4",path:"/v6.3/tutorials/devops/installation/open-shift/openshift-install-by-operator-hub.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-a2a432b4").then(t)}},{name:"v-1f0dbe86",path:"/v6.3/tutorials/devops/installation/open-shift/openshift-install.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-1f0dbe86").then(t)}},{name:"v-856d3940",path:"/v6.3/tutorials/ecr/deploy-components-without-bundle.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-856d3940").then(t)}},{name:"v-58d00a40",path:"/v6.3/tutorials/ecr/ecr-private-git-repo.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-58d00a40").then(t)}},{name:"v-69699fc0",path:"/v6.3/tutorials/ecr/export-bundle-from-application.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-69699fc0").then(t)}},{name:"v-3a7efb40",path:"/v6.3/tutorials/ecr/ecr-private-images.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-3a7efb40").then(t)}},{name:"v-8df458c0",path:"/v6.3/tutorials/ecr/publish-project-bundle.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-8df458c0").then(t)}},{name:"v-08f2d46c",path:"/v6.3/tutorials/ecr/publish-simple-bundle.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-08f2d46c").then(t)}},{name:"v-63795daa",path:"/v6.3/tutorials/micro-frontends/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-63795daa").then(t)}},{path:"/v6.3/tutorials/micro-frontends/index.html",redirect:"/v6.3/tutorials/micro-frontends/"},{name:"v-23d1ddc4",path:"/v6.3/tutorials/micro-frontends/angular.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-23d1ddc4").then(t)}},{name:"v-a598da14",path:"/v6.3/tutorials/micro-frontends/communication.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-a598da14").then(t)}},{name:"v-cafac8c0",path:"/v6.3/tutorials/micro-frontends/authentication.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-cafac8c0").then(t)}},{name:"v-f69511c4",path:"/v6.3/tutorials/micro-frontends/generate-micro-frontends-from-a-database-entity/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-f69511c4").then(t)}},{path:"/v6.3/tutorials/micro-frontends/generate-micro-frontends-from-a-database-entity/index.html",redirect:"/v6.3/tutorials/micro-frontends/generate-micro-frontends-from-a-database-entity/"},{name:"v-3be4ca38",path:"/v6.3/tutorials/micro-frontends/react.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-3be4ca38").then(t)}},{name:"v-1c11d3d2",path:"/v7.0/docs/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-1c11d3d2").then(t)}},{path:"/v7.0/docs/index.html",redirect:"/v7.0/docs/"},{name:"v-59f43a00",path:"/v6.3/tutorials/micro-frontends/widget-configuration.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-59f43a00").then(t)}},{name:"v-73f90d08",path:"/v7.0/docs/community/contributing.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-73f90d08").then(t)}},{name:"v-bd433584",path:"/v6.3/tutorials/samples/install-standard-demo.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-bd433584").then(t)}},{name:"v-15da424c",path:"/v7.0/docs/community/code-of-conduct.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-15da424c").then(t)}},{name:"v-055df94c",path:"/v7.0/docs/compose/app-builder.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-055df94c").then(t)}},{name:"v-08a2e18a",path:"/v7.0/docs/compose/ecr-overview.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-08a2e18a").then(t)}},{name:"v-49a9cc40",path:"/v7.0/docs/compose/ecm-overview.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-49a9cc40").then(t)}},{name:"v-1727dd82",path:"/v7.0/docs/compose/welcome-wizard.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-1727dd82").then(t)}},{name:"v-2bcbdf28",path:"/v7.0/docs/consume/accessibility.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-2bcbdf28").then(t)}},{name:"v-013efea8",path:"/v7.0/docs/consume/identity-management.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-013efea8").then(t)}},{name:"v-092f5bf0",path:"/v7.0/docs/consume/custom-resources.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-092f5bf0").then(t)}},{name:"v-384a5208",path:"/v7.0/docs/consume/entando-apis.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-384a5208").then(t)}},{name:"v-4e900774",path:"/v7.0/docs/create/blueprint-features.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-4e900774").then(t)}},{name:"v-3761aa7c",path:"/v7.0/docs/consume/operator-intro.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-3761aa7c").then(t)}},{name:"v-32a2b2dc",path:"/v7.0/docs/create/component-gen-customize.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-32a2b2dc").then(t)}},{name:"v-0f8a9c74",path:"/v7.0/docs/create/component-gen-tech.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-0f8a9c74").then(t)}},{name:"v-1acd0da6",path:"/v7.0/docs/curate/ecr-bundle-details.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-1acd0da6").then(t)}},{name:"v-e897f2b4",path:"/v7.0/docs/create/component-gen-overview.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-e897f2b4").then(t)}},{name:"v-ce697074",path:"/v7.0/docs/curate/ecr-bundle-filters.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-ce697074").then(t)}},{name:"v-3b569df0",path:"/v7.0/docs/curate/ecr-bundle-versions-faq.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-3b569df0").then(t)}},{name:"v-862815f4",path:"/v7.0/docs/curate/ecr-bundle-presentation-config.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-862815f4").then(t)}},{name:"v-4aeaf8dc",path:"/v7.0/docs/curate/ecr-how-microservices-connect-to-apps.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-4aeaf8dc").then(t)}},{name:"v-619bf73c",path:"/v7.0/docs/curate/ecr-troubleshooting-guide.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-619bf73c").then(t)}},{name:"v-170b2834",path:"/v7.0/docs/curate/ecr-uninstall-flow.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-170b2834").then(t)}},{name:"v-10f101c0",path:"/v7.0/docs/getting-started/development-concepts.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-10f101c0").then(t)}},{name:"v-498b9a6d",path:"/v7.0/docs/getting-started/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-498b9a6d").then(t)}},{path:"/v7.0/docs/getting-started/index.html",redirect:"/v7.0/docs/getting-started/"},{name:"v-59320970",path:"/v7.0/docs/getting-started/landing-page.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-59320970").then(t)}},{name:"v-85a297e8",path:"/v7.0/docs/getting-started/concepts-overview.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-85a297e8").then(t)}},{name:"v-a7172670",path:"/v7.0/docs/reference/caching-and-clustering.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-a7172670").then(t)}},{name:"v-6cd1d58a",path:"/v7.0/docs/reference/deployment-structure.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-6cd1d58a").then(t)}},{name:"v-42c4794c",path:"/v7.0/docs/reference/cluster-resource-limits.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-42c4794c").then(t)}},{name:"v-9378b468",path:"/v7.0/docs/reference/databases.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-9378b468").then(t)}},{name:"v-04b3508c",path:"/v7.0/docs/reference/entando-cli.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-04b3508c").then(t)}},{name:"v-6d775b02",path:"/v7.0/docs/reference/freemarker-tags/freemarker-JACMS-tags.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-6d775b02").then(t)}},{name:"v-61834b18",path:"/v7.0/tutorials/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-61834b18").then(t)}},{path:"/v7.0/tutorials/index.html",redirect:"/v7.0/tutorials/"},{name:"v-2b5ccb75",path:"/v7.0/docs/reference/freemarker-tags/freemarker-core-tags.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-2b5ccb75").then(t)}},{name:"v-662a322c",path:"/v7.0/docs/reference/local-tips-and-tricks.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-662a322c").then(t)}},{name:"v-cac5d3b6",path:"/v7.0/docs/releases/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-cac5d3b6").then(t)}},{path:"/v7.0/docs/releases/index.html",redirect:"/v7.0/docs/releases/"},{name:"v-407b1dc0",path:"/v7.0/tutorials/compose/content-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-407b1dc0").then(t)}},{name:"v-26c50960",path:"/v7.0/tutorials/compose/content-templates-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-26c50960").then(t)}},{name:"v-1aac2a40",path:"/v7.0/tutorials/compose/content-attributes.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-1aac2a40").then(t)}},{name:"v-7d1effe0",path:"/v7.0/tutorials/compose/content-types-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-7d1effe0").then(t)}},{name:"v-5875d3a0",path:"/v7.0/tutorials/compose/creating-protected-resources.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-5875d3a0").then(t)}},{name:"v-575b6d30",path:"/v7.0/tutorials/compose/widgets-fragments.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-575b6d30").then(t)}},{name:"v-2ae5af0c",path:"/v7.0/tutorials/compose/digital-assets-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-2ae5af0c").then(t)}},{name:"v-4a508620",path:"/v7.0/tutorials/compose/page-management.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-4a508620").then(t)}},{name:"v-d238dffc",path:"/v7.0/tutorials/create/mfe/",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-d238dffc").then(t)}},{path:"/v7.0/tutorials/create/mfe/index.html",redirect:"/v7.0/tutorials/create/mfe/"},{name:"v-79cc9f79",path:"/v7.0/tutorials/create/mfe/angular.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-79cc9f79").then(t)}},{name:"v-455c4095",path:"/v7.0/tutorials/create/mfe/authentication.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-455c4095").then(t)}},{name:"v-dc031c0e",path:"/v7.0/tutorials/create/mfe/communication.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-dc031c0e").then(t)}},{name:"v-52359299",path:"/v7.0/tutorials/create/mfe/react.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-52359299").then(t)}},{name:"v-10352daa",path:"/v7.0/tutorials/create/mfe/widget-configuration.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-10352daa").then(t)}},{name:"v-2f589b71",path:"/v7.0/tutorials/create/ms/add-access-controls.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-2f589b71").then(t)}},{name:"v-06f2bc13",path:"/v7.0/tutorials/create/ms/generate-microservices-and-micro-frontends.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-06f2bc13").then(t)}},{name:"v-17e34c85",path:"/v7.0/tutorials/create/ms/run-local.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-17e34c85").then(t)}},{name:"v-15033c43",path:"/v7.0/tutorials/create/ms/update-data-model.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-15033c43").then(t)}},{name:"v-5f395013",path:"/v7.0/tutorials/create/pb/export-bundle-from-application.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-5f395013").then(t)}},{name:"v-5ad381f6",path:"/v7.0/tutorials/create/ms/use-postman-with-oauth2.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-5ad381f6").then(t)}},{name:"v-54e2540d",path:"/v7.0/tutorials/create/pb/github-actions-workflow.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-54e2540d").then(t)}},{name:"v-55d3d333",path:"/v7.0/tutorials/create/pb/deploy-components-without-bundle.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-55d3d333").then(t)}},{name:"v-b645419a",path:"/v7.0/tutorials/create/pb/publish-project-bundle.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-b645419a").then(t)}},{name:"v-c5e75eb8",path:"/v7.0/tutorials/curate/ecr-private-git-repo.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-c5e75eb8").then(t)}},{name:"v-cac1f57e",path:"/v7.0/tutorials/create/pb/publish-simple-bundle.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-cac1f57e").then(t)}},{name:"v-29b00b4e",path:"/v7.0/tutorials/curate/ecr-private-images.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-29b00b4e").then(t)}},{name:"v-2e351e00",path:"/v7.0/tutorials/devops/add-rest-api.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-2e351e00").then(t)}},{name:"v-01f14850",path:"/v7.0/tutorials/devops/backing-restoring-keycloak.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-01f14850").then(t)}},{name:"v-473b1d34",path:"/v7.0/tutorials/devops/backing-up-and-restoring-your-environment.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-473b1d34").then(t)}},{name:"v-6a1fdcc2",path:"/v7.0/tutorials/devops/build-core-image.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-6a1fdcc2").then(t)}},{name:"v-08df2e42",path:"/v7.0/tutorials/devops/caching-and-clustering.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-08df2e42").then(t)}},{name:"v-2c5c21fe",path:"/v7.0/tutorials/devops/entando-operator.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-2c5c21fe").then(t)}},{name:"v-992c93e8",path:"/v7.0/tutorials/devops/default-database.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-992c93e8").then(t)}},{name:"v-751ba286",path:"/v7.0/tutorials/devops/change-default-datasource.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-751ba286").then(t)}},{name:"v-00c45ac6",path:"/v7.0/tutorials/devops/external-db.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-00c45ac6").then(t)}},{name:"v-49a30018",path:"/v7.0/tutorials/devops/external-id-management.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-49a30018").then(t)}},{name:"v-240e1c96",path:"/v7.0/tutorials/devops/invoking-api.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-240e1c96").then(t)}},{name:"v-173773e2",path:"/v7.0/tutorials/devops/plugin-configuration.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-173773e2").then(t)}},{name:"v-1e637d54",path:"/v7.0/tutorials/devops/plugin-environment-variables.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-1e637d54").then(t)}},{name:"v-3accb136",path:"/v7.0/tutorials/devops/manage-nginx.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-3accb136").then(t)}},{name:"v-dc748a20",path:"/v7.0/tutorials/getting-started/eks-install.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-dc748a20").then(t)}},{name:"v-261acd60",path:"/v7.0/tutorials/getting-started/kubernetes-install.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-261acd60").then(t)}},{name:"v-392f6e6c",path:"/v7.0/tutorials/getting-started/azure-install.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-392f6e6c").then(t)}},{name:"v-61df9ff0",path:"/v7.0/tutorials/getting-started/gke-install.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-61df9ff0").then(t)}},{name:"v-f7011000",path:"/v7.0/tutorials/getting-started/openshift-install-by-operator.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-f7011000").then(t)}},{name:"v-06f2ad5a",path:"/v7.0/tutorials/getting-started/openshift-install.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-06f2ad5a").then(t)}},{name:"v-84091f34",path:"/v7.0/tutorials/solution/entando-hub.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-84091f34").then(t)}},{name:"v-2133de34",path:"/v7.0/tutorials/solution/customer-portal.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-2133de34").then(t)}},{name:"v-32044be6",path:"/v7.0/tutorials/solution/install-standard-demo.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-32044be6").then(t)}},{name:"v-f7ea08f0",path:"/v7.0/tutorials/solution/landing-page.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-f7ea08f0").then(t)}},{name:"v-ce94d8f4",path:"/v7.0/tutorials/solution/pda-technical-guide.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-ce94d8f4").then(t)}},{name:"v-ae3e69a8",path:"/v7.0/tutorials/solution/pda-architecture.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-ae3e69a8").then(t)}},{name:"v-c6d19f54",path:"/v7.0/tutorials/solution/pda-tutorial.html",component:Us,beforeEnter:function(e,n,t){Yr("Layout","v-c6d19f54").then(t)}},{path:"*",component:Us}],Ns={title:"Entando Developers",description:"Entando Developers",base:"/entando-docs/",headTags:[["link",{rel:"icon",href:"/entando-docs/theme/favicon.png"}],["meta",{name:"viewport",content:"width=device-width, initial-scale=1"}],["script",{src:"/entando-docs/theme/javascript/hotjar.js"}],["script",{async:!0,src:"https://www.googletagmanager.com/gtag/js?id=G-HQRL49XVCW"}],["script",{},["window.dataLayer = window.dataLayer || [];\nfunction gtag(){dataLayer.push(arguments);}\ngtag('js', new Date());\ngtag('config', 'G-HQRL49XVCW');"]]],pages:[{frontmatter:{},regularPath:"/docs/",relativePath:"docs/README.md",key:"v-6105f836",path:"/docs/",lastUpdated:"4/20/2022, 4:10:39 PM",lastUpdatedTimestamp:1650485439e3,content:" Redirecting to the current Docs...\n \n"},{frontmatter:{pageClass:"entando-landing-page"},regularPath:"/",relativePath:"README.md",key:"v-8f9ecbbc",path:"/",lastUpdated:"2/8/2022, 8:58:16 AM",lastUpdatedTimestamp:1644328696e3,content:" "},{frontmatter:{pageClass:"entando-landing-page"},regularPath:"/jhipster.html",relativePath:"jhipster.md",key:"v-33b5fb82",path:"/jhipster.html",lastUpdated:"2/8/2022, 8:58:16 AM",lastUpdatedTimestamp:1644328696e3,content:" "},{frontmatter:{},regularPath:"/docs/getting-started/",relativePath:"docs/getting-started/README.md",key:"v-f5704990",path:"/docs/getting-started/",lastUpdated:"4/20/2022, 4:10:39 PM",lastUpdatedTimestamp:1650485439e3,content:" Redirecting to the current Getting Started guide...\n \n"},{frontmatter:{sidebarDepth:0},regularPath:"/next/docs/",relativePath:"next/docs/README.md",key:"v-6f3b39b2",path:"/next/docs/",headers:[{level:2,title:"Entando Architecture",slug:"entando-architecture"},{level:2,title:"Why Kubernetes?",slug:"why-kubernetes"}],lastUpdated:"4/7/2022, 10:58:02 AM",lastUpdatedTimestamp:1649343482e3,content:" ATTENTION \n This documentation is for the version of Entando currently under development and is a work in progress.\nSome screenshots or references to the previous version may be out-of-date and some documented features may\nonly be available by building from source. \n Entando Platform \n Entando is the leading open source  Application Composition Platform  for Kubernetes. It enables parallel teams to accelerate development and innovation of business capabilities on a modern, cloud-native, and Kubernetes-native stack. \n With native support for Javascript app development, a micro frontend and microservices architecture, deployment of apps in containers that can be individually scaled up and down, and automated management of containers with Kubernetes, we simplify the move for enterprises looking to modernize across on-prem and cloud infrastructures. \n Entando Architecture \n \n The Entando platform includes the following major elements: \n \n Entando App Engine : assemble micro frontends & microservices and compose them on a page. \n Entando App Builder : the user interface to build and design applications. \n Entando Component Generator : provide advanced data modeling capabilities and automatically generate the corresponding microservices and micro frontends. \n Entando Component Repository : a shared, internal repository to encourage code reuse across the enterprise. \n Entando Identity Management : token-based authentication across multiple domains and connect service providers with identity providers. \n Entando WCMS : a web content management system that supports headless CMS. \n (optional)  Entando Business Automation Bundle : workflow and task automation including out of the box integration with Red Hat Process Automation Manager (PAM). \n Why Kubernetes? \n Instead of you doing the work to ensure your apps and services stay up and running, Kubernetes does the work for you. For each app or service, you can set resource limits, the number of pods you want backing each service, upgrade strategy, and auto-scaling. Kubernetes actively manages your cluster to match your defined resource utilization and ensures your site doesn't go down. \n How Google Runs Containers in Production \n Each week, Google deploys over 2 billion containers in production to run all of its services like Gmail, YouTube, and Search. Kubernetes is Google's open source solution to automate the management of containers at scale. \n \n Over 50% of Fortune 500 companies use Kubernetes with product offerings from Amazon Elastic Kubernetes Service (EKS), Google Cloud Platform (GKE), IBM (Red Hat) OpenShift, Microsoft Azure (AKS), and VMWare Pivotal (PKS). \n"},{title:"Entando Contributor Covenant Code of Conduct",frontmatter:{},regularPath:"/next/docs/community/code-of-conduct.html",relativePath:"next/docs/community/code-of-conduct.md",key:"v-374a5768",path:"/next/docs/community/code-of-conduct.html",headers:[{level:2,title:"Our Pledge",slug:"our-pledge"},{level:2,title:"Our Standards",slug:"our-standards"},{level:2,title:"Enforcement Responsibilities",slug:"enforcement-responsibilities"},{level:2,title:"Scope",slug:"scope"},{level:2,title:"Enforcement",slug:"enforcement"},{level:2,title:"Enforcement Guidelines",slug:"enforcement-guidelines"},{level:3,title:"1. Correction",slug:"_1-correction"},{level:3,title:"2. Warning",slug:"_2-warning"},{level:3,title:"3. Temporary Ban",slug:"_3-temporary-ban"},{level:3,title:"4. Permanent Ban",slug:"_4-permanent-ban"},{level:2,title:"Attribution",slug:"attribution"}],lastUpdated:"7/21/2020, 6:50:11 AM",lastUpdatedTimestamp:1595328611e3,content:" Entando Contributor Covenant Code of Conduct \n Our Pledge \n We as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, religion, or sexual identity\nand orientation. \n We pledge to act and interact in ways that contribute to an open, welcoming,\ndiverse, inclusive, and healthy community. \n Our Standards \n Examples of behavior that contributes to a positive environment for our\ncommunity include: \n \n Demonstrating empathy and kindness toward other people \n Being respectful of differing opinions, viewpoints, and experiences \n Giving and gracefully accepting constructive feedback \n Accepting responsibility and apologizing to those affected by our mistakes,\nand learning from the experience \n Focusing on what is best not just for us as individuals, but for the\noverall community \n \n Examples of unacceptable behavior include: \n \n The use of sexualized language or imagery, and sexual attention or\nadvances of any kind \n Trolling, insulting or derogatory comments, and personal or political attacks \n Public or private harassment \n Publishing others' private information, such as a physical or email\naddress, without their explicit permission \n Other conduct which could reasonably be considered inappropriate in a\nprofessional setting \n Enforcement Responsibilities \n Community leaders are responsible for clarifying and enforcing our standards of\nacceptable behavior and will take appropriate and fair corrective action in\nresponse to any behavior that they deem inappropriate, threatening, offensive,\nor harmful. \n Community leaders have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions that are\nnot aligned to this Code of Conduct, and will communicate reasons for moderation\ndecisions when appropriate. \n Scope \n This Code of Conduct applies within all community spaces, and also applies when\nan individual is officially representing the community in public spaces.\nExamples of representing our community include using an official e-mail address,\nposting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event. \n Enforcement \n Instances of abusive, harassing, or otherwise unacceptable behavior may be\nreported to the community leaders responsible for enforcement at\ncommunity@entando.com. \n All complaints will be reviewed and investigated promptly and fairly. \n All community leaders are obligated to respect the privacy and security of the\nreporter of any incident. \n Enforcement Guidelines \n Community leaders will follow these Community Impact Guidelines in determining\nthe consequences for any action they deem in violation of this Code of Conduct: \n 1. Correction \n Community Impact : Use of inappropriate language or other behavior deemed\nunprofessional or unwelcome in the community. \n Consequence : A private, written warning from community leaders, providing\nclarity around the nature of the violation and an explanation of why the\nbehavior was inappropriate. A public apology may be requested. \n 2. Warning \n Community Impact : A violation through a single incident or series\nof actions. \n Consequence : A warning with consequences for continued behavior. No\ninteraction with the people involved, including unsolicited interaction with\nthose enforcing the Code of Conduct, for a specified period of time. This\nincludes avoiding interactions in community spaces as well as external channels\nlike social media. Violating these terms may lead to a temporary or\npermanent ban. \n 3. Temporary Ban \n Community Impact : A serious violation of community standards, including\nsustained inappropriate behavior. \n Consequence : A temporary ban from any sort of interaction or public\ncommunication with the community for a specified period of time. No public or\nprivate interaction with the people involved, including unsolicited interaction\nwith those enforcing the Code of Conduct, is allowed during this period.\nViolating these terms may lead to a permanent ban. \n 4. Permanent Ban \n Community Impact : Demonstrating a pattern of violation of community\nstandards, including sustained inappropriate behavior,  harassment of an\nindividual, or aggression toward or disparagement of classes of individuals. \n Consequence : A permanent ban from any sort of public interaction within\nthe community. \n Attribution \n This Code of Conduct is adapted from the  Contributor Covenant ,\nversion 2.0, available at\nhttps://www.contributor-covenant.org/version/2/0/code_of_conduct.html. \n Community Impact Guidelines were inspired by  Mozilla's code of conduct\nenforcement ladder . \n For answers to common questions about this code of conduct, see the FAQ at\nhttps://www.contributor-covenant.org/faq. Translations are available at\nhttps://www.contributor-covenant.org/translations. \n"},{title:"Entando App Builder",frontmatter:{sidebarDepth:2},regularPath:"/next/docs/compose/app-builder.html",relativePath:"next/docs/compose/app-builder.md",key:"v-32f0d168",path:"/next/docs/compose/app-builder.html",headers:[{level:3,title:"Key Features:",slug:"key-features"},{level:3,title:"Next Steps:",slug:"next-steps"}],lastUpdated:"2/22/2022, 1:55:15 PM",lastUpdatedTimestamp:1645556115e3,content:" Entando App Builder \n The Entando App Builder plays a key role in the composition of Entando Applications. It is a feature-rich, low-code user interface to customize and manage components. It also offers a Dashboard and a modular CMS to streamline the design and build process. \n \n The App Builder allows you to create pages and content, configure widgets and plugins, and interact with the  Entando Component Repository  (ECR). It also interfaces with the  Entando Hub , where you can share components and collaborate. \n Pages are designed and embedded with functionality via drag-and-drop: \n \n In the default deployment, the App Builder is a React JS application served by Node. In a quickstart environment, the App Builder is deployed as a container. It is the frontend of the core application and uses REST APIs to communicate with the core instance and  Entando Component Manager (ECM) . The App Builder can query the ECM to fetch information on Entando Bundles available to the ECR. \n Key Features: \n \n \n Install component bundles from the Entando Component Repository \n \n \n Deploy standalone packaged business capabilities \n \n \n Preview page design and functionality \n \n \n Append or update applications \n \n \n Deliver standardized UX design with page and content templates \n \n \n Use micro frontends to build pages from modular, editable content \n Next Steps: \n \n \n To begin,  install Entando \n \n \n Welcome Wizard \n \n \n Create a new page \n \n \n Try out components or packaged business capabilities from the  Entando Hub \n \n \n"},{title:"Contributing to Entando",frontmatter:{},regularPath:"/next/docs/community/contributing.html",relativePath:"next/docs/community/contributing.md",key:"v-af1249b0",path:"/next/docs/community/contributing.html",headers:[{level:2,title:"Contributing to the Source",slug:"contributing-to-the-source"},{level:2,title:"Code Style and Formatting",slug:"code-style-and-formatting"},{level:3,title:"Java",slug:"java"},{level:3,title:"Javascript",slug:"javascript"},{level:3,title:"Find the Code",slug:"find-the-code"},{level:2,title:"Get Help",slug:"get-help"},{level:2,title:"Licenses",slug:"licenses"}],lastUpdated:"1/25/2022, 4:09:16 PM",lastUpdatedTimestamp:1643144956e3,content:" Contributing to Entando \n There are many ways to contribute to Entando including participating in the  Entando Forum , opening issues on GitHub,  updating documentation , building bundles using the  Entando Component Repository , and contributing directly to the source. \n Contributing to the Source \n Entando welcomes contributions to our source code repositories. This is a brief overview of how to create a pull request for an Entando repository. \n If you're new to forks in the git world checkout this guide  Working with Forks \n \n Find the repository you want to edit on the Entando GitHub\n \n https://github.com/entando \n https://github.com/entando-k8s \n \n \n Create a fork of the repository you want to update \n Make your changes or updates on your fork. We recommend making your changes on a branch so that you can update your commits as needed before creating your PR \n Submit a PR against the main (or master) branch of the repository you're working against. If you're fixing a specific issue reference that issue number in the notes and linked issues \n Watch the automated builds to make sure everything passes \n The Entando team will merge your changes! \n Code Style and Formatting \n Most Entando repositories enforce code style rules. References and setup for the main\nsource types are provided below. \n Java \n Java rules are based on checkstyle and PMD can be found at in the  entando-code-style  project. There are configuration files for Intellij, Eclipse, and Netbeans for automated formatting. \n Javascript \n Code style and formatting rules for all Entando javascript projects are enforced by linters in every project. For a reference example see: .sass-lint.yml and .eslintrc.js in the  App builder \n In the future these rules will be replaced by Prettier. \n Find the Code \n Entando source can be found on GitHub in the following organizations. \n \n https://github.com/entando \n https://github.com/entando-k8s \n \n For an overview of the key projects in both GitHub organizations and their role in the architecture see  Entando Deployment Structure \n Get Help \n If you have questions, need help, or want to find out more about contributing join us at \n \n Entando Forum \n Community Slack \n Licenses \n The Entando Platform is 100% open source and most Entando repositories are licensed under the LGPL V3.0. The entando-docs repository is one exception with a  CC BY 4.0 license . See the LICENSE file in the root directory of a given repository for its specific license information. \n Entando libraries licensed with LGPL V3.0 that are used to build applications may be linked to proprietary applications. If linked statically, the application code must also be released as LGPL. If the application is linked dynamically to Entando, the proprietary code does not need to be released. \n A commercial open source license is provided for the Entando Platform for customers with Gold and Platinum subscriptions. This license permits freely extending or modifying Entando without requiring contribution of confidential IP back to the open source community. \n"},{title:"Entando Component Manager",frontmatter:{sidebarDepth:2},regularPath:"/next/docs/compose/ecm-overview.html",relativePath:"next/docs/compose/ecm-overview.md",key:"v-30e9b340",path:"/next/docs/compose/ecm-overview.html",headers:[{level:3,title:"Key Features:",slug:"key-features"}],lastUpdated:"2/22/2022, 1:55:15 PM",lastUpdatedTimestamp:1645556115e3,content:" Entando Component Manager \n ​​An Entando Application is composed of the  Entando App Builder ,  Entando App Engine , and Entando Component Manager. The Entando Component Manager (ECM) provides functionality to build and organize micro frontends and widgets from within the App Builder. It also manages the connections between an application and the installed plugins. \n The Component Manager is a service that links the  Entando Component Repository  (ECR) of the App Builder to the core application instance. It appears as  quickstart-cm-deployment  in the Kubernetes pod list: \n \n The ECM communicates with the Kubernetes service to populate the ECR with the bundles available as  Custom Resources  in the Entando namespace. These bundles can be installed in the application and managed from within the ECR. \n \n In the flow pictured above: \n \n A user visits the ECR page in the App Builder \n The ECR makes a REST call to the  digital-exchange  endpoint \n The Component Manager receives the  digital-exchange  request \n The Component Manager calls the  k8s-service  to return the list of available  EntandoDeBundles  in the namespace \n \n A similar process occurs when bundles are installed or uninstalled. The  Entando Operator  performs actions based on lifecycle events for affected Entando Custom Resources. \n Key Features: \n \n \n Manages the installation and removal of project bundles \n \n \n Makes components available in the App Builder through the Component Repository \n \n \n Handles versioning of component bundles for sharing and collaborating \n \n \n"},{title:"Web Accessibility in Entando",frontmatter:{},regularPath:"/next/docs/consume/accessibility.html",relativePath:"next/docs/consume/accessibility.md",key:"v-494daa6c",path:"/next/docs/consume/accessibility.html",headers:[{level:2,title:"Requirements and Standards",slug:"requirements-and-standards"},{level:2,title:"Tools",slug:"tools"}],lastUpdated:"1/25/2022, 4:09:16 PM",lastUpdatedTimestamp:1643144956e3,content:" Web Accessibility in Entando \n \n The power of the Web is in its universality.\nAccess by everyone regardless of disability is an essential aspect. \n \n - Tim Berners-Lee, W3C Director and inventor of the World Wide Web \n Web accessibility means that websites, tools, and technologies are designed and developed so that people with\ndisabilities can use them. Accessibility is essential for developers and organizations that want to create high-quality\nwebsites and web tools, and not exclude people from using their products and services.\nSee  w3.org  for an introduction to this topic. \n Requirements and Standards \n Many projects and programs will have specific requirements in the area of accessibility, particularly for applications\nor sites with a broad reach or specific governance considerations. Entando's approach to accessibility is to provide the\ntools and techniques that allow a development team to meet their own specific accessibility requirements. \n Development teams will need someone to become familiar with the relevant accessibility standards and help make design\ndecisions on how they will be applied to a specific project. Those standards vary by region so please check the\nlegislation in your area or consult an accessibility specialist. Useful resources include: \n \n W3C Web Accessibility Initiative (WAI) \n Web Content Accessibility Guidelines (WCAG) \n USA:  Section 508 of the Rehabilitation Act \n \n At the end of the day it's up to a development team to make sure their implementation is compliant with a specific\nguideline or standard. Typically a team will make use of Entando Page Templates, Content Templates, and custom micro\nfrontends in order to accomplish this goal. \n Tools \n Accessibility requirements are ideally known at the start of a project so the design language and tools can be adopted\nearly in the project. Using them consistently will ease implementation of the accessibility elements needed to meet the\ndesired compliance level. Retrofitting a project for accessibility can be done but is typically more involved. Example\ndesign systems used by Entando clients include: \n \n Material-UI  - a React framework used to build a custom design system and/or one based on\nMaterial Design. \n Carbon Design System  - IBM's open source design system \n Bootstrap Italia  - a Bootstrap 4-based frontend theme that implements\nthe Italian Design Guidelines for public websites. \n \n Assessing web accessibility is important throughout the life of a project. There are many tools available in this area. A\nuseful list can be found  on the W3C site  with filters by guideline, region,\nlanguage, etc. Entando clients have made good use of the following: \n \n a11y.css \n Access Assistant \n Continuum Explorer Pro \n Wave (web accessibility evaluation tool) \n \n"},{title:"Entando Component Repository",frontmatter:{},regularPath:"/next/docs/compose/ecr-overview.html",relativePath:"next/docs/compose/ecr-overview.md",key:"v-b2f788ac",path:"/next/docs/compose/ecr-overview.html",headers:[{level:2,title:"Introduction",slug:"introduction"},{level:2,title:"Glossary",slug:"glossary"},{level:3,title:"Component",slug:"component"},{level:3,title:"ECR Bundle",slug:"ecr-bundle"},{level:3,title:"EntandoDeBundle custom resource",slug:"entandodebundle-custom-resource"},{level:3,title:"Entando-component-manager",slug:"entando-component-manager"},{level:3,title:"Entando-K8S-service",slug:"entando-k8s-service"},{level:2,title:"Architecture",slug:"architecture"},{level:2,title:"Example flow",slug:"example-flow"}],lastUpdated:"1/25/2022, 4:09:16 PM",lastUpdatedTimestamp:1643144956e3,content:" Entando Component Repository \n Introduction \n The Entando Component Repository (ECR) is meant to be a repository to\nshare reusable components among different Entando instances. \n The following glossary relates to the ECR and related concepts: \n Glossary \n Component \n An Entando component - simply referred to as component - is a piece of\nreusable code/resource to be used in an Entando widget, page or\napplication. Examples of components are widgets, microfrontends,\ncontent-types, labels, plugins, and static resources \n ECR Bundle \n An ECR bundle - is a package containing one or more components and a\n'descriptor.yaml' file providing information about the bundle. The\nbundle is published on an Git registry and is shared with an Entando\napplication using the EntandoDeBundle custom resource. \n EntandoDeBundle custom resource \n The EntandoDeBundle custom resource is a Kubernetes custom resource\nreadable by the Entando6 operator. It’s used to provide information\nabout an ECR bundle and make the bundle available in kubernetes for the\nentando-component-manager. \n Entando-component-manager \n The entando-component-manager - a.k.a component-manager is part of the\nEntando6 app and dialogs both with the Kubernetes cluster via the\nentando-k8s-service and with the entando-core. The\nentando-component-manager reads the bundles from the cluster and exposes\nthem via an API accessible from AppBuilder. The component-manager is\nalso responsible of the installation/removal of components from\nentando-core \n Entando-K8S-service \n The Entando-K8S-Service is part of the Entando infrastructure and is\nresponsible for the low-level communication with the K8S cluster API. \n Architecture \n \n From an architectural point of view, the ECR is composed of \n \n The EntandoDeBundles which contain the metadata associated with a bundle \n The Entando-k8s-service which reads the bundles from the\ncluster/namspace(s) and serves them via a consumable API \n The Component-manager which creates the connection between the EntandoApp\nand the K8S-service. \n Example flow \n \n \n The user lands on the ECR page in app-builder and wants to see the\nlist of bundles shared with that EntandoApp \n \n \n AppBuilder asks the component-manager for the list of available\nbundles \n \n \n Component-manager queries the k8s-service to get the available\nbundles \n \n \n The k8s-service queries the cluster/namespace(s) it is able to read\nfrom for available bundles and returns the list to the\ncomponent-manager \n \n \n Component-manager returns a list to App-Builder \n \n \n The user is able to see the available bundles and is able to install\none or more of them \n \n \n"},{title:"Welcome Wizard",frontmatter:{},regularPath:"/next/docs/compose/welcome-wizard.html",relativePath:"next/docs/compose/welcome-wizard.md",key:"v-4ba5aba2",path:"/next/docs/compose/welcome-wizard.html",lastUpdated:"1/25/2022, 4:09:16 PM",lastUpdatedTimestamp:1643144956e3,content:" Welcome Wizard \n The Welcome Wizard is displayed when you first log in to the Application Builder. You can also start it later by going to the top navigation bar in the Application Builder, click on the information icon, and click  Begin Welcome Wizard . You can disable it from the wizard popup by selecting  Don't show next time  and then  Close , or by going to  My Profile → Preferences  and setting the  Welcome Wizard  preference to  Off . \n \n The Wizard will guide you through the key steps in designing and publishing a page in your application: \n \n Create a Page by setting its title, code, location, group, and template. \n Design the Page by placing a set of pre-configured widgets on the page. \n Preview the Page \n Publish the Page \n \n For more information see the following tutorials: \n \n Page Management \n Widgets and Fragments \n Content Creation \n Digital Assets \n \n"},{title:"Entando Identity Management -- Keycloak",frontmatter:{},regularPath:"/next/docs/consume/identity-management.html",relativePath:"next/docs/consume/identity-management.md",key:"v-c8b7e2a8",path:"/next/docs/consume/identity-management.html",headers:[{level:2,title:"Logging into your Keycloak Instance",slug:"logging-into-your-keycloak-instance"},{level:2,title:"Authentication",slug:"authentication"},{level:2,title:"Authorization",slug:"authorization"},{level:3,title:"Role Assignment for Plugins/Microservices",slug:"role-assignment-for-plugins-microservices"},{level:3,title:"Core",slug:"core"},{level:2,title:"Social Login",slug:"social-login"},{level:2,title:"One Time Passwords",slug:"one-time-passwords"},{level:2,title:"Themes, Look and Feel",slug:"themes-look-and-feel"}],lastUpdated:"4/18/2022, 5:00:21 PM",lastUpdatedTimestamp:1650315621e3,content:' Entando Identity Management -- Keycloak \n Entando Identity Management is based on open source Keycloak. Entando Applications rely on a Keycloak instance that is either  externally installed  or specific to an application. The architecture and requirements to customize your Keycloak instance are described below. \n Logging into your Keycloak Instance \n Keycloak is protected by a Secret deployed to your Entando Kubernetes instance. You can query Kubernetes for the Secret\'s default admin credentials, substituting your environment\'s namespace and Secret name: \n ent kubectl get secret default-sso-in-namespace-admin-secret -n entando -o go-template="{{println}}Username: {{.data.username | base64decode}}{{println}}Password: {{.data.password | base64decode}}{{println}}{{println}}"\n \n To find the Secret name, run \n kubectl get secrets -n YOUR-NAMESPACE\n \n and search for the Secret that ends in  namespace-admin-secret . \n Authentication \n All authentication is powered by Keycloak on Entando. This ensures that a micro frontend can call a microservice with a token available to the client. \n \n Entando implements Keycloak as a central point of authentication to provide a single, unified view of identity. This architecture increases portability. Keycloak acts as an abstraction layer to the underlying Identity Provider (IDP), allowing Entando to integrate into other IDPs without modifying the source. \n Authorization \n Role Assignment for Plugins/Microservices \n Keycloak authorizes microservices using clients and roles. Authorizations are stored in a JSON Web Token and available to services when invoked. \n Below are the steps to grant a user one or more roles for a specific client. This controls permissions when configuring the microservice. Note: when a microservice is installed in Entando, a corresponding client (and set of roles) is created per its plugin definition. \n \n Login to your Keycloak instance \n Select  Users  from the menu on the left \n Use the search box to find the appropriate user, e.g. "admin" \n Click on the user ID \n \n \n \n Click on the  Role Mappings  tab \n Use the  Client Roles  drop-down menu to specify the microservice client \n Select from the client\'s  Available Roles \n \n \n \n Use the  Add Selected  button to move the desired roles to  Assigned Roles . These will subsequently appear under  Effective Roles . \n Core \n When a user is authenticated to the  entando-core  via Keycloak, a copy of that user is added to the  entando-core  user management database to enable WCMS functionality. Within the App Builder, WCMS roles and groups can be assigned to a user for access to App Builder functions or  portal-ui  content in the runtime application. \n The code that copies the user into the  entando-core  can be customized per implementation to automatically create groups and roles. See the  entando-keycloak-plugin  for details of the code that copies users and data to the WCMS database. The README in that project includes properties that are available to your Entando Application. \n See  KeycloakAuthorizationManager.java  for an example of adding attributes programatically. In particular, refer to the  processNewUser  method. \n Social Login \n Keycloak allows Entando to provide social login as an out-of-the-box capability.  Keycloak Social Identity Providers  documents how to enable and configure social logins in your Entando Applications. \n One Time Passwords \n Keycloak enables One Time Passwords (OTP) login to Entando Applications. See  Keycloak OTP Policies  to configure and enable OTP in your application. \n Themes, Look and Feel \n Developers can customize the look and feel of the login page, as well as the identity management system that ships with Entando. The  Keycloak Theme Documentation  provides instructions for creating your own theme. Alternatively, you can modify the  Entando Theme . \n'},{title:"Accessing Entando APIs",frontmatter:{sidebarDepth:2},regularPath:"/next/docs/consume/entando-apis.html",relativePath:"next/docs/consume/entando-apis.md",key:"v-fc879dc8",path:"/next/docs/consume/entando-apis.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:3,title:"Enable or disable the Swagger UI in a running container",slug:"enable-or-disable-the-swagger-ui-in-a-running-container"},{level:2,title:"How to find your client secret",slug:"how-to-find-your-client-secret"},{level:2,title:"Setup in local environment",slug:"setup-in-local-environment"},{level:3,title:"Configure Keycloak",slug:"configure-keycloak"},{level:3,title:"Start the Entando Application",slug:"start-the-entando-application"},{level:2,title:"APIs Overview",slug:"apis-overview"},{level:3,title:"API structure",slug:"api-structure"},{level:3,title:"Models",slug:"models"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"1/25/2022, 4:09:16 PM",lastUpdatedTimestamp:1643144956e3,content:" Accessing Entando APIs \n Overview \n Entando includes the Swagger UI in a quickstart environment and is reachable at  /entando-de-app/api/swagger-ui.html : \n http://[your-host-name]/entando-de-app/api/swagger-ui.html\n Enable or disable the Swagger UI in a running container \n The Swagger UI can be enabled or disabled in a running container by modifying the SPRING_PROFILES_ACTIVE environment variable for the entando-de-app container. \n \n Edit the deployment. The name may be different outside of a quickstart environment. \n \n sudo kubectl -n entando edit deployment/quickstart-server-deployment\n \n \n \n (Optional) Scale the deployment  spec.replicas  to 0 before updating the deployment. This is necessary if you're using an in-memory database, e.g. the default quickstart configuration, and will prevent database errors that can happen on an immediate restart after the profile is changed. Save the deployment to apply the change. \n \n \n Find the entando-de-app env variables section under  spec.template.spec.containers.env[image: entando-de-app] \n \n \n 4a. To enable the swagger UI, add the SPRING_PROFILES_ACTIVE environment variable, if it's missing, or add  swagger  to its comma-delimited list. \n         - name: SPRING_PROFILES_ACTIVE\n          value: default,swagger\n \n 4b. To disable the swagger UI, remove  swagger  from the value. \n \n \n (Optional) Reset the deployment  spec.replicas  back to 1. \n \n \n Save the deployment to apply the change. \n How to find your client secret \n You'll need your client credentials to execute the Entando APIs. \n \n \n Login into your Keycloak instance \n \n \n Go to  Administration → Clients \n \n \n Select the desired client (e.g. in a quickstart environment this is  quickstart-server ) \n \n \n Click on the  Credentials  tab to get the secret \n Setup in local environment \n You may prefer to run a local standalone Entando application for some tasks. You'll need Java 11, maven, and Keycloak for authentication. See  these instructions  to setup a standalone Keycloak. \n Configure Keycloak \n Configure your Keycloak client in order to support Swagger UI. A quickstart environment has this pre-configured. \n \n \n Login to your Keycloak instance \n \n \n Access the Administration console \n \n \n Click on  Clients  on the left bar and select your client (e.g.  quickstart-server ) \n \n \n Update the following values under  Settings : \n \n Set  Valid Redirect URIs  to  http://localhost:[your port]/entando-de-app/*  or  *  to allow all redirect URIs. \n Set  Web Origins  to  http://localhost:[your port]  or  *  to accept all origins. \n Start the Entando Application \n \n \n Clone the Entando reference application: \n git clone https://github.com/entando/entando-de-app\n \n \n \n Start the application with the following options: \n \n Enable the Swagger profile via  -Dspring.profiles.active=swagger \n Enable the Keycloak profile via  -Pkeycloak \n Configure the application connection to Keycloak itself. For simplicity this uses the same client credentials you'll use to try out the APIs.\n \n Set  -Dkeycloak.auth.url  to your Keycloak endpoint (including  /auth ), e.g.  -Dkeycloak.auth.url=http://my-keycloak-server/auth \n Set  -Dkeycloak.client.id  to your client id, e.g.  -Dkeycloak.client.id=quickstart-server \n Set  -Dkeycloak.client.secret  to your client secret, e.g.  -Dkeycloak.client.secret=my-secret . See  How to find your client secret  above. \n \n \n (Optional) Set -Djetty.port=8085  if the default port 8080 is already in use. \n (Optional) To skip the docker steps (or if you don't have docker installed/running), add  -DskipDocker=true \n \n Here's a full example: \n mvn clean package jetty:run-war -Pjetty-local -Pderby -Pkeycloak -Dspring.profiles.active=swagger -Djetty.port=8085 -Dorg.slf4j.simpleLogger.log.org.eclipse.jetty.annotations.AnnotationParser=error -Dkeycloak.auth.url=http://my-keycloak-host/auth -Dkeycloak.client.id=quickstart-server -Dkeycloak.client.secret=my-client-secret -DskipDocker=true\n \n \n \n Wait for the application to start. \n [INFO] Started ServerConnector@1355c8be{HTTP/1.1, (http/1.1)}{0.0.0.0:8085}\n[INFO] Started @66257ms\n[INFO] Started Jetty Server\n \n \n \n Navigate to the Swagger UI in a browser at  /entando-de-app/api/swagger-ui.html \n  http://localhost:[your port]/entando-de-app/api/swagger-ui.html\n APIs Overview \n The Entando core exposes REST APIs for every action that can be taken in\nthe App Builder environment. For example, you can use\nthese APIs to create pages, create page templates or to add widgets to\npages. The APIs can be used to support automation, testing, or\nintegrations with external systems. \n API structure \n All of the APIs share a common top level structure. Each response will\ncontain a top level entry for  errors ,  metadata , and  payload . \n The  errors  will always contain code and a message string indicating an\nerror condition in the request. The  metadata  section is used for\npaging, sorting, filtering and data that is distinct from the body. The\nbody of each response is included in the  payload  section of the\nresponse and varies according to each API. \n Models \n All of the model classes returned by the Entando core are annotated so that the model definition is included in the Swagger documentation. At the bottom of the Swagger page all of the model classes returned by the API endpoints can be found. \n Tutorial \n \n \n Access your application Swagger UI as discussed above \n \n \n Click on the  Authorize  button in the upper right corner \n \n \n Enter the client id and client secret in the open window and click  Authorize \n \n \n If you are redirected to the Entando login page, log in with your credentials (default are  admin / adminadmin ) \n \n \n You will be redirected to the Swagger UI page, now authenticated \n \n \n Use the  Try it out  button on the APIs \n \n \n Scroll to  widget-controller \n \n \n Select the blue GET row \n \n \n Select  Try it out \n \n \n Look at the results in the window. You should see a Server response with Code 200 and full response body. \n \n \n \n \n"},{title:"Entando Custom Resources for Kubernetes",frontmatter:{sidebarDepth:2},regularPath:"/next/docs/consume/custom-resources.html",relativePath:"next/docs/consume/custom-resources.md",key:"v-c542c3e0",path:"/next/docs/consume/custom-resources.html",headers:[{level:2,title:"Objective",slug:"objective"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"The Core Entando Custom Resources",slug:"the-core-entando-custom-resources"},{level:2,title:"The ResourceRequirements specification",slug:"the-resourcerequirements-specification"},{level:2,title:"EntandoKeycloakServer",slug:"entandokeycloakserver"},{level:3,title:"Overview",slug:"overview-2"},{level:3,title:"Example",slug:"example"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties"},{level:2,title:"EntandoApp",slug:"entandoapp"},{level:3,title:"Overview",slug:"overview-3"},{level:3,title:"Example",slug:"example-2"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-2"},{level:2,title:"EntandoPlugin",slug:"entandoplugin"},{level:3,title:"Overview",slug:"overview-4"},{level:3,title:"Example",slug:"example-3"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-3"},{level:2,title:"EntandoAppPluginLink",slug:"entandoapppluginlink"},{level:3,title:"Overview",slug:"overview-5"},{level:3,title:"Example",slug:"example-4"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-4"},{level:2,title:"EntandoDatabaseService",slug:"entandodatabaseservice"},{level:3,title:"Example",slug:"example-5"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-5"}],lastUpdated:"4/19/2022, 11:43:59 AM",lastUpdatedTimestamp:1650383039e3,content:' Entando Custom Resources for Kubernetes \n Objective \n This is an overview of Entando Kubernetes Custom Resources and their usage on the Entando Platform. \n Prerequisites \n \n Basic knowledge of Kubernetes and how to deploy Docker images \n Overview \n Amongst its many features, Kubernetes comes with a REST API for dozens of different resource types.\nGenerally these APIs offer full Create/Retrieve/Update/Delete (CRUD) access to each of the resource types. We\ntypically format these resources in YAML or JSON and use commandline tools such as\n kubectl  or  oc  to manage them. Each of these resources has a clearly defined structure \n that is well documented in the  Kubernetes API . \n Kubernetes  also allows clients to subscribe to events generated as these resources get updated. These subscriptions\nare called \'watches\' and allow clients to be notified whenever the state of a resource changes. It also\nenforces a strong role based access control (RBAC) on all resources, with granular permissions at the level of operation (Create/Retrieve/Update/Delete/Watch) per resource. \n The basic architecture for Kubernetes worked so well for its developers that it was made available to third  party developers. Kubernetes now offers a mechanism for third parties to provide their own custom\nresource types that still leverqage CRUD support, event subscriptions and RBAC out of the box.\nThis mechanism is referred to as Custom Resources. \n Custom Resources are most commonly used with Kubernetes Operators. Operators are Docker images that have been\ndeployed to Kubernetes Deployments. Generally, they observe a set of custom resources and perform some operations against\nthe Kubernetes API to reflect the state changes in the Custom Resource. We can say that Custom Resources are associated\nwith specific semantics in how they are translated in the cluster. \n A new Custom Resource can be introduced into Kubernetes by registering a Custom Resource Definition (CRD). This is\njust another yaml or json resource that defines the structure of the custom resource to be installed using the OpenAPI\nJSON Schema format. When talking about Custom Resources, it is very important to distinguish between Custom Resource\nDefinitions and Custom Resources. CRD\'s are static type definitions provided by an Operator\nprovider such as Entando. For those familiar with programming languages, CRD\'s are like class definitions, whereas\nCustom Resources are actual instances of that class. \n Entando introduces two groups of Custom Resources. \n \n Core Custom Resources required\nfor a basic installation of Entando in a Kubernetes cluster. These directly result in other\nKubernetes resources being deployed in the cluster. \n Custom Resources specific\nto the Entando Component Repository that serve primarily as metadata for other Entando components. \n The Core Entando Custom Resources \n The Entando Operator observes all the Core Entando Custom Resources in one or more namespaces. If a Core\nEntando Custom Resource is created, updated or deleted, the Entando Operator will trigger a new run-to-completion Pod\nthat will translate that state change into a state change in the actual Kubernetes Cluster. Often, this will\nresult in the Deployment of one or more Docker images, along with one or more Services, and sometimes an Ingress. We refer to the Docker Images that implement these run-to-completion Pods as Entando Kubernetes Controllers. \n The Entando Operator itself is also implemented as a Docker image. See the\n entando-k8s-controller-coordinator repo  for details. \n More detailed instructions on how to install Entando are available in our\n Getting Started tutorial . Learn more about  Configuring the Operator here . \n The ResourceRequirements specification \n All of the Entando Custom Resources that result in physical Kubernetes Deployments can be configured with specific\nresource requirements. These settings can be provided under the  spec  object of the custom resource. It currently\nsupports the following attributes: \n \n spec.resourceRequirements.storageRequest  - the initial storage requested from the persistence provider. Please keep\nin mind that resizable storage is not supported by all storage providers, and this may be the final size of the storage\nallocated. \n spec.resourceRequirements.storageLimit  - the maximum amount of storage required by the deployment. \n spec.resourceRequirements.memoryRequest  - the initial memory requested from the node the deployment\'s primary container is running on. \n spec.resourceRequirements.memoryLimit  - the maximum amount of memory the deployment\'s primary container will use. If\nit exceeds this amount, the container may be terminated by Kubernetes. \n spec.resourceRequirements.cpuRequest  - the initial CPU allocation from the node the deployment\'s primary container is running on. \n spec.resourceRequirements.cpuLimit  - the maximum CPU allocation for the deployment\'s primary container. \n spec.resourceRequirements.fileUploadLimit   - the maximum upload file size supported by the deployment. \n \n All of these attributes require a number and a unit of measurement, e.g. "64Mi". Please consult the\n official Kubernetes documentation \nfor more information on how to configure these attributes. \n EntandoKeycloakServer \n The EntandoKeycloakServer Custom Resource is used to deploy and configure a Red Hat Keycloak Server instance on the\ncluster. After deploying this Keycloak instance, the Entando Operator will create a Kubernetes Secret that provides\nthe necessary information for subsequent deployment operations to access the Keycloak instance as the Admin user. This\nallows the rest of the Entando Kubernetes Controllers to create a Keycloak OpenID Connect (OIDC) client for every HTTP service that\ngets deployed. If you already have a Keycloak instance that you want to use, you can skip this custom resource entirely and create the  keycloak-admin-secret  in the operator\'s namespace as specified in the\n external Keycloak tutorial . \n Overview \n \n Entando Cluster Citizen:  Keycloak \n Custom Resource Definition:  EntandoKeycloakServer \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-keycloak-controller \n Github Repo:  entando-k8s/entando-k8s-keycloak-controller \n \n \n Deployment Details:\n \n Docker image:  entando/entando-keycloak \n Github Repo:  entando/entando-keycloak \n \n \n Possible Database Images:\n \n MySQL:  docker.io/centos/mysql-57-centos7 \n PostgreSQL:  docker.io/centos/postgresql-96-centos7 \n Example \n ---\nkind: "EntandoKeycloakServer"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-keycloak"\n  namespace: "keycloak-namespace"\nspec:\n  dbms: "postgresql"\n  imageName: "entando/entando-keycloak"\n  ingressHostName: "test-keycloak.ampie.dynu.net"\n  isDefault: true\n  environmentVariables: \n    - name: KEYCLOAK_WELCOME_THEME\n      value: your-custom-theme\n  tlsSecretName: your-tls-secret\n  replicas: 1\n Explanation of properties \n \n \n spec.dbms  is used to select the database management of choice. The Entando Operator will use this value to deploy a dedicated Database instance in this namespace\nfor Keycloak to use. If this value matches the  spec.dbms  property\nof a previously  configured  EntandoDatabaseService ,\nthe Keycloak image will be configured to use this service.\nIf left empty or given a value of \'none\', Keycloak will deploy using its own internal\nH2 database. \n \n \n spec.imageName  is used to provide a customized image. By default, the operator will use the  entando/entando-keycloak \ndiscussed above. When using the default image, please refer to the\n Docker image section \nin the README of the Entando Operator to determine how the Docker registry and version for the image is calculated.\nWhen you need to customize the theme or add extensions to Keycloak, you can create your own custom image and provide\nthe value in this property. Make sure you use the default image ( entando/entando-keycloak )\nas a base image. You can then add your customizations and build your own. Please use a fully qualified\nDocker image name here. \n \n \n spec.ingressHostName  is the hostname of the Kubernetes Ingress to be created for Keycloak. Please ensure that this is\naccessible using the default routing suffix of your Entando Operator Deployment or a DNS name previously\nregistered with your DNS provider. \n \n \n spec.isDefault  is \'true\' by default and this should suffice for most conditions. This will result in the standard\n keycloak-admin-secret  being replaced by a Secret connecting you to this newly created Keycloak instance.\nTheoretically one could use multiple Keycloak instances in a cluster, in which case this property should be false. \n \n \n spec.environmentVariables  is a Map of environment variables to pass to the Keycloak Docker image. For example, this could\nbe used to select a specific theme for Keycloak with the variable KEYCLOAK_WELCOME_THEME. These parameters\nare applied to the container\'s environment variables after all variables have been calculated. It can therefore\nalso be used as a mechanism to override any of the default environment variables that need customization. \n \n \n spec.tlsSecretName  is the name of a standard Kubernetes\n TLS Secret  that will be used for the\nresulting Ingress. This is only required if the\n globally configured TLS Secret \nfor the Operator is absent or has not been created with a wildcard hostname that supports this Keycloak instance\'s hostname. \n \n \n spec.replicas  - the number of replicas to be made available on the Deployment of this Keycloak Server. \n \n \n spec.resourceRequirements  - the minimum and maximum  resource allocations  for the Keycloak server container. \n EntandoApp \n An EntandoApp is a Deployment of a Docker image that hosts an Entando and Java based web application. Entando offers two\nstandard images that can be used, but generally we expect our customers to provide their images here. An EntandoApp\ndeployment packages three images into a single Pod: the EntandoApp image discussed here, AppBuilder, and Component Manager. \n Overview \n \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-app-controller \n Github Repo:  entando/entando-k8s-app-controller \n \n \n Deployment Details - Entando App:\n \n Docker image:  entando/entando-de-app-wildfly   or    entando/entando-de-app-eap \n Github Repo:  entando-k8s/entando-de-app \n Entando Cluster Citizen:  Entando App \n \n \n Deployment Details - AppBuilder:\n \n Docker image:  entando/app-builder \n Github Repo:  entando/app-builder \n \n \n Deployment Details - ComponentManager:\n \n Docker image:  entando/entando-component-manager \n Github Repo:  entando-k8s/entando-component-manager \n Entando Cluster Citizen:  Component Manager \n \n \n Possible Database Images:\n \n MySQL:  docker.io/centos/mysql-57-centos7 \n PostgreSQL:  docker.io/centos/postgresql-96-centos7 \n Example \n ---\nkind: "EntandoApp"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-app"\n  namespace: "your-namespace"\nspec:\n  standardServerImage: wildfly\n  customServerImage: your-org/your-image:4.3.2\n  dbms: "postgresql"\n  ingressPath: your-app\n  ingressHostName: "test-app.your-routing-suffix.com"\n  environmentVariables: \n    - name: ENTANDO_VAR1\n      value: your-var1\n  tlsSecretName: your-tls-secret\n  replicas: 1\n  ecrGitSshSecretName: your-secret\n  storageClass: standard\n Explanation of properties \n \n \n spec.standardServerImage  can be either wildfly  or  eap . This instructs the Entando Operator to use one of the\ntwo standard Entando App images. \n \n wildfly  will deploy the  entando/entando-de-app-wildfly  image \n eap  will deploy the  entando/entando-de-app-eap  image \n \n This property and the  spec.customServerImage  are  assumed to be mutually exclusive. Only provide a value to\none of the two. Please refer to the\n Docker image section \nin the README of the Entando Operator to determine how the Docker registry and version of these images are calculated. \n \n \n spec.customServerImage  can be used to deploy the Docker image containing your own custom Entando App. Please\nfollow the instructions on how to  build your own image . \nThis property and the  spec.standardServerImage  are  assumed to be mutually exclusive. Only provide a\nvalue to one of the two. \n \n \n spec.dbms  is used to select the database management of choice. If left empty, a default value of  postgresql \nis assumed. The value  none  is not supported. The Entando Operator will use this value to deploy a dedicated Database instance in this namespace\nfor the EntandoApp to use. If this value matches the  spec.dbms  property\nof a previously configured  EntandoDatabaseService ,\nthe Entando App will be configured to use this service. \n \n \n spec.ingressPath  specifies the web context of the Entando App to be deployed. This is required to create a single\npath entry in the Ingress that is used to expose the Entando App. The default behaviour of Wildfly and\nJBoss EAP is to use the name of the WAR file that is deployed, but it is possible to override this in the EntandoApp\nproject using a  jboss-web.xml  file .\nIn the absence of this file, the web context would be the\nMaven artifactId of the Entando App project. It is also possible to modify this by changing the  <finalName>  element\nin the Maven  pom.xml . \n \n \n spec.ingressHostName  is the hostname of the Kubernetes Ingress to be created for the Entando App. Please\nensure that this is accessible using the default routing suffix of your Entando Operator Deployment or a DNS\nname previously registered with your DNS provider. Keep in mind that EntandoPlugins linked to this app will\nalso be made available on this host. \n \n \n spec.environmentVariables  is a Map of environment variables to pass to the EntandoApp Docker image. For example, this could\nbe used to provide connection details for custom datasources or message queues as discussed in the\n custom datasources tutorial . Also note that all of the\n Spring variables in an Entando project \ncan also be overridden here by specifying the equivalent SNAKE_CASE names of the dot-delimited Spring properties.\nThese parameters are applied to the container\'s environment variables after all variables have been calculated.\nIt can therefore also be used as a mechanism to override any of the default environment variables that need customization.\nKeep in mind that these parameters will be passed to each of the three containers in this Pod as environment\nvariables, and that care needs to be taken to avoid conflicting variable names. \n \n \n spec.tlsSecretName  is the name of a standard Kubernetes\n TLS Secret  that will be used for the\nresulting Ingress. This is only required if the\n globally configured TLS Secret \nfor the Operator is absent or has not been created with a wildcard hostname that supports this Keycloak instance\'s hostname. \n \n \n spec.replicas  - the number of replicas to be made available on the Deployment of this Entando App. \n \n \n spec.resourceRequirements  - the minimum and maximum  resource allocation  for the Entando App Engine container. \n \n \n spec.ecrGitSshSecretName  - a secret containing a private key file named  rsa_id  that matches a public key configured in the Git server. \n \n \n spec.storageClass  - the name of the StorageClass to use for PersistentVolumeClaims created for this EntandoApp. For more information, go to  Kubernetes explanation on Storage Classes . \n EntandoPlugin \n An Entando Plugin is a microservice that can be made available to one or more EntandoApps in the cluster. Please follow\nour instructions on using our blueprint to  build your own EntandoPlugin . The\nDeployment resulting from an EntandoPlugin is a single-container Pod deployment and will include the\nplugin Docker image specified. \n Overview \n \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-plugin-controller \n Github Repo:  entando/entando-k8s-plugin-controller \n \n \n Deployment Details - plugin:\n \n Docker image: as provided by user \n Entando Cluster Citizen:  Plugin \n \n \n Possible Database Images:\n \n MySQL:  docker.io/centos/mysql-57-centos7 \n PostgreSQL:  docker.io/centos/postgresql-96-centos7 \n Example \n ---\nkind: "EntandoPlugin"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-plugin"\n  namespace: "your-namespace"\nspec:\n  image: your-org/your-image:4.3.2\n  securityLevel: lenient\n  ingressPath: /your-plugin\n  healthCheckPath: /actuator/health\n  dbms: "postgresql"\n  ingressHostName: "test-app.your-routing-suffix.com"\n  roles:\n    - code: admin\n      name: Administrators\n    - code: user\n      name: Users\n  permissions: \n    - clientId: some-keycloak-client \n      role: some-admin\n    - clientId: another-keycloak-client \n      role: another-admin\n  environmentVariables: \n    - name: ENTANDO_VAR1\n      value: your-var1\n  tlsSecretName: your-tls-secret\n  replicas: 1\n Explanation of properties \n \n spec.image  is the Docker image you can provide for the plugin you want to deploy. Please follow\nour instructions on using our blueprint to  build your own EntandoPlugin .\nIf you start with the Entando Blueprint, the resulting Spring Boot application will make use of the environment variables set by the Entando Operator. \n spec.dbms  is used to select the database management of choice. The Entando Operator will use this value to deploy a dedicated Database instance in this namespace\nfor the Entando Plugin to use. If left empty or if the value is  none , it\nis assumed that the plugin in question does not require a database. If this value matches\nthe  spec.dbms  property  of a previously  configured\n EntandoDatabaseService ,\nthe Entando Plugin will be configured to use this service. \n spec.ingressPath  specifies the web context where the Entando Plugin will be made available when linked to EntandoApps.\nPlease ensure this is in sync with the  server.servlet.context-path  property set in your Spring Boot application. \n spec.ingressHostName  is the hostname of the Kubernetes Ingress to be created for the Entando Plugin. Please\nensure that this is accessible using the default routing suffix of your Entando Operator Deployment or a DNS\nname previously registered with your DNS provider. This hostname will not be used from your Widgets that you\nimplemented for this plugin, as these widgets will use the hostname of the EntandoApp they are used from.\nThis hostname is useful for embedded web user interfaces in this plugin, such as admin user interfaces\nor diagnostic user interface. \n spec.roles  specifies the set of roles that this plugin expects. At deployment time, the Entando Operator ensures\nthat each of these roles are created on Keycloak for the Keycloak client representing this EntandoPlugin. It is\nup to the Plugin provider to ensure that Spring Security has been set up to enforce the access rules implied\nby the individual roles. Each role has a unique  code  and a more human readable   name  as a property. \n spec.permissions  specifies the set of permissions this plugin requires on other services with known Keycloak Clients.\nAt deployment time, the Entando Operator will use the service account user of this EntandoPlugin\'s Keycloak Client\nand create the necessary role bindings on the specified client id of the service to be used.\nEach permission specifies the  clientId  in Keycloak of the target service, and the  role  that this EntandoPlugin\nshould be bound to in that Keycloak client. \n spec.environmentVariables  is a Map of environment variables to pass to the EntandoPlugin Docker image.\nIt is entirely up to the plugin provider to determine the semantics of each variable. We strongly suggest for the\nplugin provider to use the standard Spring Property Resolver syntax for Spring variables, as this would allow\nany of these variables to be overridden here by specifying the equivalent SNAKE_CASE names of the dot-delimited\nSpring properties.\nThese parameters are applied to the container\'s environment variables after all variables have been calculated.\nIt can therefore also be used as a mechanism to override any of the default environment variables that need customization.\nKeep in mind that these parameters will be passed to both containers in this Pod as environment\nvariables, and that care needs to be taken to avoid conflicting variable names. \n spec.tlsSecretName  is the name of a standard Kubernetes\n TLS Secret  that will be used for the\nresulting Ingress. This is only required if the\n globally configured TLS Secret \nfor the Operator is absent or has not been created with a wildcard hostname that supports this Keycloak instance\'s hostname. \n spec.replicas  - the number of replicas to be made available on the Deployment of this Entando Plugin. \n spec.resourceRequirements  - the minimum and maximum  resource allocation  for the Entando Plugin container. \n EntandoAppPluginLink \n The EntandoAppPluginLink custom resource is created when an AppBuilder user links an EntandoPlugin to the current\nEntandoApp or deploys an EntandoPlugin for use in the current EntandoApp. The Entando Operator processes the resulting\nEntandoAppPluginLink and creates a path for the Plugin on the Ingress that exposes the EntandoApp in question. This path\nis determined by the  spec.ingressPath  property on the EntandoPlugin custom resource itself. If the EntandoPlugin\nresides in a namespace other than the namespace of the EntandoApp, the EntandoOperator creates a Kubernetes\nService in the namespace of the EntandoApp that simply delegates to the Service in the namespace of the EntandoPlugin. \n Overview \n \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-app-plugin-link-controller \n Github Repo:  entando/entando-k8s-app-plugin-link-controller \n Example \n ---\nkind: "EntandoAppPluginLink"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-link"\n  namespace: "your-namespace"\nspec:\n  entandoAppName: your-app\n  entandoAppNamespace: your-namespace\n  entandoPluginName: your-app\n  entandoPluginNamespace: your-namespace\n Explanation of properties \n \n spec.entandoAppName  specifies the name of the EntandoApp that requires the plugin, found in  EntandoApp.metadata.name \n spec.entandoAppNamespace  specifies the namespace of the EntandoApp that requires the plugin, found in  EntandoApp.metadata.namespace \n spec.entandoPluginName  specifies the name of the EntandoApp that requires the plugin, found in  EntandoPlugin.metadata.name \n spec.entandoPluginNamespace  specifies the namespace of the EntandoApp that requires the plugin, found in  EntandoPlugin.metadata.namespace \n EntandoDatabaseService \n By default, the Entando Operator deploys one of either the MySQL or PostgreSQL database Docker images for every custom\nresource that requires a database. Many customers may, however, have existing infrastructure for their databases which\nthey may want to leverage. The EntandoDatabaseService custom resource allows customers to deploy a Service that points\nto an external database. When deploying one of the Entando Custom Resources that require a database, the Entando\nOperator will look for EntandoDatabases in the same namespace. If it finds one with the same  spec.dbms  setting\nas the database required by the custom resource, it will create a dedicated schema/username/password combination\nfor the custom resource and point the deployment emanating from Custom Resources to this external database. \n Example \n ---\nkind: "EntandoDatabaseService"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-database-service"\n  namespace: "your-namespace"\nspec:\n  dbms: "oracle"\n  host: 10.0.12.41\n  port: 1521\n  databaseName: yourdb \n  tablespace: \n  secretName: some-secret\n  jdbcParameters:\n    maxStatements: 300 \n    loginTimeout: 180\n Explanation of properties \n \n spec.dbms  is used to select the database management of choice if this value matches the  spec.dbms  property\nof the Entando custom resource that will use it. Valid values are  oracle ,  postgresql  and  mysql . \n spec.host  can either be a valid IPv4 address or a hostname. Where an IP address is provided, the Entando Operator\nwill create a Kubernetes Service with an associated EndPoints resource to allow for routing to this address. Where\na hostname is provided, the Entando Operator will simply create a Kubernetes Service of type  cname . \n spec.port  is the port that the external database service is running on. This value is optional in which case we will\nuse the default port for the DBMS vendor in question. \n spec.databaseName  is the name of the database that the Entando Operator should be creating schemas in. This property\nis only for use with PostgreSQL and Oracle, as MySQL doesn\'t distinguish between schemas and databases. \n spec.tablespace  is only required for Oracle so that Schemas can be created in different tablespaces. \n spec.secretName  should be the name ( Secret.metadata.name ) of a Kubernetes Secret in the same namespace that has\na  username  key and a  password  key to provide the Entando Operator with the necessary access and permissions\nto create Schemas and users on the database in question. \n spec.jdbcParameters  is a map of name/value pairs that will be appended to the JDBC connection string to allow for\nfurther customization of the actual connection to the database. \n \n'},{title:"Entando Blueprint Features",frontmatter:{},regularPath:"/next/docs/create/blueprint-features.html",relativePath:"next/docs/create/blueprint-features.md",key:"v-b18ee374",path:"/next/docs/create/blueprint-features.html",headers:[{level:2,title:"The Features:",slug:"the-features"},{level:2,title:"Premade Widgets",slug:"premade-widgets"},{level:3,title:"Authentication",slug:"authentication"},{level:3,title:"Custom events",slug:"custom-events"},{level:3,title:"Tests and mocks",slug:"tests-and-mocks"},{level:3,title:"PropTypes",slug:"proptypes"},{level:3,title:"Fetching data",slug:"fetching-data"},{level:2,title:"Form widget",slug:"form-widget"}],lastUpdated:"1/25/2022, 4:09:16 PM",lastUpdatedTimestamp:1643144956e3,content:" Entando Blueprint Features \n The Entando Blueprint makes it easier and faster to customize your application by generating controllers, repositories, services, and micro frontends for your entity. It means generating those project files in minutes, simply by answering questions that define the parameters of your application. \n The Entando Blueprint uses JHipster technology based on Embedded JavaScript (EJS), a templating language that provides powerful constructs for large scale file generation. \n The Features: \n \n Backend with Spring Boot\n \n Data modeling \n JHipster Design Language (JDL) support \n Keycloak integration \n Liquibase integration for schema upgrade \n Preconfigured Cross-Origin Resource Sharing (CORS) settings \n Profiles (dev, prod) \n Swagger/OpenAPI frontend \n \n \n Frontend with React\n \n .env profiles \n Localization \n Keycloak integration \n \n \n \n For more information: \n \n Install  JHipster Entando Blueprint \n Try implementing an Entando Blueprint--  Create microservices and micro frontents \n Premade Widgets \n When you create an entity using the Entando Blueprint, it generates a few\npremade widgets. Each will be reviewed below. \n \n Authentication \n Custom events \n Tests and mocks \n PropTypes \n Fetching data \n Form widget \n \n We will be using  Conference  as an entity name for the example below. \n What the widgets have in  common : \n \n \n Each widget contains a README file that helps with the setup. \n \n \n All generated widgets are web components created using Custom Elements\nAPI. \n \n \n Each widget is displayed using the custom element tag. For example, inside the\ndetails widget folder  conference/detailsWidget/public/index.html , you\ncan find\n conference-details id=\"1\" override-edit-handler hide-edit-button /> .\nThe element  <conference-details />  is defined in the component entry\npoint at\n conference/detailsWidget/src/custom-elements/ConferenceDetailsElement.js . \n \n \n \n Note \n Custom element names require a hyphen like  conference-details  (kebab-case)--they cannot be single words. \n \n For more information about web components, custom elements and micro\nfrontends, refer to  Create a React micro frontend widget . \n Authentication \n If a widget requires authentication, the component is wrapped in\n KeycloakContext.Provider  and the Keycloak object is fetched from the\n window.entando.keycloak  variable. Entando uses Keycloak as the\nauthentication provider, but you can add any provider as needed. \n ReactDOM.render(\n  <KeycloakContext.Provider value={this.keycloak}>\n    <StylesProvider jss={this.jss}>\n      <ThemeProvider theme={this.muiTheme}>{FormContainer}</ThemeProvider>\n    </StylesProvider>\n  </KeycloakContext.Provider>,\n  this.mountPoint\n);\n \n For more information about the authentication process, please refer\nto the  Authentication section . \n Custom events \n All widgets rely on custom events for communication.  That is why each widget contains custom event creation and removal, along with the event listener creation.  Note that when an event listener is created, it should be when\nthe element is no longer needed. It should be created in the custom\nelement’s  disconnectedCallback()  function. \n To add more event listeners, add the event types to\n INPUT_EVENT_TYPES  object at\n detailsWidget/src/custom-elements/widgetEventTypes.js , which adds\nit to the listener list. To remove the event, simply remove the element from the list. \n For more information about custom events and widget communication,\nplease refer to the section on  Widget communication . \n Tests and mocks \n Each widget has tests written for it. Entando uses\n react-testing-library , but developers are free to upgrade and use any\ntool desired. Tests and mocks are at  detailsWidget/src/components/ . \n PropTypes \n PropTypes for data used across several components are shared. You can\nsee and modify them at  detailsWidget/src/components/ . This way you can\navoid repeating the same propTypes in each component by importing them. \n import React from 'react';\nimport conferenceType from 'components/__types__/conference';\n\nconst ConferenceDetails = props => {\n  // ...\n};\n\nConferenceDetails.propTypes = {\n  conference: conferenceType,\n  t: PropTypes.func.isRequired,\n};\n\nexport default ConferenceDetails;\n Fetching data \n For data fetching from widgets, use Fetch API. You can find the functions for\nfetching data at  detailsWidget/src/api , in different files for\ndifferent contexts. \n Form widget \n For displaying forms within a widget, use\n Formik  which helps with form state\nmanagement. For data validation, use\n Yup . \n"},{title:"The Entando Operator",frontmatter:{},regularPath:"/next/docs/consume/operator-intro.html",relativePath:"next/docs/consume/operator-intro.md",key:"v-6bdf789c",path:"/next/docs/consume/operator-intro.html",headers:[{level:2,title:"TLS Secret Creation",slug:"tls-secret-creation"},{level:2,title:"Database Deployment",slug:"database-deployment"},{level:2,title:"Ingress Path Generation",slug:"ingress-path-generation"}],lastUpdated:"4/14/2022, 4:02:21 PM",lastUpdatedTimestamp:1649966541e3,content:" The Entando Operator \n The Entando Operator processes the custom resources in Kubernetes that represent the different  components of an Entando application .\nThe goal of the operator is to provide automation and a set of default configuration options to simplify and accelerate the deployment of an Entando application. \n The sections below provide details and assumptions that the operator makes when deploying Entando Custom Resources. If you're using OpenShift, these sections will provide details on how to configure your deployment via the Operator Hub. \n For details on the individual custom resources and their configuration, check out the  custom resources documentation .  See the instructions here on deploying via the Entando Operator . \n TLS Secret Creation \n When configuring and deploying Entando via the operator, you will be asked to provide a secret for some of the components in the architecture. A few things to be aware of when creating and configuring a Secret: \n \n The Secret is assumed to be in the same namespace as the component being created. \n This Secret is expected to have a private key, and a certificate for the hostname (or a wildcard certificate) that the service will be exposed on. \n Refer to the 'ingressHostname' property in the custom resource for more information on how the hostname is determined. \n If a Secret isn't provided, the Entando Operator will evaluate the value of the  ENTANDO_PATH_TO_TLS_KEYPAIR , which is expected to contain two files: tls.key and tls.crt.\n \n If a key pair is found in the folder specified, the operator will use that key pair. \n If a key pair is not found, the Entando Operator will evaluate the value of the  ENTANDO_USE_AUTO_CERT_GENERATION . If that property is set to  true , the Entando Operator will assume that the cluster has been configured with a valid Certificate Authority (CA) and leave it to the Ingress controller to generate its own certificates. \n \n \n \n Click here for instructions on setting up TLS in your Entando Apps . \n Database Deployment \n Some Entando components include the option to select a database management system (DBMS): \n \n \n The value of the DBMS field in Entando Custom Resources can be mysql, oracle, postgresql or embedded. \n \n IMPORTANT!  -- If embedded is selected for a component, only one replica for the component can be created. \n IMPORTANT!  -- Oracle instances are not supported for automatic deployment in a container. You must create your own Oracle instance or reuse an existing instance and then configure the  external database  for your EntandoApp. \n \n \n \n If an EntandoDatabaseService has been deployed in the component's namespace and the DBMS specified for this EntandoDatabaseService is the same as the DBMS specified for this EntandoApp, then the Entando Operator will create dedicated\nschemas (in the case of PostgreSQL or Oracle), or databases in the case of MySQL. \n \n If a matching EntandoDatabaseService does not exist in this namespace, the Entando Operator\nwill automatically deploy the appropriate container to host the DBMS specified. This last option is not yet supported for Oracle. \n \n \n \n For an EntandoApp, three schemas/databases will be created: the Entando Port DB, tne Entando Serv DB and a database for the Entando Component Manager. \n \n If the Port and Serv schemas/databases are empty, the Entando Operator  will use the underlying Entando App to populate these databases with the data backup available in the standard backup path in the WAR deployment. \n In scenarios where the EntandoApp needs to connect to an existing database that is fully managed\nby the customer, it is best to setup the standard database connection variables using the\n spec.environmentVariables  property and set this property to 'none'. This will skip any database\npreparations steps in the deployment. \n \n \n \n When deploying a component the operator will evaluate the spec and if it supports the standard  spec.dbms \nproperty, the value of this property will be given to the component's  spec.dbms . Please consult\nthe documentation for each component's CRD to determine how each Entando resource uses the dbms (if any). \n Ingress Path Generation \n When deploying an Entando Custom Resource that uses an Ingress path: \n \n The  ingressHostName  property defines the host path that will be used to access this\nservice from outside the cluster. The Entando Operator will create an ingress with this hostname and expose the resource at its default path. \n \n"},{title:"Customizing the Entando Component Generator",frontmatter:{},regularPath:"/next/docs/create/component-gen-customize.html",relativePath:"next/docs/create/component-gen-customize.md",key:"v-75e450fc",path:"/next/docs/create/component-gen-customize.html",lastUpdated:"4/18/2022, 4:37:39 PM",lastUpdatedTimestamp:1650314259e3,content:" Customizing the Entando Component Generator \n The Entando Component Generator is an instance of a JHipster blueprint that can be extended to match your team's needs and requirements. If you're interested in extending the blueprint or creating your own blueprint, contact us on the  Entando Forum  or  Community Slack  and we'll help you get started. \n This is the source for the  Entando Blueprint . \n To learn more about creating blueprints and to see other blueprints available from JHipster checkout the  blueprint documentation  or visit  JHipster  for an overview. \n"},{title:"Entando Component Generator",frontmatter:{},regularPath:"/next/docs/create/component-gen-overview.html",relativePath:"next/docs/create/component-gen-overview.md",key:"v-7ccd90a6",path:"/next/docs/create/component-gen-overview.html",headers:[{level:2,title:"Objectives",slug:"objectives"},{level:2,title:"Generated Component Flow",slug:"generated-component-flow"}],lastUpdated:"4/19/2022, 3:11:34 PM",lastUpdatedTimestamp:1650395494e3,content:" Entando Component Generator \n The Entando Component Generator, powered by JHipster, is a tool that gives developers the ability to quickly generate Entando components to extend an Entando Application. \n The component generator takes advantage of the concept of  JHipster blueprints  to provide powerful templating and standard generation patterns. \n Objectives \n The component generator has two main objectives \n \n \n Accelerate development \n \n Automate the creation of microservices and micro frontends with code that runs without changes. Start from running software. \n Code is meant to be developed on and changed by developers. Ready for customization. \n Using standard tools, technologies, and patterns that can be consumed by developers who are not familiar with the underlying blueprint \n \n \n \n Standardize microservice creation and technology choices \n \n Encode business standards for networking, monitoring, build tools, and distribution into a blueprint to ensure that developers are starting from a technical point that matches your teams requirements \n Ensure code follows standards and practices of your teams including code formatting, testing tools, static analysis tools, package structures, and other rules specific to your organization \n Enable teams to quickly recognize and adopt code from system integrators and other third parties because the patterns and standards are encoded in the starting point of your applications \n Generated Component Flow \n This section provides an overview of the component generation process. If you want to jump into the code and a tutorial start here:  Entando Component Generator Tutorial \n \n \n \n Create components \n \n The Component Generator will create a Spring Boot microservice and optionally will create React micro frontends for entities that you add to your project \n The microservice and generated micro frontends are runnable out of the box and preconfigured to connect to  Entando Identity Management \n The code is meant to be edited and enhanced by developers. JHipster provides interactive updates and merges if you need to re-run the generator or add new functionality via JHipster \n The microservice includes liquibase and integrated data mocking if you want to generate data in your API calls \n \n \n \n Define bundle and deploy assets \n \n The Entando blueprint includes scripts and tools to automatically generate a bundle ready for deployment to the ECR. The bundle will include your microservice, generated microfrontends, and any microfrontends that you have created manually under the  ui  folder \n The generated Spring Boot microservice can be built and deployed to a Docker registry using the provided maven Jib plugin \n Generated bundles can be pushed to a git repository of the users choice \n \n \n \n Deploy bundles to  Entando Component Repository (ECR) \n \n Once your Docker images are pushed to your registry and your bundle is available in Git you can generate an Entando bundle descriptor and push the bundles to the ECR \n The bundles can be versioned and updated using tags in the git repository \n \n \n \n Install in Entando Apps \n \n Once the bundles are in the ECR they are available for deployment in any Entando application that has access to the ECR in the cluster \n \n \n \n"},{title:"How to customize bundle info shown in Entando App Builder",frontmatter:{},regularPath:"/next/docs/curate/ecr-bundle-presentation-config.html",relativePath:"next/docs/curate/ecr-bundle-presentation-config.md",key:"v-55c921f4",path:"/next/docs/curate/ecr-bundle-presentation-config.html",lastUpdated:"1/25/2022, 4:09:16 PM",lastUpdatedTimestamp:1643144956e3,content:" How to customize bundle info shown in Entando App Builder \n \n In the image above you can see an example of a bundle as is displayed in the ECR user interface inside the Entando App Builder. \n The corresponding custom-resource file on Kubernetes is similar to this: \n apiVersion: entando.org/v1\nkind: EntandoDeBundle\nmetadata:\n  name: simple-entando-bundle\nspec:\n  details:\n    name: \"Entando Bundle\"\n    description: An example of an Entando bundle\n    dist-tags:\n      latest: v0.0.1\n    time:\n      created: '2020-05-20T15:59:21.946Z'\n      modified: '2020-05-20T15:59:21.946Z'\n      v0.0.1: '2020-05-20T15:59:21.946Z'\n    versions:\n      - v0.0.1\n    keywords:\n      - entando6\n    author: Entando\n    thumbnail: >-\n      data:image/jpeg;base64,....\n  tags:\n....\n \n In order to change the UI elements, you need to update the custom-resource in accordance with this table \n \n \n \n Field \n UI Element \n \n \n \n \n spec.details.name \n Set the bundle title \n \n \n spec.details.description \n Set the bundle description (only visible in the list presentation format) \n \n \n spec.details.thumbnail \n Set the bundle thumbnail, expressed as a base64 encoded string \n \n \n spec.details.dist-tags.latest \n Set what's the latest version of the bundle \n \n \n \n"},{title:"Component Generation Technologies",frontmatter:{},regularPath:"/next/docs/create/component-gen-tech.html",relativePath:"next/docs/create/component-gen-tech.md",key:"v-72897874",path:"/next/docs/create/component-gen-tech.html",lastUpdated:"1/25/2022, 4:09:16 PM",lastUpdatedTimestamp:1643144956e3,content:" Component Generation Technologies \n When generating a microservice using the Entando Component Generator there are a number of technical choices that need to be made \n \n Microservice code\n \n The Component Generator currently only supports the generation of Spring Boot microservices but will support the generation of Quarkus based services soon. \n If you're interested in using Quarkus in your Entando app, contact us on the  Forum  or  Community Slack  and we'll help you get started. \n If you're considering non-Java based microservices,  here is a definition of an Entando plugin , including information on the runtime contract required to use them. \n \n \n Database type\n \n Entando recommends standardizing your choice of database to simplify operational maintenance but you do have the ability to use different databases for different microservices if you choose. \n Supported choices are none, MySQL, and Postgres. Enterprise customers can choose Oracle but should contact Entando Support for details. \n \n \n Development databases\n \n You can choose to utilize a full RDBMS or developers can utilize lightweight in memory or on disk databases with h2. \n \n \n Caching implementation\n \n When generating a microservice you will be presented with the type of cache to inject into the services. It is recommended that this is a standard choice for all of the microservices in your application but can be customized on a per service basis if desired. \n \n \n Build system\n \n Determines the java build tool to use when building your services \n Supports maven or gradle \n \n \n Other technologies\n \n Users of the component generator can also decide to use other technologies from JHipster or from the JHipster marketplace. \n There are many powerful technologies in the marketplace but it is up to the developer to integrate any choices from the marketplace into their Entando application. Entando doesn't provide any direct support for marketplace tech choices. \n \n \n Micro frontends\n \n Users can optionally choose to generate micro frontends for entities generated via the blueprint. \n The Entando Component Generator only provides micro frontends in React from the generation flow but developers can create and bundle micro frontends using other technologies as well. \n \n \n \n If you want to try out these choices follow the tutorial on  creating Entando microservices and micro frontends using the component generator . \n"},{title:"Filtering bundles",frontmatter:{},regularPath:"/next/docs/curate/ecr-bundle-filters.html",relativePath:"next/docs/curate/ecr-bundle-filters.md",key:"v-674bd9c6",path:"/next/docs/curate/ecr-bundle-filters.html",headers:[{level:2,title:"Filtering bundles by component",slug:"filtering-bundles-by-component"},{level:3,title:"Supported labels keys are:",slug:"supported-labels-keys-are"},{level:3,title:"Example",slug:"example"},{level:2,title:"Filtering bundles by status",slug:"filtering-bundles-by-status"},{level:2,title:"Filtering bundles by textual search",slug:"filtering-bundles-by-textual-search"},{level:2,title:"Mixing search criteria",slug:"mixing-search-criteria"}],lastUpdated:"1/25/2022, 4:09:16 PM",lastUpdatedTimestamp:1643144956e3,content:' Filtering bundles \n ECR bundles are filterable by component, by status or by textual research. \n Filtering bundles by component \n ECR bundles are filterable by component from App Builder user interface. \n \n Behind the scenes, filtering is done using the label-based filtering provided out of the box from Kubernetes. \n To enable filtering of a bundle, the custom-resource representing the bundle on the Entando Cluster needs to contain the correct labels. An important note on the values to add the  labels  field, even if to correctly define a label in a k8s resource both the key and the value are required, from an Entando point of view only the key part of the label is used for filtering. The value could be set to anything, but our reccomendation is to use  "true"  for clarity and simplicity. \n Supported labels keys are: \n \n \n \n \n \n \n \n Label entry \n Description \n \n \n \n \n widget: "true" \n The bundle contains one or more microfrontends (widgets)  \n \n \n plugin: "true" \n The bundle contains one or more microservices (plugins) \n \n \n fragment: "true" \n The bundle contains one or more fragments \n \n \n pageTemplate: "true" \n The bundle contains one or more page templates \n \n \n contentType: "true" \n The bundle contains one or more content types \n \n \n contentTemplate: "true" \n The bundle contains one or more content templates \n Example \n Here is an example of the metadata for a ecr bundle containg micro-frontends, some microservices and page templates \n apiVersion: entando.org/v1\nkind: EntandoDeBundle\nmetadata:\n  name: demo-bundle\n  labels:\n    widget: "true"\n    plugin: "true"\n    pageTemplate: "true"\nspec:\n  details:\n  ...\n Filtering bundles by status \n ECR bundles are filterable by status from App Builder user interface. \n \n You can choose to see the full list of the bundles available in Kubernetes cluster by selecting the  Explore  tab, or the list of the currently installed bundles by clicking on the  Installed  tab. \n Filtering bundles by textual search \n You can search for bundles containing some keywords by executing a textual search. \n \n You can open the menu on the left to select which field to target. \n If you are creating a new bundle, keep in mind the textual search is performed against data extracted from the bundle CRD file. \n Mixing search criteria \n You can mix all previous search criteria to refine the scope of your search as you want.\nFor example, you could search for all available bundles ( Explore  tab) that contain  Page Templates  components\n(using the checkboxes) and the word  Login  in their name (using the textual search). \n'},{title:"Bundle and Component Descriptors",frontmatter:{sidebarDepth:2},regularPath:"/next/docs/curate/ecr-bundle-details.html",relativePath:"next/docs/curate/ecr-bundle-details.md",key:"v-2d64c0b4",path:"/next/docs/curate/ecr-bundle-details.html",headers:[{level:3,title:"Bundle Conventions",slug:"bundle-conventions"},{level:3,title:"Bundle Descriptor",slug:"bundle-descriptor"},{level:2,title:"Plugin",slug:"plugin"},{level:3,title:"Permissions",slug:"permissions"},{level:2,title:"Widget",slug:"widget"},{level:2,title:"Fragment",slug:"fragment"},{level:2,title:"Page Template",slug:"page-template"},{level:2,title:"Page",slug:"page"},{level:2,title:"CMS Asset",slug:"cms-asset"},{level:2,title:"Content Template",slug:"content-template"},{level:2,title:"Content Type",slug:"content-type"},{level:2,title:"Content",slug:"content"},{level:2,title:"Categories",slug:"categories"},{level:2,title:"Groups",slug:"groups"},{level:2,title:"Labels",slug:"labels"},{level:2,title:"Languages",slug:"languages"},{level:2,title:"Static Resources",slug:"static-resources"}],lastUpdated:"4/8/2022, 9:57:10 AM",lastUpdatedTimestamp:164942623e4,content:' Bundle and Component Descriptors \n The Entando Component Manager reads the  descriptor.yaml  file from the root of the bundle package and uses it to install any components and resources included in the bundle. \n The different component types are shown below: \n \n Here is the basic bundle structure: \n .\n├ descriptor.yaml\n├ resources/\n│ └ ...\n└ ... (folders reported in descriptor.yaml file)\n Bundle Conventions \n \n \n The bundle descriptor file must be named  descriptor.yaml  or the bundle will not be recognized. \n \n \n Static resources should be placed in a  resources  folder. They are not explicitly referenced in the  descriptor.yaml  file itself. \n Bundle Descriptor \n The bundle descriptor YAML file aggregates all included components and has the structure shown below. Note that the Page Template feature is  pageModels  and the Content Template feature is  contentModels . \n \n Warning \n The bundle descriptor file must be named  descriptor.yaml \n \n descriptor.yaml \n code: survey_bundle # The bundle ID\ndescription: This is the survey bundle # The description of the bundle\n\ncomponents: # All components are listed here.\nOptional. Use if the component requires deployment\n  plugins:\n    - folder/you/want/your_plugin_descriptor.yaml\n    - folder/you/want/another_plugin_descriptor.yaml\nTo create Widgets, add references to the descriptor files \n  widgets:\n    - widgets/your_widget_descriptor.yaml\n    - widgets/another_widget_descriptor.yaml\nTo create Fragments, add references to the descriptor files \n  fragments:\n    - fragments/your_fragment.yaml\nTo create Page Templates, add references to the descriptor files \n  pageModels:\n    - pageModels/your_page_model_descriptor.yaml\n    - pageModels/another_page_model_descriptor.yaml\nTo create and publish Pages, add references to the descriptor files \n  pages:\n    - page/your_page_descriptor.yaml\n    - page/another_page_descriptor.yaml\nTo create a CMS Asset, add a reference to the descriptor file in the same location \nas the image or file you want to upload\n  assets:\n    - assets/your-asset/your_asset_descriptor.yaml\n    - assets/your-asset/your_image.jpg\nTo create Content Types, add references to the descriptor files\n  contentTypes:\n    - contentTypes/your_content_type_descriptor.yaml\nTo create Content Templates, add references to the descriptor files\n  contentModels:\n    - contentModels/your_content_model_descriptor.yaml\n    - contentModels/another_content_model_descriptor.yaml\nTo create and publish Contents, add references to the descriptor files\n  contents:\n    - contents/your_content_descriptor.yaml\n    - contents/another_content_descriptor.yaml\nTo create Categories, add references to the descriptor files\n  categories:\n    - categories/your_categories.yaml\nTo create Groups, add references to the descriptor files\n  groups:\n    - groups/your_groups.yaml\nTo create Labels, add references to the descriptor files\n  labels:\n    - labels/your_labels.yaml\nTo enable Languages, add references to the descriptor files\n  languages:\n    - languages/languages.yaml\n Plugin \n Here is an example of a plugin descriptor: \n Plugin descriptor.yaml \nDescriptor version field added in v3 and later. \nTo take advantage of the environment variables below, v4 will need to be specified.\ndescriptorVersion: "v4" \nThe Docker image used to create the plugin\nimage: "entando/your-image:1.0.0" \nThe base name to assign to pods that have to be created in Kubernetes\ndeploymentBaseName: "yourplugin" \nThe DBMS the plugin will use\ndbms: "postgresql" \nThe roles the plugin will expose in Keycloak\nroles: \n  - "task-list"\n  - "task-get"\n  - "connection-list"\n  - "connection-get"\n  - "connection-create"\n  - "connection-delete"\n  - "connection-edit"\nThe health check path that Kubernetes will use to check the status \nof the plugin deployment  \nhealthCheckPath: "/actuator/health" \nThe ingress path to assign to the plugin deployment \ningressPath: "/your-plugin-path"\nA list of Keycloak clientIds/roles to bind to one another\npermissions: \n  - clientId: realm-management\n    role: manage-users\n  - clientId: realm-management\n    role: view-users\nA set of environment variables that can be set inline or \nreferenced as Secrets in the namespace. Supported as of descriptorVersion v4.\nenvironmentVariables:\n  - name: SIMPLE_VAR  # directly injects the value\n    value: yourSimpleValue\n  - name: SECRET_VAR  # leverages a secret value\n    valueFrom:\n      secretKeyRef:\n        name: YOUR-BUNDLE-ID-your-secret\n        key: yourSecretKey\n \n TIP \n Entando uses the  healthCheckPath  to monitor the health of the plugin. A plugin in an Entando Bundle can use any technology, as long as it provides a health check service configured via the  healthCheckPath . This path must be specified in the descriptor file and return an HTTP 200 or success status. This can be implemented by a Java service included with the Entando Blueprint in the Spring Boot application. You can also  use a Node.js service as shown here . \n \n TIP \n See the  Plugin Environment Variables  tutorial to setup environment variables, either inline or based on Kubernetes Secrets. \n Permissions \n The  permissions  property specifies a list of coupled  clientIds  and roles that will be bound in Keycloak. To find them, open the Keycloak console and navigate to  clients  →  awesomeplugin-server  →  Service Account Roles . \n Widget \n Here is an example of a Widget descriptor: \n Widget descriptor.yaml \n code: another_todomvc_widget # The Widget identification\n\ntitles: # Widget\'s Titles\n  en: TODO MVC Widget # Title in English\n  it: TODO MVC Widget # Title in Italian\n\ngroup: free # The owner group of the Widget\nOptional. The UI Path, where the widget.ftl file will have the customUi content\ncustomUiPath: widget.ftl\nOptional. The Custom UI\ncustomUi: >-\n    <h1>Your Custom Widget UI</h1>\nOptional. The ConfigUI\nconfigUi:\n  customElement: todomvc-config # The name of the custom element used to render the configUI\n  resources:\n    - <bundleid>/static/js/main.js # The resources necessary for the custom element to render the configUI, like the code\n Fragment \n Here is an example of a Fragment descriptor: \n Fragment descriptor.yaml \n code: your_fragment # The unique ID\nOptional. The Fragment content\nguiCode: >-\n  "<div>Here is the content</div>"\nOptional. A path to a FreeMarker file containing the Fragment content\nguiCodePath: fragment.ftl\n Page Template \n Here is an example of a Page Template descriptor: \n Page Template descriptor.yaml \n code: todomvc_page_template # The Page Template identification\ndescription: TODO MVC basic page template # The Page Template description\n\ntitles: # Page Template\'s Titles\n  en: TODO MVC PageTemplate # Title in English\n  it: TODO MVC PageTemplate # Title in Italian\nThe Page Template configuration\nconfiguration:\n  frames: # All frames\n    - pos: 0 # Frame position\n      description: Header # Frame description\n      sketch: # Frame sketch configuration\n        x1: 0\n        y1: 0\n        x2: 11\n        y2: 1\n      defaultWidget:\n        code: your-widget # the Widget code to apply when using the button "apply default widgets" in the page configuration UI\nA simplified way to define a Frame\n    - pos: 1\n      description: Breadcrumb\n      sketch: { x1: 0, y1: 0, x2: 11, y2: 1 }\nOptional. Define the Page Template in a separate file or inside the descriptor file with `template`\ntemplatePath: page.ftl\nOptional. Define the Page Template as below or in a separate file with `templatePath`\ntemplate: >-\n  <#assign wp=JspTaglibs[\\"/aps-core\\"]>\n  <!DOCTYPE HTML PUBLIC \\"-//W3C//DTD HTML 4.0 Transitional//EN\\">\n  <html>\n      <head>\n          <title><@wp.currentPage param=\\"title\\" /></title>\n      </head>\n      <body>\n          <h1><@wp.currentPage param=\\"title\\" /></h1>\n          <a href=\\"<@wp.url page=\\"homepage\\"/>\\">Home</a><br>\n          <div>\n              <h1>Bundle 1 Page Template</h1>\n              <@wp.show frame=0 />\n          </div>\n      </body>\n  </html>\n Page \n This descriptor enables a page to be created and published via a bundle. Page status can be  published  or  draft . The Widget section can be used to fully configure a page layout. \n Groups in a page descriptor are configured by  ownerGroup  and  joinGroups . The  ownerGroup  property specifies the group of users who can manage the entity in the AppBuilder. The  joinGroups  property specifies who can view or access the page. For example, setting  ownerGroup  to "free" means anyone with access to the AppBuilder can manage the page, whereas setting  joinGroup  to "free" means any end user can view the page in the application. \n Page descriptor.yaml \n code: dashboard\nparentCode: homepage\ntitles:\n  en: your dashboard\n  it: La mia Dashboard\npageModel: dashboard\nownerGroup: free\njoinGroups: []\ndisplayedInMenu: true\nseo: false\ncharset: utf-8\nECR will publish the page according to this property\nstatus: published|draft\nPage Configuration\nwidgets:\n  - code: Brand-Logo\n    config: null\n    pos: 0\n  - code: Login_buttons\n    config: null\n    pos: 2\n  - code: seeds_card\n    config:\n      cardname: creditcard\n    pos: 6\n  - code: list_item\n    config:\n      icon: managealerts\n      count: \'0\'\n      title: Alerts\n    pos: 7\n  - code: list_item\n    config:\n      icon: viewstatements\n      count: \'0\'\n      title: View Statements\n    pos: 11\n  - code: seedscard-transaction-table\n    config: null\n    pos: 13\n CMS Asset \n This descriptor contains the metadata required for uploading and updating a CMS Asset. \n Asset descriptor.yaml \n correlationCode: \'your-reference-code\'\ntype: image\nThis file should be placed in the same folder as the descriptor.yaml\nname: 113f4437cac3b3f3d4db7229f12287a4_d3.png\ndescription: 113f4437cac3b3f3d4db7229f12287a4_d3.png\ngroup: free\ncategories: []\n Content Template \n Here is an example of a Content Template descriptor: \n Content-template descriptor.yaml \n id: 8880003\ncontentType: CNG\ndescription: Demo Content Template\nOptional. Define the Content Template Shape in a separate file or inside the descriptor file with `contentShape`\ncontentShapePath:\nOptional. Define the Content Template Shape as below or in a separate file with `contentShapePath`\ncontentShape: >-\n  <article>\n    <h1>$content.Title.text</h1>\n    <h2>Demo content template</h2>\n    #if ( $content.MainBody.text != "" )\n    $content.MainBody.text\n    #end\n  </article>\n\n\nwidgets:\n  - code: Brand-Logo\n    config: null\n    pos: 0\n  - code: Login_buttons\n    config: null\n    pos: 2\n  - code: seeds_card\n    config:\n      cardname: creditcard\n    pos: 6\n  - code: list_item\n    config:\n      icon: managealerts\n      count: \'0\'\n      title: Alerts\n    pos: 7\n  - code: list_item\n    config:\n      icon: viewstatements\n      count: \'0\'\n      title: View Statements\n    pos: 11\n  - code: seedscard-transaction-table\n    config: null\n    pos: 13\n Content Type \n For more details on Content Type properties, refer to the  Content Type documentation . \n Content-type descriptor.yaml \n code: CNG\nname: Demo\nstatus: 0\n\nattributes:\n  - code: title\n    type: Text\n    name: Title\n    roles:\n      - code: jacms:title\n        descr: The main title of a Content\n    disablingCodes: []\n    mandatory: true\n    listFilter: false\n    indexable: false\n\n    enumeratorStaticItems: string\n    enumeratorStaticItemsSeparator: string\n    enumeratorExtractorBean: string\n\n    validationRules:\n      minLength: 0\n      maxLength: 100\n      regex: string\n      rangeStartString: string\n      rangeEndString: string\n      rangeStartStringAttribute: string\n      rangeEndStringAttribute: string\n      equalString: string\n      equalStringAttribute: string\n      rangeStartDate: string\n      rangeEndDate: string\n      rangeStartDateAttribute: string\n      rangeEndDateAttribute: string\n      equalDate: string\n      equalDateAttribute: string\n      rangeStartNumber: 0\n      rangeStartNumberAttribute: string\n      rangeEndNumber: 0\n      rangeEndNumberAttribute: string\n      equalNumber: 0\n      equalNumberAttribute:\n      ognlValidation:\n        applyOnlyToFilledAttr: false\n        errorMessage: Something\n        keyForErrorMessage: some\n        keyForHelpMessage: thing\n        ognlExpression: string\n Content \n This descriptor enables content to be created and optionally published via a bundle, according to the  status  property. The content ID is optional and enables linking from other components, like Content Widget. It can be autogenerated or explicitly declared. \n Groups in a content descriptor are configured by the owner group  mainGroup  and the join group  groups . The owner group consists of users who can manage the content within AppBuilder, while the join group consists of users who can view the content. \n Content descriptor.yaml \n id: NWS650\ntypeCode: NWS\ndescription: Dealing with a financial emergency\nmainGroup: free\ngroups:\n  - free\nstatus: PUBLIC\nattributes:\n  - code: date\n    value: \'2020-04-23 00:00:00\' # the date should be in ISO-8601 format\n  - code: title\n    values:\n      en: Dealing with a financial emergency\n  - code: subtitle\n    values:\n      en: |\n        <p>How to tackle financial stress</p>\n  - code: body\n    values:\n      en: |\n        <p>For many Americans, financial concerns are their number-one stress point. Here are 6 ways to help reduce your money stress and get motivated to take control of your finances.</p>\n  - code: img\n    values:\n      en:\n        correlationCode: \'651\'\n        name: bank_750xx684385064_d0.jpg\n  - code: links\n    elements:\n      - code: links\n        value:\n          symbolicDestination: \'#!U;http://www.yoursite.com/!#\'\n          destType: 1\n          urlDest: \'http://www.yoursite.com/\'\n          pageDest: null\n          contentDest: null\n          resourceDest: null\n        values:\n          en: vostro sito\n      - code: links\n        value:\n          symbolicDestination: \'#!U;http://www.yoursite.com/!#\'\n          destType: 1\n          urlDest: \'http://www.yoursite.com/\'\n        values:\n          en: vostro sito 2\n  - code: attaches\n    elements:\n      - code: attaches\n        values:\n          en:\n            correlationCode: \'205\'\n            name: Entando_Admin_Console_Overview_4.3.3_EN.pdf\n Categories \n This descriptor contains a list of Categories: \n Category descriptor.yaml \n - code: new-category # Identifies the Category\n  parentCode: home # The parent Category; home is the base category\n  titles:\n    it: "Una nuova categoria" # Category name in Italian\n    en: "New category" # Category name in English\n Groups \n This descriptor contains a list of Groups: \n Group descriptor.yaml \n - code: your_group # Identifies the Group\n  name: "Your group" # The name of the Group\n Labels \n This descriptor contains a list of Labels: \n Label descriptor.yaml \n - key: YOUR-FIRST-LABEL # Identifies the Label\n  titles: # The titles on the Label\n    it: Vostro Titolo # The title in Italian\n    en: Your Title # The title in English\n Languages \n This descriptor contains a list of Languages to enable during the installation process: \n Language descriptor.yaml \n - code: en\n  description: English\n- code: it\n  description: Italian\n Static Resources \n In order to upload static files, you will need to create a folder called  resources . All files inside this folder will be uploaded into Entando with the same folder structure. \n resources/\n├ css/\n│ └ styles.css\n├ js/\n│ └ script.js\n├ images/\n│ ├ favicon.ico\n│ └ logo.png\n└ page.html\n \n Using the structure above, the resultant files in the Entando architecture will be: \n your-bundle-id/\n├ css/\n│ └ styles.css\n├ js/\n│ └ script.js\n├ images/\n│ ├ favicon.ico\n│ └ logo.png\n└ page.html\n \n \n Important \n The  code  property  your-bundle-id  is inside  descriptor.yaml . \n \n To use static files in a Widget or Page Template, use the FTL tag  <@wp.resourceURL /> : \n <img src="<@wp.resourceURL />your-bundle-id/images/logo.png">\n<link rel="stylesheet" href="<@wp.resourceURL />your-bundle-id/css/styles.css">\n<link rel="shortcut icon" href="<@wp.resourceURL />your-bundle-id/images/favicon.ico" type="image/x-icon"/>\n<script type="application/javascript" src="<@wp.resourceURL />your-bundle-id/js/script.js"><\/script>\n \n '},{title:"Bundle versions and updates - FAQ",frontmatter:{},regularPath:"/next/docs/curate/ecr-bundle-versions-faq.html",relativePath:"next/docs/curate/ecr-bundle-versions-faq.md",key:"v-7e983c10",path:"/next/docs/curate/ecr-bundle-versions-faq.html",headers:[{level:2,title:"Does the ECR support versioning?",slug:"does-the-ecr-support-versioning"},{level:2,title:"How is a bundle version defined?",slug:"how-is-a-bundle-version-defined"},{level:2,title:"What format should I use to version my bundle?",slug:"what-format-should-i-use-to-version-my-bundle"},{level:2,title:"As a bundle developer, how should I create a new version of a bundle?",slug:"as-a-bundle-developer-how-should-i-create-a-new-version-of-a-bundle"},{level:2,title:"How to prevent a particular bundle version from being visible in the ECR?",slug:"how-to-prevent-a-particular-bundle-version-from-being-visible-in-the-ecr"},{level:2,title:"My bundle contains a microservice generated with the Entando Component Generator, does the version of the microservice have to be the same as the bundle version?",slug:"my-bundle-contains-a-microservice-generated-with-the-entando-component-generator-does-the-version-of-the-microservice-have-to-be-the-same-as-the-bundle-version"},{level:2,title:"How bundle versions are installed from the ECR",slug:"how-bundle-versions-are-installed-from-the-ecr"}],lastUpdated:"1/25/2022, 4:09:16 PM",lastUpdatedTimestamp:1643144956e3,content:" Bundle versions and updates - FAQ \n Does the ECR support versioning? \n A bundle, as discussed in the  overview , is a package containing one or more components.\nAs in many other packaging systems, the ECR supports bundle versioning, allowing developers to create and release improvements of their package over time. \n How is a bundle version defined? \n In the ECR, the bundle custom resource comes with a set of  tags , each one representing a version of the bundle.\nHere an example for a CMS quickstart bundle \n apiVersion: entando.org/v1\nkind: EntandoDeBundle\nmetadata:\n    name: cms-quickstart-bundle\nspec:\n  details:\n    name: Entando Example CMS Bundle\n    description: Example Bundle containing CMS components for the Quickstart experience\n  tags:\n    - integrity: ''\n      shasum: ''\n      tarball: 'https://github.com/entando/entando-cms-quickstart-bundle.git'\n      version: v0.0.1\n    - integrity: ''\n      shasum: ''\n      tarball: 'https://github.com/entando/entando-cms-quickstart-bundle.git'\n      version: v0.0.2\n \n As you can see from the code above, the bundle  cms-quickstart-bundle  has 2 versions available.\nEach version in the  tags  object must correspond a tag in the git repository provided in the  tarball  field. \n What format should I use to version my bundle? \n The ECR requires versions to follow the  semantic versioning 2.0.0 , with the possibility to prepend a  v  to the version itself. Some valid bundle versions are: \n \n 1.0 \n v0.1.0-alpha \n 1.0.1-SNAPSHOT \n 22.109.10234-RC.1 \n As a bundle developer, how should I create a new version of a bundle? \n If you're a bundle developer and you want to release a new version of your bundle, you can simply update the content of your bundle and commit the changes to the bundle git repository.\nOnce all the required changes are committed, you can create a new tag in the git repository using the  git tag  command and publish it to the remote repository using the  git push --tags  command \n For example, let's assume my bundle already has a version  1.0.0  and I want to publish the version  2.0.0  of my bundle, here the commands I need to use to create and publish the new tag: \n     git tag -a \"2.0.0\" -m \"My new version\"\n    git push --tags\n How to prevent a particular bundle version from being visible in the ECR? \n If, for some reason, you don't want a particular version to be available for the installation, you can proceed as follows: \n \n You can edit the bundle directly using the command  kubectl edit entandodebundles.entando.org -n <namespace-of-the-bundle> <name-of-the-bundle> \n \n or if you still have the original file you can also: \n \n remove the undesired version from the tag list in your bundle Kubernetes file ( integrity ,  shasum ,  tarball  and  version ) \n delete your bundle from your cluster using a command like this  kubectl delete -f your-bundle-file.yml [-n your-cluster-namespace] \n upload your bundle again to Kubernetes using a command like this  kubectl create -f your-bundle-file.yml [-n your-cluster-namespace] \n My bundle contains a microservice generated with the Entando Component Generator, does the version of the microservice have to be the same as the bundle version? \n The version of the microservice - or to be more precise the docker image associated with the microservice - isn't bound to the version of the bundle containing the microservice itself. \n This gives the bundle developer complete control over the bundle release process, especially in those situations where the bundle contains more components and even more microservices. \n How bundle versions are installed from the ECR \n When the user decides to install a version of the bundle, the ECR checks the provided tag in the git repository and clones locally just the content of the repository for that tag. \n For this reason it's important that for each provided tag in the custom-resource a corresponding tag is available in the git repository, otherwise the ECR will not be able to donwload the bundle and will throw an error. Note that the ECR can only see published tags, so make sure that all the time you create a new tag in your git repository you publish it to the remote repository too. \n"},{title:"How Microservices get Connected to Entando Apps",frontmatter:{},regularPath:"/next/docs/curate/ecr-how-microservices-connect-to-apps.html",relativePath:"next/docs/curate/ecr-how-microservices-connect-to-apps.md",key:"v-dee87a08",path:"/next/docs/curate/ecr-how-microservices-connect-to-apps.html",headers:[{level:2,title:"How a Microservice from a Bundle gets Deployed with the ECR?",slug:"how-a-microservice-from-a-bundle-gets-deployed-with-the-ecr"},{level:2,title:"Other Options",slug:"other-options"},{level:2,title:"Kubernetes naming conventions",slug:"kubernetes-naming-conventions"}],lastUpdated:"1/25/2022, 4:09:16 PM",lastUpdatedTimestamp:1643144956e3,content:" How Microservices get Connected to Entando Apps \n In this document we will describe some of the assumptions and details related to the process of connecting a microservice part of a bundle to an Entando App. \n In order to fully understand the concepts explained in this piece of the documentation, please make sure you have familiarity with these concepts: \n \n Entando custom resources \n Entando ingresses \n How a Microservice from a Bundle gets Deployed with the ECR? \n When a bundle containing a microservice is installed using the ECR, behind the scenes some actions take place. \n \n To begin, an  EntandoPlugin custom resource  is generated starting from the PluginDescriptor. Some fields will be automatically generated from the provided image. \n \n \n From the  image  field in the PluginDescriptor, we will extract the  organization ,  name  and  version  of the image. \n organization ,  name  and  version  are then converted to valid characters and composed to form the plugin name ( metadata.name ), the labels ( metadata.labels ) and the ingressPath ( spec.ingressPath ) of the custom resource. \n \n NOTE : Two PluginDescriptors having images with the same organization, name and version will generate a custom resource with the same  metadata.name  and  spec.ingressPath . \n \n Next, a check for a microservice with the same name is performed to verify if a new deployment is required for the microservice. \n If a microservice with the same name is not available in the namespace where the Entando App has been deployed, a new EntandoPlugin custom resource is created and deployed in the namespace using the details defined in the bundle. \n At the same time, an EntandoAppPluginLink custom resource is deployed in the namespace in order to expose the microservice ingress path on the EntandoApp ingress. \n If both the EntandoPlugin custom resource and the EntandoAppPluginLink are deployed correctly, the APIs of the microservice will be available from the same domain of the EntandoApp, making it possible reach those APIs from the EntandoApp using relative urls. \n \n This is the standard flow when no other micorservice with a given name is already available in the EntandoApp namespace. \n If there is an existing microservice with the same name as the one generated from the PluginDescriptor, the ECR will connect the EntandoApp to\nthe existing microservice by generating and deploying the required EntandoAppPluginLink per step 3 above.\nThis way, plugins can be reused by many applications at the same time. \n Other Options \n The naming convention recommendations above are accurate for creating bundles and for self contained applications where the Entando operator is managing the lifecycle of your microservices. If you have a substantial API infrastructure or you intend to deploy a large number of versioned microservices you can also utilize Entando with API management infrastructure like API gateways. If you are using an API gateway or other API abstraction layer you will need to manually manage the ingress for your micro frontends in your application to point to the API gateway deployment. \n In cases where conflicts occur bundles can easily be renamed by updating metdata. \n Kubernetes naming conventions \n Here some rules about naming conventions extracted from the  Kubernetes documentation on object names and ids \n \n Most resource types require a name that can be used as a DNS subdomain name as defined in RFC 1123. This means the name must: \n \n contain no more than 253 characters \n contain only lowercase alphanumeric characters, '-' or '.' \n start with an alphanumeric character \n end with an alphanumeric character \n \n \n"},{title:"Bundle uninstall",frontmatter:{},regularPath:"/next/docs/curate/ecr-uninstall-flow.html",relativePath:"next/docs/curate/ecr-uninstall-flow.md",key:"v-7a0a0434",path:"/next/docs/curate/ecr-uninstall-flow.html",headers:[{level:2,title:"Uninstall process",slug:"uninstall-process"},{level:2,title:"Troubleshooting",slug:"troubleshooting"}],lastUpdated:"3/16/2022, 11:03:03 AM",lastUpdatedTimestamp:1647442983e3,content:" Bundle uninstall \n Uninstall process \n To uninstall a bundle that was previously installed on an Entando App Engine, from Entando App builder UI go to\nthe  Component Repository  tab. For the bundle you want to uninstall, click on the  Installed  button next to it. This will open a pop-up window with the option to uninstall. \n \n An initial check is made to verify none of the bundle components are in use.\nIf any of the components are in use, a popup will alert you.\nNote that you can't force the removal of a bundle if its components are in use. \n Once the removal process starts: \n \n Bundle resources are deleted from the Entando App Engine \n Components included in the bundle are removed from the Entando App Engine \n Plugins are unlinked \n Troubleshooting \n If any error happens during the uninstall process and you don't know what to do,\ncheck out the  Troubleshooting guide  or the  Entando Forum \n"},{title:"Troubleshooting ECR",frontmatter:{},regularPath:"/next/docs/curate/ecr-troubleshooting-guide.html",relativePath:"next/docs/curate/ecr-troubleshooting-guide.md",key:"v-5263095c",path:"/next/docs/curate/ecr-troubleshooting-guide.html",headers:[{level:2,title:"A bundle installation/removal has failed, how to access the logs?",slug:"a-bundle-installation-removal-has-failed-how-to-access-the-logs"},{level:3,title:"Overview",slug:"overview"},{level:3,title:"Solution",slug:"solution"},{level:2,title:"My bundle has an issue, how should I publish a new version of the bundle?",slug:"my-bundle-has-an-issue-how-should-i-publish-a-new-version-of-the-bundle"},{level:3,title:"Overview",slug:"overview-2"},{level:3,title:"Solution",slug:"solution-2"},{level:2,title:"Bundle installation fails because a file has not been found in the bundle",slug:"bundle-installation-fails-because-a-file-has-not-been-found-in-the-bundle"},{level:3,title:"Overview",slug:"overview-3"},{level:3,title:"Solution",slug:"solution-3"},{level:2,title:"Bundle installation failed due to plugin(s) images not reachable",slug:"bundle-installation-failed-due-to-plugin-s-images-not-reachable"},{level:3,title:"Overview",slug:"overview-4"},{level:3,title:"Solution",slug:"solution-4"},{level:2,title:"I can't uninstall a bundle because some components are in use",slug:"i-can-t-uninstall-a-bundle-because-some-components-are-in-use"},{level:3,title:"Overview",slug:"overview-5"},{level:3,title:"Solution",slug:"solution-5"}],lastUpdated:"1/25/2022, 4:09:16 PM",lastUpdatedTimestamp:1643144956e3,content:" Troubleshooting ECR \n A bundle installation/removal has failed, how to access the logs? \n Overview \n Currently the Entando component manager logs are available in kubernetes via dashboard (openshift) or cli tools (k9s or kubectl).\nIf in you Entando cluster you have more than one Entando App custom resource, you will need to know what's the correct component-manager to check using the corresponding Entando App name and namespace where the app has been deployed. \n Solution \n Using  kubectl  and assuming for simplicity that you have only one Entando App named  quickstart  and your Entando cluster is only composed of one namespace, also named  quickstart ,\nyou can get the component-manager logs using the command \n kubectl logs -f deployment/quickstart-server-deployment --namespace quickstart -c de-container\n \n Note : the  -f  flag is optional and could be used to follow the logs for debugging purposes \n My bundle has an issue, how should I publish a new version of the bundle? \n Overview \n Sometimes a bundle could have some issues: typos in the  descriptor.yaml  file, wrong references of components or to not available docker images are just a few of the possible errors. \n Solution \n \n If the bundle is shared using a git repository, you can make the required changes to your project and publish the new version to git and generate a new tag for it. \n Once the new tag is published, update the bundle costum-resource avaialble in you Entando Cluster by adding the new tag to the  tags  objects  and replacing the latest  dist-tags  to point to this new version. \n Proceed with the new installation \n \n If you're actively working on your bundle and you simply want to verify things are working correctly, instead of generating a new tag for each release of the bundle you can try to keep overriding a specific tag using the git command  git tag -f . We suggest you to follow this practice only during development and not in production. \n Bundle installation fails because a file has not been found in the bundle \n Overview \n When a component that is referenced in the  descriptor.yaml  is missing in the bundle or not correctly referenced, the bundle installation fails and in the logs is reported which file has not been found. \n ERROR - File with name {filename} not found in the bundle\n Solution \n When such a problem happens, verify that the component referenced in the descriptor file are actually present in the bundle and that the reference is properly typed. \n Publish a new version of your bundle as described in the\n \"My bundle has an issue\"  section \n Bundle installation failed due to plugin(s) images not reachable \n Overview \n Plugin included in a bundle are referenced using their docker image. Sometime the image is not available - maybe has not yet be published or is in a private docker registry - and plugin installation can't happen and the entire bundle installation process can't finish successfully \n Solution \n Verify that the docker image you are referencing is correct and publicly available. \n \"My bundle has an issue\"  section \n I can't uninstall a bundle because some components are in use \n Overview \n When removing an installed bundle, the Entando component manager verfies that the bundle components\nare not in use by any other component. Removing such components would cause an error during removal\nas in certain case the deleting a component in use is not permitted. \n Solution \n In order to prevent such errors, the user is alerted and required to manually decouple the bundle\ncomponents before beign able to completely remove the bundle from the system. \n"},{title:"Entando Architecture Concepts",frontmatter:{},regularPath:"/next/docs/getting-started/concepts-overview.html",relativePath:"next/docs/getting-started/concepts-overview.md",key:"v-13a593e8",path:"/next/docs/getting-started/concepts-overview.html",headers:[{level:2,title:"Entando App Engine",slug:"entando-app-engine"},{level:2,title:"Entando App Builder",slug:"entando-app-builder"},{level:2,title:"Entando Component Generator",slug:"entando-component-generator"},{level:2,title:"Entando Component Repository",slug:"entando-component-repository"},{level:2,title:"Entando Identity Management",slug:"entando-identity-management"},{level:2,title:"Entando WCMS",slug:"entando-wcms"},{level:2,title:"Entando Cluster Citizens",slug:"entando-cluster-citizens"},{level:3,title:"Architecture Diagram",slug:"architecture-diagram"},{level:3,title:"Members of the Cluster",slug:"members-of-the-cluster"},{level:2,title:"Entando Ingresses",slug:"entando-ingresses"},{level:3,title:"What is an Ingress?",slug:"what-is-an-ingress"},{level:3,title:"How Ingresses are used in an Entando Cluster",slug:"how-ingresses-are-used-in-an-entando-cluster"},{level:3,title:"Default Ingress HTTP Routes",slug:"default-ingress-http-routes"},{level:3,title:"Exposing Plugins in the EntandoApp Domain",slug:"exposing-plugins-in-the-entandoapp-domain"},{level:3,title:"How to Check Ingresses in my Cluster",slug:"how-to-check-ingresses-in-my-cluster"},{level:3,title:"Learn More",slug:"learn-more"}],lastUpdated:"4/14/2022, 1:19:13 PM",lastUpdatedTimestamp:1649956753e3,content:' Entando Architecture Concepts \n A portal, website, web app, or mobile app built with Entando is called an Entando application.\nAn Entando application is an assembly of out of the box and/or custom built components running on the\nEntando Platform. Components can be widgets, micro frontends, microservices, page templates, WCMS content or WCMS content types. \n Entando App Engine \n The Entando App Engine is the heart of the Entando Platform by providing the primary out-of-the-box services for\ndeveloping applications. Key features: \n \n Expose the APIs the Entando App Builder uses to provide the page and content management interface for your application. \n Handle the work of assembling micro frontends and microservices and combining them on specific pages as defined by the Entando App Builder. \n Provide the data access layer to persist the page and application design. \n Manage the cluster infrastructure. \n \n See also:  APIs tutorial \n Entando App Builder \n The  Entando App Builder  is the feature-rich management interface used to design and build pages for Entando applications. \n See also:  Widget Tutorial \n Entando Component Generator \n The Entando Component Generator is Entando\'s implementation of  JHipster  that allows users to\nquickly and efficiently generate the skeleton of an Entando Component. The Entando Component Generator provides advanced\ndata modeling capabilities including object relational mapping and automatic generation of micro frontends and microservices.\nThe generated skeleton serves as a starting point to help a development team swiftly meet the needs of the business. \n See also:  Entando JHipster Blueprint \n Entando Component Repository \n The  Entando Component Repository  (ECR) is used to store and retrieve shareable components so they can be used in multiple\nEntando applications across the enterprise. \n Entando Identity Management \n Entando Identity Management  is the  Keycloak -based token-based authentication mechanism used by the\nEntando platform. It provides the ability to add Single Sign On capabilities across multiple domains and to connect service\nproviders with identity providers. \n See also:  Entando Authentication \n Entando WCMS \n The Entando Web Content Management System (WCMS) is a lightweight content and digital asset management system with support\nfor headless operation. It allows management of widgets and html fragments so they can be placed within an Entando application. \n See also:  Content Types  or  Content Templates \n Entando Cluster Citizens \n The purpose of this guide is to give an overview of the members of an Entando cluster and their role. \n Architecture Diagram \n Let’s start with a picture of an Entando cluster and how the various\nmembers interact with each other. \n Members of the Cluster \n An Entando cluster is composed of various citizens which interact with\neach other. Most of these citizens have a Custom Resource Definition\nfile associated with them and are deployable on Kubernetes using the\nEntando operator and controllers. \n EntandoApp \n An Entando application is composed of three parts: \n \n \n Entando App Builder : the user interface to customize and build an Entando application, as well as interact with the Entando Component Repository. \n \n \n Entando App Engine : the backend APIs providing access to Entando\nservices. \n \n \n Entando Component Manager : the service providing the Entando\nComponent Repository functionality, e.g. listing the available\nbundles, install/uninstall a bundle, etc. \n \n \n The interaction between these three components (and the rest of the\nEntando cluster) use the authorization/authentication features provided\nby Keycloak. \n Entando Component Manager \n As briefly introduced before, the  Entando Component Manager  is able to\nlist the EntandoDeBundles accessible from the EntandoApp and provide the\ninstall/uninstall services to install a bundle on an Entando App. All of\nthese services are made possible by the communication with the Entando\nKubernetes service, the only service of the Entando ecosystem (other\nthan the operator itself) able to interact with the cluster and some of\nthe Entando Custom Resources. \n Entando Kubernetes Service \n The Entando Kubernetes Service is part of the Entando cluster\ninfrastructure custom resource, and provides an access point to some of\nthe custom resources defined by Entando, in particular: \n \n \n Entando applications \n \n \n Entando plugins \n \n \n Entando links \n \n \n Entando Component Repository bundles \n \n \n Some of the main services provided by the Entando Kubernetes Service\nare: \n \n \n Provide a list of the available EntandoDeBundles to the\ncomponent-manager \n \n \n Deploy a plugin during the installation of a bundle or discovery of\nan already available plugin and expose that to an app \n \n \n Create a link between an EntandoApp and an EntandoPlugin to expose\nthe plugin’s APIs to the EntandoApp and the micro frontends (MFEs) \n Entando Component Repository Bundles \n An EntandoDeBundle - or Component Repository bundle - is a package with\na set of Entando components and resources. The Entando Component Manager\nis able to read these kinds of packages and install the components to\nextend the functionalities of an EntandoApp. For more details on the\nEntandoDeBundle and the Entando Component Repository, check the\n Component Repository Overview \ndocumentation. \n Entando Plugin \n An Entando plugin is a microservice that exposes APIs reusable by one or\nmore Entando apps. Usually the plugin services are exposed to the\nEntando developer and the end users via micro frontends. Check the\n micro frontends  tutorials for more details. You can\nquickly generate an Entando plugin using the  Entando JHipster Blueprint . The generated project will be ready to work in an Entando environment providing the\nintegration with Keycloak, generating a set of default micro frontends\nand exposing the plugin’s logic via an EntandoDeBundle (check the\nreferences for details). \n Keycloak \n Keycloak is responsible for authorization and\nauthentication on Entando. All members of an Entando cluster interact with\nKeycloak to verify user/service authorization to perform any specific\ntask. Check out the references below for more details on Keycloak. \n Entando Ingresses \n What is an Ingress? \n An Ingress is a Kubernetes resource which purpose is to expose HTTP and HTTPS routes from outside the cluster to services within the cluster. Traffic routing is controlled by rules defined on the Ingress resource. \n How Ingresses are used in an Entando Cluster \n When deploying an Entando Cluster, ingresses are generated for the resources that requires to be exposed to the outside world. The process of creating an ingress, setup the correct routes and the certificates is done by the via the Entando Operator and the entando custom resource controllers. \n Keycloak Ingress \n A dedicated ingress is created for Keycloak to expose the authentication and authorization functionalities. A dedicated ingress is required to guarantee that both token issuing and token validation work correctly, even when the services using the Keycloak instance are on different namespaces. \n EntandoApp Ingress \n Another ingress is automatically created to expose App Builder, App Engine and the Entando Component Manager, a service part of the ECR.\nThe three containers are served under the same domain. This is beneficial since they are able to interact without cross-origin issues. \n The Entando App ingress is also used when linking an Entando Plugin with and Entando App, operation that usually happens when a bundle containing an Entando Plugin is installed via the ECR in an Entando App. Check out the dedicated section for details. \n Entando Plugin Ingress \n Entando Plugins are automatically exposed via an ingress when deployed in an Entando Cluster. \n Default Ingress HTTP Routes \n In this table you can see what are the default routes that are exposed for each ingress\n \n \n \n \n \n \n \n Ingress \n Ingress Http route \n Application \n \n \n \n \n Keycloak ingress \n /auth \n Keycloak \n \n \n Entando App ingress \n /entando-de-app \n App engine \n \n \n /app-builder/ \n App builder \n \n \n /digital-exchange \n Entando component manager \n \n \n /plugin-ingressPath \n Entando plugin linked to the app \n \n \n Entando plugin ingress \n /plugin-ingressPath \n Entando plugin \n \n \n \n Note : The Entando plugin variable  ingressPath  is defined in the Entando Plugin custom resource under the  spec  element. The plugin ingress path is also used to expose the plugin within the EntandoApp domain. \n Exposing Plugins in the EntandoApp Domain \n The process of exposing an Entando Plugin under the same domain (ingress) of the Entando App is made possible from the creation of an  EntandoAppPluginLink  custom resource and the corresponding controller. \n Once the link between the Entando App and the Entando Plugin is created, the controller reads the specification of the link and automatically creates the HTTP routes in the Entando App so that the plugin is exposed on the same domain as the App builder, App engine and Component Manager. \n This allows the micro frontend developers, who need access to the plugin, to disregard CORS policy and the full path where the plugin is exposed. The plugin can be referenced using relative URLs. \n How to Check Ingresses in my Cluster \n Using the Openshift Dashboard \n On the Openshift dashboard, ingresses are not exposed directly as pods and deployments. The dashboard provides direct access to the Ingress Routes (or simply routes) under the  Applications  →  Routes  menu. \n \n To see the ingress resources, you need to access them from the  Resources   →  Other resources  menu. From the dropdown, select the  Ingress  resource and you should be able to see the ingress available on that specific project/namespace. \n Using kubectl from the Command Line \n Once you know the namespace(s) where your Entando Cluster is deployed, use the following command from the command line. \n kubectl get ingresses.extensions -n YOUR-NAMESPACE\n \n Here an example of the result in a test namespace \n > kubectl get ingresses.extensions -n local\n\nNAME                               CLASS    HOSTS                             ADDRESS         PORTS   AGE\ndefault-sso-in-namespace-ingress   <none>   quickstart.192.168.64.15.nip.io   192.168.64.15   80      19d\nquickstart-ingress                 <none>   quickstart.192.168.64.15.nip.io   192.168.64.15   80      19d\n \n To get more details about a specific ingress, you can use the  get  command specifying the ingress name you want to check and the  yaml  output format. \n > kubectl get ingresses.extensions -n local qst-ingress -o yaml\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  creationTimestamp: "2020-05-13T15:27:08Z"\n  generation: 1\n  labels:\n    EntandoApp: qst\n  managedFields:\n  - apiVersion: extensions/v1beta1\n    fieldsType: FieldsV1\n    fieldsV1:\n      f:status:\n        f:loadBalancer:\n          f:ingress: {}\n    manager: nginx-ingress-controller\n    operation: Update\n    time: "2020-05-13T15:27:08Z"\n  name: qst-ingress\n  namespace: local\n  ownerReferences:\n  - apiVersion: entando.org/v1\n    blockOwnerDeletion: true\n    controller: true\n    kind: EntandoApp\n    name: qst\n    uid: aa7053e1-fd8b-419f-bdee-df3018c013fa\n  resourceVersion: "16802097"\n  selfLink: /apis/extensions/v1beta1/namespaces/local/ingresses/qst-ingress\n  uid: e9b6f027-369a-4b84-b4b1-736a6e49f180\nspec:\n  rules:\n  - host: local.192.168.1.9.nip.io\n    http:\n      paths:\n      - backend:\n          serviceName: qst-server-service\n          servicePort: 8080\n        path: /entando-de-app\n        pathType: ImplementationSpecific\n      - backend:\n          serviceName: qst-server-service\n          servicePort: 8083\n        path: /digital-exchange\n        pathType: ImplementationSpecific\n      - backend:\n          serviceName: qst-server-service\n          servicePort: 8081\n        path: /app-builder/\n        pathType: ImplementationSpecific\nstatus:\n  loadBalancer:\n    ingress:\n    - ip: 127.0.0.1\n Learn More \n For more details about ingress concepts in Kubernetes, please refer to the official documentation: \n \n Kubernetes Ingress documentation \n \n'},{title:"Development Process on Entando",frontmatter:{sidebarDepth:2},regularPath:"/next/docs/getting-started/development-concepts.html",relativePath:"next/docs/getting-started/development-concepts.md",key:"v-77fc0840",path:"/next/docs/getting-started/development-concepts.html",headers:[{level:2,title:"Create Components",slug:"create-components"},{level:2,title:"Curate and Share Components",slug:"curate-and-share-components"},{level:2,title:"Compose an Application",slug:"compose-an-application"},{level:2,title:"Consume Applications",slug:"consume-applications"}],lastUpdated:"2/11/2022, 2:38:27 PM",lastUpdatedTimestamp:1644608307e3,content:" Development Process on Entando \n With the Entando Platform, the development of an application is organized into four distinct stages: Create, Curate, Compose, and Consume. In the simplest terms, you  create  functional building blocks,  curate  them into a catalog,  compose  the blocks onto a page or a website, which is then  consumed  in an application. \n Entando provides a distributed and composable environment in which components can be independently built, scaled and iterated. This process enables parallel teams to accelerate development and innovation on a cloud- and Kubernetes-native stack. \n Create Components \n The first step in building a modern application on Entando is to design and create each independent component or functional block. Developers can use the  Entando Component Generator  and  Blueprint  to automate the building and packaging of project files, with the flexibility to customize. The modular design of apps built on Entando means new business capabilities can be integrated into your application without reworking existing systems. \n \n \n \n Documentation \n Tutorials \n \n \n \n \n Entando Component Generator \n Micro Frontends \n \n \n Entando Blueprint Feature \n Microservices \n \n \n Component Generation Technologies \n Build and Publish Project Bundles \n Curate and Share Components \n On the Entando Platform, Curate and Share means development teams can bundle and share components within a central catalog. Multiple teams or groups can collaborate on single components or a whole packaged business capability (PBC) across organizations and applications. They can test and assess components for readiness, manage and publish versions and share metadata for continuous upgrades. \n \n \n \n Documentation \n Tutorials \n \n \n \n \n Bundle and Component Descriptors \n Install Bundles from a Private Git Repository \n \n \n Filtering Bundles \n Install Bundle Plugins from a Private Image Repo \n \n \n Customize Bundle Info in App Builder \n \n \n \n Bundle Version and Updates FAQ \n \n \n \n Bundle Uninstall \n Compose an Application \n The Compose stage on Entando is centered around the  Entando App Builder , a low-code composition user interface. In the App Builder, application owners can assemble new components or upgrade existing ones with templates, widgets and fully functional PBCs. The  Entando Component Manager  and  Entando Component Repository  are integrated into the App Builder, making the composing process flexible and agile by managing all your components there. \n \n \n \n Documentation \n Tutorials \n \n \n \n \n Welcome Wizard \n Page Management \n \n \n Entando Component Repository \n Widgets and Fragments \n \n \n Entando App Builder \n Content Creation \n \n \n Entando Component Manager \n Content Templates \n \n \n \n Digital Assets \n Consume Applications \n In the development lifecycle of an application, Consume is the execution stage where end users interact with the app to complete certain tasks. On Entando, the modular design of the components and services means each can be scaled individually or as a whole, according to those interactions. Likewise, content can be added or changed, engine rules adapted and upgrades made seamlessly. As a result, the development cycle is a continuous process with minimal disruptions and faster time to market. \n \n \n \n Documentation \n Tutorials \n \n \n \n \n Accessibility \n External Identity Management System \n \n \n Entando Operator \n Add REST API \n \n \n Entando APIs \n Invoke Entando core APIs \n \n \n Custom Resources \n Change Default Datasource \n \n \n Entando Identity Management System \n \n \n \n \n"},{title:"Getting Started with Entando",frontmatter:{sidebarDepth:2},regularPath:"/next/docs/getting-started/",relativePath:"next/docs/getting-started/README.md",key:"v-d4bd3f66",path:"/next/docs/getting-started/",headers:[{level:2,title:"Try Entando",slug:"try-entando"},{level:2,title:"Learn about Entando",slug:"learn-about-entando"},{level:2,title:"Automatic Install",slug:"automatic-install"},{level:2,title:"Manual Install",slug:"manual-install"},{level:3,title:"Install Kubernetes",slug:"install-kubernetes"},{level:3,title:"Prepare Kubernetes",slug:"prepare-kubernetes"},{level:3,title:"Deploy Entando",slug:"deploy-entando"},{level:2,title:"Login to Entando",slug:"login-to-entando"},{level:2,title:"Next Steps",slug:"next-steps"}],lastUpdated:"4/20/2022, 3:03:28 PM",lastUpdatedTimestamp:1650481408e3,content:" Getting Started with Entando \n WARNING \n Mac:  Entando 7 is not currently compatible with the Apple M1 ARM64 architecture found in some newer Macs. \n Try Entando \n You can set up Entando in two simple steps or install it manually to meet your specific needs. \n \n Automatic Install : The fastest way to locally install and start up Entando in Kubernetes. \n Manual Install : Useful if you want a shared cluster or a custom local instance. \n \n Once you're set up, you can  build a simple bundle and create an app  to try out the platform or walk through the  Welcome Wizard  in our  App Builder . For a more in-depth experience, check out our  Standard Banking Demo . \n Learn about Entando \n Learn about what Entando can do or explore the elements that make developing applications on Kubernetes faster and easier: \n \n Introduction to Entando \n Learning Paths \n Concepts Overview \n Automatic Install \n Automatically install Entando via the Entando command-line interface (CLI) and prepare a local developer environment with default settings.\nThe following steps launch an Ubuntu VM via Multipass, install Kubernetes, then deploy Entando to it. \n \n Install  Multipass \n \n https : //multipass.run/#install \n \n \n Install Entando into Kubernetes on Ubuntu using the  Entando CLI \n \n curl  -sfL https://get.entando.org  |   bash \n \n \n The progress of the install will be displayed on the console. Installation can take 10+ minutes depending on how long the Docker images take to download. The sequence of steps performed by the CLI is identical to the manual steps below. To understand what the CLI does, review the manual steps. \n The URL to access the Entando App Builder will print to the console once the install completes. \n Login with username: admin  and password:  adminadmin . Refer to  Login to Entando  for more information and next steps. \n Manual Install \n Manual installation allows you to configure a shared cluster or customize a local developer environment. The following learn-as-you-go approach gives you a working knowledge of Kubernetes as you get Entando up and running in a local environment. This is a three stage process: \n \n Install Kubernetes \n Prepare the Kubernetes Environment \n Deploy Entando \n \n We've tested a variety of Kubernetes implementations, including Minikube, Minishift, CodeReady Containers, K3s, and Microk8s, to find the optimal combination of low CPU/memory usage, fast startup times, and minimal configuration. After downloading the necessary files, we'll have our own instance of Kubernetes up and running in <60 seconds. \n What's Needed to Run Kubernetes? \n Kubernetes is a container orchestrator designed to manage a server cluster. It requires at least one master node running a Linux OS. A lightweight Ubuntu virtual machine (VM) can be created in seconds with Multipass. Choosing a Type 1 hypervisor eliminates a guest OS, maximizing speed and performance. \n Install Kubernetes \n Enable Hypervisor \n Why a Hypervisor? \n Hypervisors allow you to create and run VMs. Virtualization software that run on top of your operating system as \"guests\" are Type 2 hypervisors, e.g. VirtualBox or VMWare Workstation. Type 1 hypervisors run directly on your host machine. \n \n Install a Type 1 hypervisor for optimal performance. \n Mac:  Install  hyperkit \n brew  install  hyperkit\n \n Windows:   Install Hyper-V \n \n What if my machine doesn't support hyperkit or Hyper-V? \n Install a Type 2 hypervisor that runs on top of your operating system. \n \n Install Virtual Box:\n Mac \n Windows \n Launch an Ubuntu VM \n Why Multipass? \n Multipass is a cross-platform tool developed by the publishers of Ubuntu to create lightweight Ubuntu VMs in seconds. \n \n \n \n Install  Multipass \n \n \n Launch a VM \n \n \n multipass launch --name quickstart --cpus  4  --mem 8G --disk 20G\n \n \n Open a VM shell \n \n multipass shell quickstart\n Run Kubernetes \n Why K3s? \n K3s is a certified Kubernetes distribution designed for production workloads in resource-constrained environments. \n It's packaged as a single <50MB binary that minimizes the dependencies and procedure required to install, run and auto-update a production Kubernetes cluster. \n \n \n Install the version of  K3s  supported by Entando 7.0. Note that this is not the latest version of K3s. \n \n curl  -sfL https://get.k3s.io  |   INSTALL_K3S_CHANNEL = \"v1.21.10+k3s1\"   sh  -\n \n \n Check that the cluster  STATUS  is  Ready . \n \n sudo  kubectl get  node \n \n \n What's running out of the box? \n sudo  kubectl get pods -A\n \n \n \n Congratulations! \n You now have a local instance of Kubernetes up and running. \n \n Now that Kubernetes is running, you can use kubectl to send commands directly to K3s from the host machine, rather than from within the VM. To set this up with the  ent CLI , run  ent attach-vm quickstart  and then use  ent kubectl  for any calls to K8s. Alternatively, see the K3s documentation to  access your cluster with kubectl . \n Prepare Kubernetes \n To install Entando, we'll add  Custom Resources , create a  Namespace  and configure external access to our cluster. \n Create a Namespace \n What are Namespaces? \n Kubernetes supports multiple virtual clusters backed by the same physical cluster. These virtual clusters are called  namespaces . You can use namespaces to allocate resources and set CPU/memory limits for individual projects or teams. \n \n sudo  kubectl create namespace entando\n Add Custom Resources \n Why Custom Resources? \n Standard resources in Kubernetes include  Pods , which are groups of one or more containers,  Services  to call or access Pods, and  Ingresses  to enable external access to Services. \n Custom resources  let you store and retrieve structured data. Combining a custom resource with a custom controller allows you to define a desired state to automate how your applications or services run in a Kubernetes cluster. \n \n Examples of custom resources in Entando are the  Entando App Engine  and the  Entando Identity Management System . \n From your Ubuntu shell \n \n Install the cluster-scoped custom resource definitions (CRDs) \n \n sudo  kubectl apply -f https://raw.githubusercontent.com/entando/entando-releases/v7.0.0/dist/ge-1-1-6/namespace-scoped-deployment/cluster-resources.yaml\n \n \n Install the namespace-scoped custom resources \n \n sudo  kubectl apply -n entando -f https://raw.githubusercontent.com/entando/entando-releases/v7.0.0/dist/ge-1-1-6/namespace-scoped-deployment/namespace-resources.yaml\n Configure Access to Your Cluster \n What about Networking? \n Entando sets up  Ingresses  in Kubernetes to expose HTTP routes from outside the cluster to services within the cluster. This is used to access Entando from a local browser. \n If you run into network issues during startup, or if you are using Windows for your local development instance, you'll need to  troubleshoot your network . Indications of network issues can include Entando failing to completely start or a working Entando instance failing to restart later. \n \n To set up external access to your cluster, you need to specify the fully qualified domain of your Ubuntu VM, which we refer to via the placeholder YOUR-HOST-NAME. \n \n \n On Windows with Hyper-V, YOUR-HOST-NAME is the name of your VM followed by  .mshome.net , e.g.  quickstart.mshome.net . \n \n \n On Mac, Linux, or Windows without Hyper-V, you'll use a host name based on your VM's IP address. You can determine the IP address from within the VM with this command: \n \n \n hostname  -I  |   awk   '{print $1}' \n \n \n Your IP-based YOUR-HOST-NAME should follow this pattern:  quickstart.YOUR-IP.nip.io , e.g.  quickstart.192.168.64.33.nip.io . The suffix  .nip.io  makes use of the free  nip.io  DNS service so that any requests to this host name will resolve to your VM. The prefix  quickstart  is arbitrary so you can choose your own. \n \n Now that you've determined YOUR-HOST-NAME, use it to configure the Entando Application. \n \n Download the template  entando-app.yaml . \n \n curl -sLO \"https://raw.githubusercontent.com/entando/entando-releases/v7.0.0/dist/ge-1-1-6/samples/entando-app.yaml\"\n \n \n Modify  entando-app.yaml  to set the  ingressHostName  to YOUR-HOST-NAME. Examples: \n \n \n ingressHostName : quickstart.mshome.net \n ingressHostName : quickstart.192.168.63.33.nip.io \n \n Embedded Databases \n To speed up the  Getting Started  environment, embedded databases are used by default.\nSee this  Tutorial on Default Databases  for information on how to change your database connection, or you can modify the  dbms  setting in the  entando-app.yaml . \n \n Entando Operator \n An optional ConfigMap can be used to modify the behavior of the Entando Operator. For example, on a slower network, you may want to increase the download timeouts. Refer to the  Entando Operator  page for more information. \n Deploy Entando \n Deploy Entando by applying  entando-app.yaml  to your namespace. \n sudo  kubectl apply -f entando-app.yaml -n entando\n \n \n Use the  get pods --watch  command to observe Entando starting up. \n sudo  kubectl get pods -n entando --watch\n \n What does a successful startup look like? \n \n The  entando-operator  and  entando-k8s-service  start when you apply the namespace resources above, so they should already be in the  Running  status by the time you reach this point \n When you apply the  entando-app.yaml , the  quickstart-deployer  starts and kicks off a series of deployments, beginning with the Keycloak deployment via the  default-sso-in-namespace-deployer \n \n Jobs / Deployments \n \n Some Pods, like  quickstart-deployer , run to completion and then shutdown; they should eventually show  READY :  0/1  and  STATUS :  Completed \n Other deployments, like  quickstart-ab-deployment  or  quickstart-deployment , should eventually show  READY :  1/1  and  STATUS :  Running \n The deployment is finished when the  quickstart-deployer  Pod shows a status of  Completed \n \n Lifecycle Events \n \n Each line represents an event:  Pending ,  ContainerCreating ,  Running  or  Completed \n Restarts should ideally be  0 ; otherwise, there may be a resource problem (slow network, not enough CPU or memory, etc.) with your cluster, and Kubernetes is trying to self-heal \n \n NAME                                                  READY   STATUS              RESTARTS  AGE    \nentando-operator-5b5465788b-s6wjh                    1/1     Running             0          99m\nentando-k8s-service-86f8954d56-lp5nl                 1/1     Running             0          99m\nquickstart-deployer-7217                             0/1     ContainerCreating   0          7s\nquickstart-deployer-7217                             1/1     Running             0          14s\ndefault-sso-in-namespace-deployer-2045               0/1     Pending             0          0s\ndefault-sso-in-namespace-deployer-2045               0/1     Pending             0          0s\ndefault-sso-in-namespace-deployer-2045               0/1     ContainerCreating   0          0s\ndefault-sso-in-namespace-deployer-2045               1/1     Running             0          4s\ndefault-sso-in-namespace-deployment-7ddc5d44f-bsq7w  0/1     Pending             0          0s\ndefault-sso-in-namespace-deployment-7ddc5d44f-bsq7w  0/1     Pending             0          5s\ndefault-sso-in-namespace-deployment-7ddc5d44f-bsq7w  0/1     ContainerCreating   0          5s\ndefault-sso-in-namespace-deployment-7ddc5d44f-bsq7w  0/1     Running             0          88s\ndefault-sso-in-namespace-deployment-7ddc5d44f-bsq7w  0/1     Running             0          114s\ndefault-sso-in-namespace-deployment-7ddc5d44f-bsq7w  1/1     Running             0          115s\ndefault-sso-in-namespace-deployer-2045               0/1     Completed           0          2m6s\ndefault-sso-in-namespace-deployer-2045               0/1     Terminating         0          2m6s\ndefault-sso-in-namespace-deployer-2045               0/1     Terminating         0          2m6s\nquickstart-ab-deployment-5b5c7c4f5c-w774v            0/1     Pending             0          0s\nquickstart-ab-deployment-5b5c7c4f5c-w774v            0/1     Pending             0          0s\nquickstart-ab-deployment-5b5c7c4f5c-w774v            0/1     ContainerCreating   0          0s\nquickstart-deployment-667859b44d-nnk79               0/1     Pending             0          0s\nquickstart-cm-deployment-69bb5f9fd8-ll8dk            0/1     Pending             0          0s\nquickstart-deployment-667859b44d-nnk79               0/1     Pending             0          2s\nquickstart-deployment-667859b44d-nnk79               0/1     ContainerCreating   0          2s\nquickstart-cm-deployment-69bb5f9fd8-ll8dk            0/1     Pending             0          2s\nquickstart-cm-deployment-69bb5f9fd8-ll8dk            0/1     ContainerCreating   0          3s\nquickstart-cm-deployment-69bb5f9fd8-ll8dk            0/1     Running             0          88s\nquickstart-ab-deployment-5b5c7c4f5c-w774v            0/1     Running             0          102s\nquickstart-ab-deployment-5b5c7c4f5c-w774v            0/1     Running             0          2m\nquickstart-cm-deployment-69bb5f9fd8-ll8dk            0/1     Running             0          2m3s\nquickstart-ab-deployment-5b5c7c4f5c-w774v            1/1     Running             0          2m10s\nquickstart-cm-deployment-69bb5f9fd8-ll8dk            1/1     Running             0          2m12s\nquickstart-deployment-667859b44d-nnk79               0/1     Running             0          3m29s\nquickstart-deployment-667859b44d-nnk79               0/1     Running             0          4m50s\nquickstart-deployment-667859b44d-nnk79               1/1     Running             0          4m52s\nquickstart-deployer-7217                             0/1     Completed           0          7m17s\nquickstart-deployer-7217                             0/1     Terminating         0          7m17s\nquickstart-deployer-7217                             0/1     Terminating         0          7m17s\n \n \n \n Press  Ctrl-C  to exit the  watch  command once everything is up and running. \n \n What Pods come out of the box? \n sudo  kubectl get pods -n entando\n \n NAME                                                  READY   STATUS    RESTARTS   AGE\nentando-operator-5b5465788b-s6wjh                     1/1     Running   0          106m\nentando-k8s-service-86f8954d56-lp5nl                  1/1     Running   0          106m\ndefault-sso-in-namespace-deployment-7ddc5d44f-bsq7w   1/1     Running   0          7m4s\nquickstart-ab-deployment-5b5c7c4f5c-w774v             1/1     Running   0          5m1s\nquickstart-cm-deployment-69bb5f9fd8-ll8dk             1/1     Running   0          5m\nquickstart-deployment-667859b44d-nnk79                1/1     Running   0          5m\n\n \n \n \n The URL of your running Entando instance is http://YOUR-HOST-NAME/app-builder/. \n \n Example URL \n \n quickstart.192.168.64.33.nip.io/app-builder/\n Login to Entando \n Now that you've installed Entando, login to the Entando App Builder. \n \n \n Username:  admin \n Password:  adminadmin \n \n After login, change your password to activate your account. \n \n Note: If the login process hangs for more than 5 seconds, refresh the browser. \n \n \n In the App Builder, applications are composed from various components, including micro frontends and CMS content. \n Congratulations! \n You now have Entando up and running on Kubernetes in your local environment. \n Next Steps \n Check out these resources to continue your journey with Entando! \n \n \n Build Your First Application:  Use the  Welcome Wizard  to build your first application via guided prompts. \n \n \n Try a Tutorial:  Take advantage of the  Learning Paths , which organize a few of the most popular tutorials by user type. \n \n \n Dig Deeper into Entando Concepts:  Review the  Docs  sections to more deeply understand the Entando building blocks. \n \n \n Learn about the Quickstart Environment:  See the  Quickstart Tips  for more information on how to manage your Getting Started or quickstart environment. \n \n \n \n"},{title:"Entando Solution Templates",frontmatter:{sidebarDepth:2},regularPath:"/next/docs/getting-started/landing-page.html",relativePath:"next/docs/getting-started/landing-page.md",key:"v-4f033390",path:"/next/docs/getting-started/landing-page.html",headers:[{level:2,title:"Entando Customer Portal",slug:"entando-customer-portal"},{level:2,title:"Entando Hub",slug:"entando-hub"},{level:2,title:"Entando Process Driven Applications Plugin",slug:"entando-process-driven-applications-plugin"},{level:2,title:"Entando Standard Banking Demo",slug:"entando-standard-banking-demo"}],lastUpdated:"1/29/2022, 1:14:41 PM",lastUpdatedTimestamp:1643480081e3,content:" Entando Solution Templates \n The Entando Application Composition Platform offers several Solution Templates to demonstrate various business capabilities and integrations: \n \n Entando Customer Portal \n Entando Hub \n Entando Process Driven Applications Plugin \n Entando Standard Banking Demo \n \n Each open source Solution Template was built with Entando and can be used as-is, reviewed for common development practices, or leveraged as a useful starting point for a related application. \n The following Solution Templates and other sets of components are available in the  public Entando Hub  for installation in a user environment, where turnkey functionality can be customized and extended. \n Entando Customer Portal \n The  Entando Customer Portal  streamlines development of a customer-facing, self-service subscription management application. The platform integrates Keycloak role based access control and Jira Service Management as a ticket tracking system. \n Entando Hub \n The  Entando Hub  empowers a team to share and collaborate on proprietary or Entando open source components. Capabilities, versions and metadata can be transparently analyzed, managed and published. \n Entando Process Driven Applications Plugin \n The  Entando Process Driven Applications Plugin  provides a comprehensive and versatile automation scheme for Business Process Management. It comprises a custom UX layer, a Spring Boot Backend for Frontend microservice interface, and integration with the  Red Hat Process Automation Manager . \n Entando Standard Banking Demo \n The  Entando Standard Banking Demo  showcases the benefits and possibilities of a composable application built from modular components. The example banking environment integrates a transaction table, sign up form, alert icon, and summary cards to demonstrate MFE communication and capabilities. Prominent features include Keycloak role based access control, coexistence of React and Angular MFEs, and pluggable Spring Boot microservices. \n \n"},{title:"Entando Deployment Structure",frontmatter:{sidebarDepth:2},regularPath:"/next/docs/reference/deployment-structure.html",relativePath:"next/docs/reference/deployment-structure.md",key:"v-9fd918ac",path:"/next/docs/reference/deployment-structure.html",headers:[{level:2,title:"entando-operator",slug:"entando-operator"},{level:2,title:"database init containers",slug:"database-init-containers"},{level:2,title:"entando-de-app",slug:"entando-de-app"},{level:2,title:"app-builder",slug:"app-builder"},{level:2,title:"component-manager(cm)",slug:"component-manager-cm"},{level:2,title:"entando-k8s-service",slug:"entando-k8s-service"},{level:2,title:"keycloak",slug:"keycloak"},{level:2,title:"Other Key Repositories",slug:"other-key-repositories"},{level:3,title:"entando-core",slug:"entando-core"},{level:3,title:"entando-cms",slug:"entando-cms"},{level:3,title:"entando-components",slug:"entando-components"},{level:3,title:"Entando Kubernetes Controllers",slug:"entando-kubernetes-controllers"}],lastUpdated:"4/14/2022, 1:19:13 PM",lastUpdatedTimestamp:1649956753e3,content:" Entando Deployment Structure \n This page provides a high level overview of the key Entando GitHub repositories along with a brief description\nof how those repositories are realized in a running Entando deployment. The descriptions provided here are meant\nas a guide for identifying opportunities to dig deeper into the architecture and how things are structured\nrather than a panacea for understanding the architecture. \n entando-operator \n The Entando operator coordinates the installation and configuration of all of the components of an Entando\nCluster. The operator can be installed once per Entando Cluster and used to coordinate the plugin lifecycle for\nmultiple Entando applications across many namespaces. \n \n GitHub:  https://github.com/entando-k8s/entando-k8s-controller-coordinator/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-k8s-controller-coordinator \n Customization \n It is unlikely that the operator will be customized as part of an Entando implementation. It is not built to\nbe extended inside the codebase. The most common pattern will be to use the existing custom resources that the\noperator knows how to deploy to extend the Entando platform. \n database init containers \n During installation, an Entando application needs to create several databases and initialize those\ndatabases with information when deploying from a backup in your images. At initialization, the  entando-k8s-dbjob \nwill be run 5 times in total. Once for keycloak, twice for the entando application (port and serv dbs), once to\npopulate the Entando application database, and once to create the Component Repository database. \n \n GitHub:  https://github.com/entando-k8s/entando-k8s-dbjob \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-k8s-dbjob \n \n The screenshot below highlights the init containers for the Entando application schema creation, db\ninitialization, and component repository database. \n \n Many managed kubernetes instances like OpenShift won’t show init containers in their dashboards. So if you’re\ntroubleshooting you may need to look deeper. When fetching logs for an init container using kubectl, you must\npass the container name as an argument to the call. For example, \n     kubectl logs <pod> -c <container> -n <namespace>        \n    kubectl logs default-sso-in-namespace-deployment-db-preparation-job-ddbdbddb-a  -c default-sso-in-namespace-deployment-db-schema-creation-job -n sprint1-rc\n Customization \n It is unlikely that the init containers will be customized as part of an Entando project. The init containers\nwill automatically restore a backup included in your application so that you can create custom images that\ninclude your application setup.\nSee  Backing Up and Restoring Your Environment . \n entando-de-app \n The  entando-de-app  is a J2EE application and is an instance of the  entando-core  (see a description of the\n entando-core  repo below). Reviewing the dependencies of this application in the pom.xml will reveal the\ndependencies on the  entando-core ,  entando-engine , and  admin-console  which encompass the core\nfunctionality in versions of Entando prior to Entando 6. In a quickstart deployment the  entando-de-app  is deployed as part of the  entando-composite-app  multi\ncontainer pod. \n \n GitHub:  https://github.com/entando/entando-de-app/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-de-app-eap , https://hub.docker.com/repository/docker/entando/entando-de-app-wildfly \n Customization \n The  entando-de-app  is very likely to be customized as part of an Entando implementation. This image can be\ncustomized with new APIs, legacy Entando plugins, new database tables, or other extensions to the  entando-core .\nIt is highly recommended that most extensions to the platform on Entando occur in microservices. However, legacy\nintegrations, extensions to the CMS, and migrations from earlier Entando versions may require changes to the  entando-de-app . \n app-builder \n The  app-builder  is the front end of the  entando-de-app . It communicates with the  entando-de-app  via  REST\nAPIs . The  app-builder  is a React JS application and is served via node in the default\ndeployment. In a quickstart deployment, the  app-builder  container is deployed in the  entando-app \nmultiple container pod. The  app-builder  also communicates with the Component Manager via REST API to fetch\ninformation about Entando bundles deployed to the Entando Component Repository (ECR). \n \n GitHub:  https://github.com/entando/app-builder/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/app-builder/ \n Customization \n The  app-builder  is customized as part of many Entando implementations.\nIt can be customized at runtime via micro frontends\n widget configuration . \n component-manager(cm) \n The  component-manager  provides the link between the entando-de-app (or your custom core instance) and the ECR. The  component-manager  queries the entando-k8s service to fetch available\nbundles that have been deployed as custom resources inside of an Entando cluster.\nThe  component-manager  also manages the relationships between an Entando application and the\ninstalled plugins. This can be seen in the plugin link custom resources in Kubernetes. \n \n GitHub:  https://github.com/entando-k8s/entando-component-manager/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-component-manager/ \n Customization \n It is unlikely that the  component-manager  will be customized as part of an Entando implementation. \n entando-k8s-service \n The  entando-k8s-service  acts as an abstraction layer to fetch data from kubernetes APIs. The primary\nfunctionality is in discovering and making available for installation Entando plugins. The\n entando-k8s-service  is invoked by the  component-manager . \n \n GitHub:  https://github.com/entando-k8s/entando-k8s-service/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-k8s-service/ \n Customization \n It is very unlikely that the  entando-k8s-service  will be customized as part of an Entando implementation. \n keycloak \n The  entando-keycloak  project is an extension of the base Keycloak images. The extension provides the default\nthemes for Entando, a customized realm and clients, and adds the Oracle ojdbc jars for connection to Oracle\ndatabases. \n \n GitHub:  https://github.com/entando/entando-keycloak/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-keycloak/ \n Customization \n The keycloak image will often be customized as part of an Entando implementation. Common extensions will\ninclude changing the theme, adding default connections, adding default social logins, adding default clients,\nor other changes. \n Other Key Repositories \n entando-core \n The entando-core project is a J2EE application that exposes APIs for the Entando CMS, includes the legacy\nadmin console, and includes the portal-ui project that performs the server side composition for pages\nrendered via an Entando application. Note that only the composition is performed server side.\nJavascript code is rendered on the client. The entando-core is realized via an instance that includes the\nWAR files generated from a core build as dependencies. In a default deployment this is the  entando-de-app . \n \n GitHub:  https://github.com/entando/entando-core/ \n DockerHub: None (deployed to maven central) \n Customization \n For users familiar with versions prior to Entando 6, there will be cases where the  entando-core  is customized.\nIn most cases, these customizations will be delivered via a WAR overlay in the instance project.\nUsing a WAR overlay is a functional approach for users already familiar with the process, but it is highly\nrecommended to extend the platform using microservices for new projects. \n entando-cms \n The  entando-cms  project is the  app-builder  (React JS) side of the Entando WCMS. It is bundled into the\n app-builder  at build time and will be included in the default deployment of the  app-builder  in almost all cases. \n \n GitHub:  https://github.com/entando/entando-cms/ \n DockerHub: None (deployed to npm) \n Customization \n In some cases the  entando-cms  may be customized if new custom features are added to CMS specific\nfunctionality. However, most cases will use the more general  app-builder  extension points noted above.\nThe  entando-cms  does not expose any dedicated extension interfaces outside of those already provided by the\n app-builder . \n entando-components \n The entando-components project is a collection of legacy plugins for Entando 5 and earlier. These plugins are deployed as WAR dependencies in an entando-core instance. \n \n GitHub:  https://github.com/entando/entando-components/ \n DockerHub: None (deployed to maven central) \n Entando Kubernetes Controllers \n There are a number of controllers that are available to the Entando operator to manage installations and\ncomponents in an Entando Cluster. Those controllers are small and lightweight images that are executed as\nrun to completion pods to manage the installation flow for different parts of the infrastructure. The\ncontrollers are implemented using Quarkus. For more information on the controllers, the Entando custom\nresources, and configuring your Entando deployment see also:\n Custom Resources . \n GitHub: \n \n https://github.com/entando-k8s/entando-k8s-composite-app-controller/ \n https://github.com/entando-k8s/entando-k8s-plugin-controller/ \n https://github.com/entando-k8s/entando-k8s-cluster-infrastructure-controller/ \n https://github.com/entando-k8s/entando-k8s-app-controller/ \n https://github.com/entando-k8s/entando-k8s-app-plugin-link-controller/ \n \n DockerHub: \n \n https://hub.docker.com/repository/docker/entando/entando-k8s-composite-app-controller/ \n https://hub.docker.com/repository/docker/entando/entando-k8s-plugin-controller/ \n https://hub.docker.com/repository/docker/entando/entando-k8s-cluster-infrastructure-controller/ \n https://hub.docker.com/repository/docker/entando/entando-k8s-app-controller/ \n https://hub.docker.com/repository/docker/entando/entando-k8s-app-plugin-link-controller/ \n Customization \n It is unlikely that the controllers will be customized as part of an Entando implementation. \n"},{title:"Caching and Clustering in an Entando Application",frontmatter:{},regularPath:"/next/docs/reference/caching-and-clustering.html",relativePath:"next/docs/reference/caching-and-clustering.md",key:"v-c5890230",path:"/next/docs/reference/caching-and-clustering.html",headers:[{level:2,title:"App Engine Clustering and High Availability",slug:"app-engine-clustering-and-high-availability"},{level:2,title:"Storage Requirements for Clustered Entando Applications",slug:"storage-requirements-for-clustered-entando-applications"},{level:2,title:"Caching",slug:"caching"},{level:3,title:"Data Management",slug:"data-management"},{level:2,title:"Redis Implementation",slug:"redis-implementation"},{level:2,title:"Performance",slug:"performance"},{level:3,title:"Cache Management",slug:"cache-management"}],lastUpdated:"4/18/2022, 11:02:29 AM",lastUpdatedTimestamp:1650294149e3,content:' Caching and Clustering in an Entando Application \n App Engine Clustering and High Availability \n The Entando App Engine can be deployed as a clustered set of instances using the clustering and replication ability of Kubernetes. It is backed by a shared cache with two default choices for implementation. \n This guide demonstrates how to configure and test a clustered instance of the Entando App Engine. \n Microservices clustering that adds functionality to an Entando Application is different from clustering used by the Entando App Engine. Microservices rely on a custom clustering configuration and setup based on implementation and selections made during their creation. Refer to documentation addressing  clustered microservices and caching implementation  for configuration and deployment details. \n Storage Requirements for Clustered Entando Applications \n To scale an Entando Application across multiple nodes, a storage class that supports a  ReadWriteMany  access policy must be created. There are a number of ways to accomplish this, inclusive of dedicated storage providers such as GlusterFS. Cloud Kubernetes providers also offer clustered storage options specific to their implementation, such as Google Cloud File in GKE or Azure Files in AKS. \n Two different storage classes can be used for clustered vs. non-clustered storage if the default class doesn\'t support  ReadWriteMany . Add the following properties to the operator ConfigMap: \n entando.k8s.operator.default.clustered.storage.class: "[clustered RWX storage class]"\nentando.k8s.operator.default.non.clustered.storage.class: "[RWO storage class]"\n \n Set both values to the storage class appropriate to the configuration. \n TIP \n To scale an Entando Application without the use of clustered storage assumes all instances are scheduled to a single node and requires a  ReadWriteOnce (RWO)  policy in conjunction with taints on other nodes. Understanding the pros and cons of same-node scheduling is critical for node resource optimization and application recovery should the instance become unreachable. Note that if the node quits or is shut down, the application will be unavailable until Kubernetes reschedules the pods to an alternate node. \n Caching \n Data Management \n At startup, the Entando App Engine will load all database data into the shared cache. Applicable content will be served from the cache when a page is rendered or content is fetched. In the event of a write to the cache, both the cache and database will be updated. \n The following objects are cached in the base implementation of the Entando App Engine: \n \n Pages \n Page templates \n Categories \n Widgets \n Configuration (Application level configuration) \n Roles \n Groups \n Languages \n Labels (i18n) \n User profiles \n API Catalog (legacy API metadata separate from swagger) \n Data models and data types (deprecated) \n Redis Implementation \n An Entando Application can be configured to utilize an external  Redis  cache. In a Redis implementation of an Entando Application, the cache is deployed independently of the Entando App Engine and the Entando App Engine is configured to connect to the deployed instance. \n \n The Redis cache is not deployed by the Entando Operator and must be managed by a DevOps team member or Kubernetes cluster administrator. \n Check out the Caching and Clustering tutorial  for more information and step-by-step instructions to use a Redis cache in an Entando Application. \n Performance \n Consider the following when designing an Entando App Engine cluster: \n \n In a read only implementation, or an implementation with infrequent writes to the cached objects listed above, the network latency between pods on different nodes will not be a major driver of runtime performance. Each pod will have a fully replicated copy of the cache. \n In write heavy implementations, network latency between nodes can factor into performance. \n The overall performance impact of network latency will vary depending upon implementation. Performance is impacted by the types of objects written, the size of those objects, and whether the writes invalidate single or entire lists of objects in the cache. \n \n It is generally recommended that performance testing on clustered instances correlates to the expected runtime traffic pattern of a live application. Every application will have a unique performance profile. \n Cache Management \n When a new replica of an Entando Application joins a cluster of applications, the cache is replicated to that node. If the cache is relatively large or the network is slow, this may add to the total startup time of the new instance. Existing instances will continue to function. \n'},{title:"Cluster Resource Limits",frontmatter:{},regularPath:"/next/docs/reference/cluster-resource-limits.html",relativePath:"next/docs/reference/cluster-resource-limits.md",key:"v-7bc2fb4c",path:"/next/docs/reference/cluster-resource-limits.html",headers:[{level:3,title:"Cluster Resource Limits",slug:"cluster-resource-limits"},{level:3,title:"Bundle size limitations",slug:"bundle-size-limitations"}],lastUpdated:"3/17/2022, 8:12:28 PM",lastUpdatedTimestamp:1647562348e3,content:" Cluster Resource Limits \n Entando needs a well-defined amount of resources in order to start and Kubernetes takes care of using only the needed amount of them.\nHowever, you can choose to impose boundaries on the minimum and maximum used/allocated resources by updating the downloaded  entando.yaml  file and setting the  ENTANDO_K8S_OPERATOR_IMPOSE_DEFAULT_LIMITS  property to true.\nIn this way, Entando will allocate a predefined amount of resources and Kubernetes will act more strictly checking for resource availability. See  Kubernetes resources  for more information. \n By not imposing limits you can minimize initial needed resources and startup time, leaving Kubernetes free to manage its resources as he wants.\nBy imposing limits you can obtain a better-balanced system. \n It's important to note that, accordingly to the Kubernetes documentation, in order to deploy on a namespace with a\n ResourceQuotas  on memory and cpu, \n \n every Container must have a memory request, memory limit, cpu request, and cpu limit \n \n so, in that case, you will need to set  ENTANDO_K8S_OPERATOR_IMPOSE_DEFAULT_LIMITS  to true, otherwise your deploy will fail. \n Here you can see the detailed resource requests/limits per container: \n \n \n \n Component \n Mem requests \n CPU requests \n Mem limits \n CPU limits \n \n \n \n \n AppBuilderDeployableContainer \n 128Mi \n 125m \n 512Mi \n 500m \n \n \n EntandoAppDeployableContainer \n 448Mi \n 375m \n 1792Mi \n 1500m \n \n \n ComponentManagerDeployableContainer \n 192Mi \n 188m \n 768Mi \n 750m \n \n \n EntandoPluginDeployableContainer \n 256Mi \n 250m \n 1024Mi \n 1000m \n \n \n EntandoK8SServiceDeployableContainer \n 192Mi \n 250m \n 768Mi \n 1000m \n \n \n KeycloakDeployableContainer \n 192Mi \n 250m \n 768Mi \n 1000m \n Bundle size limitations \n Entando supports bundles without size limitations, you can install as many bundles as you want and bundles as big as you desire. \n The only thing you have to check is the  <YOUR-APP-NAME>-de-pvc  volume size. Each bundle is installed in that volume, so when it reaches its maximum capacity you will not be able to install bundles anymore. \n You can find  quickstart-de-pvc  volume inside de-container container, that is part of the pod named  <YOUR-APP-NAME>-server-deployment-*** , where asterisks should assume values based on your instance.\nFeel free to set its size accordingly to your needs. \n"},{title:"Manage Entando Databases",frontmatter:{},regularPath:"/next/docs/reference/databases.html",relativePath:"next/docs/reference/databases.md",key:"v-d1257868",path:"/next/docs/reference/databases.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Lightweight, low-config Databases with PostgreSQL and MySQL",slug:"lightweight-low-config-databases-with-postgresql-and-mysql"},{level:2,title:"Existing External Databases",slug:"existing-external-databases"},{level:3,title:"Structure",slug:"structure"},{level:3,title:"How it works",slug:"how-it-works"},{level:3,title:"Keeping track of credentials",slug:"keeping-track-of-credentials"},{level:2,title:"Vendor specific notes",slug:"vendor-specific-notes"},{level:3,title:"Oracle",slug:"oracle"},{level:3,title:"Notes",slug:"notes"},{level:3,title:"MySQL",slug:"mysql"},{level:3,title:"Resulting Connection String",slug:"resulting-connection-string-2"},{level:3,title:"Notes",slug:"notes-2"},{level:3,title:"PostgreSQL",slug:"postgresql"},{level:2,title:"Skipping database preparation",slug:"skipping-database-preparation"},{level:3,title:"How it works",slug:"how-it-works-2"},{level:2,title:"Liquibase Migration",slug:"liquibase-migration"}],lastUpdated:"4/18/2022, 11:02:29 AM",lastUpdatedTimestamp:1650294149e3,content:' Manage Entando Databases \n Overview \n Entando’s Docker images currently support three different relational\ndatabase management systems: PostgreSQL, MySQL and Oracle. With\nPostgreSQL and MySQL. By default, Entando’s will automatically create a\nKubernetes Deployment hosting the database management systems. However,\nfor Oracle, and also for other scenarios that may require it, Entando\nsupports connectivity to existing external databases. This document\nprovides the user with the necessary information to decide how to manage\nEntando’s databases. \n Lightweight, low-config Databases with PostgreSQL and MySQL \n When deploying Entando Custom Resources that require databases to a new\nNamespace, the default behavior for Entando is to create a Kubernetes\nDeployment. It uses the standard OpenShift compliant images. \n This is a fairly low-configuration approach, as Entando will create and\ninitialize the databases transparently. Persistent data is stored on any\nPersistent Volume that meets our Persistent Volume Claim requirements.\nWhen an Entando Custom Resource is redeployed, the Persistent Volumes\nremain in tact. Since the subsequent data initialization is idempotent,\nthe supporting Deployments will scale up and behave as expected. \n Generally our services encapsulate the database they use entirely, and\nprovide facilities to import and export the data without needing any\nknowledge of the internal workings of the underlying data store. For\nmost simple Entando Apps the database doesn’t grow too large and is\nfairly easy to manage. This state of affairs allowed us to keep our\ndatabases isolated from each other, thus allowing for isolated\ndeployments without needing complex coordination of database migration\nfor the different deployment pipelines. \n It is worth noting that these database Deployments are not clustered.\nThe customer is therefore strongly advised to provide redundancy and\nclustering in the form of clustered storage. These database deployments\ndo specify a restartPolicy of \'Always\', so in the event of a\nnon-corrupting failure, the database pod should therefore restart in\nabout 30 seconds. This by no means offers the features of a full\ndatabase cluster, but may suffice for many scenarios. \n However, in more advanced use cases, such as the use of our CMS\nfunctionality, this simplistic approach may not scale. And where there\nis a a centralized database admin team, or where there is a requirement\nto comply to strict organizational governance w.r.t. databases, this\napproach does result in a multitude of databases that may be difficult\nfor the database admin team to manage. \n Existing External Databases \n For this reason, Entando can also be configured to use an existing\ndatabase service provided by the customer. In these scenarios, the\ncustomer is expected to take responbility for the lower level database\noperations such as tablespace creation, permissions and clustering.\nEntando will however still be responsible for creating and populating\nthe tables, indices and foreing keys. Entando will also create all of\nthese in the appropriate table \'container\' for the DBMS in question such\nas a schema (Oracle/PostgreSQL) or a database (MySQL). In order to\nachieve this, Entando installs a dedicated CustomResourceDefinition in\nKubernetes, called an \'EntandoDatabaseService\' \n The idea is for EntandoDatabaseService custom resources to be created in\nthe namespace the EntandoApps and EntandoPlugin that should use them\nwill be created. The EntandoDatabaseService is usually created along\nwith a secret that carries admin credentials to the database in\nquestion. \n Structure \n The EntandoDatabaseService custom resource looks like this: \n  EntandoDatabaseService\nmetadata:\n  name: string, any K8S compliant name\n  namespace: string, the namespace this will be created in\nspec:\n  dbms: string, one of oracle, postgresql or mysql\n  host: string, either an ip address or hostname where the database service is hosted\n  port: integer, the port on which the database service is hosted\n  databaseName: string, the name of the database, only required for PostgreSQL and Oracle\n  secretName: the name of the Secret in the same namespace carrying admin credentials to the database service\n  tablespace: (Oracle only)  the tablespace to use to create the required schemas in\n  jdbcParameters: a map containing name-value pairs for any additional parameters required for the JDBC driver to connect to the database.\n \n The Secret that will provide the admin credentials, identified by the\nabove  secretName  should look like this: \n Secret:\n  name: string, any K8S compliant name\n  namespace: string, the namespace this will be created in\n  stringData:\n    username: string, name of an admin user that can create schemas and other users\n    password: string, password of the above user\n How it works \n In order for the EntandoApp and EntandoPlugin deployer to pick up the\ncorrect database service, the EntandoDatabaseService needs to be created\nBEFORE the EntandoApps and EntandoPlugins are created. There can be\nmultiple EntandoDatabaseServices in the namespace, but they need to\npoint to database services of different vendors, i.e. PostgreSQL, Oracle\nand MySQL. Entando currently cannot enforce any validation but if there\nare two EntandoDatabaseServices that have the same DBMS vendor, it will\nsimply pick the first one and continue. Please ensure that only one\nEntandoDatabaseService exists for each DBMS vendor you need to use. \n Once the appropriate EntandoDatabaseServices have been created, any\nEntandoApp or EntandoPlugin that is created will have to specify the\nappropriate DBMS vendor in their  spec.dbms  property. If the\nEntandoOperator detects an EntandoDatabaseService with a matching DBMS\nvendor, it will continue to create the necessary schemas on the specific\ndatabase. If the EntandoOperator does not detect an\nEntandoDatabaseService with a matching DBMS vendor, it will fall back\nonto its default behaviour which is to create a matching Deployment and\nspin up a database service from the same namespace. If the  spec.dbms \nproperty is not specified on an EntandoApp, the EntandoOperator will\ndefault to PostgreSQL. If the  spec.dbms  property is not specified on\nan EntandoPlugin, the EntandoOperator will assume that the EntandoPlugin\nin question does not require a database and hence bypass any database\nand schema creation. \n When the EntandoOperator processes your Entandoapp or EntandoPlugin with\nan appropriate  spec.dbms  specified, it will create a Schema/User pair\nfor each datasource required. A typical EntandoApp deployment requires 3\ndatasources (portdb,servdb and dedb). Plugins generally only require one\ndatasource (plugindb). \n The database schema and user created will have the same name. The name\nis derived from the name of the EntandoPlugin or EntandoApp by replacing\nall characters that are not ANSI-SQL compliant with an underscore. The\ndatasource name is then suffixed to the schema name. When defining the\nname of your app or plugin, please keep in mind that some DBMS vendors\ndo not support long schema names. Future versions of Entando will allow\nyou to override the schema prefix for an app or plugin, but for now this\nis a limitation one has to keep in mind. \n Keeping track of credentials \n The EntandoOperator generates a Kubernetes Secret for each schema/user\ncombination it creates. The name of this secret is the concatenation of\nthe name of the EntandoApp or EntandoPlugin, the datasource qualifier\nand then the suffix "-secret". For instance, for an EntandoApp called\n"my-app" the "portdb" datasource will have a corresponding Kubernetes\nSecret called "my-app-portdb-secret". The EntandoOperator will never\noverwrite or update an existing database secret. We generate a random\nstring for the password which is generally considered the safest\napproach. If you do however wish to change the password in for the\nresulting user, please remember to update the password on the Kubernetes\nSecret too. Such an operation is however error prone and could result in\nsubsequent deployments failing. \n The EntandoOperator’s schema creation logic is idempotent. If it\ntherefore finds that the generated schema/user combination found in the\nassociated Kuberentes Secret already exists, it won’t do anything.\nHowever, it will attempt to log in, and if it fails to log in, it will\nattempt to create the user. If the user already exists, but with a\ndifferent password than the one in the Kubernetes Secret, all subsequent\ndeployment operations will fail. \n Vendor specific notes \n Oracle \n Example \n   EntandoDatabaseService\n    metadata:\n      name:oracle-service\n    spec:\n      dbms: oracle\n      host: 10.0.0.13\n      port: 1521\n      databaseName: ORCLPDB1.localdomain\n      secretName: oracle-secret\n      tablespace: entando_ts\n      jdbcParameters: {}\n  Secret:\n    metadata:\n      name: oracle-secret\n    stringData:\n      username: admin\n      password: admin123\n Resulting connection string: \n jdbc:oracle:thin:@//10.0.0.13:1521/ORCLPDB1.localdomain \n Notes \n Oracle has some rather complicated rules in building the correct\nconnection string. Please note that for the sake of portability and\nlightweight image we are limited to the thin driver. The  databaseName \ncould also be an Oracle service as opposed to an Oracle  SID . Please\ncoordinate with your Oracle DB Admin to determine exactly what value to\nuse here. We strongly recommend testing your settings with some code or\na tool that constructs JDBC connection. \n When the EntandoOperator prepares the schemas for your EntandoApp or\nEntandoPlugin, it will create a user for every datasource required, and\nas is standard behaviour for Oracle, that user will have its own schema\nwith the same name. Permissions are set up to ensure that one user\ncannot access tables from another user’s schema. Please note that Oracle\nlimits schema names to 30 characters. If you intend to use Oracle,\nplease keep the name of your apps and plugins short enough. The suffixes\nthat we append to the app or plugin name to ensure the resulting schema\nname is unique are usually shorter than 8 characters, so names of about\n20 characters should be safe. \n You can specify which tablespace Entando should use to create the\nschemas in using the  spec.tablespace  property \n ORA-01704: string literal too long \n Entando requires extended datatypes to be activated in Oracle 12c and\nhigher\n( https://oracle-base.com/articles/12c/extended-data-types-12cR1 ) \n MySQL \n Example \n EntandoDatabaseService\n  metadata:\n    name:mysql-service\n  spec:\n    dbms: mysql\n    host: 10.0.0.13\n    port: 3306\n    databaseName:\n    secretName: mysql-secret\n    jdbcParameters:\n       useSSL: "true"\nSecret:\n  metadata:\n    name: mysql-secret\n  stringData:\n    username: admin\n    password: admin123\n Resulting Connection String \n jdbc:mysql://10.0.0.13:3306 \n Notes \n MySQL doesn’t distinguish between schemas and databases. For this reason, no\ndatabaseName is required. The EntandoOperator will therefore create an\nentirely new database for each datasource your EntandoApp or\nEntandoPlugin requires. It will also create a user with the same name as\nthe database with permission set up to ensure one user cannot access the\ndatabase of another user. Please note that MySQL limits database names\nto 63 characters. Keep this in mind when defining the names of your\nEntandoApps and EntandoPlugins \n PostgreSQL \n Example \n   EntandoDatabaseService\n    metadata:\n      name:postgresql-service\n    spec:\n      dbms: postgresql\n      host: 10.0.0.13\n      port: 5432\n      databaseName: my_db\n      secretName: postgresql-secret\n      jdbcParameters: {}\n\n  Secret:\n    metadata:\n      name: postgresql-secret\n    stringData:\n      username: admin\n      password: admin123\n Resulting Connection String \n jdbc:postgresql://10.0.0.13:5432/my_db \n Notes \n PostgreSQL behaves very similar to Oracle when it comes to how it\nassociates a user with its own schema. The current username is used as a\ndefault schema/prefix to resolve tables. As with Oracle, Entando ensures\nthat two users don’t have access to each other’s schemas. \n Skipping database preparation \n When an Entando App is being deployed, there is an operator responsible for the entire deployment process. It also takes care of DB creation and preparation.\nIf you already have a prepared DB (schemas, tables, etc.), you could skip schemas creation and DB preparation of the EntandoApp in order to speed up the deployment process. \n You can achieve this by specifying some properties for the EntandoApp component present in the  entandoapp.yaml  file. \n For  spec.dbms  property you should choose  none , then you should add all needed DB connection parameters.\nAfter updating parameters with the one you need, you should end with a yaml like this: \n      -   kind :   "EntandoApp" \n       metadata : \n         annotations :   { } \n         labels :   { } \n         name :   "example-qs" \n       spec : \n         dbms :   "none" \n         replicas :   1 \n         standardServerImage :  wildfly\n         ingressPath :  /entando - de - app\n         environmentVariables : \n           -   name :  SPRING_DATASOURCE_USERNAME\n             value :  admin\n           -   name :  SPRING_DATASOURCE_PASSWORD\n             value :  adminadmin\n           -   name :  SPRING_DATASOURCE_URL\n             value :   "jdbc:postgresql://192.168.1.82:5432/testdb?currentSchema=admin_qs_dedb" \n           -   name :  SPRING_JPA_DATABASE_PLATFORM\n             value :  org.hibernate.dialect.PostgreSQLDialect\n           -   name :  PORTDB_URL\n             value :   "jdbc:postgresql://192.168.1.82:5432/testdb?currentSchema=admin_qs_portdb" \n           -   name :  PORTDB_USERNAME\n             value :  admin\n           -   name :  PORTDB_PASSWORD\n             value :  adminadmin\n           -   name :  PORTDB_CONNECTION_CHECKER\n             value :  org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLValidConnectionChecker\n           -   name :  PORTDB_EXCEPTION_SORTER\n             value :  org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLExceptionSorter\n           -   name :  SERVDB_URL\n             value :   "jdbc:postgresql://192.168.1.82:5432/testdb?currentSchema=admin_qs_servdb" \n           -   name :  SERVDB_USERNAME\n             value :  admin\n           -   name :  SERVDB_PASSWORD\n             value :  adminadmin\n           -   name :  SERVDB_CONNECTION_CHECKER\n             value :  org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLValidConnectionChecker\n           -   name :  SERVDB_EXCEPTION_SORTER\n             value :  org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLExceptionSorter\n How it works \n Using  spec.dbms: "none"  will cause the operator to skip that initial schema/user creation step entirely.\nThen adding those variables under the  spec.environmentVariables  section will supply connection parameters that will be used by EntandoApp.\nKeep in mind that all these parameters will be applied to each of the containers in the EntandoApp pod and that they will also override existing values. \n Liquibase Migration \n Beginning with Entando 7.0, the Entando App Engine modules will implement automatic Liquibase migrations to manage structural changes to databases running on MySQL or PostgreSQL. \n The parameter provided to the environment variable  DB_MIGRATION_STRATEGY  determines how required updates are applied to components of an existing database. Three database migration modes are supported and govern upgrade behavior: \n \n auto  (default setting): The application starts and databases are updated. Changes are applied to each component introduced in Entando versions 7.0 and later. \n disabled : The application does not start. Database changes are detected but not implemented. The application indicates which components require updates. \n generate_sql : The application does not start but generates the SQL scripts to upgrade databases manually. \n \n'},{title:"Entando 7.x Release Notes",frontmatter:{},regularPath:"/next/docs/releases/",relativePath:"next/docs/releases/README.md",key:"v-8f8b9fb6",path:"/next/docs/releases/",headers:[{level:2,title:"New Features and Major Fixes",slug:"new-features-and-major-fixes"},{level:2,title:"Previous Releases",slug:"previous-releases"}],lastUpdated:"4/20/2022, 1:26:35 PM",lastUpdatedTimestamp:1650475595e3,content:" Entando 7.x Release Notes \n New Features and Major Fixes \n This information will be provided when the next version of Entando is released. \n Previous Releases \n Refer to the  Versions  list in the left navigation menu to access documentation and release notes for previous versions of Entando. \n"},{title:"Aps Core Tag Library",frontmatter:{},regularPath:"/next/docs/reference/freemarker-tags/freemarker-core-tags.html",relativePath:"next/docs/reference/freemarker-tags/freemarker-core-tags.md",key:"v-7fd3ecd6",path:"/next/docs/reference/freemarker-tags/freemarker-core-tags.html",headers:[{level:2,title:"Tag action",slug:"tag-action"},{level:3,title:"Description",slug:"description"},{level:3,title:"Example",slug:"example"},{level:3,title:"Attributes",slug:"attributes"},{level:3,title:"Tag class",slug:"tag-class"},{level:2,title:"Tag categories",slug:"tag-categories"},{level:3,title:"Description",slug:"description-2"},{level:3,title:"Example",slug:"example-2"},{level:3,title:"Attributes",slug:"attributes-2"},{level:3,title:"Tag class",slug:"tag-class-2"},{level:2,title:"Tag checkHeadInfoOuputter",slug:"tag-checkheadinfoouputter"},{level:3,title:"Description",slug:"description-3"},{level:3,title:"Attributes",slug:"attributes-3"},{level:3,title:"Tag class",slug:"tag-class-3"},{level:2,title:"Tag cssURL",slug:"tag-cssurl"},{level:3,title:"Description",slug:"description-4"},{level:3,title:"Example",slug:"example-3"},{level:3,title:"Attributes",slug:"attributes-4"},{level:3,title:"Tag class",slug:"tag-class-4"},{level:2,title:"Tag currentPage",slug:"tag-currentpage"},{level:3,title:"Description",slug:"description-5"},{level:3,title:"Example",slug:"example-4"},{level:3,title:"Attributes",slug:"attributes-5"},{level:3,title:"Tag class",slug:"tag-class-5"},{level:2,title:"Tag currentWidget",slug:"tag-currentwidget"},{level:3,title:"Description",slug:"description-6"},{level:3,title:"Example",slug:"example-5"},{level:3,title:"Attributes",slug:"attributes-6"},{level:3,title:"Tag class",slug:"tag-class-6"},{level:2,title:"Tag fragment",slug:"tag-fragment"},{level:3,title:"Description",slug:"description-7"},{level:3,title:"Attributes",slug:"attributes-7"},{level:3,title:"Tag class",slug:"tag-class-7"},{level:2,title:"Tag freemarkerTemplateParameter",slug:"tag-freemarkertemplateparameter"},{level:3,title:"Description",slug:"description-8"},{level:3,title:"Attributes",slug:"attributes-8"},{level:3,title:"Tag class",slug:"tag-class-8"},{level:2,title:"Tag headInfo",slug:"tag-headinfo"},{level:3,title:"Description",slug:"description-9"},{level:3,title:"Example",slug:"example-6"},{level:3,title:"Attributes",slug:"attributes-9"},{level:3,title:"Tag class",slug:"tag-class-9"},{level:2,title:"Tag i18n",slug:"tag-i18n"},{level:3,title:"Description",slug:"description-10"},{level:3,title:"Example",slug:"example-7"},{level:3,title:"Attributes",slug:"attributes-10"},{level:3,title:"Tag class",slug:"tag-class-10"},{level:2,title:"Tag ifauthorized",slug:"tag-ifauthorized"},{level:3,title:"Description",slug:"description-11"},{level:3,title:"Example",slug:"example-8"},{level:3,title:"Attributes",slug:"attributes-11"},{level:3,title:"Tag class",slug:"tag-class-11"},{level:2,title:"Tag imgURL",slug:"tag-imgurl"},{level:3,title:"Description",slug:"description-12"},{level:3,title:"Example",slug:"example-9"},{level:3,title:"Attributes",slug:"attributes-12"},{level:3,title:"Tag class",slug:"tag-class-12"},{level:2,title:"Tag info",slug:"tag-info"},{level:3,title:"Description",slug:"description-13"},{level:3,title:"Example",slug:"example-10"},{level:3,title:"Attributes",slug:"attributes-13"},{level:3,title:"Tag class",slug:"tag-class-13"},{level:2,title:"Tag internalServlet",slug:"tag-internalservlet"},{level:3,title:"Description",slug:"description-14"},{level:3,title:"Example",slug:"example-11"},{level:3,title:"Attributes",slug:"attributes-14"},{level:3,title:"Tag class",slug:"tag-class-14"},{level:2,title:"Tag nav",slug:"tag-nav"},{level:3,title:"Description",slug:"description-15"},{level:3,title:"Example",slug:"example-12"},{level:3,title:"Attributes",slug:"attributes-15"},{level:3,title:"Tag class",slug:"tag-class-15"},{level:2,title:"Tag outputHeadInfo",slug:"tag-outputheadinfo"},{level:3,title:"Description",slug:"description-16"},{level:3,title:"Attributes",slug:"attributes-16"},{level:3,title:"Tag class",slug:"tag-class-16"},{level:2,title:"Tag pageInfo",slug:"tag-pageinfo"},{level:3,title:"Description",slug:"description-17"},{level:3,title:"Attributes",slug:"attributes-17"},{level:3,title:"Tag class",slug:"tag-class-17"},{level:2,title:"Tag pager",slug:"tag-pager"},{level:3,title:"Description",slug:"description-18"},{level:3,title:"Example",slug:"example-13"},{level:3,title:"Attributes",slug:"attributes-18"},{level:3,title:"Tag class",slug:"tag-class-18"},{level:2,title:"Tag parameter",slug:"tag-parameter"},{level:2,title:"Tag pager",slug:"tag-pager-2"},{level:3,title:"Description",slug:"description-19"},{level:3,title:"Example",slug:"example-14"},{level:3,title:"Attributes",slug:"attributes-19"},{level:3,title:"Tag class",slug:"tag-class-19"},{level:2,title:"Tag printHeadInfo",slug:"tag-printheadinfo"},{level:3,title:"Description",slug:"description-20"},{level:3,title:"Attributes",slug:"attributes-20"},{level:3,title:"Tag class",slug:"tag-class-20"},{level:2,title:"Tag resourceURL",slug:"tag-resourceurl"},{level:3,title:"Description",slug:"description-21"},{level:3,title:"Example",slug:"example-15"},{level:3,title:"Attributes",slug:"attributes-21"},{level:3,title:"Tag class",slug:"tag-class-21"},{level:2,title:"Tag show",slug:"tag-show"},{level:3,title:"Description",slug:"description-22"},{level:3,title:"Example",slug:"example-16"},{level:3,title:"Attributes",slug:"attributes-22"},{level:3,title:"Tag class",slug:"tag-class-22"},{level:2,title:"Tag url",slug:"tag-url"},{level:3,title:"Description",slug:"description-23"},{level:3,title:"Example",slug:"example-17"},{level:3,title:"Attributes",slug:"attributes-23"},{level:3,title:"Tag class",slug:"tag-class-23"},{level:2,title:"Tag pageWithWidget",slug:"tag-pagewithwidget"},{level:3,title:"Description",slug:"description-24"},{level:3,title:"Example",slug:"example-18"},{level:3,title:"Attributes",slug:"attributes-24"},{level:3,title:"Tag class",slug:"tag-class-24"},{level:2,title:"Tag currentUserProfileAttribute",slug:"tag-currentuserprofileattribute"},{level:3,title:"Description",slug:"description-25"},{level:3,title:"Attributes",slug:"attributes-25"},{level:3,title:"Tag class",slug:"tag-class-25"},{level:2,title:"Tag userProfileAttribute",slug:"tag-userprofileattribute"},{level:3,title:"Description",slug:"description-26"},{level:3,title:"Attributes",slug:"attributes-26"},{level:3,title:"Tag class",slug:"tag-class-26"}],lastUpdated:"8/4/2020, 5:01:47 PM",lastUpdatedTimestamp:1596574907e3,content:' Aps Core Tag Library \n \n \n Version: 2.3 \n \n \n Short Name: wp \n \n \n URI: /aps-core \n Tag  action \n Description \n Build the URL to call a jsp or a functionality of a servlet defined\nwithin the system. This tag can use the ParameterTag sub-tag to add url\nparameters. \n Example \n (<@wp.action path="/do/my.action" var="myaction" />)  or\n (<@wp.action path="/JSP/my.jsp" var="my.jsp"/>) \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n path \n no \n The relative path of jsp or servlet to invoke, relative to the context of web-application \n \n \n var \n no \n Name of the page-scoped variable where to place the URL. \n Tag class \n com.agiletec.aps.tags.ActionURLTag \n Tag  categories \n Description \n Return the list of the system categories on SelectItem objects. \n Example \n <@wp.categories var="systemCategories" titleStyle="prettyFull" root="$\\{userFilterOptionVar.userFilterCategoryCode}" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n titleStyle \n no \n The style of the single select item. Currently it can be \'default\' (single title node), \'full\' (title with all parents) or \'prettyFull\' (title with all parents in form of \'..\'). The default when none is given is \'default\'. \n \n \n fullTitleSeparator \n no \n The separator beetwen the titles when \'titleStyle\' is \'full\' or \'prettyFull\'. \n \n \n var \n no \n Name of the page-scoped variable where to place the list of categories. \n \n \n root \n no \n The root of the categories to show. The default is the system root categories \n Tag class \n com.agiletec.aps.tags.CategoriesTag \n Tag  checkHeadInfoOuputter \n Description \n This sub-tag verifies the availability of the information to display.\nThis sub-tag can be used only in a page template, in conjunction with\n\'outputHeadInfo\'. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n type \n yes \n Specifies the type of information to analyse. \n Tag class \n com.agiletec.aps.tags.CheckHeadInfoOutputterTag \n Tag  cssURL \n Description \n Extension of the ResourceURL tag. It returns the URL of the css files. \n Example \n <@wp.cssURL />href="<@wp.cssURL />myportal.css" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n Tag class \n com.agiletec.aps.tags.CssURLTag \n Tag  currentPage \n Description \n Returns the requested information held by the current page bean. \n Example \n <@wp.currentPage param="code" var="currentViewCode" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n param \n false \n The wanted parameter: actually can be either "title", "owner" (group), "code", "hasChild" or "childOf" (with attribute "targetPage"). The default when none is given is "title". \n \n \n langCode \n no \n Code of the language to use for the page information being returned. \n \n \n var \n no \n Name of the page context variable where the information are placed. Please note that the in this case the special characters will not be escaped. \n \n \n targetPage \n no \n Target page when "param" is "childOf". \n \n \n escapeXml \n no \n Decides whether to escape the special characters in the information retrieved or not. Value admitted (true, false), the default is true. \n Tag class \n com.agiletec.aps.tags.CurrentPageTag \n Tag  currentWidget \n Description \n Returns information about the widget where the tag resides. To obtain\ninformation about a widget placed in a frame other than the current, use\nthe "frame" attribute. \n Example \n <@wp.currentWidget param="config" configParam="name" var="configName" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n param \n yes \n The requested parameter. It can assume one of the following values: - "code" returns the code of the associated widget type (empty if none associated) - "title" returns the name of the associated widget type (empty if none associated) - "config" returns the value of the configuration parameter declared in the "configParam" attribute. The default is "title". \n \n \n configParam \n no \n Name of the configuration parameter request. This attribute is mandatory when the attribute "param" is set to "config". \n \n \n var \n no \n Name of the page context variable where the requested information is pushed. In this case the special characters will not be escaped. \n \n \n frame \n false \n Id of the frame hosting the widget with the desired information. \n \n \n escapeXml \n no \n Toggles the escape of the special characters. Admitted value are (true, false), the default is "true". \n Tag class \n com.agiletec.aps.tags.CurrentWidgetTag \n Tag  fragment \n Description \n Print a gui fragment by the given code. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n code \n true \n The code of the fragment to return. \n \n \n var \n false \n Name of the page context variable where the requested information is pushed. In this case the special characters will not be escaped. \n \n \n escapeXml \n false \n Toggles the escape of the special characters. Admitted value are (true, false), the default is "true". \n Tag class \n org.entando.entando.aps.tags.GuiFragmentTag \n Tag  freemarkerTemplateParameter \n Description \n Add a parameter into the Freemarker’s TemplateModel Map. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n var \n true \n Name of the variable where the requested information is pushed. \n \n \n valueName \n true \n Name of the variable of the page context where extract the information. \n \n \n removeOnEndTag \n false \n Whether to remove the parameter on end of Tag. Possible entries (true, false). Default value: false. \n Tag class \n org.entando.entando.aps.tags.FreemarkerTemplateParameterTag \n Tag  headInfo \n Description \n Declares the information to insert in the header of the HTML page. The\ninformation can be passed as an attribute or, in an indirect manner,\nthrough a variable of the page context. It is mandatory to specify the\ntype of the information. \n Example \n <@wp.headInfo type="JS" info="entando-misc-bootstrap/bootstrap.min.js" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n type \n yes \n Declaration of the information type. Currently only "CSS" is currently supported. \n \n \n info \n no \n Information to declare. This is an alternative of the "var" attribute. \n \n \n var \n no \n Name of the variable holding the information to declare. This attribute is the alternative of the "info" one. This variable can be used for those types of information that cannot be held by an attribute. \n Tag class \n com.agiletec.aps.tags.HeadInfoTag \n Tag  i18n \n Description \n Return the string associated to the given key in the specified language.\nThis string is either returned (and rendered) or can be optionally\nplaced in a page context variable. This tag can use the ParameterTag\nsub-tag to add label parameters. \n Example \n <@wp.i18n key="COPYRIGHT" escapeXml="false" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n key \n yes \n Key of the label to return. \n \n \n lang \n no \n Code of the language requested for the lable. \n \n \n var \n no \n Name of the variable (page scope) where to store the wanted information. In this case the special characters will not be escaped. \n \n \n escapeXml \n no \n Toggles the escape of the special characters of the returned label. Admitted values (true, false), the default is true. \n Tag class \n com.agiletec.aps.tags.I18nTag \n Tag  ifauthorized \n Description \n Toggles the visibility of the elements contained in its body, depending\non user permissions. \n Example \n <@wp.ifauthorized permission="enterBackend"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n permission \n no \n The code of the permission required. \n \n \n groupName \n no \n The name of the group membership required. \n \n \n var \n no \n The name of the (boolean) page context parameter where the result of the authorization check is placed. \n Tag class \n com.agiletec.aps.tags.CheckPermissionTag \n Tag  imgURL \n Description \n Extension of the ResourceURL tag. It returns the URL of the images to\ndisplay as static content outside the cms. \n Example \n <@wp.imgURL />entando-logo.png" alt="Entando - Access. Build. Connect." /> \n Attributes \n Tag class \n com.agiletec.aps.tags.ImgURLTag \n Tag  info \n Description \n Returns the information of the desired system parameter. \n Example \n <@wp.info key="systemParam" paramName="applicationBaseURL" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n key \n yes \n Key of the desired system parameter, admitted values are: "startLang" returns the code of start language of web browsing "defaultLang" returns the code of default language "currentLang" returns the code of current language "langs" returns the list of the languages defined in the system "systemParam" returns the value of the system param specified in the "paramName" attribute. \n \n \n var \n no \n Name of the variable where to store the retrieved information (page scope). In this case the special characters will not be escaped. \n \n \n paramName \n no \n Name of the wanted system parameter; it is mandatory if the "key" attribute is "systemParam", otherwise it is ignored. \n \n \n escapeXml \n no \n Toggles the escape of the special characters in the information returned. Admitted values are (true,false), the former being the default value. \n Tag class \n com.agiletec.aps.tags.InfoTag \n Tag  internalServlet \n Description \n Tag for the "Internal Servlet" functionality. Publishes a function\nserved by an internal Servlet; the servlet is invoked from a path\nspecified in the attribute "actionPath" or by the widget parameter\nsharing the same name. This tag can be used only in a widgets. \n Example \n <@wp.internalServlet actionPath="/ExtStr2/do/jpuserreg/UserReg/initRegistration" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n actionPath \n false \n The init action path. \n \n \n staticAction \n false \n Whether to execute only the given action path. Possible entries (true, false). Default value: false. \n Tag class \n com.agiletec.aps.tags.InternalServletTag \n Tag  nav \n Description \n Generates through successive iterations the so called "navigation" list.\nFor every target/page being iterated (inserted in the page context) are\nmade available the page code, the title (in the current language) and\nthe link. Is it also possible to check whether the target page is empty\n-that is, with no configured positions- or not. \n Example \n <@wp.nav var="page"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n spec \n no \n Declares the set of the pages to generate. \n \n \n var \n yes \n Name of the page context variable where the data of target being iterated are made available. \n Tag class \n com.agiletec.aps.tags.NavigatorTag \n Tag  outputHeadInfo \n Description \n Iterates over various information in HTML header displaying them; this\ntag works in conjunction with other specific sub-tags. Please note that\nthe body can contain only a sub-tag, or information, at once. This tag\nmust be used only in a page template. E.g (<@wp.outputHeadInfo\ntype="CSS">) \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n type \n yes \n Specifies the type of information to return, in accordance with the sub-tag to use. \n Tag class \n com.agiletec.aps.tags.HeadInfoOutputterTag \n Tag  pageInfo \n Description \n Returns the information of the specified page. This tag can use the\nsub-tag "ParameterTag" to add url parameters if the info attribute is\nset to \'url\'. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n pageCode \n true \n The code of the page. \n \n \n info \n false \n Code of required page parameter. Possible entries: "code" (default value) , "title", "owner" (group), "url", "hasChild" or "childOf" (with attribute "targetPage"). \n \n \n langCode \n false \n Code of the language to use for the returned information. \n \n \n var \n false \n Name used to reference the value pushed into the pageContext. In this case, the system will not escape the special characters in the value entered in pageContext. \n \n \n targetPage \n no \n Target page when "param" is "childOf". \n \n \n escapeXml \n false \n Whether to escape HTML. Possible entries (true, false). Default value: true. \n Tag class \n com.agiletec.aps.tags.PageInfoTag \n Tag  pager \n Description \n List pager. \n Example \n <@wp.pager listName="result" objectName="groupContent" max="10" pagerIdFromFrame="true" advanced="true" offset="5"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n max \n no \n The maximum value for each object group. \n \n \n listName \n yes \n Name of the list as found in the request. \n \n \n objectName \n yes \n Name of the object currently iterated. The following methods are exposed:  getMax, getPrevItem, getNextItem, getCurrItem, getSize, getBegin, getEnd, getMaxItem, getPagerId. \n \n \n pagerId \n no \n Sets the ID of the pager itself, it has to be used when two or more pagers exist in the same page. This attributes overrides "pagerIdFromFrame". \n \n \n pagerIdFromFrame \n no \n Sets the ID of the pager (mandatory when two or more pagers share the same page) based upon the frame where the tag is placed. Admitted values are (true, false), the latter being the default. Please note that the "pagerId" attribute takes precedence over this one. \n \n \n advanced \n no \n Toggles the pager in advanced mode. Admitted values are (true, false). the advanced mode of the tag is used when the list to iterate over is huge. \n \n \n offset \n no \n This attribute is considered only when the pager is in advanced mode. This is the numeric value of the single step increment (or decrement) when iterating over the list \n Tag class \n com.agiletec.aps.tags.PagerTag \n Tag  parameter \n Tag  pager \n Description \n This tag can be used to parameterise other tags. The parameter value can\nbe added through the \'value\' attribute or the body tag. When you declare\nthe param tag, the value can be defined in either a value attribute or\nas text between the start and the ending of the tag. \n Example \n <@wp.parameter name="resourceName"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n name \n true \n The name of the parameter. \n \n \n value \n false \n The value of the parameter. \n Tag class \n com.agiletec.aps.tags.ParameterTag \n Tag  printHeadInfo \n Description \n Returns the information to display. This sub-tag must be used only in a\npage template, in conjunction with \'outputHeadInfo\'. \n Attributes \n Tag class \n com.agiletec.aps.tags.HeadInfoPrinterTag \n Tag  resourceURL \n Description \n Returns URL of the resources. \n Example \n <@wp.resourceURL />static/js/entando-misc-html5-essentials/html5shiv.js"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n root \n no \n Declares the resource root. If not otherwise specified, the value of SystemConstants.PAR_RESOURCES_ROOT_URL is used. \n \n \n folder \n no \n Declares a specific directory for the desired resources. Unless specified, the value "" (empty string) is used in the generation of the URL. \n Tag class \n com.agiletec.aps.tags.ResourceURLTag \n Tag  show \n Description \n Defines the position of inclusion of a widget. This tag can be used only\nin a page template. \n Example \n <@wp.show frame="0" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n frame \n yes \n The positional number of the frame, starting from 0. \n Tag class \n com.agiletec.aps.tags.WidgetTag \n Tag  url \n Description \n Generates the complete URL of a portal page. The URL returned is either\nreturned (and rendered) or placed in the given variable. To insert\nparameters in the query string the sub-tag "ParameterTag" is provided. \n Example \n <@wp.url paramRepeat="true" > \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n page \n no \n Code of the destination page. The default is the current page. \n \n \n lang \n no \n Code of the language to use in the destination page. \n \n \n var \n no \n Name of the page-scoped variable where to place the URL. \n \n \n paramRepeat \n no \n Repeats in the URL all the parameters of the actual request. \n \n \n excludeParameters \n no \n Sets the list of parameter names (comma separated) to exclude from repeating. By default, this attribute excludes only the password parameter of the login form. Used only when paramRepeat="true". \n Tag class \n com.agiletec.aps.tags.URLTag \n Tag  pageWithWidget \n Description \n Search and return the page (or the list of pages) with the given widget\ntype. When "filterParamName" and "filterParamValue" attributes are\npresent, the returned list will be filtered by a specific widget\nconfiguration. \n Example \n <@wp.pageWithWidget widgetTypeCode="userprofile_editCurrentUser" var="userprofileEditingPageVar" listResult="false" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n var \n true \n Attribute_description: \n \n \n widgetTypeCode \n true \n The code of the widget to search \n \n \n filterParamName \n false \n Optional widget config param name \n \n \n filterParamValue \n false \n Optional widget config param value \n \n \n listResult \n false \n Optional, dafault false. When true the result is a list of pages, when false the returned page is the first occurence \n Tag class \n com.agiletec.aps.tags.PageWithWidgetTag \n Tag  currentUserProfileAttribute \n Description \n Current User Profile tag. Return a attribute value of the current user\nprofile. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n attributeName \n false \n the name of the attribute from which extract the value. \n \n \n attributeRoleName \n false \n the name of the attribute role from which extract the value. \n \n \n var \n false \n Name used to reference the value pushed into the pageContext. \n \n \n escapeXml \n false \n Decides whether to escape the special characters in the information retrieved or not. Value admitted (true, false), the default is true. \n Tag class \n org.entando.entando.aps.tags.CurrentUserProfileAttributeTag \n Tag  userProfileAttribute \n Description \n User Profile tag. Return a attribute value from the profile givea an\nusername. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n username \n true \n the username \n \n \n attributeName \n false \n the name of the attribute from which extract the value. \n \n \n attributeRoleName \n false \n the name of the attribute role from which extract the value. \n \n \n var \n false \n Name used to reference the value pushed into the pageContext. \n \n \n escapeXml \n false \n Decides whether to escape the special characters in the information retrieved or not. Value admitted (true, false), the default is true. \n Tag class \n org.entando.entando.aps.tags.UserProfileAttributeTag \n'},{title:"Entando CLI",frontmatter:{sidebarDepth:2},regularPath:"/next/docs/reference/entando-cli.html",relativePath:"next/docs/reference/entando-cli.md",key:"v-63e6ea8c",path:"/next/docs/reference/entando-cli.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Installation",slug:"installation"},{level:3,title:"Prerequisites",slug:"prerequisites"},{level:3,title:"Install the CLI",slug:"install-the-cli"},{level:3,title:"Check the Environment",slug:"check-the-environment"},{level:3,title:"Update the CLI",slug:"update-the-cli"},{level:2,title:"Available Commands",slug:"available-commands"},{level:2,title:"Project Management",slug:"project-management"},{level:3,title:"Project Setup",slug:"project-setup"},{level:3,title:"Prepare and Publish a Bundle",slug:"prepare-and-publish-a-bundle"},{level:3,title:"Install the Bundle into an Application",slug:"install-the-bundle-into-an-application"},{level:3,title:"Run a Project Locally",slug:"run-a-project-locally"},{level:3,title:"Bundle and Custom Resource Management",slug:"bundle-and-custom-resource-management"},{level:3,title:"Get the Bundle ID and Plugin ID",slug:"get-the-bundle-id-and-plugin-id"},{level:2,title:"Bundle Commands",slug:"bundle-commands"},{level:3,title:"Prepare a Bundle for Publication",slug:"prepare-a-bundle-for-publication"},{level:3,title:"Extract a Bundle from an Application",slug:"extract-a-bundle-from-an-application"},{level:2,title:"Profile Management",slug:"profile-management"},{level:2,title:"Configuration Management",slug:"configuration-management"},{level:3,title:"Commands",slug:"commands"},{level:3,title:"Keys",slug:"keys"},{level:2,title:"Diagnostic Commands",slug:"diagnostic-commands"},{level:2,title:"Reference",slug:"reference"}],lastUpdated:"4/19/2022, 4:38:02 PM",lastUpdatedTimestamp:1650400682e3,content:' Entando CLI \n Overview \n The Entando Command Line Interface (CLI) provides a set of commands that accelerate common tasks such as installing a new instance of Entando, generating an Entando project via JHipster, deploying an Entando Bundle, creating an Entando Application, etc. \n Installation \n Prerequisites \n The basic requirements for the CLI vary depending on the category of developer tasks. The CLI is able to install secondary dependencies using the  ent check-env  command as described  here . \n \n \n \n Category \n Prerequisite \n \n \n \n \n Basic Development \n Git or  Git for Windows \n \n \n \n nvm or  NVM for Windows \n \n \n Install Entando in a local VM \n Multipass \n \n \n Build and publish Entando Bundles \n Docker and Docker Compose \n \n \n \n a Git repository for the bundle artifacts \n \n \n \n a Docker Hub account (or organization) for microservice Docker images \n \n \n Deploy an Entando Bundle \n a Kubernetes cluster with admin access, which can be a local cluster (created via the Entando CLI or manually) or a shared remote cluster \n \n \n \n TIP \n The automated option in  Getting Started  will install the CLI along with an Ubuntu VM containing K3s Kubernetes and a quickstart Entando Application. \n Install the CLI \n Install the current offical release of the CLI via the following command \n curl  -L https://get.entando.org/cli  |   bash \n Check the Environment \n Use the  check-env  command to prepare your environment for development. This will verify the presence of required dependencies as well as the appropriate versions for your specific Entando instance. Certain configurations allow  check-env  to automatically install dependencies and prompt the developer for guidance or approval as needed. \n ent check-env develop\n Update the CLI \n The CLI can be updated to the latest version (corresponding to the current Entando version) using \n bash   < ( curl  -L  "https://get.entando.org/cli" )  --update\n \n Run  ent check-env develop  after updating the CLI to determine if dependency versions have changed. \n Alternatively, deleting the  ~/.entando  directory with  rm -rf ~/.entando  and then reinstalling the CLI, per the instructions above, will perform a clean install. This will also remove the private copies of JHipster, Entando Blueprint, etc. \n Available Commands \n Use  ent help  to review the list of available commands \n ~~~~~~~~~~~~~~~~~~~\n Entando CLI\n~~~~~~~~~~~~~~~~~~~\n\n> Essentials:\n  - Activate using:  ~/.entando/ent/v7.0.0/cli/v7.0.0/activate\n  - Deactivate using: ~/.entando/ent/v7.0.0/cli/v7.0.0/deactivate\n\n> Available commands:\n  - app                  => Helper for managing an Entando App\n  - app-info             => Displays information about an Entando App\n  - bundler              => Wrapper for the ent private installation of the Entando bundle tool\n  - check-env            => Checks the environment for required dependencies and settings\n  - diag                 => Runs diagnostics and aggregates the related info in a .tgz file\n  - ecr                  => Helper for managing the ECR\n  - ent                  => Helper for managing the local ents\n  - help                 => Help information\n  - host                 => Helper for managing the system that hosts the quickstart VM\n  - jhipster             => Wrapper for the ent private installation of jhipster\n  - kubectl              => Helper for using kubectl in ent managed scenarios\n  - npm                  => Wrapper for the ent private installation of npm (mostly for internal use)\n  - pod                  => Displays information related to a set of pods\n  - prj                  => Helper for managing Entando bundle projects\n  - profile              => Helper for managing an Entando App\n  - quickstart           => Helper for installing Entando instances locally\n  - run-tests            => Runs the internal tests\n\n> Further info about entando:\n  - ~/.entando/ent/v7.0.0/cli/v7.0.0/README.md\n  - https://www.entando.com/\n  - https://developer.entando.com/\n\n> ⚠ RECOMMENDED FIRST STEP ⚠ :\n  - Check the dependencies (ent check-env --help)\n \n Check a command\'s help text ( --help ) to view specific options and subcommands, e.g.  ent check-env --help . For general configuration options related to ent itself, see  ent --help . \n Project Management \n Sequences commonly used with Entando projects are detailed below. \n Project Setup \n \n Create a project directory \n \n mkdir  testProject  &&   cd  testProject\n \n \n Generate the project skeleton using the JHipster-based Entando Blueprint \n \n ent jhipster --blueprints entando\n \n \n Generate an entity and MFEs \n \n ent jhipster entity Conference\n \n \n Build the new project \n \n ent prj build\n \n \n Note: Using the  ent prj  wrapper avoids having to build each part of the project individually. The first run using  ent prj  can be slower due to MFE node downloads. See  the BLueprint tutorial  for more details. \n Prepare and Publish a Bundle \n Use the publication system (pbs) to assemble your Entando project into a bundle that can be loaded into Kubernetes. You\'ll need your GitHub credentials, an empty GitHub repository to hold your bundle artifacts, and a Docker Hub account or organization. \n \n Initialize the bundle directory. This method accepts SSH and HTTPS URLs. \n \n ent prj pbs-init\n \n \n Publish the build artifacts to GitHub and Docker Hub \n \n ent prj pbs-publish\n \n \n Deploy the bundle into the Entando Component Repository \n \n ent prj deploy\n \n See  Build and Publish a Project Bundle  for more details. \n Install the Bundle into an Application \n The CLI allows you to install a bundle without accessing the Entando App Builder. \n \n Note: A bundle must be deployed before it can be installed. \n \n \n Run the following command from the project folder \n \n ent prj  install \n \n \n If a bundle has already been installed, use  --conflict-strategy  to adopt a strategy for existing components (CREATE, SKIP, OVERRIDE) \n \n ent prj  install  --conflict-strategy = OVERRIDE\n Run a Project Locally \n \n Initialize Keycloak, which leverages Docker Compose \n \n ent prj ext-keycloak start\n \n \n Initialize backend microservices \n \n ent prj be-test-run\n \n To fetch logs from bundle plugins, use the command \n ent prj be-log\n \n \n Initialize one or more frontend widgets, each from its own shell \n \n ent prj fe-test-run\n \n Check out  Run Blueprint-generated Microservices and Micro Frontends in Dev Mode  for more details. \n Bundle and Custom Resource Management \n Entando supports a series of  ent ecr  commands to manage bundles and custom resources. The following commands are particularly useful. \n Display the list of bundles associated with the current profile \n ent ecr list\n \n Generate a custom resource and deploy it to the current profile \n ent ecr deploy\n \n The helpers  get-bundle-id  and  get-plugin-id  have been added to  ent ecr  to calculate and display unique identifiers related to custom resources. This provides additional security controls around bundle-specific and microservice plugin resources. \n Determine the bundle identifier \n ent ecr get-bundle-id YOUR-BUNDLE-REPOSITORY-URL\n \n Determine the plugin identifier \n ent ecr get-plugin-id --auto YOUR-BUNDLE-REPOSITORY-URL\n Get the Bundle ID and Plugin ID \n Entando uses a unique identifier for your bundle as a way to provide additional security controls around bundle-specific resources. You can determine this identifier with the command \n ent prj get-bundle-id --auto\n \n A unique identifier will also be calculated for each microservice plugin in your project. You can determine this identifier with the command \n ent prj get-plugin-id --auto --repo = < BUNDLE-REPO-URL > \n Bundle Commands \n Use the  ent bundler  command to prepare a bundle for publication or extract a bundle from an application. \n Prepare a Bundle for Publication \n The project command  ent prj generate-cr  provides a wrapped version of  ent bundler  and prepares a bundle custom resource from a Git repository. Reference the help text for options (e.g. bundle name, description, repository). The output of  ent prj generate-cr  is a YAML file which can be piped to  ent kubectl  for direct application to Kubernetes. \n   ent bundler from-git\n \n See the  Build and Publish a Simple Bundle tutorial  for an example of how to use  ent prj generate-cr . \n Extract a Bundle from an Application \n Point the bundler to an existing Entando Application to extract its components (pages, content, etc.) and static assets into a custom bundle. This bundle can be used to migrate Entando components from one environment to another (e.g. Dev to QA), as a template for building a new Entando Application, or as the skeleton of an Entando solution. \n The bundler provides an interactive mode to identify the components to export from the application. The bundle folder structure created by an Entando project, including a top-level descriptor file, is generated with the following command. \n   ent bundler from-env  \n \n An  env.json  file to configure the application URLs and client credentials must live in the directory from which the bundler is run. \n { \n    "coreBaseApi" :   "http://<YOUR-DOMAIN-OR-IP>/entando-de-app" , \n    "k8ssvcApi" :   "http://<YOUR-DOMAIN-OR-IP>/k8s" , \n    "clientId" :   "<YOUR-CLIENT-ID>" , \n    "clientSecret" :   "<YOUR-CLIENT-SECRET>" \n } \n \n Instructions to export a bundle, including how to configure  env.json , can be found in the  Export and Publish a Bundle tutorial . \n Profile Management \n To manage and switch between different ent configurations, use  ent profile . \n To switch between different Entando Applications, even if they are in different clusters,  ent profile  uses Kubernetes contexts, kubeconfig files, and/or custom commands (refer to  ent profile first-use-readme ). \n It is common practice for the vendor tool that connects to a cloud Kubernetes to create a Kubernetes context that must be linked to the profile. \n An overview of the current connection and profile information is provided via  ent status . \n \n Create and switch to a new profile \n \n ent pro new [profileName] [EntandoAppName] [namespace]\n\nThis sets the minimal profile data and explains next steps.\n \n \n Link the current profile to a Kubernetes context (alias of  ent attach-kubectx ) \n \n ent pro link [contextName]\n \n This instructs ent how to connect to the Kubernetes containing the Entando Application. \n \n Activate the profile that ent should use across shells \n \n ent pro use [profileName]\n \n This attempts to fully restore a profile type by considering the login and related Entando Applications. \n \n Activate the profile that ent should use within the current shell \n \n source ent pro use [profileName]\n \n This allows ent instances in different shells to simultaneously use different Kube contexts, kubeconfigs or custom commands. The quickstart script creates a profile named "qs--{vmname}" that is associated with the Entando Application it generates. \n \n Print a list of the available profiles \n \n ent pro list\n \n \n Delete a profile \n \n ent pro delete [profileName]\n Configuration Management \n The output of  ent config  is a key-value archive of configurations related to the current profile.\nIt can serve several purposes, but a few "good to know" keys and commands are below. \n Commands \n \n Print the current config archive \n \n ent config --print\n \n \n Interactively edit a config archive \n \n ent config --edit\n \n \n Return the value of a config key \n \n ent config --get {key}\n \n \n Set the value of a config key \n \n ent config --set {key} {value}\n \n \n Delete a config key \n \n ent config --set {key}\n Keys \n \n \n \n Key \n Definition \n \n \n \n \n ENTANDO_NAMESPACE \n stores the fallback namespace used by explicit or implicit runs of  ent kubectl \n \n \n ENTANDO_APPNAME \n stores the Entando Application name related to the current profile \n \n \n DESIGNATED_JAVA_HOME \n stores the path of the Java version used internally by ent \n Diagnostic Commands \n Performing the  Automatic Install  found in the Getting Started guide installs the CLI in a Multipass VM. The following commands can be run from this VM for insight into an Entando Application. \n \n Display basic information about Kubernetes and Entando resources (e.g. namespace, pods, ingresses) \n \n ent app-info\n \n \n Display  kubectl describe  and  kubectl logs  for each of the major Entando pods in a namespace \n \n ent pod-info\n \n \n List the current pods in an Entando namespace and prepare a diagnostic tar.gz \n \n ent diag\n \n This outputs  kubectl describe  and  kubectl logs  for each of the fundamental Entando pods. It also exports custom resources, ingresses, deployments, "previous" pod logs, namespace events, etc. Diagnostic information can be highly useful when analyzing and troubleshooting behavior. The command  ent diag  outputs the directory paths of the diagnostic logs, similar to the following \n > Collected diagdata available under "~/.entando/reports/entando-diagdata-2020-11-19T02:58:47+0000" for consultation\n> Collected diagdata available in archive "~/.entando/reports/entando-diagdata-2020-11-19T02:58:47+0000.tgz"\n Reference \n \n Source repository:  https://github.com/entando/entando-cli/tree/develop \n \n'},{title:"Development Tips and Tricks",frontmatter:{sidebarDepth:2},regularPath:"/next/docs/reference/local-tips-and-tricks.html",relativePath:"next/docs/reference/local-tips-and-tricks.md",key:"v-0d268fa8",path:"/next/docs/reference/local-tips-and-tricks.html",headers:[{level:2,title:"Quickstart Management",slug:"quickstart-management"},{level:3,title:"General",slug:"general"},{level:3,title:"Multipass",slug:"multipass"},{level:3,title:"Entando in Kubernetes",slug:"entando-in-kubernetes"},{level:2,title:"Shared Servers",slug:"shared-servers"},{level:2,title:"Network Issues",slug:"network-issues"},{level:3,title:".nip.io isn't allowed",slug:"nip-io-isn-t-allowed"},{level:3,title:"The IP address changed after the initial install",slug:"the-ip-address-changed-after-the-initial-install"},{level:2,title:"Windows Development",slug:"windows-development"},{level:3,title:"Multipass loses control of VMs",slug:"multipass-loses-control-of-vms"},{level:3,title:"Hyper-V IP changes",slug:"hyper-v-ip-changes"},{level:3,title:"JHipster",slug:"jhipster"},{level:3,title:"Multipass with VirtualBox",slug:"multipass-with-virtualbox"}],lastUpdated:"4/13/2022, 9:31:31 AM",lastUpdatedTimestamp:1649856691e3,content:" Development Tips and Tricks \n We've collected a list of tips and tricks to optimize your local quickstart or  Getting Started  development environment. We invite you to ask questions, collaborate with the community, and share your own favorite\npractices over on the  Entando forum . \n Quickstart Management \n Here are a few common questions about the quickstart environment. The quickstart environment uses Multipass to launch an Ubuntu VM, where K3s Kubernetes is then installed and from which Entando is deployed. \n General \n Q: How can I remove a quickstart environment? \n A:  If you want to completely remove the VM created by Multipass, you can use  multipass delete YOUR-VM-NAME  (where the default YOUR-VM-NAME for a quickstart is  entando ) and then  multipass purge  to recover the resources. If you just want to shutdown Entando but keep the VM, you can use  multipass shell YOUR-VM-NAME  to shell into the VM and then remove the namespace via  sudo kubectl delete namespace entando . \n Q: What if the installation fails due to timeout? \n A:  A Docker Hub policy limiting download bandwidth may cause the quickstart installation to fail with timeout errors. The workaround is a two step process: \n \n Delete the  entando  namespace \n \n ent k delete namespace entando\n \n \n Run the following \n \n ent quickstart \"entando\" \"quickstart\" --simple --debug=1 --yes --with-vm --release=v7.0.0\n \n The namespace will be recreated, preserving the images already pulled, so it's unlikely the installation time will exceed the timeout threshold again. \n Multipass \n Q: How can I shell into a Multipass VM? \n A:   multipass shell YOUR-VM-NAME . If you don't provide YOUR-VM-NAME, Multipass will use the default name  primary , and even launch it for you if it doesn't exist. \n Q: What do I need to do after restarting my laptop? \n A:  By default, Multipass is installed as a service and will restart automatically. If Multipass isn't running, you'll need to first initialize this service; then you can start your VM via  multipass start YOUR-VM-NAME . Kubernetes will launch automatically along with any installed pods, including Entando. It can take a few minutes for all of the pods to fully initialize, but you can use  sudo kubectl -n entando get pods --watch  to observe the progress. \n Q: How can I pause or idle my Entando instance? \n A:  You can pause with  multipass stop YOUR-VM-NAME , or idle with  multipass suspend YOUR-VM-NAME  to preserve the VM state. You can then use  multipass start YOUR-VM-NAME  to start the VM. \n Q: What else can Multipass do? \n A:  You can run  multipass help  or refer to the  Multipass docs  for more information on Multipass. \n Entando in Kubernetes \n Q: How can I install a new copy of Entando into an existing VM? \n A:  By default, the quickstart installation deploys Kubernetes resources into a dedicated namespace called  entando . If you want to remove all of the resources in  entando , you can simply delete the namespace with  sudo kubectl delete namespace entando . You can then re-create the namespace and re-install the resources. Alternatively, you can achieve this with  ent quickstart --vm-reuse=true , but you'll need to set other  ent quickstart  options, so check the  ent  help. \n Q: How can I shell into a running pod or view its logs? \n A:  You can use the standard Kubernetes commands, e.g.  sudo kubectl exec -it YOUR-POD-NAME -c YOUR-CONTAINER-NAME -- bash  or  sudo kubectl logs YOUR-POD-NAME YOUR-CONTAINER-NAME . \n Q: What do I do if Entando doesn't fully initialize? \n A:  The most common cause of this is a networking problem. See the  Network issues  section below for details. If all else fails, reach out to the Entando team on Slack or in the Forums. \n Shared Servers \n We recommend using Multipass to quickly spin up an Ubuntu VM to host a local Kubernetes cluster for test purposes. A local environment is often useful, but most teams utilize a shared Kubernetes cluster. This shared cluster is managed by an operations team, and installed either on-premise or with a cloud provider for full integration testing, CI/CD, DevOps, etc. \n Network Issues \n A local Entando 7 quickstart installation (e.g. what you get if you follow the  Getting Started  guide) may use a set of local domain names to enable access to Entando services. Your IP address will vary, but may look something like this: \n quickstart.192.168.99.1.nip.io\nYOUR-APP.192.168.99.1.nip.io\n \n The base domain configured via the ingressHostName (e.g. in your entandoapp.yaml) is based on the IP address that is created during the initial VM installation. This domain is used to generate ingress routes to map incoming URLs to individual services. In production environments, there's generally a dedicated network layer to manage IPs/routing (both on premise and in the cloud), but this is not readily available in most local setups. Below are a couple of common issues that can prevent Entando from initializing in a local environment: \n  .nip.io isn't allowed \n \n This could be due to firewall settings or corporate security policies. The simplest workaround is to manually edit your /etc/hosts file and map the domain to the IP of your local virtual machine. \n \n  192.168.99.1 quickstart.192.168.99.1.nip.io\n 192.168.99.1 YOUR-APP.192.168.99.1.nip.io\n \n \n If you add microservices to your installation, you may need to add additional mappings for the new ingresses. \n To update files on Windows, see the  Windows process  below. \n  The IP address changed after the initial install \n \n Restarting a Windows computer can cause this (see  Windows Hyper-V IP Changes  below), and the workaround noted in the  .nip.io isn't allowed  section above also applies (i.e. update your /etc/hosts file). Simply update the IP address in the first column to use the current IP of your virtual machine. \n Windows Development \n Multipass loses control of VMs \n Q: What do I do if Multipass cannot access my VMs? \n A:  The most common symptoms include an  IP=UNKNOWN  entry when issuing a  multipass list , and when attempts to stop or shell into the VM consistently fail. \n Internet Connection Sharing (ICS) is a Windows service that provides Internet connectivity to virtual machines, and its  hosts.ics  file can occasionally get corrupted. Restarting the host laptop or desktop should remedy this, but a quicker and simpler fix is to shutdown any VMs using the hypervisor (Hyper-V or VirtualBox), remove the  hosts.ics  file from  Windows/System32/drivers/etc  using elevated privileges, and then restart the VM(s). You can examine the  hosts.ics  file first to check if it is well-formed, with clean IP to VM-NAME mappings insteaad of spurious numbers or letters. \n Hyper-V IP changes \n Q: My Entando installation stops working when I restart Windows. How can I fix this? \n A:  The basic issue is that Windows Hyper-V makes it difficult to set a static IP for a VM (see this  forum post  for details). As discussed  above , Entando's ingress routes rely on a fixed IP address and will break if the IP address changes after initial installation. Here are a few options to solve this issue, short of modifying your router or network switch settings: \n Option 1: Single host routing \n The simplest way to deal with the peculiarities of Hyper-V IP assignment is to avoid it, instead using Windows-specific mshome.net addresses. This allows you to access a VM with an address like  YOUR-VM-NAME.mshome.net . If you set up your enviroment using the  Automatic Install  instructions, then the ent CLI will select the single host option and the address will be  entando.mshome.net . You can accomplish the same thing yourself using the  ent quickstart  script, but see  --help  for the current set of options. \n Option 2: Manually update your hosts file \n The next simplest option to re-enable external access to your cluster is to update your hosts file after each Windows restart. \n You need two pieces of information for this workaround, and you'll also need administrator access. \n \n Determine the original IP used for your VM. This is included in the  ENTANDO_DEFAULT_ROUTING_SUFFIX , or you can find it included in the ingress names. Run   kubectl -n entando get ingress  to see something like this: \n \n NAME                                     CLASS    HOSTS                                           \ndefault-sso-in-namespace-ingress         <none>   quickstart.192.168.235.100.nip.io  \nquickstart-ingress                       <none>   quickstart.192.168.235.100.nip.io  \n \n \n Determine the current IP using  hostname -I  in the VM, or by running  multipass list  from Windows: \n \n $ multipass list\nName                    State             IPv4             Image\nprimary                 Running           172.31.118.12   Ubuntu 18.04 LTS\n \n \n As a Windows administrator, edit your hosts file  (C:\\Windows\\System32\\drivers\\etc\\hosts)  to map any required URLs from the old IP to the new IP. This will bypass .nip.io lookups. \n \n 172.31.118.12 quickstart.192.168.235.100.nip.io\n172.31.118.12 YOUR-APP.192.168.235.100.nip.io\n \n \n You should now be able to access your Entando URLs via the new IP. If your Entando installation stalled during startup, it should continue initializing as soon as the external address is functional again. \n Option 3: Add a Windows route \n This option is initially a little more involved, but future repairs to your network settings can then be made very easily. You'll need to choose a static IP, configure a Windows route to map it to the Hyper-V interface, and claim the IP in the Ubuntu VM via a netplan entry. \n When implementing this option for the first time, all steps must be executed before installing Entando. Subsequent Windows restarts require steps #1 and #2, only. \n \n \n Determine an IP that is unused on your local network (e.g. via ping). The following steps assume that IP 192.168.99.1 is selected. \n \n \n Determine the interface address to Hyper-V (e.g. 32 below). Use cmd  route print  and find the Interface entry for Hyper-V: \n \n \n Interface List\n 32...00 15 5d 86 45 20 ......Hyper-V Virtual Ethernet Adapter\n \n \n Using elevated privileges, add a persistent route to map your IP to the Hyper-V interface: \n \n route -p add [YOUR-IP] mask 255.255.255.255 0.0.0.0 IF [HYPER-V-INTERFACE]\nroute -p add 192.168.99.1 mask 255.255.255.255 0.0.0.0 IF 32\n \n \n \n Verify the route was added via  route print 192.168.99.1 . This command is useful after restart to check if the route needs to be created again. \n \n \n Configure your VM to claim the same address. Shell into the VM using  winpty multipass shell YOUR-VM-NAME . \n \n \n Change to the root user to make the following steps simpler:  sudo -i \n \n \n Determine your network adapter name via  ip link , e.g. eth0. It's often second in the list after the loopback adapter. \n \n \n ubuntu@primary:~$  ip   link \n 1 : lo:  < LOOPBACK,UP,LOWER_UP >  mtu  65536  qdisc noqueue state UNKNOWN mode DEFAULT group default qlen  1000 \n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n 2 : eth0:  < BROADCAST,MULTICAST,UP,LOWER_UP >  mtu  1500  qdisc mq state UP mode DEFAULT group default qlen  1000 \n    link/ether 00:15:5d:00:1a:0c brd ff:ff:ff:ff:ff:ff\n \n \n \n Navigate to your netplan directory:  cd /etc/netplan \n \n \n Create a netplan entry starting with 0 (so it's indexed and loaded first):  vi 0-entando.yaml \n \n \n network : \n   version :   2 \n   renderer :  networkd\n   ethernets : \n     YOUR-NETWORK-ADAPTER : \n       dhcp4 :  no\n       addresses :  \n         -  YOUR - IP/24\n \n Example: \n network : \n   version :   2 \n   renderer :  networkd\n   ethernets : \n     eth0 : \n       dhcp4 :  no\n       addresses :  \n         -  192.168.99.1/24\n \n \n \n Apply the changes with  netplan apply \n \n \n From the VM, verify connectivity via  ping 192.168.99.1 . You should receive a response and not a timeout. \n \n \n (Optional) Run a Python server to verify you can access the VM from the host at  http://192.168.99.1:8000.  It may take a minute or so before the server is ready. \n \n \n python3 -m http.server 8000\n \n \n You should now be able to install Entando using the static IP. If your Entando installation stalled during startup, and was previously configured with a static IP, it should continue initializing as soon as the external address is functional again. \n Option 4: Reinstall Entando \n We're including this option because it works and requires no additional configuration. If you work with Entando regularly, we recommend developing in a centralized and shared Kubernetes instance rather than running a full stack locally. If you require a local cluster, we recommend using option 1 or 2. \n JHipster \n Q: How can I run JHipster on Windows? \n A:  JHipster requires a TTY interface for its menus to function correctly. Here are a few options to satisfy that requirement on Windows: \n \n Run  jhipster  under cmd or Powershell \n Using Git Bash, run  winpty jhipster.cmd \n Use Ubuntu bash via WSL (1 or 2), or within the Multipass VM \n Multipass with VirtualBox \n Q: How do I run Multipass with VirtualBox? \n A:  Multipass supports the use of VirtualBox on Windows as an alternative to Hyper-V. Refer to the Multipass documentation for VirtualBox configuration instructions. \n For Entando to work correctly with VirtualBox, you will need to add a port forwarding rule to access Entando from your host system. \n \n Create your VM within Multipass \n Go to the Oracle VM VirtualBox Manager to edit the  Network  settings for the VM \n Go to the  Advanced  options and click  Port Forwarding Rules \n Add a new rule\n \n Name : your choice \n Protocol : TCP \n Host IP : leave this blank \n Host Port : 80 \n Guest IP : leave this blank \n Guest Port : 80 \n Click OK \n \n \n Any requests to port 80 on your localhost should be forwarded to the VM. \n Use the IP of your host to configure the  ENTANDO_DEFAULT_ROUTING_SUFFIX  in your YAML file, e.g.  192.168.64.25.nip.io . You must use the host ID and not the non-routable address identified from within the guest VM, e.g. 10.0.2.15. \n \n"},{frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/",relativePath:"next/tutorials/README.md",key:"v-357745d0",path:"/next/tutorials/",headers:[{level:2,title:"Frontend Development",slug:"frontend-development"},{level:2,title:"Backend Development",slug:"backend-development"},{level:2,title:"Operations",slug:"operations"}],lastUpdated:"4/7/2022, 10:58:02 AM",lastUpdatedTimestamp:1649343482e3,content:" ATTENTION \n This documentation is for the version of Entando currently under development and is a work in progress.\nSome screenshots or references to the previous version may be out-of-date and some documented features may\nonly be available by building from source. \n Learning Paths \n Entando simplifies the development of modern apps: \n \n Built using modern JavaScript frameworks \n Backed by microservices deployed in containers, and \n Orchestrated by Kubernetes for fully automated DevOps lifecycles \n \n \n Entando supports full stack micro frontend and microservice architectures for codebases that are easier to understand, maintain, and debug across large, distributed teams, and comes with a private component repository that makes it easy for teams to share and reuse components. \n Use the navigation on the left to find step-by-step tutorials for common tasks or check out our learning paths below for a more structured approach. \n Frontend Development \n \n \n \n Basic \n Intermediate \n Advanced \n \n \n \n \n Build a Basic Widget \n Add Configuration to a Widget \n Generate Micro Frontends and Microservices Based on a Database Entity \n \n \n Create a React Micro Frontend \n Enable Communication between MFEs \n \n \n \n Create an Angular Micro Frontend \n Add Access Controls to your MFEs \n \n \n \n Create and Manage Content \n Backend Development \n \n \n \n Basic \n Intermediate \n Advanced \n \n \n \n \n Build and Publish a Simple Bundle \n Build and Publish a Project Bundle \n Export a Bundle from an Existing Application \n \n \n Generate Micro Frontends and Microservices Based on a Database Entity \n Use JDL Studio to Create a Complex Database Entity \n Manage Plugin Environment Variables \n \n \n Run Micro Frontends and Microservices in Your Local Environment \n Add Access Controls to Your Microservices \n \n \n \n \n Use Postman with OAuth2 APIs \n Operations \n \n \n \n Basic \n Intermediate \n Advanced \n \n \n \n \n Set Up Entando on a Local Kubernetes Cluster \n Backing Up and Restoring Your Entando Environment \n Install Bundle Microservices from a Private Registry \n \n \n Set Up Entando on Amazon Elastic Kubernetes Service (EKS) \n Customize the base Entando Application via a Docker Image \n Add a GitHub Actions CI Workflow \n \n \n Set Up Entando on Azure Kubernetes Service (AKS) \n Connect Your Entando Application to an External Database \n Manage NGINX \n \n \n Set Up Entando on Google Kubernetes Engine (GKE) \n Install the Standard Demo Application \n Setup Plugin Profiles \n \n \n Set Up Entando on Red Hat OpenShift \n Configure the Entando Operator \n \n \n \n \n"},{title:"Content Templates",frontmatter:{},regularPath:"/next/tutorials/compose/content-templates-tutorial.html",relativePath:"next/tutorials/compose/content-templates-tutorial.md",key:"v-d62d0140",path:"/next/tutorials/compose/content-templates-tutorial.html",headers:[{level:2,title:"Create a Content Template",slug:"create-a-content-template"}],lastUpdated:"3/23/2022, 1:59:41 PM",lastUpdatedTimestamp:1648058381e3,content:" Content Templates \n Content Templates define how information is displayed when a Content is published. They provide the styling and layout for Content Types and offer different representations of the same content. \n Create a Content Template \n Content Templates are managed via the Web CMS, through a user interface provided by the  Entando App Builder . Follow the steps below to create and configure a Content Template. \n 1. From the left menu of the App Builder, go to  Content  →  Templates . \n 2. Click the  Add  button in the upper right corner. \n \n 3. Define the characteristics of the Content Template: \n \n \n \n Type : Choose a Content Type from the drop-down list. Click the  Set  button to input your selection and enable Attribute suggestions in subsequent fields. \n \n \n Code : Enter a sequence of up to 10 numbers to uniquely identify the Content Template. This field is mandatory. \n \n \n Name : Enter a name or description for the Content Template. This field supports a string value of 50 characters or less and should consist of one or more of the following: uppercase letters, lowercase letters, numbers and/or special characters. \n \n \n Model : Enter HTML to model the Content Template based on Velocity language. \n \n \n Style Sheet : (Optional) Enter the CSS to be applied to the HTML  Model . \n \n \n 4. Click the  Save  button. \n This adds the Content Template to the Content Type. \n"},{title:"Content Attributes",frontmatter:{},regularPath:"/next/tutorials/compose/content-attributes.html",relativePath:"next/tutorials/compose/content-attributes.md",key:"v-a4229f80",path:"/next/tutorials/compose/content-attributes.html",headers:[{level:2,title:"Simple Attribute Types",slug:"simple-attribute-types"},{level:2,title:"Composed Attribute Types",slug:"composed-attribute-types"}],lastUpdated:"2/9/2022, 9:50:35 AM",lastUpdatedTimestamp:1644418235e3,content:" Content Attributes \n Attributes can be seen as the smallest elements that compose a Content\nType. In other words, a Content Type is just a collection of different\nattributes. Attributes are responsible for carrying the actual\ninformation inside a Content in Entando and could be of different types.\nIn this chapter, we will review and describe the different attribute\ntypes. \n Firstly, we can distinguish simple attribute types from composite\nattribute types. In the first case, the attribute type carries a single\npiece of information (for example, an image), while the latter is an\naggregation of simple attribute types (for example, a set of images). \n Simple Attribute Types \n Attach \n This represents the information carried by a file, which is attached to\nthe content. \n It consists of an URL corresponding to the desired file present in the\nsystem’s resources, and a text which can either indicate the description\nor the name of the file. \n This attribute type is rendered as a button named “Add”. By pushing that\nbutton, the user is prompted to select a desired file present in the\nsystem’s Digital Assets Attachments list. \n Boolean \n This attribute type represents a boolean value which can either be true\nor false. This attribute type is rendered as two radio buttons labeled\n“Yes” and “No”. \n Checkbox \n This attribute type behaves in the same way as a Boolean does – it is\nactually an alternative to the Boolean attribute type - but it is\nrendered with a checkbox labeled “Yes” or “No”. \n Date \n This attribute type represents a date, tracking time within a content;\nit is often used to filter contents appearing in lists by publication\ndate, etc. \n It is rendered as a datepicker. \n Timestamp \n This attribute type is specialized for the Date attribute, allowing you\nto also specify the hour, minute and second. \n It is rendered as a datepicker for the date, and a select for hours,\nminutes and seconds. \n Enumerator \n The enumerator attribute type represents textual information with a\npredefined set of choices; it is defined by: \n \n \n Elements which are mandatory and declares the set of available\nchoices; \n \n \n Separator, which is optional and declares the character to use to\nseparate the arguments of the enumerator. By default the comma “,”\nis used. \n \n \n ExtractorBean: this parameter represents the name of the Spring bean\nto use to process the values of the enumerator. The name must\nexactly match the id of the bean as defined in the Spring\nconfiguration file. \n \n \n It is rendered as a select list. \n Enumerator Map \n The enumerator map attribute type represent textual information with a\npredefined set of choices; it is defined by: \n \n \n Elements in the form of a separated list of key=value pairs, (i.e.\nkey1=value1,key2=value2) \n \n \n Separator, which is optional and declares the character to use to\nseparate the key, values pairs. By default the comma is used. \n \n \n It is rendered as a select list which shows the available values. \n Hypertext \n This attribute type holds HTML tagged text; it retains a single value\nfor all languages. \n Even if this attribute type could support all HTML tags, we strongly\nrecommend using only tags which provide meaning and avoid those which\ndecorate or add graphics. \n Hypertext attributes are rendered as a text area in the content edit\npage; if the CKEditor is active, the user has access to a set of\nadditional functionalities from a dedicated editor’s toolbar. Such as\ntable insertion and table manipulation, special characters insertion,\nstring formatting, links creation. \n Image \n This attribute type binds an image resource to the content. \n The image is always taken from the Digital Assets images list. The user\nwill need to specify the description accompanying the image. \n Usually attributes of type Image are not indexed and are not used to\nfilter contents. \n It is rendered as a button named “Add” that, when pushed, allows the\nuser to select an image from the Digital Assets images list. Once\nselected the user is presented with a preview, as a thumbnail, of the\nimage and has the possibility to define some parameters: \n \n \n Text which is mandatory and by default takes the name of the\nselected image \n \n \n legend (optional) \n \n \n alt (optional) \n \n \n description (optional) \n \n \n title (optional) \n \n \n Link \n This attribute type represents an hypertext link; it is normally used to\ninclude a link in your content: it is possible to define up to three\ndifferent types of links: \n \n \n external links: a link pointing to a location external to the Entando\nportal \n \n \n link to page: a link which points to a page of the portal \n \n \n link to a content: a link to another content \n \n \n It is rendered as a button named “Add” that when pushed opens up a modal\nwindow from which the user can select the link type. \n Longtext \n This attribute type represents a simple unformatted text; it supports\nseveral languages and is normally used for small descriptions, when a\nshort string won’t suffice. \n It supports minimum length , maximal length and regular expressions as\noptional parameters. \n It is rendered as a textarea. \n Monotext \n Monotext represents the information in textual form, but supports only a\nlanguage; it is used for all \n those fields which do not require localization. \n It supports minimum length, maximal length, and regular expressions as\noptional parameters. \n It is rendered as a textfield. \n Number \n This attribute type holds an integer number; it retains a single value\nfor all languages. \n Supports the optional parameters: From, To, and Equal to. \n It is rendered as a textfield. \n Text \n This attribute type holds a string; it retains a single value for all\nlanguages. \n It supports minimum length, maximal length, and regular expressions as\noptional parameters. \n It is rendered as a textfield. \n ThreeState \n Conceptually similar to the Boolean attribute, this attribute type\nallows a third status “Both” to be present. \n It is rendered as a radio button with “Yes”, “No”, “Both” options. \n Composed Attribute Types \n All the attributes types of the previous chapter can only retain a\nsingle type of information, but sometimes it is desirable to aggregate\ndifferent types of attributes into one attribute: this is where composed\nattributes are used. \n From a functional point of view, it would be perfectly legal to build a\ncontent type specifying all the attributes back to back: the content\nwould be formally complete, but from a logical point of view the\nattributes would appear mutually unrelated and, worse, the relationship\nbetween them would not be explicit. \n Entando offers three types of composed attributes: List, Monolist,\nComposite. \n List \n This Attribute Type represents a set of independent and homogeneous\nelementary Attribute types, each associated with one of the languages\ndefined in the system. \n An immediate consequence is that this kind of list can handle only\nmono-language basic attributes. \n It is rendered with a button named “Add” that if pushed presents the\nuser a prompt to select or define the single elements which compose the\nlist. \n Monolist \n This attribute type is a list that is common to all the system\nlanguages; this kind of list handles multi-language and mono-language\nattributes. \n It is rendered with a button named “Add” that, if pushed, presents the\nuser with a prompt to select or define the single elements that compose\nthe monolist. \n Composite \n This attribute type is an aggregate of different, non-homogeneous,\nsimple attributes types. The aggregation of different types is treated\nas a single unit. \n It is rendered as a combination of the elementary attribute types, where\neach attribute type presents the proper rendering. \n"},{title:"Content Types",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/compose/content-types-tutorial.html",relativePath:"next/tutorials/compose/content-types-tutorial.md",key:"v-05ac7de0",path:"/next/tutorials/compose/content-types-tutorial.html",headers:[{level:2,title:"Create a Content Type",slug:"create-a-content-type"},{level:2,title:"Attribute Configuration",slug:"attribute-configuration"}],lastUpdated:"3/23/2022, 5:40:18 PM",lastUpdatedTimestamp:1648071618e3,content:' Content Types \n A Content Type represents or models a Content. Alternatively, a Content is an instance or specialization of a Content Type. \n Content Types are characterized by  Attribute Types . Each Attribute Type consists of one or more properties, known as Attributes, which are defined by their Attribute Type. \n Create a Content Type \n Content Types are managed via the Web CMS, through a user interface provided by the  Entando App Builder . Follow the steps below to create and configure a Content Type. \n 1. From the left menu of the App Builder, go to  Content  →  Types . \n 2. Click the  Add  button in the upper right corner. \n \n 3. Configure the Content Type. \n When adding a Content Type it is mandatory to enter  Code  and  Name  values consistent with the following: \n \n \n Code : A unique identifier of the Content Type that must be 3 uppercase letters. \n \n \n Name : A string value of 50 characters or less consisting of one or more of the following: uppercase letters, lowercase letters, numbers and/or special characters. \n \n \n Other field entries are not mandatory, but to specify a meaningful Content Type you must choose the appropriate  Type  from the drop-down in the Attributes section. The available options define Attributes to characterize the Content. \n \n 4. Click the  Add  button. \n This launches the configuration of the selected Attribute Type. Each Attribute Type requires its own configuration. \n Attribute Configuration \n Clicking  Add  loads a form to configure the Attribute. The  Type  field is pre-filled with your Attribute Type selection. \n 1. Define the characteristics of the Attribute: \n \n \n \n Code : It is mandatory to enter a unique name for the Attribute key of an Attribute Type. This field supports a string value of 10 characters or less and should consist of one or more of the following: uppercase letters, lowercase letters, numbers and/or special characters. \n \n \n Name : Enter a description of the Attribute. This field supports a string value of 50 characters or less and should consist of one or more of the following: uppercase letters, lowercase letters, numbers and/or special characters. \n \n \n Certain Attribute Types support the option to declare that the Attribute is  Mandatory ,  Searchable  and/or  Can be used as a filter in lists  via toggle buttons. \n \n \n Certain Attribute Types support the option to choose an Attribute  Role . Be sure to click the  Add  button after making your selection. \n \n \n The remaining fields are not mandatory and may be left empty. \n \n \n TIP \n Certain Attribute Types allow you to assign the  Role  of  jacms:title - The main title of a Content . This informs plugins or services that the Attribute is a title, regardless of its key, or  Code . Entering "title" for the  Code  avoids confusion when this  Role  is selected. \n \n 2. Click the  Continue  button. \n This adds the configured Attribute to the Attribute Type. \n \n \n \n Complete the additional configuration steps required by your Attribute Type, if applicable. \n \n \n (Optional) Add other Attribute Types to your Content Type, subject to the configuration process above. \n \n \n 3. Click the  Save  button. \n The Content Type you created is now displayed in the table. \n \n'},{title:"Content Creation",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/compose/content-tutorial.html",relativePath:"next/tutorials/compose/content-tutorial.md",key:"v-5e4809c0",path:"/next/tutorials/compose/content-tutorial.html",headers:[{level:2,title:"Create Content",slug:"create-content"},{level:2,title:"Save and Approve Content",slug:"save-and-approve-content"},{level:2,title:"Find Content",slug:"find-content"},{level:2,title:"Content Actions",slug:"content-actions"},{level:2,title:"Publish, Unpublish, or Delete Content",slug:"publish-unpublish-or-delete-content"}],lastUpdated:"3/29/2022, 3:19:52 PM",lastUpdatedTimestamp:1648581592e3,content:" Content Creation \n This tutorial describes how to create, edit and publish content in an application with the Entando Web Content Management System from within the  App Builder . \n Create Content \n \n \n Log into your App Builder. \n \n \n From the left sidebar, go to  Content  →  Management . All existing\ncontent is displayed in a table. \n \n \n \n \n \n To create new  Content , click the  Add  button on the right side of page. Select the  Type  desired from the drop-down list. New types can be added to the list in the  Content Type  section.\n \n \n \n You are asked to provide the following information. \n \n \n Info \n \n \n Content Type : This is predefined. \n \n \n Description : Enter the name or description. This field is required. \n \n \n \n \n Groups \n \n \n Owner Group : Choose an available user group to manage the content from the drop-down list. Click the  +  symbol to select. This field is required and can be amended in the App Builder's  User  section under  Groups . \n \n \n View Only Groups : Add groups to provide viewing access to content. \n \n \n \n \n Categories : Click  +  under  Join  to include the  Content  in the appropriate category for searching and sorting.  This field is not mandatory. \n \n \n Content Attributes : Enter the required  Date  and  Title  fields under the  Attributes  section. You can enter the remaining optional fields as needed. \n \n \n Content Info - History : This displays the iterations for the saved item. You can view the details or revert to a previous version. \n Save and Approve Content \n \n For new or edited content, determine which  Status  it belongs to: \n \n \n \n Draft : The  Content  is in the development stage and not ready for approval or publication. The  Save  or  Save and Continue  buttons establish  Draft  status for the content. \n \n \n Ready : The  Content  is ready for review, but has not been approved or published.  Items with this status can be saved and approved later or published immediately. \n \n \n \n Saving options: \n \n \n \n Save : The content is saved in a  Draft  version. \n \n \n Save and Continue : The content is saved in a  Draft  version and the editable form is displayed. \n \n \n Save and Approve : The content is saved, approved, and ready for use in an application. \n Find Content \n Using the  Advanced Filters  feature, you can search for Content by name, type, category, group, or status.\n \n In the resulting table, content is listed with these parameters:  Name ,  Author \n Code ,  Created by ,  Last Edited ,  Type ,  Status ,  Visibility ,  Group ,  Creation  Date,  Last Modified , and executable  Actions . Any field can be deleted from view by unchecking them in the  Additions to the Table of Results  drop-down menu. \n Content Actions \n For all items in the  Content  table, the  Actions  drop-down menu provides these executable options: \n \n \n Copy/Paste : Replicate the content \n \n \n Draft Version : Edit the unpublished draft version \n \n \n Published Version : Edit or revert to a previous published version of the content \n \n \n Edit : Update the data fields in the Content definition \n Publish, Unpublish, or Delete Content \n To  Publish ,  Unpublish , or  Delete  content, use the buttons above the table for checked items. This takes you to a confirmation page where a summary displays the usage of the item in your application. \n \n"},{title:"Page and Content Protection",frontmatter:{},regularPath:"/next/tutorials/compose/creating-protected-resources.html",relativePath:"next/tutorials/compose/creating-protected-resources.md",key:"v-592245a0",path:"/next/tutorials/compose/creating-protected-resources.html",headers:[{level:2,title:"Create a Group",slug:"create-a-group"},{level:2,title:"Protect a Page",slug:"protect-a-page"},{level:2,title:"Protect Content",slug:"protect-content"},{level:2,title:"Protect Images and Attachments",slug:"protect-images-and-attachments"},{level:2,title:"Freemarker Tags and Consuming Protected Resources",slug:"freemarker-tags-and-consuming-protected-resources"}],lastUpdated:"1/25/2022, 4:09:16 PM",lastUpdatedTimestamp:1643144956e3,content:" Page and Content Protection \n In the Entando Web Content Management System (WCMS) you have the ability to protect pages, content, and digital assets (images and files) by assigning groups that have the authorization to view those assets. If users without the correct authorization attempt to view those assets the platform will return an error. You can handle those errors as required for your application with dedicated error pages or by adding logic to your widgets or freemarker templates. \n Create a Group \n Protected pages, content, and digital assets in the WCMS are protected by assigning groups to the resource that is being created. You can add new groups in the Entando App Builder as follows: \n \n Go to  Users → Groups  from the left navigation \n Select  Add \n Enter a  Name  and a  Code  for your group` \n \n The groups you create here can be utilized to protect pages, content, images, and attachments in the CMS. Groups can be assigned to individual users in the  Users  section of the app builder or as part of a customization of your entando-core-app using APIs or custom code. \n Pages and Content have settings for an  Owner Group  as well as a set of optional  Join Groups . The  Owner Group  indicates the team within the  App Builder  who owns and can modify the page. Additional groups can be given access to the item via the  Join Group  setting. Note: the default App Builder configuration prevents the  Owner Group  from being changed after the item is created. \n Protect a Page \n \n Select  Pages → Management  from the left navigation \n Create a new page. Assign values as you see fit \n To protect a page, assign the  Owner Group  to any group other than  Free Access \n (Optional) Add groups via  Join Group \n Finish configuring the page and select  Save \n \n At this point only users assigned to either the  Owner Group  or  Join Group  will have the ability to view that page. They can also manage the Page if they have the appropriate App Builder role. \n If you would like to test this, navigate to the page URL in a private or incognito browser window and you will be redirected to the  Sign in to Proceed Further  page of your application.\nThe  Sign in to Proceed Further  page can be changed by going to  Pages → Settings  and picking the page you would like to render to users who need to sign in. \n Protect Content \n \n Select  Content → Management  from the left navigation \n Select the  Add Content  button and pick the content type to be created \n To protect a content item, assign the  Owner Group  to any group other than  Free Access \n (Optional) Add groups via  Join Group \n Finish configuring the page and select  Save \n \n The content you are creating will only be available to users assigned to the  Owner Group  of  Join Group . The default WCMS widgets will only return content authorized for a given user. See the  freemarker tags  section below for information on creating custom widgets that utilize protected content. \n Images and Attachments and Groups \n When creating content the  Owner Group  of the content and the  Group  assigned to the digital asset must match. For example, when creating content with an  Owner Group  of  Administrators  the content creator will be unable to select images and attachments that are assigned a different group. The exception to this is assets with a group of  Free Access . Assets with  Free Access  can be added to protected content. \n Protect Images and Attachments \n Images and attachments uploaded to the CMS can be protected by assigning groups. \n \n Select  Content → Assets  from the left navigation \n Upload your file(s) \n In the provided modal window select the  Group  that you would like to own the asset \n Only users with the assigned  Group  will have the ability to view the asset you've created\n \n The asset will only be available to content with the same  Group  unless the attachment or image has been given a group of  Free Access \n Freemarker Tags and Consuming Protected Resources \n The WCMS provides a set of freemarker tags to assist in consuming protected assets in widgets and pages. The  if-authorized  and  tag-nav  tags can help in rendering page lists and fetching assets. \n The  content  and  content-list  tags also provide the ability to fetch and render protected content and protected lists of content. \n Additionally, the   REST APIs  allow clients to fetch protected pages and assets by group via query parameters. The content REST APIs also include the ability to filter by group and access level. \n"},{title:"Widgets and Fragments",frontmatter:{},regularPath:"/next/tutorials/compose/widgets-fragments.html",relativePath:"next/tutorials/compose/widgets-fragments.md",key:"v-1793e788",path:"/next/tutorials/compose/widgets-fragments.html",headers:[{level:2,title:"Create a Widget",slug:"create-a-widget"},{level:2,title:"Create a UX Fragment",slug:"create-a-ux-fragment"},{level:2,title:"FreeMarker Basics in Entando",slug:"freemarker-basics-in-entando"}],lastUpdated:"1/25/2022, 4:09:16 PM",lastUpdatedTimestamp:1643144956e3,content:' Widgets and Fragments \n This tutorial will take you through the basics of creating an Entando\nwidget and placing it on a page. This document will also review the\nbasics of fragments which are re-usable pieces of a user interface. \n Create a Widget \n For this example you will use the Entando App Builder to build and\ndisplay a simple widget on a page. In a production system or a larger\ndevelopment environment you would build and deploy widgets differently,\nhowever this example provides a quick idea of the building blocks. For a more advanced example you can try  this tutorial  which includes building and deploying a micro frontend as a widget in Entando. \n \n \n In the App Builder menu, go to:  Components → Micro frontends & Widgets \n \n At bottom of the page, select ADD \n \n \n \n Now create a widget with the sample HTML code.  Enter into the following fields: \n \n Code:  MyHelloWorld \n en Title:  Hello World \n it Title:  Ciao Mondo \n Custom UI field:  <h2>Hello World</h2> \n Select SAVE \n Note: the Custom UI Field is a freemarker template where you can put raw html and include freemarker logic. This allows you to import javascript, css, or any normal HTML. \n \n \n \n Select a new Home Page \n \n Go To:  Pages → Settings \n From the “Home Page” dropdown menu, select “Home / Service” and select SAVE \n \n \n \n Place the widget on the page \n \n Go To:  Pages → Management \n On the row that says "Service", on the far right side, select the Kebab button and select DESIGN \n From the right hand column, drag and drop the new widget into an open frame in the page \n From the top of the page, select PREVIEW \n You should see "Hello World" on the page \n \n \n \n Publish the updated page \n \n Go To:  Pages → Management \n Note for the row showing the Services page, the Status is now yellow \n Select the Kebab button and select PUBLISH \n Create a UX Fragment \n A UX Fragment is a way to take a common piece of front end code and reuse\nit across multiple pages or widgets. Common elements such as basic HTML,\njavascript, or freemarker logic can be stored as fragments and\nreferenced via the  <@wp.fragment …  tag. \n Starting from the simple widget tutorial above: \n \n \n Create a new fragment: \n \n In the App Builder Go To:  Components → UX Fragments \n At bottom of page, select ADD, and enter the following fields \n Code:  test \n Gui Code:  <h2>Hello World</h2> \n Select SAVE \n \n \n \n Place the fragment in a template: \n \n Go To:  Pages → Page Templates \n On the row for service, select EDIT \n In the  Template  text box, add   <@wp.fragment code="test"/>  on a new line between the  <body>  and   </body>  tags \n SAVE the page template \n \n \n \n View the page with the new fragment: \n \n Go To:  Pages → Management \n On the row that says "Service", on the far right side, select the Kebab button and select CONFIGURE \n From the top of the page, select PREVIEW \n Note: You will see the fragment  <h2> This is a fragment. </h2>  which includes the HTML tags. By default html embedded via a fragment tag is escaped so you get it rendered exactly as you enter it. You’ll need to un-escape it to get it to render correctly. \n \n \n \n Update the Fragment: \n \n Go To:  Pages → Page Templates \n On the row for service, select EDIT \n Change the tag to:  <@wp.fragment code="test" escapeXml=false/> \n \n \n \n View the page with the updated fragment: \n \n Go To:  Pages → Management \n On the row that says "Service", on the far right side, select the Kebab button and select CONFIGURE \n From the top of the page, select PREVIEW \n See correctly rendered fragment \n FreeMarker Basics in Entando \n The FreeMarker templating language gives you a lot of flexibility and\npower in how pages are rendered. You can include conditional logic,\ninject information from the backend, check for query parameters and\nroute to different pages. \n For example, to check for a query parameter you can use:\n <#if RequestParameters.myParam?exists > … \n To check the current username, use:\n <#if (Session.currentUser.username != "guest") > \n When you need dynamic behavior in your widgets consider using the power\nof FreeMarker. \n https://freemarker.apache.org \n'},{title:"jACMS Aps Core Tag Library",frontmatter:{},regularPath:"/next/docs/reference/freemarker-tags/freemarker-JACMS-tags.html",relativePath:"next/docs/reference/freemarker-tags/freemarker-JACMS-tags.md",key:"v-c90a8f02",path:"/next/docs/reference/freemarker-tags/freemarker-JACMS-tags.html",headers:[{level:2,title:"Tag content",slug:"tag-content"},{level:3,title:"Tag Class com.agiletec.plugins.jacms.aps.tags.ContentTag",slug:"tag-class-com-agiletec-plugins-jacms-aps-tags-contenttag"},{level:3,title:"Description",slug:"description"},{level:3,title:"Attributes",slug:"attributes"},{level:2,title:"Tag contentInfo",slug:"tag-contentinfo"},{level:3,title:"Tag Class com.agiletec.plugins.jacms.aps.tags.ContentInfoTag",slug:"tag-class-com-agiletec-plugins-jacms-aps-tags-contentinfotag"},{level:3,title:"Description",slug:"description-2"},{level:3,title:"Attributes",slug:"attributes-2"},{level:2,title:"Tag contentList",slug:"tag-contentlist"},{level:3,title:"Tag Class com.agiletec.plugins.jacms.aps.tags.ContentListTag",slug:"tag-class-com-agiletec-plugins-jacms-aps-tags-contentlisttag"},{level:3,title:"Description",slug:"description-3"},{level:3,title:"Attributes",slug:"attributes-3"},{level:2,title:"Tag contentListFilter",slug:"tag-contentlistfilter"},{level:3,title:"Tag Class Tag class: com.agiletec.plugins.jacms.aps.tags.ContentListFilterTag",slug:"tag-class-tag-class-com-agiletec-plugins-jacms-aps-tags-contentlistfiltertag"},{level:3,title:"Description",slug:"description-4"},{level:3,title:"Attributes",slug:"attributes-4"},{level:2,title:"Tag contentListUserFilterOption",slug:"tag-contentlistuserfilteroption"},{level:3,title:"Tag Class Tag class: com.agiletec.plugins.jacms.aps.tags.ContentListUserFilterOptionTag=",slug:"tag-class-tag-class-com-agiletec-plugins-jacms-aps-tags-contentlistuserfilteroptiontag"},{level:3,title:"Description",slug:"description-5"},{level:3,title:"Attributes",slug:"attributes-5"},{level:2,title:"Tag searcher",slug:"tag-searcher"},{level:3,title:"Tag Class com.agiletec.plugins.jacms.aps.tags.SearcherTag",slug:"tag-class-com-agiletec-plugins-jacms-aps-tags-searchertag"},{level:3,title:"Description",slug:"description-6"},{level:3,title:"Attributes",slug:"attributes-6"},{level:2,title:"Tag rowContentList",slug:"tag-rowcontentlist"},{level:2,title:"Tag Class Tag class: com.agiletec.plugins.jacms.aps.tags.RowContentListTag",slug:"tag-class-tag-class-com-agiletec-plugins-jacms-aps-tags-rowcontentlisttag"},{level:3,title:"Description",slug:"description-7"},{level:3,title:"Attributes",slug:"attributes-7"}],lastUpdated:"11/3/2020, 4:20:16 AM",lastUpdatedTimestamp:1604395216e3,content:' jACMS Aps Core Tag Library \n \n \n Version: 2.3 \n \n \n Short Name: jacmsaps \n \n \n URI: /jacms-aps-core \n Tag  content \n Tag Class  com.agiletec.plugins.jacms.aps.tags.ContentTag \n Description \n Displays the content given its ID. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n contentId \n false \n ID of the content to display. It can accept "expression language". \n \n \n modelId \n false \n Id of the model to use to display the content. The model ID can be either specified explicitly (the model must match the content to serve) or the type name ("list" or "default"); in the latter case the model specified in the configuration will be used. The model must adhere to the content being returned. "Expression language" is accepted. \n \n publishExtraTitle \n false \n Toggles the insertion of the values of the titles in the Request Context. The title values are extracted from the attribute marked with the role "jacms:title". Admitted values are (true, false), default \'false\'. \n \n \n var \n false \n Inserts the rendered content in a variable of the page context with the name provided. \n \n \n attributeValuesByRoleVar \n false \n Inserts the map of the attribute values indexed by the attribute role, in a variable of the page context with the name provided. \n Tag  contentInfo \n Tag Class  com.agiletec.plugins.jacms.aps.tags.ContentInfoTag \n Description \n Return information of a specified content. The content can will be extracted by id from widget parameters or from request parameter. The tag extract any specific parameter (by "param" attribute) or entire ContentAuthorizationInfo object (setting "var" attribute and anything on "param" attribute). \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n contentId \n false \n ID of the content \n \n \n param \n false \n Admitted values for "param" attribute are: \'contentId\' (returns the code of content id), \'mainGroup\' (returns the code of owner group), \'authToEdit\' (returns true if the current user can edit the content, else false). \n \n \n var \n false \n Inserts the required parameter (or the entire authorization info object) in a variable of the page context with the name provided. \n Tag  contentList \n Tag Class  com.agiletec.plugins.jacms.aps.tags.ContentListTag \n Description \n Loads a list of contents IDs by applying the filters (if any). Only the IDs of the contents accessible in the portal can be loaded. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n listName \n true \n Name of the variable in the page context that holds the search result. \n \n \n contentType \n false \n Sets the code of the content types to search. The name must match the configured one, respecting capital letters and spaces. \n \n \n category \n false \n Identifier string of the category of the content to search. \n \n \n cacheable \n false \n Toggles the system caching usage when retrieving the list. Admitted values (true, false), default "true". \n \n \n titleVar \n false \n Inserts the title on a variable of the page context with the name provided. \n \n \n pageLinkVar \n false \n Inserts the code of the page to link on a variable of the page context with the name provided. \n \n \n pageLinkDescriptionVar \n false \n Inserts the description of the page to link on a variable of the page context with the name provided. \n \n \n userFilterOptionsVar \n false \n Name of the variable in the page context that holds the user filter options \n Tag  contentListFilter \n Tag Class  Tag class: com.agiletec.plugins.jacms.aps.tags.ContentListFilterTag \n Description \n "ContentListTag" sub-tag, it creates a filter to restrict the result of the content search. Please note that the filters will be applied in the same order they are declared and the result of the search will reflect this fact. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n key \n true \n String used to filter and sort the contents. This string can be: - the name of a content attribute compatible with the type declared in the "contentListTag" (it requires the "attributeFilter" attribute to be "true") - the ID of one of the content metadata (the "attributeFilter" must be false) The allowed filter key that can be applied to content metadata are: - "created" allows sorting by date of creation of content - "modified" allows sorting by date of modification of content. \n \n \n attributeFilter \n true \n Decides whether the filter must be applied to an attribute or to a content metadata, admitted values are (true, false). The "key" attribute will be checked for validity if the filter is going to be applied to a metadata \n \n \n value \n false \n The filtering value. \n \n \n start \n false \n Filters the contents by attribute type or by the field specified with the key (respect the following matches): Text field -→ start Text Text attribute type -→ start Text Numeric attribute type -→ start Numeric date attribute type -→ start data If the data filter is used: - today, oggi or odierna will select all the contents with a date greater or equal to the system date - using date with the pattern "dd/MM/yyyy" will select all the contents with a date greater or equal to the one inserted. \n \n \n end \n false \n Similar the the "start" attribute but with the opposite behavior. \n \n \n order \n false \n Specifies the sorting behavior of the IDs found: "ASC"ending or "DESC"ending. By default no ordering is performed. \n \n \n likeOption \n false \n Toggles the \'like\' functionality. Admitted values: (true, false). Default: false. The option is available for metadata and on Text Content attributes. \n Tag  contentListUserFilterOption \n Tag Class  Tag class: com.agiletec.plugins.jacms.aps.tags.ContentListUserFilterOptionTag = \n Description \n "ContentListTag" sub-tag, it creates a custom user filter to restrict the result of the content search by front-end user. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n key \n true \n The key of the filter. This string can be: - the name of a content attribute compatible with the type declared in the "contentListTag" (it requires the "attributeFilter" attribute to be "true") - the ID of one of the content metadata (the "attributeFilter" must be false) The allowed filter key that can be applied to content metadata are: - "fulltext" allows filter by full-text search<br /> - "category" allows filter by a system category. \n \n \n attributeFilter \n true \n Decides whether the filter must be applied to an attribute or to a content metadata, admitted values are (true, false). The "key" attribute will be checked for validity if the filter is going to be applied to a metadata. \n Tag  searcher \n Tag Class  com.agiletec.plugins.jacms.aps.tags.SearcherTag \n Description \n Generates a list of content IDs, restricting them to the key word contained in the "search" parameter of the http request. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n listName \n yes \n Name of the variable, stored in the page context, containing the list of content IDs. \n Tag  rowContentList \n Tag Class  Tag class: com.agiletec.plugins.jacms.aps.tags.RowContentListTag \n Description \n Publish a list of contents. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n listName \n true \n Name of the variable in the page context that holds the contents (list of properties of key "contentId" and "modelId"). \n \n \n titleVar \n false \n Inserts the title on a variable of the page context with the name provided. \n \n \n pageLinkVar \n false \n Inserts the code of the page to link on a variable of the page context with the name provided. \n \n \n pageLinkDescriptionVar \n false \n Inserts the description of the page to link on a variable of the page context with the name provided. \n \n \n \n'},{title:"Digital Assets",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/compose/digital-assets-tutorial.html",relativePath:"next/tutorials/compose/digital-assets-tutorial.md",key:"v-4412ada8",path:"/next/tutorials/compose/digital-assets-tutorial.html",headers:[{level:2,title:"Manage Assets:",slug:"manage-assets"},{level:3,title:"Add a New Asset",slug:"add-a-new-asset"},{level:2,title:"Edit Assets",slug:"edit-assets"},{level:2,title:"Edit Images",slug:"edit-images"},{level:2,title:"Embed an Asset on a Page",slug:"embed-an-asset-on-a-page"},{level:2,title:"Include an Asset in a Content",slug:"include-an-asset-in-a-content"},{level:2,title:"Configure File Extensions for Upload",slug:"configure-file-extensions-for-upload"}],lastUpdated:"3/31/2022, 10:16:10 AM",lastUpdatedTimestamp:164873617e4,content:' Digital Assets \n The Entando Web Content Management System (WCMS) includes capabilities that let you manage contents and digital assets. Digital Assets are images, documents, and other media files in specific formats. \n Default Supported Document Formats:   pdf ,  xls ,  doc ,  ppt ,  txt ,  rtf ,  sxw ,  sxc ,  odt ,  ods ,  odp ,  tar ,  gz ,  zip ,  rar ,  flv ,  swf ,  avi ,  wmv ,  ogg ,  mp3 ,  wav ,  ogm ,  mov ,  iso ,  nrg ,  docx ,  docm ,  xlsx ,  xlsm ,  xlsb ,  pptx ,  pptm ,  ppsx ,  ppsm ,  sldx ,  sldm \nThe Entando WCMS can be configured to allow or exclude any type of file extension\nto your site. For the App Builder, you should also include the MIME type for the assets you want to allow. \n Default Supported Image Formats :  jpg ,  jpeg ,  png ,  svg ,  svg+xml \n Manage Assets: \n \n Login to the App Builder. \n From the left sidebar, go to  Content  →  Assets . \n \n \n \n View  Images  or  Attachments  with the tabs at the top of the page. \n Search by name or use the  Advanced filters  function to search by  Group ,  Filename , and/or  Category . \n Assets are displayed and ordered by Name.  Choose View  to toggle between a list or grid format. The order can also be changed. \n For each resource, click on the action menu (indicated by three vertical dots) to the right to Edit, Delete and preview available sizes. \n Add a New Asset \n \n From the Content Assets page in the App Builder, click  Add  on the right to add a new image or document file. \n \n \n \n Group : Choose from the drop-down menu. This is a required field and defaults to  Free Access . Additional groups can be defined in the Users section. \n Categories : Add your asset to the appropriate category with the  +  symbol under  Join . Categories are used in searching and sorting, but this is not a mandatory field. New Categories can be created in  Content  →  Categories . \n Drag and Drop your files into the window or click  Browse . The file you choose should appear in the Name field. You can choose multiple files at one time. You can also click  Add Another Resource  and  Choose file (s) individually. \n After all files have been chosen, click  Add  to upload. This takes you back to the main assets page where your uploaded files will be listed in the table. If you have an image file, see Edit Assets below. \n If a Name field is left blank, you will receive an error message. Simply go to the actions menu (indicated by three vertical dots) next to the empty file and select Delete. This action menu includes an  Edit  option. \n Edit Assets \n Changes to the Asset name and categories can be made on the Edit page. \n \n From  Content  →  Assets  page, in the list of assets, click on the Asset\'s actions menu (indicated by vertical dots) and select  Edit . \n Edit the Name field. For Categories, use the  +  button under  Join  to add the  Asset  to any category. \n Once all changes are made, click the  Add  button to finish. \n \n To organize or download assets, go to  Administration  →  File browser  and navigate to  /public/cms  to find your documents and images. \n Edit Images \n You can flip, rotate and crop newly uploaded images. \n \n Go to  Content  →  Assets  →  Add . \n After uploading an image, click on the actions menu to the right of the image and select  Edit .\n \n Use the arrows to flip, rotate or recenter your image. When done, click the  Crop  check button. Multiple resized images can be created at this time. Click  Free  to remove resizing ratio restrictions. \n Click  Done  at the top. \n Click  Add  to save all versions. \n Embed an Asset on a Page \n The uploaded asset can be embedded on a page by using: \n <@wp.resourceUrl>YOUR-PATH/YOUR-ASSET.jpg\n \n This path can be found in the App Builder at  Administration  →  File Browser . \ne.g.  <img src="<@wp.resourceUrl>cms/images/YOUR_FILENAME.jpg"> \n Include an Asset in a Content \n The Asset can be included in a Content Type that has an  Attach  or  Image  attribute. Follow the  Content Type tutorial  for detailed steps or follow the briefly outlined steps here. \n Create a Content Type with an image  Attribute . \n \n From the left sidebar, select  Content  →  Types  →  Add . \n \n \n \n Fill out  Code ,  Name  and click  Add . \n This takes you to the  Add Attribute  page. For this example, the Attribute Type is image. Enter the  Code  and  Name  as required.  All other fields are optional. Click  Continue  at bottom of the page. Note the Attribute Code field is used below to reference the image in the Template.\n \n To create the Template or Model where this  Content Type  can be inserted, go to  Content  →  Template  →  Add .\n \n From the drop-down menu for  Type , select the one just created. \n Enter the  Code  and  Name  fields as required. \n Complete the Model HTML layout in Velocity. The Inline Editing Assist tool is available by using the Ctl-Space buttons on your keyboard. Your image tag should look something like this:\n <img src="$content.your-attribute-code.getImagePath("0")"/>  \n Click  Save . The new Content Model is complete and should appear in the list to be used anywhere in your application. \n Configure File Extensions for Upload \n The types of files that can be uploaded to an Entando Application are controlled by the\nconfiguration of the server side of the App Builder. If you\'re using the quickstart version, this is  entando-de-app . \n There are two properties that control these settings set in  src/main/conf/systemParams.properties . This file is a comma delimitted list of values. The property keys are: \n \n jacms.imageResource.allowedExtensions= \n jacms.attachResource.allowedExtensions= \n \n To configure the uploads for the App Builder and Admin Console, include both the MIME type and the file extension of the asset. The APIs that support resources check the MIME type of the uploaded asset. \n An example configuration for images: \n \n jacms.imageResource.allowedExtensions=jpg,jpeg,png,svg,svg+xml \n \n Where  svg+xml  is the MIME type for an svg image. \n The  systemParams.properties  file is bundled into the WAR and the image for the application, so you need to create and deploy an image to reflect the changes to these properties in your application. \n'},{title:"Page Management",frontmatter:{},regularPath:"/next/tutorials/compose/page-management.html",relativePath:"next/tutorials/compose/page-management.md",key:"v-5eae31e0",path:"/next/tutorials/compose/page-management.html",headers:[{level:2,title:"Create a Page",slug:"create-a-page"},{level:2,title:"Page Templates",slug:"page-templates"},{level:3,title:"JSON Configuration",slug:"json-configuration"},{level:3,title:"Template",slug:"template"},{level:3,title:"Create a Page Template",slug:"create-a-page-template"}],lastUpdated:"3/28/2022, 4:15:24 PM",lastUpdatedTimestamp:1648498524e3,content:' Page Management \n The  Entando App Builder  provides the capability to publish application pages containing content as well as other Entando components. Page Templates are used to define the layout of available frames on a page. \n Create a Page \n Follow the steps below to create a Page with a Content widget. \n 1. Go to  Pages  →  Management . \n \n 2. Click the  Add  button. \n This generates a form where the following fields are mandatory: \n \n Title : used for SEO \n Code : must be unique \n Page placement : the location of the Page in the Page Tree \n Owner Group : the Group that has access to the Page \n Page Template : the structure and presentation of the Page \n \n \n 3. Click the  Save and Design  button. \n This loads the Designer UI, which lets you place widgets into the Page Template frames. \n \n 4. Add a widget. \n This is done by dragging a widget from the right panel into the desired frame. Adding the Content widget will load the configuration page shown below. \n \n 5. Click  Add existing content . \n This generates the content selection pop-up. \n \n You can search for the name of the content that you would like to publish. Remember that content must be saved and approved before it can be published to a page. \n 6. Select the desired content item(s) from the list. \n 7. Click the  Continue  button. \n The selected  Content  item will now be displayed. \n \n 8. Click the  Save  button. \n The following actions are now available: \n \n Click on the  Preview  button to show the page preview with the updated settings. \n Click on the  Publish  button to publish the page. \n Click on the  View published page  button to view the published page in your application. \n Page Templates \n Page Templates provide the scaffolding of a Page and are constructed using two main elements: \n \n A  JSON configuration  field which lists the set of frames that can be used on a page. \n A  Template  field which uses Freemarker code to setup the HTML page itself. \n JSON Configuration \n Each item in the  frames  array of the JSON configuration represents a frame or slot in the page, characterized by the following values: \n \n pos : A zero-based position index (starts from zero). This value is used by APIs to address a specific widget on the page. \n descr : The frame description displayed in the Page Design view. \n mainFrame : This designates the primary frame in the Page Template. \n defaultWidget : The code for a default widget to use in this frame. Page Template developers can use this field to provide suggestions for common widgets, e.g. header and footer widgets. \n sketch : An object with 4 coordinates (x1,x2,y1,y2) to allow the developer to place the widgets in the Page preview. The x and y values go from 0 to 11 (similar to columns in Bootstrap), so if you want to place a 2x2 frame at the top left corner of the page, the values would be  x1: 0 ,  x2: 1 ,  y1: 0  and  y2: 1 . \n Template \n To add a frame in a specific place of the page, input  <@wp.show frame=0 /> , where  frame  is the  pos  variable from the  JSON configuration . To setup the  wp  variable,  <#assign wp=JspTaglibs["/aps-core"]>  is required at the top of the template. \n Common code can be shared across Pages by using  UX Fragments  and  <@wp.fragment code="\\<FRAGMENT\\_CODE\\>" escapeXml=false /\\> . \n Create a Page Template \n Follow the steps below to prepare a Page Template with two frames on it. \n 1. Go to  Pages  →  Templates  →  Add \n \n 2. Enter the field information below: \n \n Code : double_frame (Note: Dashes are not allowed) \n Name : Double Frame \n JSON Configuration: \n \n { \n   "frames" :   [ \n     { \n       "pos" :   0 , \n       "descr" :   "Frame 1" , \n       "mainFrame" :   false , \n       "defaultWidget" :   null , \n       "sketch" :   { "x1" :   0 ,   "y1" :   0 ,   "x2" :   11 ,   "y2" :   1 } \n     } , \n     { \n       "pos" :   1 , \n       "descr" :   "Frame 2" , \n       "mainFrame" :   false , \n       "defaultWidget" :   null , \n       "sketch" :   { "x1" :   0 ,   "y1" :   2 ,   "x2" :   11 ,   "y2" :   3 } \n     } \n   ] \n } \n \n \n Template: \n \n < #assign  wp = JspTaglibs [ "/aps-core" ] > \n <! DOCTYPE   HTML   PUBLIC   "-//W3C//DTD HTML 4.0 Transitional//EN" > \n < html > \n   < head > \n       < title > < @wp . currentPage param = "title"   /> </ title > \n   </ head > \n   < body > \n     < h1 > < @wp . currentPage param = "title"   /> </ h1 > \n     < div > < @wp . show frame = 0   /> </ div > \n     < div > < @wp . show frame = 1   /> </ div > \n   </ body > \n </ html > \n \n Include the following fragment in the  head  section to make use of the user\'s Keycloak identity information. \n < @wp . fragment code = "keycloak_auth"  escapeXml = false   /> \n \n 3. Verify that the  Template preview  is reflecting the desired two frame layout. \n 4. Click the  Save  button. \n'},{title:"Micro Frontends",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/create/mfe/",relativePath:"next/tutorials/create/mfe/README.md",key:"v-3a0d543c",path:"/next/tutorials/create/mfe/",headers:[{level:2,title:"Introduction",slug:"introduction"},{level:2,title:"Tutorials",slug:"tutorials"}],lastUpdated:"1/28/2022, 7:38:52 AM",lastUpdatedTimestamp:1643373532e3,content:" Micro Frontends \n Introduction \n \n The idea behind Micro Frontends is to think about a website or web app as  a composition of features  which are owned by  independent teams . Each team has a  distinct area of business  or  mission  it cares about and specialises in. A team is  cross functional  and develops its features  end-to-end , from database to user interface. \n —  Michael Geers,  micro-frontends.org \n \n Think of micro frontends as the implementation of a microservices architecture applied to the full web application that extends all the way to the frontend. \n Entando implements micro frontends based on  Web Components , a set of technologies that allow developers to create reusable custom elements supported by all major internet browsers. \n Web Components can work with vanilla JavaScript as well as with the most popular web frameworks (e.g., React, Angular, and Vue). \n Entando's microservice and micro frontend architecture allows developers to work with their favorite technology stack, and makes it easier for companies to integrate disparate applications. \n Tutorials \n \n \n Create a React Micro Frontend \n \n \n Create an Angular Micro Frontend \n \n \n Add an App Builder configuration screen to a\nwidget \n \n \n Display widget configuration \n \n \n Communicate Between Micro Frontends \n \n \n Widget authentication with Keycloak \n \n \n"},{title:"Create an Angular Micro Frontend",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/create/mfe/angular.html",relativePath:"next/tutorials/create/mfe/angular.md",key:"v-2b5d3579",path:"/next/tutorials/create/mfe/angular.html",headers:[{level:2,title:"Create Angular App",slug:"create-angular-app"},{level:3,title:"Convert to Custom Element",slug:"convert-to-custom-element"},{level:3,title:"Test Micro Frontend",slug:"test-micro-frontend"},{level:2,title:"Build It",slug:"build-it"},{level:2,title:"Host Micro Frontend",slug:"host-micro-frontend"},{level:3,title:"Create Public Folder",slug:"create-public-folder"},{level:3,title:"Add Widget",slug:"add-widget"},{level:3,title:"See It in Action",slug:"see-it-in-action"}],lastUpdated:"1/25/2022, 4:09:16 PM",lastUpdatedTimestamp:1643144956e3,content:" Create an Angular Micro Frontend \n Prerequisites \n \n A working instance of Entando. \n \n \n Tested Versions \n node v13.8.0 → We suggest using  nvm  to handle node installations. \n Create Angular App \n Install Angular CLI. \n npm   install  -g @angular/cli\n \n Generate a new angular application. \n ng new angular-widget\n \n Choose the following options: \n ? Would you like to  add  Angular routing? No\n? Which stylesheet  format  would you like to use? CSS\n \n Serve the application. \n cd  angular-widget\n \n ng serve\n \n This is the expected output: \n angular-widget\n├── e2e\n│   └── src\n│       ├── app.e2e-spec.ts\n│       └── app.po.ts\n│\n├── node_modules\n├── src\n│   ├── app\n│   │   ├── app.component.css\n│   │   ├── app.component.html\n│   │   ├── app.component.spec.ts\n│   │   ├── app.component.ts\n│   │   └── app.module.ts\n│   │\n│   ├── assets\n│   │   └── .gitkeep\n│   │\n│   ├── environment\n│   │   ├── environment.prod.ts\n│   │   └── environment.ts\n│   │\n│   ├── favicon.ico\n│   ├── index.html\n│   ├── main.ts\n│   ├── polyfills.ts\n│   ├── styles.css\n│   └── test.ts\n│\n├── .editorconfig\n├── .gitignore\n├── angular.json\n├── browserlist\n├── karma.conf.js\n├── package.json\n├── README.md\n├── tsconfig.app.json\n├── tsconfig.json\n├── tsconfig.spec.json\n└── tslint.json\n Convert to Custom Element \n Next, let's convert our Angular app into a custom element. We'll use  Angular elements  to transform components into custom elements. \n ng  add  @angular/elements\n \n WARNING \n Install the Angular elements package using  ng add , not with  npm install  as it runs additional steps behind the scenes like adding the  document-register-element  polyfill. \n \n TIP \n Angular elements are Angular components packaged as custom elements (also called Web Components), a web standard for defining new HTML elements in a framework-agnostic way. \n \n Open  angular-widget/src/app/app.module.ts . \n \n Here's what the initial file looks like: \n \n import   {  BrowserModule  }   from   '@angular/platform-browser' ; \n import   {  NgModule  }   from   '@angular/core' ; \n\n import   {  AppComponent  }   from   './app.component' ; \n\n@ NgModule ( { \n   declarations :   [ \n    AppComponent\n   ] , \n   imports :   [ \n    BrowserModule\n   ] , \n   providers :   [ ] , \n   bootstrap :   [ AppComponent ] \n } ) \n export   class   AppModule   {   } \n \n Replace the entire file with: \n import   {  BrowserModule  }   from   '@angular/platform-browser' ; \n import   {  NgModule ,  Injector  }   from   '@angular/core' ; \n import   {  createCustomElement  }   from   '@angular/elements' ; \n import   {  AppComponent  }   from   './app.component' ; \n\n@ NgModule ( { \n   declarations :   [ \n    AppComponent\n   ] , \n   imports :   [ \n    BrowserModule\n   ] , \n   providers :   [ ] , \n   entryComponents :   [ AppComponent ] \n } ) \n export   class   AppModule   { \n   constructor ( private   injector :  Injector )   { } \n\n   ngDoBootstrap ( )   { \n     const  el  =   createCustomElement ( AppComponent ,   {   injector :   this . injector  } ) ; \n    customElements . define ( 'angular-widget' ,  el ) ; \n   } \n } \n \n \n In the initial file,  AppModule  is bootstrapped directly during application launch. \n In the updated file, we booststrap our custom element using the  ngDoBootstrap()  method . \n \n Custom Elements \n \n Must contain a hyphen  -  in the name. : \n Cannot be a single word. \n Should follow  kebab-case  for naming convention. \n Test Micro Frontend \n Now, let's check our custom element to see if it's working. \n Open  angular-widget/src/index.html . \n In the  <body> , replace  <app-root></app-root>  with your custom element  <angular-widget /> . \n <! doctype   html > \n < html   lang = \" en \" > \n < head > \n   < meta   charset = \" utf-8 \" > \n   < title > AngularWidget </ title > \n   < base   href = \" / \" > \n   < meta   name = \" viewport \"   content = \" width=device-width, initial-scale=1 \" > \n   < link   rel = \" icon \"   type = \" image/x-icon \"   href = \" favicon.ico \" > \n </ head > \n < body > \n   < angular-widget   /> \n </ body > \n </ html > \n \n Congratulations! \n You’re now running  Angular  in a micro frontend. \n Build It \n From the project root, type: \n ng build --prod --outputHashing = none\n \n This will generate an  angular-widget/dist  directory. \n If we assume browser support for  ES6 (ECMAScript 2015) , we can focus on the following JavaScript files to publish our app: \n \n main-es2015.js \n polyfills-es2015.js \n runtime-es2015.js \n \n Generated Build Files \n --outputHashing=none  generates files without hashes so we can deploy new versions of the micro frontend without having to reconfigure our widget in Entando to point to the newly built files. \n \n If you want to use file names with content hashes to avoid potential caching issues in your browser, you can update the  Custom UI  field of your widget after building new versions of your micro frontend. Widget configuration is covered in the next section. \n Host Micro Frontend \n Now we're ready to host our micro frontend in Entando. \n Create Public Folder \n \n \n Navigate to  Entando App Builder  in your browser. \n \n \n Click  Administration  at the lower left hand side of the screen. \n \n \n Click the  File Browser  tab. \n \n \n Click the  public  folder. \n \n \n Click  Create Folder . \n \n \n Enter  angular-widget \n \n \n Click  Save . \n \n \n Click  angular-widget . \n \n \n Click 'Upload Files`. \n \n \n Upload the following files from  angular-widget/dist/angular-widget : \n \n \n \n main-es2015.js \n polyfills-es2015.js \n runtime-es2015.js \n \n Additional Deployment Options \n \n Install the micro frontend from a bundle in the  Entando Component Repository . \n Add the micro frontend to  Entando App Builder . \n Load the micro frontend from an API. \n Add Widget \n \n Go to  Components > Micro frontends & Widgets  in the Entando App Builder. \n Click  Add  at the lower right. \n \n \n \n Enter the following: \n \n \n Code: angular_widget  → note: dashes are not allowed \n Title: Angular Widget  → for both English and Italian languages \n Group: Free Access \n Custom UI: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < script   async   src = \" < @wp . resourceURL  /> angular-widget/main-es2015.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> angular-widget/polyfills-es2015.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> angular-widget/runtime-es2015.js \" > </ script > \n\n < angular-widget   /> \n \n \n Click  Save . \n \n TIP \n <#assign wp=JspTaglibs[ \"/aps-core\"]>  gives you access to the  @wp  object where you can use environment variables like  resourceURL . \n See It in Action \n Let's see the Angular micro frontend in action on our page. \n Add Page \n Note \n If you've already configured your home page: \n \n   Next to the  Home  folder, under  Actions , click  Configure . \n   Skip to the  Add Widget  section. \n \n \n Let's add our widget to the  Home  page. \n \n \n Go to  Pages  →  Management \n \n \n Next to the  Home  folder, under  Actions , click  Edit . \n \n \n Next to  Page Template  select  Service Page . \n \n \n Click  Save and Configure . \n Add Widget \n \n \n In the Search field in right-hand sidebar, enter  Angular Widget . \n \n \n Drag and drop  Angular Widget  into the  Sample Frame  in the main body of the page. \n \n \n Click  Publish . \n \n \n At the upper right, click  Go to Homepage . \n \n \n \n Congratulations! \n You now have an Angular micro frontend running in Entando. \n \n"},{title:"Authentication",frontmatter:{},regularPath:"/next/tutorials/create/mfe/authentication.html",relativePath:"next/tutorials/create/mfe/authentication.md",key:"v-eec44296",path:"/next/tutorials/create/mfe/authentication.html",lastUpdated:"1/25/2022, 4:09:16 PM",lastUpdatedTimestamp:1643144956e3,content:" Authentication \n Keycloak is used for authentication. \n To set up keycloak server, please refer to Keycloak\n documentation . \n As all MFE widgets use the same Keycloak instance, it should be\ninitialized on a container of all widgets. \n Using Details widget generated using Entando JHipster blueprint as an\nexample, let’s get familiar with authentication implementation. \n As mentioned before, widget auth implementation assumes that Keycloak is\ninitialized outside of the widget. In Details example, it is done in\nindex.html where Keycloak server’s keycloak.js is used. \n <head>\n    <script src=\"keycloak.js\"><\/script>\n    <script>\n        var keycloak = new Keycloak();\n        keycloak\n          .init({ onLoad: 'check-sso' })\n          .success(onInit);\n    <\/script>\n</head>\n \n \n Note \n keycloak.js is provided by your Keycloak server at\n <SERVER_URL:PORT>/auth/js/keycloak.js \n \n Keycloak is initialized by passing Keycloak server path, realm and\nclient ID and calling  init({/* options */})  function. \n const keycloak = Keycloak({\n  url: 'http://localhost:9080/auth',\n  realm: 'jhipster',\n  clientId: 'jhipster-entando-react-client',\n});\n\nkeycloak\n  .init({ onLoad: 'check-sso' })\n  .success(onInit);\n \n Depending on Keycloak version you are using,  init()  function can\nreturn a Promise (newer versions support  promiseType: 'native' \noption). \n keycloak\n  .init({ onLoad: 'check-sso', promiseType: 'native' })\n  .then(authenticated => {\n    alert(authenticated ? 'Authenticated' : 'Not authenticated');\n  })\n  .catch(() => {\n    alert('Failed to initialize');\n  });\n \n All the Keycloak events are made custom events - this way widgets could\nreact to them if a need arises. \n function createKcDispatcher(payload) {\n  return () => window.dispatchEvent(new CustomEvent('keycloak', { detail: payload }));\n}\n\nkeycloak.onReady = createKcDispatcher({ eventType: 'onReady' });\nkeycloak.onAuthSuccess = createKcDispatcher({ eventType: 'onAuthSuccess' });\nkeycloak.onAuthError = createKcDispatcher({ eventType: 'onAuthError' });\nkeycloak.onAuthRefreshSuccess = createKcDispatcher({ eventType: 'onAuthRefreshSuccess' });\nkeycloak.onAuthRefreshError = createKcDispatcher({ eventType: 'onAuthRefreshError' });\nkeycloak.onAuthLogout = createKcDispatcher({ eventType: 'onAuthLogout' });\nkeycloak.onTokenExpired = createKcDispatcher({ eventType: 'onTokenExpired' });\nconst onInit = createKcDispatcher({ eventType: 'onInit' });\n \n Keycloak object is then stored into  window.entando  object for widgets\nto have access to. \n window.entando = {\n  ...(window.entando || {}),\n  keycloak,\n};\n \n On the widget side inside the custom element creation logic Keycloak\nobject is accessed and passed into the component via Keycloak context \n const getKeycloakInstance = () =>\n  (window &&\n    window.entando &&\n    window.entando.keycloak &&\n    { ...window.entando.keycloak, initialized: true }\n  ) || { initialized: false };\n\n\n// ...\n\nconstructor(...args) {\n  // ...\n  this.keycloak = getKeycloakInstance();\n}\n\nconnectedCallback() {\n  // ...\n  ReactDOM.render(\n    <KeycloakContext.Provider value={this.keycloak}>\n      <ConferenceDetailsContainer />\n    </KeycloakContext.Provider>,\n    this.mountPoint\n  );\n}\n \n And on the component side you can show different content depending on\nthe authentication status \n At  auth/KeycloakViews.js \n export const AuthenticatedView = ({ children, keycloak }) => {\n  const authenticated = keycloak.initialized && keycloak.authenticated;\n  return authenticated ? children : null;\n};\n\nexport const UnauthenticatedView = ({ children, keycloak }) => {\n  const authenticated = keycloak.initialized && keycloak.authenticated;\n  return !authenticated ? children : null;\n};\n \n At  components/ConferenceDetailsContainer.js \n render() {\n  const { conference, loading } = this.state;\n  const { t, keycloak } = this.props;\n\n  return (\n    <ThemeProvider theme={this.theme}>\n      <UnauthenticatedView keycloak={keycloak}>\n        {t('common.notAuthenticated')}\n      </UnauthenticatedView>\n      <AuthenticatedView keycloak={keycloak}>\n        {loading && t('common.loading')}\n        {!loading && <ConferenceDetails conference={conference} />}\n      </AuthenticatedView>\n    </ThemeProvider>\n  );\n}\n \n \n Note \n Keycloak object is accessible via props because of  withKeycloak  HOC:\n export default withKeycloak(ConferenceDetailsContainer); \n \n Next Steps \n To apply more fine-grained access controls, see  this tutorial . \n"},{title:"Create a React Micro Frontend",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/create/mfe/react.html",relativePath:"next/tutorials/create/mfe/react.md",key:"v-9d2da6ce",path:"/next/tutorials/create/mfe/react.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Create React App",slug:"create-react-app"},{level:3,title:"Wrap with Custom Element",slug:"wrap-with-custom-element"},{level:3,title:"Import Custom Element",slug:"import-custom-element"},{level:3,title:"Test Micro Frontend",slug:"test-micro-frontend"},{level:2,title:"Build the Resource URL",slug:"build-the-resource-url"},{level:3,title:"Add Widget",slug:"add-widget"},{level:3,title:"Add Page",slug:"add-page"},{level:3,title:"Build It",slug:"build-it"},{level:3,title:"npm build",slug:"npm-build"},{level:2,title:"Host Micro Frontend",slug:"host-micro-frontend"},{level:3,title:"Create Public Folder",slug:"create-public-folder"},{level:3,title:"Update Custom UI Field",slug:"update-custom-ui-field"},{level:3,title:"View the Widget",slug:"view-the-widget"}],lastUpdated:"1/25/2022, 4:09:16 PM",lastUpdatedTimestamp:1643144956e3,content:" Create a React Micro Frontend \n Prerequisites \n \n A working instance of Entando. \n Use the Entando CLI to verify all dependencies are installed with the command  ent check-env develop . \n Create React App \n We'll use  Create React App  to generate a simple app in seconds. \n \n Create 'my-widget' directory structure with the following: \n \n npx create-react-app my-widget --use-npm\n \n This is the expected output: \n my-widget\n├── README.md\n├── node_modules\n├── package.json\n├── .gitignore\n├── public\n│   ├── favicon.ico\n│   ├── index.html\n│   ├── logo192.png\n│   ├── logo512.png\n│   ├── manifest.json\n│   └── robots.txt\n└── src\n    ├── App.css\n    ├── App.js\n    ├── App.test.js\n    ├── index.css\n    ├── index.js\n    ├── logo.svg\n    ├── serviceWorker.js\n    └── setupTests.js\n \n \n Start the app \n \n cd  my-widget\n npm  start\n Wrap with Custom Element \n \n Add a new file  src/WidgetElement.js  with the following custom element to wrap the entire React app \n \n import  React  from   'react' ; \n import  ReactDOM  from   'react-dom' ; \n import  App  from   './App' ; \n\n class   WidgetElement   extends   HTMLElement   { \n     connectedCallback ( )   { \n         this . mountPoint  =  document . createElement ( 'div' ) ; \n         this . appendChild ( this . mountPoint ) ; \n        ReactDOM . render ( < App  / > ,   this . mountPoint ) ; \n     } \n } \n\ncustomElements . define ( 'my-widget' ,  WidgetElement ) ; \n\n export   default  WidgetElement ; \n \n The React  root  node is programatically generated in the  connectedCallback  method when the custom element is added to the DOM. \n TIP \n connectedCallback  is a lifecycle hook that  runs each time the element is added to the DOM. \n \n Custom Elements \n \n Must contain a hyphen  -  in the name. \n Cannot be a single word. \n Should follow  kebab-case  for naming convention. \n Import Custom Element \n \n Open  src/index.js . The initial file looks like: \n \n import  React  from   'react' ; \n import  ReactDOM  from   'react-dom' ; \n import   './index.css' ; \n import  App  from   './App' ; \n import   *   as  serviceWorker  from   './serviceWorker' ; \n\nReactDOM . render ( < App  / > ,  document . getElementById ( 'root' ) ) ; \n\n // If you want your app to work offline and load faster, you can change \n // unregister() to register() below. Note this comes with some pitfalls. \n // Learn more about service workers: https://bit.ly/CRA-PWA \nserviceWorker . unregister ( ) ; \n \n \n Replace the entire file with these two lines \n \n import   './index.css' ; \n import   './WidgetElement' ; \n Test Micro Frontend \n \n \n Open  public/index.html \n \n \n Replace  <div id=\"root\"></div>  with the custom element  <my-widget /> \n \n \n    < body > \n     < noscript > You need to enable JavaScript to run this app. </ noscript > \n     < my-widget   /> \n    ...\n   </ body > \n \n Congratulations! \n You’re now running  React  in a containerized micro frontend. \n Build the Resource URL \n Add your micro frontend to Entando by uploading the JavaScript and CSS files to the  public  folder. This is the way Entando makes files available to the public. \n Add Widget \n First, add a widget to get the resource URL for the  public  folder. Then use the same widget to add the Micro Frontend to Entando. \n \n \n Go to  Components > Micro frontends & Widgets  in the App Builder \n \n \n Click  Add  in the lower right corner \n \n \n \n \n Enter the following: \n \n \n Title: My Widget  → enter both English and Italian languages \n Code: my_widget  → dashes are not allowed \n Group: Free Access \n Icon :  → upload an icon of your choice \n In the center panel under  Custom UI , enter the following: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < @wp . resourceURL  /> \n \n \n Click  Save \n \n TIP \n <#assign wp=JspTaglibs[ \"/aps-core\"]>  gives you access to the  @wp  object where you can use environment variables like  resourceURL . \n Add Page \n Next, add the widget to a page to view the  Resource URL .\nIf you're getting started with a new install of Entando, add the widget to the  Home  page. \n \n \n For Experienced Entando users: Add a new page → Add your widget to the page \n \n \n \n \n Go to  Pages  →  Management \n \n \n Next to the  Home  folder, under  Actions , →  Edit \n \n \n In the  Title  field, choose  My Widget \n \n \n In the Code field, choose  my_widget \n \n \n Under Page groups, in the Owner group field, choose  Free Access \n \n \n Scroll down to  Page Template  and select  Single Frame Page . Leave all other fields blank or in the default setting. \n \n \n Click  Save and Design . You are now in the page Designer. \n \n \n In the Search field of the right sidebar, type  My Widget . It will show as an option. \n \n \n Drag and drop  My Widget  into the  Sample Frame  in the body of the page \n \n \n Click  Publish \n \n \n In the top right corner, click  View Published Page . This will take you to a blank home page with your widget. \n \n \n Copy the  Resource URL  at the top. For example, this is the URL in a quickstart environment set up via the Getting Started guide: \n \n \n /entando-de-app/cmsresources/\n Build It \n With the Resource URL where the new React App will be hosted, you are ready to build. \n \n \n Create an  .env.production  file in the root of  my-widget  project \n \n \n Add the  PUBLIC_URL  into the file. \n \n \n PUBLIC_URL=/entando-de-app/cmsresources/my-widget\n \n Notes \n \n /entando-de-app/cmsresources/  is the Resource URL for your Entando application \n /my-widget  is the public folder that's created to host the files. \n npm build \n \n \n Open a command line and navigate to the project root of your  my-widget \n \n \n Run the command: \n \n \n npm  run build\n \n \n Rename the following files generated in the  build  directory \n \n \n \n \n Example of Generated Build File \n Rename to \n Function \n \n \n \n \n build/static/js/2.f14073bd.chunk.js \n static/js/vendor.js \n Third-party libraries \n \n \n build/static/js/runtime-main.8a835b7b.js \n static/js/runtime.js \n Bootstrapping logic \n \n \n build/static/js/main.4a514a6d.chunk.js \n static/js/main.js \n App \n \n \n build/static/css/main.5f361e03.chunk.css \n static/css/main.css \n Stylesheet \n \n \n \n Generated Build Files \n The JavaScript and CSS files are renamed so App Builder can deploy the new versions of the micro frontend without having to update the  Custom UI  field of the widget. \n \n If you want to use the original  file names with the content hashes to avoid potential caching issues in your browser , update the  Custom UI  field of your widget when deploying new versions of your micro frontend. The  Custom UI  settings will be covered in the next section. \n Additional Deployment Options \n \n Install the micro frontend from a bundle in the  Entando Component Repository . \n Add the micro frontend to  Entando App Builder . \n Load the micro frontend from an API. \n Host Micro Frontend \n Now you are ready to host the micro frontend in Entando. \n Create Public Folder \n \n \n Navigate to  Entando App Builder  in your browser \n \n \n Click  Administration  at the lower left hand side of the screen \n \n \n Click the  File browser  tab \n \n \n Choose the  public  folder \n \n \n Click  Create folder \n \n \n Enter  my-widget \n \n \n Click  Save \n \n \n Click  my-widget \n \n \n Create the same folder structure as your generated build directory \n \n \n \n my-widget/static/css \n my-widget/static/js \n my-widget/static/media \n \n \n Upload the renamed files in the corresponding  js  and  css  folders \n \n \n my-widget/static/css/main.css \n my-widget/static/js/main.js \n my-widget/static/js/runtime.js \n my-widget/static/js/vendor.js \n \n Note: You can drag and drop the files in your browser \n \n Upload the  React  logo \n \n \n my-widget/static/media/logo.5d5d9eef.svg  → You don't need to rename this file \n Update Custom UI Field \n \n \n Go to  Components  →  Micro frontends & Widgets \n \n \n Under the  My Widgets  category → next to  My Widget  → under  Action  → select  Edit \n \n \n Update  Custom UI  field: \n \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < link   rel = \" stylesheet \"   type = \" text/css \"   href = \" < @wp . resourceURL  /> my-widget/static/css/main.css \" > \n < script   async   src = \" < @wp . resourceURL  /> my-widget/static/js/runtime.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> my-widget/static/js/vendor.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> my-widget/static/js/main.js \" > </ script > \n < my-widget   /> \n \n \n Click  Save \n View the Widget \n View the React micro frontend in action on your page. \n \n \n In the  Entando App Builder  go back to  Pages  →  Management \n \n \n Next to the page you created, under  Actions →  Design . This takes you back to the page Designer. \n \n \n Click on  View Published Page  on the top right side \n \n \n \n Congratulations! \n You now have a React micro frontend running in Entando. \n \n"},{title:"Communicate Between Micro Frontends",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/create/mfe/communication.html",relativePath:"next/tutorials/create/mfe/communication.md",key:"v-f9d0080e",path:"/next/tutorials/create/mfe/communication.html",headers:[{level:2,title:"Publisher",slug:"publisher"},{level:3,title:"Create Custom Event",slug:"create-custom-event"},{level:3,title:"Update React App to Dispatch Event",slug:"update-react-app-to-dispatch-event"},{level:3,title:"Test Event Dispatcher",slug:"test-event-dispatcher"},{level:2,title:"Subscriber",slug:"subscriber"},{level:3,title:"Add Event Listener",slug:"add-event-listener"},{level:3,title:"Display Custom Event",slug:"display-custom-event"},{level:3,title:"Test Event Listener",slug:"test-event-listener"},{level:2,title:"Add Widgets to App Builder",slug:"add-widgets-to-app-builder"},{level:3,title:"Create Environment File",slug:"create-environment-file"},{level:3,title:"Run npm build",slug:"run-npm-build"},{level:3,title:"Create Public Folder",slug:"create-public-folder"},{level:3,title:"Add Widgets",slug:"add-widgets"},{level:3,title:"View on a Page",slug:"view-on-a-page"},{level:2,title:"Angular to React",slug:"angular-to-react"},{level:3,title:"Create Angular Publisher",slug:"create-angular-publisher"},{level:3,title:"Add to App Builder",slug:"add-to-app-builder"}],lastUpdated:"4/12/2022, 5:31:02 PM",lastUpdatedTimestamp:1649799062e3,content:" Communicate Between Micro Frontends \n Recommended Learning \n \n Tutorial:  Create a React Micro Frontend \n Tutorial:  Create an Angular Micro Frontend \n \n \n Entando supports communication between micro frontends using  Custom Events , an established web standard. In this tutorial, we build: \n \n A React micro frontend that publishes an event \n A React micro frontend that listens to an event \n An Angular micro frontend that publishes an event to a React micro frontend \n Publisher \n Create a simple app to publish an event. \n npx create-react-app publisher-widget --use-npm\n \n Start the app. \n cd  publisher-widget\n \n npm  start\n Create Custom Event \n Next, add event firing logic. \n Add a new file  publisher-widget/src/PublisherWidgetElement.js . \n import  React  from   'react' ; \n import  ReactDOM  from   'react-dom' ; \n import  App  from   './App' ; \n\n const   EVENTS   =   { \n   greeting :   'greeting' , \n } ; \n\n class   PublisherWidgetElement   extends   HTMLElement   { \n\n   constructor ( )   { \n     super ( ) ; \n     this . onGreet   =   name   =>   this . publishWidgetEvent ( EVENTS . greeting ,   {  name  } ) ; \n   } \n\n   connectedCallback ( )   { \n     this . mountPoint  =  document . createElement ( 'div' ) ; \n     this . appendChild ( this . mountPoint ) ; \n     this . render ( ) ; \n   } \n\n   publishWidgetEvent ( eventId ,  detail )   { \n     const  widgetEvent  =   new   CustomEvent ( eventId ,   {  detail  } ) ; \n    window . dispatchEvent ( widgetEvent ) ; \n   } \n\n   render ( )   { \n    ReactDOM . render ( < App onGreet = { this . onGreet }   / > ,   this . mountPoint ) ; \n   } \n } \n\ncustomElements . define ( 'publisher-widget' ,  PublisherWidgetElement ) ; \n\n export   default  PublisherWidgetElement ; \n \n \n In the  CustomEvent  constructor,  detail  is the specific name to use in the event payload, as per the  DOM specification . \n Import Custom Element \n Update  publisher-widget/src/index.js . \n import   './index.css' ; \n import   './PublisherWidgetElement' ; \n Test Custom Element \n Update  publisher-widget/public/index.html , and view it in the browser. \n    < body > \n     < noscript > You need to enable JavaScript to run this app. </ noscript > \n     < publisher-widget   /> \n    ...\n   </ body > \n Update React App to Dispatch Event \n Update  publisher-widget/src/App.js . \n import  React  from   'react' ; \n import   './App.css' ; \n\n class   App   extends   React . Component   { \n   constructor ( props )   { \n     super ( props ) ; \n     this . state  =   {   name :   '' } ; \n   } \n\n   handleNameChange ( value )   { \n     this . setState ( prevState   =>   ( { \n       ... prevState , \n       name :  value , \n     } ) ) ; \n   } \n\n   render ( )   { \n     const   {  name  }   =   this . state ; \n     const   {  onGreet  }   =   this . props ; \n     return   ( \n       < div > \n         < h1 > Send a greeting < / h1 > \n         < label htmlFor = \"name\" > Name < / label > \n         < input id = \"name\"  onChange = { e   =>   this . handleNameChange ( e . target . value ) }  value = { name }   / > \n         < button onClick = { ( )   =>   onGreet ( name ) } > Say hello ! < / button > \n       < / div > \n     ) ; \n   } \n } \n\n export   default  App ; \n Test Event Dispatcher \n In the JavaScript console of your browser, enter: \n window . addEventListener ( 'greeting' ,   ( evt )   =>  console . log ( 'Hello' ,  evt . detail . name ) ) \n \n Write something in the text field. Click the \"Say hello!\" button and take a look at the JS console. It will show the event message. \n Congratulations! \n You’ve now published a custom event. \n Subscriber \n Next, let’s create the subscriber. \n npx create-react-app subscriber-widget --use-npm\n \n Start the app. \n cd  subscriber-widget\n \n npm  start\n Add Event Listener \n Add a new file  subscriber-widget/src/SubscriberWidgetElement.js . \n import  React  from   'react' ; \n import  ReactDOM  from   'react-dom' ; \n import  App  from   './App' ; \n\n const   EVENTS   =   { \n   greeting :   'greeting' , \n } ; \n\n class   SubscriberWidgetElement   extends   HTMLElement   { \n\n   constructor ( )   { \n     super ( ) ; \n     this . name  =   null ; \n     this . subscribeToWidgetEvent ( EVENTS . greeting ,   ( evt )   =>   this . onGreeting ( evt . detail . name ) ) ; \n   } \n\n   connectedCallback ( )   { \n     this . mountPoint  =  document . createElement ( 'div' ) ; \n     this . appendChild ( this . mountPoint ) ; \n     this . render ( ) ; \n   } \n\n   subscribeToWidgetEvent ( eventType ,  eventHandler )   { \n    window . addEventListener ( eventType ,  eventHandler ) ; \n   } \n\n   onGreeting ( name )   { \n     this . name  =  name ; \n     this . render ( ) ; \n   } \n\n   render ( )   { \n    ReactDOM . render ( < App name = { this . name }   / > ,   this . mountPoint ) ; \n   } \n } \n\ncustomElements . define ( 'subscriber-widget' ,  SubscriberWidgetElement ) ; \n\n export   default  SubscriberWidgetElement ; \n Import Custom Element \n Update  subscriber-widget/src/index.js . \n import   './index.css' ; \n import   './SubscriberWidgetElement' ; \n Test Micro Frontend \n Update  subscriber-widget/public/index.html , and view it in the browser. \n    < body > \n     < noscript > You need to enable JavaScript to run this app. </ noscript > \n     < subscriber-widget > \n    ...\n   </ body > \n Display Custom Event \n Update  subscriber-widget/src/App.js . \n import  React  from   'react' ; \n import   './App.css' ; \n\n function   App ( {  name  } )   { \n   return  name  ?   ( < h2 > Just got a greeting from  { name } < / h2 > ) \n     :   ( < h2 > Waiting  for  a greeting ... < / h2 > ) ; \n } \n\n export   default  App ; \n Test Event Listener \n In the JavaScript console of your browser, enter: \n const  widgetEvent  =   new   CustomEvent ( 'greeting' ,   { \n   detail :   { \n     name :   'Pippo' \n   } , \n } ) ; \nwindow . dispatchEvent ( widgetEvent ) ; \n \n The custom event should now display in the  subscriber-widget . \n Congratulations! \n You’ve now created a micro frontend that listens to custom events. \n Add Widgets to App Builder \n Now let's add the publisher and subscriber micro frontends in Entando. \n \n Note: These follow the same steps as in the  Create a React Micro Frontend  tutorial. \n Create Environment File \n Publisher Widget \n \n \n Create an  .env  file in the project root for the  publisher-widget . \n \n \n Open the  .env  file, and enter the  PUBLIC_URL  where the micro frontend will be hosted. \n \n \n Example: \n PUBLIC_URL=http://quickstart.192.168.64.34.nip.io/entando-de-app/cmsresources/publisher-widget\n \n Notes \n \n Replace  quickstart.192.168.64.34.nip.io  with the ingress you use to access Entando from your local browser. \n /entando-de-app/cmsresources/  is your Resource URL. \n publisher-widget  is the public folder we'll create to host the publisher micro frontend. \n Subscriber Widget \n \n \n Create an  .env  file in the project root for the  subscriber-widget . \n \n \n Open the  .env  file, and enter the  PUBLIC_URL  where the micro frontend will be hosted. \n \n \n \n Use  subscriber-widget  for the name of the public folder we'll create to host the subscriber micro frontend. \n \n Example: \n PUBLIC_URL=http://quickstart.192.168.64.34.nip.io/entando-de-app/cmsresources/subscriber-widget\n Run npm build \n Publisher Widget \n \n \n Open a command line, and navigate to the project root of the  publisher-widget . \n \n \n Run build. \n \n \n npm  run build\n \n \n Rename the following generated files in the  build  directory. \n \n \n \n \n Example of Generated Build File \n Rename to \n Function \n \n \n \n \n build/static/js/2.f14073bd.chunk.js \n static/js/vendor.js \n Third-party libraries \n \n \n build/static/js/runtime-main.8a835b7b.js \n static/js/runtime.js \n Bootstrapping logic \n \n \n build/static/js/main.4a514a6d.chunk.js \n static/js/main.js \n App \n \n \n build/static/css/main.5f361e03.chunk.css \n static/css/main.css \n Stylesheet \n Subscriber Widget \n \n Repeat steps 1-3 for the  subscriber-widget . \n Create Public Folder \n Publisher Widget \n \n \n Navigate to  Entando App Builder  in your browser. \n \n \n Go to  Configuration  →   File Browser   →  public \n \n \n Click  Create Folder . \n \n \n Enter  publisher-widget . \n \n \n Click  Save . \n \n \n Click  public  →  publisher-widget . \n \n \n Create the same folder structure as your generated build directory \n \n \n \n publisher-widget/static/css \n publisher-widget/static/js \n \n \n Upload the files we renamed in the corresponding  js  and  css  folders. \n \n \n publisher-widget/static/css/main.css \n publisher-widget/static/js/main.js \n publisher-widget/static/js/runtime.js \n publisher-widget/static/js/vendor.js \n Subscriber Widget \n \n Repeat steps 1-8 for the  subscriber-widget . \n Add Widgets \n Publisher Widget \n \n \n Go to  Entando App Builder  in your browser. \n \n \n Go to  Components  →  Micro Frontends & Widgets  at the top nav. \n \n \n Click  Add . \n \n \n Enter the following: \n \n \n \n Code: publisher_widget  → note: dashes are not allowed \n Title: Publisher Widget  → for both English and Italian languages \n Group: Free Access \n Custom UI: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < link   rel = \" stylesheet \"   type = \" text/css \"   href = \" < @wp . resourceURL  /> publisher-widget/static/css/main.css \" > \n < script   async   src = \" < @wp . resourceURL  /> publisher-widget/static/js/runtime.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> publisher-widget/static/js/vendor.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> publisher-widget/static/js/main.js \" > </ script > \n < publisher-widget   /> \n \n \n Click  Save . \n Subscriber Widget \n Repeat steps 1-5 for the subscriber widget. \n \n Code: subscriber_widget  → note: dashes are not allowed \n Title: Subscriber Widget  → for both English and Italian languages \n Group: Free Access \n Custom UI: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < link   rel = \" stylesheet \"   type = \" text/css \"   href = \" < @wp . resourceURL  /> subscriber-widget/static/css/main.css \" > \n < script   async   src = \" < @wp . resourceURL  /> subscriber-widget/static/js/runtime.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> subscriber-widget/static/js/vendor.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> subscriber-widget/static/js/main.js \" > </ script > \n < subscriber-widget   /> \n View on a Page \n You can setup the widgets on an existing page (such as the Home page) or  create your own page . The following steps assume you'll use the Home page. \n \n \n Go to  Pages  →  Management \n \n \n For the  Home  page  (folder icon) , in the  Actions  column, click the  ⋮  icon \n \n \n Click  Edit . \n \n \n In the  Settings  section, select a Page Template with more than one frame, e.g.  1-column : \n \n \n \n Page Template: 1 Column \n \n \n \n Click  Save and Configure . \n \n \n In the  WIDGETS  sidebar on the right: \n \n \n \n Drag  Publisher Widget  and  Subscriber Widget  into  Frame 1  and  Frame 2 . \n \n \n \n Click  Publish . \n \n \n To view the home page, scroll to the top of the page, and click  Go to Homepage . \n \n \n Enter a greeting in the input field. Press the submit button. The subscriber widget will update with the greeting. Done! \n \n \n Congratulations! \n You can now communicate between micro frontends with  Custom Events . \n Angular to React \n We can also communicate between micro frontends using different JavaScript frameworks. \n In this next example, we’ll create an Angular micro frontend to publish an event, and we'll use the React micro frontend we created in the previous section to receive the event. \n Create Angular Publisher \n ng new angular-publisher-widget\n \n Choose the following options: \n ? Would you like to  add  Angular routing? No\n? Which stylesheet  format  would you like to use? CSS\n \n Serve the application. \n cd  angular-publisher-widget\n \n ng serve\n Convert to Custom Element \n Next, let's convert our Angular app into a custom element. We'll use  Angular elements  to transform components into custom elements. \n ng  add  @angular/elements\n \n Replace the contents of  angular-publisher-widget/src/app/app.module.ts . \n \n In this file, we bootstrap the custom element using the  ngDoBootstrap  method. \n \n import   {  BrowserModule  }   from   '@angular/platform-browser' ; \n import   {  NgModule ,  Injector  }   from   '@angular/core' ; \n import   {  createCustomElement  }   from   '@angular/elements' ; \n import   {  AppComponent  }   from   './app.component' ; \n import   {  ReactiveFormsModule  }   from   '@angular/forms' ; \n\n@ NgModule ( { \n   declarations :   [ \n    AppComponent\n   ] , \n   imports :   [ \n    BrowserModule , \n    ReactiveFormsModule\n   ] , \n   providers :   [ ] , \n   entryComponents :   [ AppComponent ] \n } ) \n export   class   AppModule   { \n   constructor ( private   injector :  Injector )   { } \n\n   ngDoBootstrap ( )   { \n     const  el  =   createCustomElement ( AppComponent ,   {   injector :   this . injector  } ) ; \n    customElements . define ( 'angular-publisher-widget' ,  el ) ; \n   } \n } \n Create Custom Event \n Replace the contents of  angular-publisher-widget/src/app/app.component.ts . \n \n Here, we're adding code to dispatch the custom event. \n \n import   {  Component  }   from   '@angular/core' ; \n import   {  FormControl ,  FormGroup  }   from   '@angular/forms' ; \n\n const   EVENTS   =   { \n   greeting :   'greeting' , \n } ; \n\n@ Component ( { \n   selector :   'app-root' , \n   templateUrl :   './app.component.html' , \n   styleUrls :   [ './app.component.css' ] \n } ) \n export   class   AppComponent   { \n  greetingForm  =   new   FormGroup ( { \n     name :   new   FormControl ( '' ) , \n   } ) ; \n\n   publishWidgetEvent ( eventId ,  detail )   { \n     const  widgetEvent  =   new   CustomEvent ( eventId ,   {  detail  } ) ; \n    window . dispatchEvent ( widgetEvent ) ; \n   } \n\n   onSubmit ( )   { \n     const  name  =   this . greetingForm . get ( 'name' ) . value ; \n     this . publishWidgetEvent ( EVENTS . greeting ,   {  name  } ) ; \n   } \n } \n Add HTML Form \n Replace the contents of  angular-publisher-widget/src/app/app.component.html . \n \n In the app component html, we're adding a simple form to call our component class  app.component.ts . \n \n < h1 > Send a greeting </ h1 > \n < form   [formGroup] = \" greetingForm \"   (ngSubmit) = \" onSubmit() \" > \n   < label > \n    Name\n     < input   type = \" text \"   formControlName = \" name \" > \n   </ label > \n   < button   type = \" submit \" > Say hello! </ button > \n </ form > \n View Micro Frontend \n Open  angular-publisher-widget/src/index.html . \n In the  <body> , replace  <app-root></app-root>  with your custom element  <angular-publisher-widget /> . \n < body > \n   < angular-publisher-widget   /> \n </ body > \n \n You can check to see if your micro frontend is working in your browser (e.g., localhost:4200) \n Add to App Builder \n Now we're ready to host our micro frontend in Entando. \n Build It \n From the project root, type: \n ng build --prod --outputHashing = none\n \n This will generate a  dist  directory. \n Create Public Folder \n \n \n Navigate to  Entando App Builder  in your browser. \n \n \n Click  Configuration  →   File Browser   →  public . \n \n \n Create a folder named  angular-publisher-widget . \n \n \n Click  Upload Files . \n \n \n From your generated  dist  folder, upload: \n \n \n \n main-es2015.js \n polyfills-es2015.js \n runtime-es2015.js \n Add Widget \n \n \n Go to  Components > Micro frontends & Widgets  in the Entando App Builder. \n \n \n Click  Add  at the lower right. \n \n \n Enter the following: \n \n \n \n Code: angular_publisher_widget  → note: dashes are not allowed \n Title: Angular Publisher Widget  → for both English and Italian languages \n Group: Free Access \n Custom UI: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < script   async   src = \" < @wp . resourceURL  /> angular-publisher-widget/main-es2015.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> angular-publisher-widget/polyfills-es2015.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> angular-publisher-widget/runtime-es2015.js \" > </ script > \n\n < angular-publisher-widget   /> \n \n \n Click  Save . \n View on Homepage \n \n \n Go to  Pages  →  Management \n \n \n Next to the  Home  page  (folder icon) , in the  Actions  column, click the  ⋮  icon \n \n \n In the Search field in right-hand sidebar, enter  Angular Publisher Widget . \n \n \n Drag and drop  Angular Publisher Widget  into the  Sample Frame  in the main body of the page. \n \n \n \n Replace  Publisher Widget . \n \n \n \n Click  Publish . \n \n \n In the top navigation, on the right, click  Go to Homepage . \n \n \n Enter a greeting in the input field. Press the submit button. The subscriber widget will update with the greeting. Done! \n \n \n \n Note: If you don't see an input field, refresh the page. \n \n Congratulations! \n You've now created an Angular micro frontend that can communicate with a React micro frontend. \n \n"},{title:"Add a Configuration Screen in App Builder",frontmatter:{},regularPath:"/next/tutorials/create/mfe/widget-configuration.html",relativePath:"next/tutorials/create/mfe/widget-configuration.md",key:"v-aa13396a",path:"/next/tutorials/create/mfe/widget-configuration.html",headers:[{level:2,title:"Create React App",slug:"create-react-app"},{level:2,title:"Add Input Field",slug:"add-input-field"},{level:2,title:"Custom Element",slug:"custom-element"},{level:2,title:"Configuration Screen",slug:"configuration-screen"},{level:2,title:"Add Attribute",slug:"add-attribute"},{level:2,title:"Display Input",slug:"display-input"},{level:2,title:"Build It",slug:"build-it"},{level:2,title:"Update Widget in App Builder",slug:"update-widget-in-app-builder"}],lastUpdated:"4/19/2022, 11:37:04 AM",lastUpdatedTimestamp:1650382624e3,content:' Add a Configuration Screen in App Builder \n Entando widgets can be customized through an App Builder configuration screen that is itself a micro frontend. It can be developed and tested in isolation without a running Entando instance. \n Create React App \n Let’s start with the boilerplate provided by  Create React\nApp , probably the most popular one. \n npx create-react-app my-widget-config --use-npm \n my-widget-config\n├── README.md\n├── node_modules\n├── package.json\n├── .gitignore\n├── public\n│   ├── favicon.ico\n│   ├── index.html\n│   ├── logo192.png\n│   ├── logo512.png\n│   ├── manifest.json\n│   └── robots.txt\n└── src\n    ├── App.css\n    ├── App.js\n    ├── App.test.js\n    ├── index.css\n    ├── index.js\n    ├── logo.svg\n    ├── serviceWorker.js\n    └── setupTests.js\n \n Then, type  cd my-widget-config  and  npm start  to start the app. \n Add Input Field \n Let’s start with a simple form: only an input with a label. So, let’s\nedit  App.js \n import React from \'react\';\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { name: \'\'};\n  }\n\n  handleNameChange(value) {\n    this.setState(prevState => ({\n      ...prevState,\n      name: value,\n    }));\n  }\n\n  render() {\n    const { name } = this.state;\n    return (\n      <div>\n        <h1>Sample Entando Widget Configuration</h1>\n        <label htmlFor="name">Name</label>\n        <input id="name" onChange={e => this.handleNameChange(e.target.value)} value={name} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n \n You are free to use your favorite form handling library e.g.,\n Formik ,\n redux-form  (that requirese redux) or others. \n In regards to styling, since this is going to be an App Builder screen,\nwe strongly suggest using  PatternFly\nv3  ( patternfly  and  patternfly-react \npackages) to keep UX coherence. \n Custom Element \n Now, let’s add the web component that will wrap the entire React app.\nLet’s name it  WidgetElement \n import React from \'react\';\nimport ReactDOM from \'react-dom\';\nimport App from \'./App\';\n\nclass WidgetElement extends HTMLElement {\n  constructor() {\n    super();\n    this.reactRootRef = React.createRef();\n    this.mountPoint = null;\n  }\n\n  get config() {\n    return this.reactRootRef.current ? this.reactRootRef.current.state : {};\n  }\n\n  set config(value) {\n    return this.reactRootRef.current.setState(value);\n  }\n\n  connectedCallback() {\n    this.mountPoint = document.createElement(\'div\');\n    this.appendChild(this.mountPoint);\n    ReactDOM.render(<App ref={this.reactRootRef} />, this.mountPoint);\n  }\n}\n\ncustomElements.define(\'my-widget-config\', WidgetElement);\n\nexport default WidgetElement;\n \n Its responsibility is rendering the React app and syncing the React app\nstate in a  config  property. That  must  be named that way. The key to\nApp Builder communication is that it works in three steps: \n \n \n App Builder reads  config  property when the widget config screen is\nrendered \n \n \n config  property is mutated when a user configures the widget \n \n \n When a user saves the config, App Builder retrieves it (again, from\nthe  config  property) and persists it through Entando APIs \n \n \n This means the widget developer can focus on the configuration screens\nwithout having to call Entando APIs to read or write configuration. \n One more JS file to update:  index.js . Starting from this \n import React from \'react\';\nimport ReactDOM from \'react-dom\';\nimport \'./index.css\';\nimport App from \'./App\';\nimport * as serviceWorker from \'./serviceWorker\';\n\nReactDOM.render(<App />, document.getElementById(\'root\'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n \n You only have to import  WidgetElement  plus the css, if needed.\nSomething like \n import \'./index.css\';\nimport \'./WidgetElement\';\n \n We assume we don’t need a service worker for the widget, so we can\ndelete serviceWorker.js. \n To ensure our web component is working we have to edit\n public/index.html . Remove  <div id="root"></div>  from the  body  (we\nprogrammatically generated the react root in the  connectedCallback \nmethod of  WidgetElement ) and add our new web component tag\n <my-widget /> . \n <!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" />\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\n    <title>React App</title>\n  </head>\n  <body>\n    <my-widget-config />\n  </body>\n</html>\n \n \n Note \n the web component tag name ( my-widget-config  in this tutorial)\n must  match the first parameter of the  customElements.define \nmethod. \n \n The page should auto reload and... congrats, you’re running an Entando\nwidget in isolation. \n Configuration Screen \n Next, we’ll build our widget before embedding it into the Entando\ninstance. From the react project root, type \n npm run build \n and a  build/static  directory will be generated. For convenience in this tutorial, rename the generated files: \n \n \n a file like  js/runtime~main.c7dcdf0b.js  to  js/runtime.js \n(bootstrapping logic) \n \n \n a file like  js/2.230b21ef.chunk.js  to  js/vendor.js  (third-party\nlibraries) \n \n \n a file like  js/main.1fd3965a.chunk.js  to  js/main.js  (app) \n \n \n Next load these files into Entando under  public/my-widget-config/static  using  Administration  →  File Browser . \n Now go to  Components  →  Micro frontends & Widgets  and find the original widget we\'re creating the configuration screen for. Edit the widget and update the\n configUI  field. \n {\n  "customElement": "my-widget-config",\n  "resources": [\n    "my-widget-config/static/js/runtime.js",\n    "my-widget-config/static/js/vendor.js",\n    "my-widget-config/static/js/main.js"\n  ]\n}\n \n \n Note \n \n \n It is possible to keep the original names in order to avoid\npotential caching issues, but then you will have to update the\n Config UI  field in the App Builder widget screen each time a new\nversion of the widget is deployed. \n \n \n configUI  is a JSON object, so pay attention to save a\nwell-formed one (the integrated JSON editor will help you) \n \n \n value for  customElement  must match the name of custom tag in\n index.html  and the one passed as parameter to\n customElements.define  in  WidgetElement \n \n \n \n You can now add a page in App Builder, drag the widget into the page template slot and you’ll see the configuration screen we just built. \n Display Widget Configuration \n So, we already created a React micro frontend widget and configuration\nscreen to customize a  name  field. \n In this tutorial we will display that field in our micro frontend\nwidget. \n Add Attribute \n Edit  WidgetElement  to add attribute handling to the custom element,\nand re-render our app when an attribute changes. Now, the  name \nattribute is being read from the custom element and passed as a prop to\nthe react root component ( App ). \n import React from \'react\';\nimport ReactDOM from \'react-dom\';\nimport App from \'./App\';\n\nconst ATTRIBUTES = {\n  name: \'name\',\n};\n\nclass WidgetElement extends HTMLElement {\n\n  static get observedAttributes() {\n    return Object.values(ATTRIBUTES);\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (!Object.values(ATTRIBUTES).includes(name)) {\n      throw new Error(`Untracked changed attribute: ${name}`);\n    }\n    if (this.mountPoint && newValue !== oldValue) {\n      this.render();\n    }\n  }\n\n  connectedCallback() {\n    this.mountPoint = document.createElement(\'div\');\n    this.appendChild(this.mountPoint);\n    this.render();\n  }\n\n  render() {\n    const name = this.getAttribute(ATTRIBUTES.name);\n    ReactDOM.render(<App name={name} />, this.mountPoint);\n  }\n}\n\ncustomElements.define(\'my-widget\', WidgetElement);\n\nexport default WidgetElement;\n \n \n Note \n attributeChangedCallback  is also a custom elements lifecycle hook\nmethod. \n Display Input \n Edit the  App  component now, to make it display the  name  prop. \n import React from \'react\';\nimport \'./App.css\';\n\nfunction App({name}) {\n  return (\n    <div className="App">\n      <header className="App-header">\n        <p>\n          Hello, {name}!\n        </p>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n \n Now, to ensure our custom element is working, we can edit\n public/index.html  and set a value for the  name  attribute of the\ncustom element. \n <!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" />\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\n    <title>React App</title>\n  </head>\n  <body>\n    <my-widget name="Marco" />\n  </body>\n</html>\n \n After page reload, you should be able to display a simple "Hello,\nMarco!" message. \n Build It \n From the react project root, type: \n npm run build \n and the  build/static  directory will be regenerated. Again, for convenience, rename the files and then update them in Entando under  public/my-widget/static  using  Administration  →  File Browser : \n \n \n a file like  js/runtime~main.c7dcdf0b.js  to  js/runtime.js \n(bootstrapping logic) \n \n \n a file like  js/2.230b21ef.chunk.js  to  js/vendor.js  (third-party\nlibraries) \n \n \n a file like  js/main.1fd3965a.chunk.js  to  js/main.js  (app) \n \n \n a file like  css/main.d1b05096.chunk.js  to  css/main.css \n(stylesheet) \n \n \n \n Note \n you could keep the original names in order to avoid potential caching\nissues, but then you will have to update the  Custom UI  field in the\nApp Builder widget screen every time a new version of the widget is\ndeployed. \n \n If the application server you’re running does not have hot deploy\nenabled, restart it. \n Update Widget in App Builder \n Open the  Entando App Builder , go to  Components  →  Micro frontends & Widgets , find the widget  My Widget  and click to edit it. \n Update the  Custom UI  field from: \n <#assign wp=JspTaglibs[ "/aps-core"]>\n<link rel="stylesheet" type="text/css" href="<@wp.resourceURL />my-widget/static/css/main.css">\n<script async src="<@wp.resourceURL />my-widget/static/js/runtime.js"><\/script>\n<script async src="<@wp.resourceURL />my-widget/static/js/vendor.js"><\/script>\n<script async src="<@wp.resourceURL />my-widget/static/js/main.js"><\/script>\n<my-widget />\n \n to \n <#assign wp=JspTaglibs[ "/aps-core"]>\n<link rel="stylesheet" type="text/css" href="<@wp.resourceURL />my-widget/static/css/main.css">\n<script async src="<@wp.resourceURL />my-widget/static/js/runtime.js"><\/script>\n<script async src="<@wp.resourceURL />my-widget/static/js/vendor.js"><\/script>\n<script async src="<@wp.resourceURL />my-widget/static/js/main.js"><\/script>\n<@wp.currentWidget param="config" configParam="name" var="configName" />\n<my-widget name="${configName}" />\n \n We basically added a JSTL tag to extract a field (under  configParam )\nfrom the config field of the current widget and put it in a  configName \nvariable, that we pass to the custom element. \n Save the widget and reload the page that contains the widget. You should see\n Hello, Marco!  as expected. \n'},{title:"Generate Microservices and Micro Frontends",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/create/ms/generate-microservices-and-micro-frontends.html",relativePath:"next/tutorials/create/ms/generate-microservices-and-micro-frontends.md",key:"v-22e9e3da",path:"/next/tutorials/create/ms/generate-microservices-and-micro-frontends.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Generate the Project",slug:"generate-the-project"},{level:3,title:"Project Structure",slug:"project-structure"},{level:2,title:"Next Steps",slug:"next-steps"}],lastUpdated:"4/21/2022, 4:11:11 PM",lastUpdatedTimestamp:1650571871e3,content:' Generate Microservices and Micro Frontends \n Overview \n This tutorial describes how to use the Entando Component Generator (ECG) to create microservices and micro frontends for deployment to the  Entando Component Repository  and Entando Applications. The ECG is powered by  JHipster  and leverages the Entando Blueprint. \n \n The general flow of component generation is: \n \n Run the Entando Blueprint to create your components (Spring Boot microservice and optionally React micro frontends) \n Customize and enhance your generated code \n Build an Entando Bundle from your components \n Deploy a  custom resource  for your bundle into Kubernetes \n Install your Entando Bundle into your Entando Application(s) \n Prerequisites \n Use the  Entando CLI  to verify environmental dependencies (e.g. Java, npm, git, JHipster, Entando Blueprint). \n ent check-env develop\n Generate the Project \n Create a project with microservices. \n \n Setup a new project directory \n \n mkdir  testProject  &&   cd  testProject\n \n \n Use  ent jhipster  to generate the project skeleton via the Entando Blueprint \n \n ent jhipster --blueprints entando\n \n \n This triggers a project initialization prompt. Enter "Yes" in response. \n \n The project dir doesn\'t seem to be initialized, should I do it now?  ( Yes ) \n \n Enter "Yes" when prompted with the following overwrite to resolve the conflict: \n \n Overwrite .gitignore? \n \n \n You\'ll be presented with a series of additional prompts pertaining to project configuration. These are echoed below, with the base values for this tutorial in parentheses. Input your preferences, except where a required entry is identified in  bold . Note that the  Enter  key will select the default option. \n \n \n Please provide the project name:  (Up to you) \n \n \n What is the base name of your application?  (Up to you) \n \n \n As you are running in a microservice architecture, on which port would like your server to run? It should be unique to avoid port conflicts.  (8081) \n \n \n What is your default Java package name?  (Up to you) \n \n \n Which *type* of database would you like to use?  (SQL)\n- If no database is selected you\'ll be building a stateless microservice, which is a valid choice, but the rest of this tutorial won\'t work. \n \n \n Which *production* database would you like to use?  (PostgreSQL or MySQL) \n \n \n Which *development* database would you like to use?  (H2 with disk-based persistence) \n \n \n Which cache do you want to use? (Spring cache abstraction)  (Caffeine (local cache, for a single node)) \n \n \n Do you want to use Hibernate 2nd level cache?  (Yes) \n \n \n Which other technologies would you like to use?  ( Don\'t select any other technologies ) \n \n \n Which BE dependencies do you want to use?  (Dependencies maintained by Entando (entando/entando-bundle-bom)) \n \n \n What name would you give to the bundle to share on an Entando Component Repository?  (Up to you) \n \n \n Which is the organization name to use when publishing the docker image?  ( Enter the name of the organization where you are going to push your Docker image. If you\'re using your personal Docker hub account enter your username. ) <-- this can be changed later as needed \n \n \n Would you like to generate micro frontends when creating entities?  (Always) \n \n \n Would you like to enable internationalization support  (Up to you) \n \n \n Please choose the native language of the application  (Up to you) \n \n \n Besides JUnit and Jest, which testing frameworks would you like to use?  (Up to you) \n \n \n Would you like to install other generators from the JHipster Marketplace?  (No) \n \n \n \n \n Next, add an Entity to your microservice and create the corresponding micro frontends. In this tutorial,  Conference  is the name of the entity that will be added to the application. \n \n \n ent jhipster entity Conference\n \n \n \n You\'ll be presented with a series of prompts to add fields to your entity. These are echoed below, with the base values for this tutorial in parentheses. Input your preferences, and note that the  Enter  key will select the default option. \n \n \n Do you want to add a field to your entity?  (Yes) \n \n \n What is the name of your field?  (name) \n \n \n What is the type of your field?  (String) \n \n \n Do you want to add validation rules to your field?  (No) \n \n \n Do you want to add a field to your entity?  (Yes) \n \n \n What is the name of your field?  (location) \n \n \n What is the type of your field?  (String) \n \n \n Do you want to add validation rules to your field?  (No) \n \n \n Do you want to add a field to your entity?  (No) \n \n \n Do you want to add a relationship to another entity?  (No) \n \n \n Do you want to use separate service class for your business logic?  (Up to you) \n \n \n If "yes": \n \n \n Do you want to use a Data Transfer Object (DTO)?  (Up to you) \n \n \n Do you want to add filtering?  (Up to you) \n \n \n \n \n Is this entity read-only?  (Up to you) \n \n \n Do you want pagination and sorting on your entity?  (Yes, with infinite scroll) \n \n \n (If you chose to be prompted to generate micro frontends)  Do you want to generate micro frontends?  (Up to you) \n \n \n \n \n Affirm each overwrite prompt (echoed below) to resolve conflicts as the Blueprint generates controllers, repositories, services and micro frontends for your entity.  Note: Enter "a" in response to the initial prompt to authorize all overwrites to existing files with the necessary configuration changes. \n \n \n Overwrite src/main/resources/config/liquibase/master.xml? \n \n \n Overwrite package.json? \n \n \n Overwrite bundle/descriptor.yaml? \n \n \n Overwrite bundle/plugins/jhipster-plugin.yaml? \n \n \n Overwrite src/main/resources/config/liquibase/master.xml? \n \n \n Overwrite src/main/java/com/mycompany/myapp/config/CacheConfiguration.java? \n \n \n \n \n You have now generated an Entando project, including a Spring Boot microservice with database integration and React-based micro frontends. \n Project Structure \n \n /src/main/docker  contains Docker files to help with local development environments. \n /src/main/java  and  src/main/resources  contain the microservice codebase and configuration. \n /ui  holds the React-based micro frontends. By default, JHipster generates 3 MFEs per entity to contain the details, form, and table. \n /bundle  is used to assemble the project code into an Entando Bundle. \n Next Steps \n Follow one of the links below to learn how to assemble and run a bundle locally or deploy it. \n \n Build and publish a project bundle  to deploy your microservice and micro frontends to the Entando Component Repository \n Learn how to  run Blueprint-generated components locally in dev mode \n Discover the benefits and features of  the Entando Blueprint \n Iterate on your data model  using the JHipster Domain Language (JDL) \n \n'},{title:"Role Based Access Controls",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/create/ms/add-access-controls.html",relativePath:"next/tutorials/create/ms/add-access-controls.md",key:"v-7b7a2191",path:"/next/tutorials/create/ms/add-access-controls.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Tutorial",slug:"tutorial"},{level:2,title:"Notes",slug:"notes"},{level:3,title:"Realm Roles versus Client Authorities",slug:"realm-roles-versus-client-authorities"},{level:3,title:"Local versus Kubernetes Testing",slug:"local-versus-kubernetes-testing"},{level:3,title:"Debugging",slug:"debugging"}],lastUpdated:"1/25/2022, 4:09:16 PM",lastUpdatedTimestamp:1643144956e3,content:" Role Based Access Controls \n Overview \n This tutorial guides you through adding access controls to your existing Entando project. Security experts recommend following a practice known as  Defense in Depth  where security controls are placed in each layer of an architecture. This tutorial will help you setup such controls in both the frontend and backend of your Entando application. \n For the purpose of this tutorial we'll use the simple Conference application from  this tutorial  as a starting point. Please work through that tutorial if you have not already. \n The basic security setup for a blueprint-generated application allows any authenticated user to access the functionality contained in the MFEs and/or microservices. Our business requirement for this tutorial is to define two kinds of users in our application -  Conference Users  who can view the Conferences in the tableWidget, and  Conference Admins  who can view and also delete Conferences from the tableWidget. \n Tutorial \n Let's start by securing the list of Conferences so only our two user roles can view the list. \n \n Edit  ConferenceResource.java  located in the  src/main/java/com/<ORG>/<NAME>.web.rest  directory. Modify the REST API  Conference:getAllConferences  method by adding the following annotation. \n \n     @PreAuthorize(\"hasAnyAuthority('conference-user','conference-admin')\")\n    public List<Conference> getAllConferences() {\n \n See the  Spring Security documentation  for more details but this restricts use of the  getConference  method to users who have been assigned either the  conference-user  or the  conference-admin  role on the Keycloak client configured for the microservice. In local testing this defaults to the  internal  client but see notes below on how that works in production. \n Now we should verify this security check is working. \n \n Start up your Keycloak, tableWidget MFE, and microservice. See  these instructions  if you need a refresher but these are the basic commands using the ent CLI and Docker for keycloak. \n \n ent prj ext-keycloak start\nent prj be-test-run\n \n Using a separate cmdline: \n ent prj fe-test-run\n \n \n Access the tableWidget MFE, typically on  http://localhost:3000 , using the default admin/admin account. \n \n Once authenticated, you'll get the message \"No conferences are available\" and, if you check your browser console, you should see a  403 (Forbidden)  error for the request made to  localhost:8080/services/conference/api/conferences . This is expected because we have not yet granted the new role to the admin user. \n Now let's give the admin user the correct role. \n \n Login to keycloak on  http://localhost:9080  using the  admin/admin  credentials. \n \n First we need to create the two roles per our requirements. We're going to add the roles to the  internal  client because it's the one configured by default in the Spring Boot application.yml. \n \n Go to  Clients → internal → Roles  and click  Add Role \n Fill in the  Role Name  with  conference-admin  and click  Save \n Repeat steps 5-6 to create the  conference-user  role. \n \n Now we need to map this role to our user. \n \n Go to  Users → View all users → admin → Role Mappings \n Select  internal  for the  Client Roles  and then move  conference-user  from  Available Roles  to  Assigned Roles \n Go back to the MFE and you should now see the full list of Conferences. \n \n We've now successfully secured the  getAllConferences  API but we have more to do. The admin user was granted just the  conference-user  role but still has access to delete Conferences. We need to lock that down. \n \n Go back into the  ConferenceResource.java  file and add this annotation to the  deleteConference  method: \n \n     @PreAuthorize(\"hasAuthority('conference-admin')\")\n    public ResponseEntity<Void> deleteConference(@PathVariable Long id) {\n \n Here we're restricting the delete method to only the  conference-admin  role. \n \n Restart the microservice. By default this will include rebuilding any changed source files. \n Once the microservice is available, go back to the MFE and try deleting one of the Conferences in the list. You should be able to attempt the delete in the UI but you'll get a 403 error in the browser console and an error like this in the service logs: \n \n 2021-03-22 15:56:16.205  WARN 3208 --- [  XNIO-1 task-3] o.z.problem.spring.common.AdviceTraits   : Forbidden: Access is denied\n \n That's exactly what we wanted! This demonstrates that a user without  conference-admin  is unable to call the delete API. \n Next, let's update the MFE so a user without the  conference-admin  authority cannot even see the delete button in the UI. \n \n Edit the  ConferenceTableContainer.js  under  ui/widgets/conference/tableWidget/src/components . Replace the onDelete logic with an additional check on the user's authorities. \n \n     const isAdmin = (keycloak && keycloak.authenticate) ? keycloak.hasResourceRole(\"conference-admin\", \"internal\"): false;\n    const showDelete = onDelete && isAdmin;\n\n    const Actions = ({ item }) =>\n      showDelete ? (\n \n The key logic there is the hasResourceRole call which checks whether the  internal  client role  conference-admin  was mapped to the current user. \n \n View the MFE (whch should have automatically reloaded) and you should see that the delete icon is no longer visible, matching the admin's current permissions.  We've now verified that a user with just  conference-user  can neither see the delete action in the UI nor call its corresponding API. \n \n Next, let's promote the admin user to a full  conference-admin  so they can delete Conferences. \n \n \n Go back into Keycloak at  http://localhost:9080 , then go to  Users → View all users → admin → Role Mappings , and also give the user the  conference-admin  role. \n \n \n Reload the MFE. The delete icons should now be visible and you should be able to successfully delete a Conference from the list. This satisfies our original business requirement. \n Notes \n Realm Roles versus Client Authorities \n This tutorial made use of authorities which in Keycloak are Roles mapped to a User for a specific Client. You could also make use of higher-level Realm Roles assigned directly to users, e.g.  ROLE_ADMIN . That will work but can result in collisions between applications if they happen to use the same roles. \n If you choose to use Realm-assigned roles then the code above would need to change. In the backend, use the following annotations:  @Secured('ROLE_ADMIN)  or  @PreAuthorize(hasRole('ROLE_ADMIN')) . In the frontend, use  keycloak.hasRealmRole  instead of  keycloak.hasResourceRole . See the  Spring Security page  for more examples. \n Local versus Kubernetes Testing \n This tutorial also makes use of the  internal  client configured in the microservice via the application.yml with roles manually created and assigned in Keycloak. In Kubernetes, Entando will automatically create client roles per the bundle plugin definition (see the plugin definition  here  for more information). Those roles will be created for the client specific to the microservice itself, e.g.  <docker username>-conference-server . This client name will be injected as an environment variable into the plugin container itself so the annotations noted above will work both in local and Kubernetes environments. \n The MFE authorization checks in the tutorial explicitly note the client id,  e.g.  internal , which won't work in Kubernetes. There are a couple options here: \n \n Change the application.yml clientId under  security.oauth2.client.registration.oidc  to match the Kubernetes clientId. That's the most secure and allows the MFE checks to work the same in both local and Kubernetes environments. However, you not be be able to use the same clientId depending on how the microservice is deployed \n An alternative is to broaden the MFE authorization check to look for a named role on any client. This could result in overlap with other clients but with appropriately named roles (e.g. prefixed by feature, e.g.  conference-admin ) this could be the most flexible option. This can be provided via a helper function, e.g. in  api/helpers.js : \n \n //Check if the authenticated user has the clientRole for any keycloak clients\nexport const hasKeycloakClientRole = clientRole => {\n  if (getKeycloakToken()) {\n    const { resourceAccess } = window.entando.keycloak;\n    if (resourceAccess) {\n      for (const client in resourceAccess) {\n        // eslint-disable-line no-unused-vars\n        const roles = resourceAccess[client].roles;\n        if (roles && roles.includes(clientRole)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\n \n This would result in a simpler role check: \n     const isAdmin = hasKeycloakClientRole('conference-admin');\n Debugging \n In both local and Kubernetes environments, the default blueprint javascript will make a global variable available in the browser, e.g.  window.entando.keycloak . Examining this variable can help diagnose issues with assigned roles and authorities. In some cases you may need to logout of Entando and re-authenticate in order to get the latest role assignments. \n"},{title:"Run Blueprint-generated Microservices and Micro Frontends in Dev Mode",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/create/ms/run-local.html",relativePath:"next/tutorials/create/ms/run-local.md",key:"v-a7dae2b6",path:"/next/tutorials/create/ms/run-local.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"CLI Steps",slug:"cli-steps"},{level:2,title:"Manual Steps",slug:"manual-steps"},{level:3,title:"Start Keycloak using docker-compose",slug:"start-keycloak-using-docker-compose"},{level:3,title:"Start the microservice",slug:"start-the-microservice"},{level:3,title:"Start the table widget",slug:"start-the-table-widget"},{level:3,title:"Start the form widget",slug:"start-the-form-widget"},{level:3,title:"Start the details widget",slug:"start-the-details-widget"},{level:3,title:"Widget Details notes:",slug:"widget-details-notes"},{level:2,title:"Notes",slug:"notes-3"},{level:3,title:"Change Keycloak dev settings",slug:"change-keycloak-dev-settings"},{level:3,title:"The service-url Variable",slug:"the-service-url-variable"},{level:3,title:"User is not authenticated message",slug:"user-is-not-authenticated-message"}],lastUpdated:"4/18/2022, 4:37:39 PM",lastUpdatedTimestamp:1650314259e3,content:' Run Blueprint-generated Microservices and Micro Frontends in Dev Mode \n Overview \n This tutorial will take you through running an Entando project (microservice and micro frontends) in a local development environment. If you haven\'t generated your Entando project yet, start with the  Generate Microservices and Micro Frontend  tutorial first. \n The steps below assume you are working in the top-level project directory. \n CLI Steps \n The following steps make use of the Entando  ent prj  command. See the  Manual Steps  section below for a more detailed description of what the individual commands do. \n \n Startup Keycloak. This uses docker-compose under the hood. Since this is using Docker it will continue to run in the background until you stop it via  ent prj ext-keycloak stop . You can also view its logs using  ent prj ext-keycloak logs . \n \n ent prj ext-keycloak start\n \n \n Startup the Spring Boot application containing your microservices. The logs will be shown on the console and you can stop the application via  CTRL+C . \n \n ent prj be-test-run\n \n \n Startup one or more of the frontend widgets, each from its own shell. You can stop the application using  Ctrl+C . This command runs React in development mode so any changes you make to the source files should be immediately seen in the browser. \n \n ent prj fe-test-run\n Manual Steps \n Start Keycloak using docker-compose \n \n Startup the Keycloak server: \n \n    docker-compose  -f src/main/docker/keycloak.yml up\n Notes: \n \n If you have to install docker-compose you can follow this guide:\n https://docs.docker.com/compose/install/ \n By default docker-compose will recreate the Keycloak container (and reset the H2 database) each time it is started. You can make the following changes to persist Keycloak changes across restarts:\n \n Modify the following line in your  src/main/docker/keycloak.yml \n \n \n \n \'-Dkeycloak.migration.strategy=OVERWRITE_EXISTING\',\n \n and replace it with this \n \'-Dkeycloak.migration.strategy=IGNORE_EXISTING\',\n \n \n In the same file, add a persistent volume under  volumes : \n \n  - ./keycloak-db:/opt/jboss/keycloak/standalone/data\n \n Keycloak changes should now be persistent. You can reset your Keycloak database by emptying the  src/main/docker/keycloak-db  directory and restarting the container. \n Start the microservice \n \n \n Start the generated Microservice executing the command: \n ./mvnw\n Notes: \n If you want to reset the widget data (as example if you deleted all rows from the table widget) if during the generation of the microservice you selected "H2 with disk-based persistence" you can delete the target folder, restart the microservice and the data will be regenerated. \n Start the table widget \n Now you can start your generated table widget: \n \n \n Go to the table widget folder in your project: \n cd ui/widgets/YOUR-ENTITY-NAME/tableWidget\n \n \n \n Then install and start your widget executing the command: \n npm install && npm start\n \n \n \n When the widget is started a browser window is opened and the widget URL is loaded \n \n \n If you’re not logged in you’re redirected to the login page. \n \n \n Log in using: \n Username: user\nPassword: user\n \n \n \n After the login process you’ll be redirected to the widget page and you can see the table widget with some generated data. \n Start the form widget \n Now you can start your generated form widget: \n \n \n If you are running another widget, stop it clicking  Ctrl+C  in your widget command line window \n \n \n Go to the form widget folder in your project: \n cd ui/widgets/YOUR-ENTITY-NAME/formWidget\n \n \n \n Then install and start your widget executing the command: \n npm install && npm start\n \n \n \n When the widget is started a browser window is opened with and the widget URL is loaded \n \n \n If you’re not logged in you’re redirected to the login page. \n \n \n Log in using: \n Username: user\nPassword: user\n \n \n \n You’ll be redirected to the widget page and you can see the widget form with the ID 1 loaded. \n Form widget notes: \n If you want to load other data you have to change the index.html file in the folder: \n cd ui/widgets/YOUR-ENTITY-NAME/formWidget/public\n \n and change the id attribute in this line: \n <my-entity-form service-url="%REACT_APP_SERVICE_URL%" id="1" />\n Start the details widget \n You can also start your generated details widget: \n \n \n If you are running another widget, stop it clicking  Ctrl+C  in your widget command line window \n \n \n Go to the details widget folder in your project: \n cd ui/widgets/YOUR-ENTITY-NAME/detailsWidget\n \n \n \n Then install and start your widget executing the command: \n npm install && npm start\n \n \n \n When the widget is started a browser window is opened with and the widget URL is loaded \n \n \n If you’re not logged in you’re redirected to the login page. \n \n \n Log in using: \n Username: user\nPassword: user\n \n \n \n You’ll be redirected to the widget page and you can see the widget form with the ID 1 loaded. \n Widget Details notes: \n If you want to load other data you have to change the index.html file in the public folder: \n cd ui/widgets/YOUR-ENTITY-NAME/detailsWidget/public\n \n and change the "id" attribute in this line: \n <my-entity-details service-url="%REACT_APP_SERVICE_URL%" id="1" />\n Notes \n Change Keycloak dev settings \n If you want to change your Keycloak settings to use another keycloak installation (not the docker-compose pre-configured one) or if you want to change the service-url of your widget you can change the parameters set in the  .env.local  file that was generated by the Entando Blueprint in the root folder of your react widgets: \n cd ui/widgets/YOUR-ENTITY-NAME/tableWidget\n \n then edit the file  .env.local \n By default this variables are set to: \n REACT_APP_SERVICE_URL=http://localhost:8081/services/YOUR-APPLICATION-NAME/api\nREACT_APP_KEYCLOAK_URL=http://localhost:9080/auth\nREACT_APP_KEYCLOAK_REALM=jhipster\nREACT_APP_KEYCLOAK_CLIENT_ID=web_app\n The service-url Variable \n The  service-url  variable is the Microservice API URL. \n User is not authenticated message \n When you run the widgets if you see the message:  User is not authenticated . This means that probably your keycloak application is not running so please check if the docker-compose command is still in execution. \n'},{title:"Update the Project Data Model",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/create/ms/update-data-model.html",relativePath:"next/tutorials/create/ms/update-data-model.md",key:"v-05ca4e63",path:"/next/tutorials/create/ms/update-data-model.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"3/16/2022, 6:46:32 PM",lastUpdatedTimestamp:1647470792e3,content:" Update the Project Data Model \n Overview \n This tutorial explains how to use the  Entando Component Generator  powered by  JHipster  to quickly update the data model for your Entando project. \n Prerequisites \n Leverage an existing project or  create a project  and navigate to the root folder. The steps below assume you're working in the top-level project directory. \n Tutorial \n \n Use JHipster to extract the current application description. The resulting JHIpster Domain Language (JDL) file contains your project's application configuration and entity definitions. \n \n ent jhipster export-jdl export.jdl\n \n \n To strip unnecessary information, create a new file comprising only the elements that describe entities. If you followed the  project generation tutorial , that could be as simple as \n \n entity Conference {\n  name String\n}\n \n \n \n You can enhance this definition by adding fields, entities, table mappings, field validation, etc. This is easily accomplished with the  online JDL-Studio or corresponding JHipster IDE plugins/extensions . \n \n \n Create a new file containing your enhanced data model, e.g.  conference.jdl . \n \n \n entity Conference {\n  name String required\n  location String\n  date ZonedDateTime\n}\n\nentity Session {\n  name String required\n  track Track required\n}\n\nenum Track {\n  BUSINESS, TECHNICAL\n}\n\nrelationship OneToMany {\n   Conference to Session\n}\n \n The above adds two fields to the Conference entity, introduces the Session entity plus an enum, and creates a mapping between the two entities. Below is the updated data model in JDL-Studio: \n \n \n Import the JDL file into your application. You will be prompted with the option to generate MFEs if this was requested during project generation. \n \n ent jhipster import-jdl conference.jdl\n \n If the original project structure has been retained, this step will update your data model, add entries to Liquibase to upgrade database schema during deployment, add service methods to your microservice, add fields to your MFEs, etc. \n \n You can now build your updated project and  run it locally  or  deploy it to Entando . To execute a comprehensive local test, use the following commands to build the project \n \n ent prj build\nent prj xk start\nent prj be-test-run\nent prj fe-test-run\n \n then start Keycloak, the microservice, and one of the MFEs. \n Definition enhancement through build and test can be repeated as many times as needed throughout the life of your project. \n"},{title:"Use Postman with OAuth2 APIs",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/create/ms/use-postman-with-oauth2.html",relativePath:"next/tutorials/create/ms/use-postman-with-oauth2.md",key:"v-65ebad25",path:"/next/tutorials/create/ms/use-postman-with-oauth2.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Create a new Postman Collection",slug:"create-a-new-postman-collection"},{level:2,title:"Define Collection variables",slug:"define-collection-variables"},{level:2,title:"Configure new token generation",slug:"configure-new-token-generation"},{level:2,title:"Update your Keycloak configuration (Postman Web only)",slug:"update-your-keycloak-configuration-postman-web-only"},{level:2,title:"Generate a new token",slug:"generate-a-new-token"},{level:2,title:"Add a request",slug:"add-a-request"},{level:2,title:"Troubleshooting",slug:"troubleshooting"}],lastUpdated:"3/25/2022, 4:56:49 PM",lastUpdatedTimestamp:1648241809e3,content:" Use Postman with OAuth2 APIs \n Overview \n The tutorial will help you to configure Postman to reach your APIs secured with OAuth2 and Keycloak. \n In this tutorial, we will call an API from an application generated with the  Entando JHipster blueprint . \n Prerequisites \n Get the  Postman  application or create an account to use it on the web.\nThe screenshots in this tutorial have been made with the current web version. \n Create a new Postman Collection \n According to the official website \n \n Postman's collection folders make it easy to keep your API requests and elements organized. \n \n This helps us to gather different requests under the same folder but also to share the configuration and the Auth mode among them. \n Click on the button when you are on the collection left menu. \n \n Name it as you want, we usually try to create a collection per application. \n Define Collection variables \n Postman allows us to define variables for a given collection, and we can use them at the collection level to configure the OAuth2 settings but also at the request level. \n \n Please note you can choose the variable names you want, according to what makes sense to you. \n \n \n \n Variable \n Default value in a Blueprint-based Entando App \n Details \n \n \n \n \n client_id \n web_app \n The client id account used to authenticate the user \n \n \n client_secret \n web_app \n The secret for the client_id \n \n \n scope \n openid profile email \n The scope to retrieve during the auth \n \n \n access_token_url \n http://localhost:9080/auth/realms/jhipster/protocol/openid-connect/token \n The token endpoint \n \n \n auth_url \n http://localhost:9080/auth/realms/jhipster/protocol/openid-connect/auth \n The authorization endpoint \n \n \n base_url \n http://localhost:8081/api \n The url all the requests start with \n \n \n \n Notes: \n \n The base_url variable is added for convenience, but is not mandatory for authentication purposes \n \n \n Use the .well-known endpoint to retrieve these values if you don't have them\n http://keycloak_host:keycloak_host/auth/realms/<realm>/.well-known/openid-configuration \nFor a local running app it should be  http://localhost:9080/auth/realms/jhipster/.well-known/openid-configuration \n \n \n In the Postman application, you may need to save the Collection in order to make the variables available in the following steps. \n Configure new token generation \n In your collection view, click on the  Authorization  tab and define the type to  OAuth 2.0  as-is:\n \n Enter the fields with the variables previously defined. You can define the  Token Name  with the value you want: \n \n Please note, regarding you are using the Postman Web or the app, the  Callback URL  field contains different values.\nBasically, the Web solution needs to use a specific value while the App just need to use a value already\npresent in the Keycloak configuration (e.g.  http://locahost:8081 ) \n This is the reason why we need to update the Keycloak configuration with Postman Web. \n Update your Keycloak configuration (Postman Web only) \n To generate a new token you need to ensure the Postman redirect URL is configured in the Keycloak admin panel. There  https://oauth.pstmn.io/v1/browser-callback  (or a wildcard  * ) should be present in the  Valid Redirect URIs  list for your client.\nThis URL is used to redirect to the Postman app after authentication successfully completes. \n Generate a new token \n Clicking on the  Get New Access Token  will open the Keycloak login form and then you can authenticate with the user to be used when testing the API. The user will need to already be assigned the appropriate roles.\n \n After the authentication succeeds, you should be redirected to the Postman app.\n \n The token is then displayed in a window and you can confirm its use by clicking on the  Use Token  button.\n Add a request \n The next step is to add a request to the collection, using the previous OAuth2 config as an authorization method.\nIn your collection name click on the  Add request  entry\n \n In the  Auth  tab select  Inherit auth from parent . Requests in the collection can then inherit those settings,\nallowing you to execute a configuration step every time you add a new one.\n \n Postman will then automatically add an Authorization header with a Bearer  Token  value where  Token  is the token value generated in the previous step. \n \n Note: \n \n By default, these headers are hidden. A button allows you to display them. \n \n Finally, you can define the endpoint you want to consume, the HTTP method to use and add more headers if needed. \n \n The expected result should be a 2XX code from our API.\nIf you experience a 401 error, this probably means that the token is not valid anymore.\nBecause the token has an expiration period, it's mandatory to refresh it frequently.\nTo get a new token execute the  Generate a new token  section again. \n Troubleshooting \n For security reasons, the access token timeout should always be short to avoid security issues if someone steals the token.\nThe refresh token can be used to acquire a new access token when the access token has expired. The process would be: \n \n Get the Access token (and the Refresh Token) \n Call the API \n Check if the token is still valid\n \n The token is valid: execute the call \n The token has expired: use the refresh token to generate a new Token and execute the call \n \n \n \n Unfortunately, Postman doesn't handle the refresh action if the token has expired, and you need to generate a new one by yourself by clicking on the  Get new access token  button.\nTo avoid this manual action you can make the token longer by updating the timeout over 5 min. However, we do not recommend this solution outside of a local development environment. \n The Postman team is tracking this issue and plans to include this feature in a future release:  https://github.com/postmanlabs/postman-app-support/issues/10112 . \n"},{title:"Install Plugins and Micro Frontends without a Bundle",frontmatter:{},regularPath:"/next/tutorials/create/pb/deploy-components-without-bundle.html",relativePath:"next/tutorials/create/pb/deploy-components-without-bundle.md",key:"v-280a3933",path:"/next/tutorials/create/pb/deploy-components-without-bundle.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Generate a Docker image",slug:"generate-a-docker-image"},{level:2,title:"Publish the Docker image",slug:"publish-the-docker-image"},{level:2,title:"Deploy the plugin",slug:"deploy-the-plugin"},{level:2,title:"Link the plugin to the App",slug:"link-the-plugin-to-the-app"},{level:2,title:"Upload the Static Resources",slug:"upload-the-static-resources"},{level:2,title:"Use the Micro Frontend and Microservice",slug:"use-the-micro-frontend-and-microservice"}],lastUpdated:"2/9/2022, 9:50:35 AM",lastUpdatedTimestamp:1644418235e3,content:' Install Plugins and Micro Frontends without a Bundle \n Overview \n In this tutorial you will learn how to install a plugin and micro frontend, generated with the Entando Blueprint, without the need to include the components in a bundle. Once the plugin is deployed into a cluster, link it to the EntandoApp, upload the static resources, and create the widgets for your app from the Entando App Builder. \n Prerequisites \n \n \n An Entando plugin built with the Entando Component Generator and populated with Micro\nFrontends.  Generate a plugin and Micro Frontend here . \n \n \n Node and npm installed (use the LTS version) \n \n \n Docker installed and able to upload images to Docker Hub or a repository of your choice \n \n \n An instance of the Entando platform running on Kubernetes. See  Getting Started . \n \n \n Note \n Here is a definition of an Entando plugin , including information on the runtime contract required for using non-Java based plugins. \n Generate a Docker image \n JHipster uses the JIB Maven plugin to generate a Docker image for your\nmicroservice. \n The name of the output image generated with JIB during the setup wizard is defined with: \n \n The organization name you chose; default is set to  entando \n The name of the application \n Version  0.0.1-SNAPSHOT \n \n For example, a custom organization name of  myorg  and an application name of  jhipster  will result in a Docker image named  myorg/jhipster:0.0.1-SNAPSHOT . \n \n Build the Docker image: ./mvnw -Pprod clean package jib:dockerBuild\n \n \n \n The output image name can also be set by customizing the  ./mvnw  command using the  -Djib.to.image  parameter. With the organization name  myneworg , name  myapp  and version  latest , use: \n  ./mvnw -Pprod clean package jib:dockerBuild -Djib.to.image=myneworg/myapp:latest\n \n Note \nThe output image name can be changed in the  pom.xml  file by configuring the  plugins.plugin.jib-maven-plugin.configuration.to.image  tag as follows: \n  <plugin>\n   <groupId>com.google.cloud.tools</groupId>\n   <artifactId>jib-maven-plugin</artifactId>\n   <configuration>\n     \x3c!-- ... --\x3e\n     <to>\n       <image>\x3c!-- use a custom value here --\x3e</image>\n     </to>\n     \x3c!-- ... --\x3e\n   </configuration>\n </plugin>\n \n Warning \n If you change the target image of the Docker build, remember to update\nthe plugin metadata in the bundle accordingly. Once you deploy the plugin, you will also have to change the plugin Custom Resource in the  bundle/plugins  folder to point to the correct image. \n Publish the Docker image \n Publish the Docker image for the microservice to make it\navailable for the bundle installation in the cluster. Docker Hub or an equivalent registry will do. \n docker push <name-of-the-image:tag>\n Deploy the plugin \n You can now deploy the plugin Custom Resource generated by the Entando Blueprint in the  bundle/plugins  folder. \n From the JHipster project directory, deploy the plugin: \n cd  bundle/plugins\n\nkubectl create -f  < plugin-file.yaml >  -n entando\n Link the plugin to the App \n Once the plugin server deployment is up and running, create an  EntandoAppPluginLink Custom Resource \nto make the plugin API available from the EntandoApp domain. \n Here is an example of a EntandoAppPluginLink Custom Resource. Some defaults are: \n \n The EntandoPlugin generated with the Blueprint is  my-demo-plugin \n The EntandoApp exposing  my-demo-plugin  API is  quickstart . This is the app name in the environment built with the Getting Started instructions. \n Both are deployed on the  entando  namespace \n The link is named  quickstart-to-my-demo-plugin-link \n The name of the link yaml is  my-link.yaml \n \n TIP \n Change the defaults as needed if you used your own custom names for any of these fields. \n \n apiVersion: entando.org/v1\nkind: EntandoAppPluginLink\nmetadata:\n  name: quickstart-to-my-demo-plugin-link\n  namespace: entando\nspec:\n  entandoAppName: quickstart\n  entandoAppNamespace: entando\n  entandoPluginName: my-demo-plugin\n  entandoPluginNamespace: entando\n \n \n Add this link to your environment \n \n kubectl create -f my-link.yaml -n entando\n \n A new link deployer will start and work behind the scenes to add your plugin  ingressPath  (part of the plugin  spec ) to the EntandoApp ingress. \n Upload the Static Resources \n Now that the plugin and app are linked, generate the Micro Frontend from the App Builder\nand upload the static resources like  js  and  css  files. \n \n \n From the App Builder, go to  Configuration -> File Browser \n \n \n Navigate to the  public  folder. Create a new folder using the name of the bundle (the value is in the  code  field available in the  /bundle/descriptor.yaml  file of the blueprint project) or use a custom name such as  demo-widget . \n \n \n Upload all the resources in the  /bundle/resources  folder of the project into the new folder \n \n \n Warning \n If you do not duplicate the folder name and structure of  /bundle/resources , you will need to update the references to them in the customUI/configUI of the widget. \n \n \n \n In the App Builder, go to  Components → Micro frontends & Widgets \n \n \n Select  Add  to create the widget \n \n \n Enter the following with your choices for  anyname : \n \n \n \n Title: anyname1  → enter for both English and Italian languages \n Code: anyname2  → dashes are not allowed \n Group: Free Access \n Icon :  → upload an icon of your choice \n \n \n \n Under customUI, copy one of the widgets you generated with the Blueprint.\nFor example, the customUI for the  detailWidget  of the Conference entity is available in\n /bundle/ui/widgets/conference/detailsWidget/conference-details-widget.ftl \n \n \n If your path differs from the default, update the service URL to match the location where the ingress for your microservice was deployed. \n \n \n For example, update the service-URL value with the relative path of your service if you\'re deploying a bundle  <car-table service-url="/newBp/api"  /> . \n Or use the full path if you\'re deploying the BE and FE individually\n <car-table service-url="http://newbp-plugin-entando.192.168.64.7.nip.io/newBp/api"/> . \n \n If you\'re creating a new page from scratch or your page is missing the Keycloak fragment, you can add it with this freemarker snippet: \n \n <@wp.fragment code="keycloak_auth" escapeXml=false />\n \n Note \n Your Entando application includes a  keycloak_auth  fragment that will inject the token\nand connection to Keycloak that your Micro Frontends need to invoke the protected APIs. To view the token, go to  Components → UX Fragments  in the App Builder and search for  keycloak_auth . \n Use the Micro Frontend and Microservice \n Now the Micro Frontends and microservice is available for use in your Entando App Builder. \n'},{title:"Export and Publish a Bundle",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/create/pb/export-bundle-from-application.html",relativePath:"next/tutorials/create/pb/export-bundle-from-application.md",key:"v-78a28bda",path:"/next/tutorials/create/pb/export-bundle-from-application.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:3,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Export an Entando Bundle",slug:"export-an-entando-bundle"},{level:3,title:"Setup the Keycloak client",slug:"setup-the-keycloak-client"},{level:3,title:"Create env.json",slug:"create-env-json"},{level:3,title:"Run the Bundler",slug:"run-the-bundler"}],lastUpdated:"4/15/2022, 12:46:49 PM",lastUpdatedTimestamp:1650041209e3,content:' Export and Publish a Bundle \n Overview \n Use the Entando bundler command to export a bundle of Entando components from an existing Entando application. An Entando bundle can be used to do the initial install of Entando components into an Entando application, migrate Entando components from one environment to another (e.g. Dev to QA), to provide a template for building a new Entando application, or as the skeleton of an Entando solution. The output of this command is the same bundle directory structure created by an Entando project including a bundle descriptor file. \n Prerequisites \n \n Use the  Entando CLI  to verify you have the prerequisites in place for this tutorial (e.g. git, entando-bundler). \n \n ent check-env develop \n \n \n You\'ll also need a running Entando application. \n You\'ll need admin access to Keycloak or admin access to Kubernetes to set it up. \n \n The tutorial assumes you\'re using an Entando quickstart application. You may need to adjust the specific URLs, credentials, namespaces, etc. for a custom application. \n Export an Entando Bundle \n Setup the Keycloak client \n You\'ll need to setup a Keycloak client with the appropriate permissions for the bundler to access all of the necessary Entando APIs. \n \n Find the Secret for the Keycloak admin account. If you already have the admin credentials, then you can skip to step 3. \n \n kubectl get secrets -n entando \n \n In a quickstart application, the Secret is named. default-sso-in-namespace-admin-secret \n \n Determine the admin password using the Secret name. \n \n kubectl get secret default-sso-in-namespace-admin-secret -n entando -o go-template = "{{println}}Username: {{.data.username | base64decode}}{{println}}Password: {{.data.password | base64decode}}{{println}}{{println}}" \n \n Example output: \n Username: entando_keycloak_admin\nPassword: 1pTZev82Ee\n \n \n Login to Keycloak using the admin credentials. The URL will be something like  http://YOUR-HOST-NAME/auth/ . You can use this command to verify the URL. \n \n kubectl describe ingress/quickstart-ingress\n \n \n Go to  Clients  →  Create . \n Enter a  Client ID  of your choice, e.g.  entando-bundler , and click  Save . \n The  Settings  tab should be shown. Edit the following values: \n \n \n Access Type:  confidential \n Service Accounts Enabled:  On \n Valid Redirect URLs:  * \n Web Origins:  * \n \n \n Click  Save \n Go to the  Service Account Roles  tab \n Select  Client Roles  →  quickstart-server \n Select  Available Roles  →  superuser . \n Click  Add Selected  to add  superuser  to the  Assigned Roles . This change will be saved automatically. \n Go to the  Credentials  tab and copy the  Secret  shown there. You\'ll need this in the next section. \n Create env.json \n \n Create a directory where you\'ll run the bundler and change to that directory. \n \n mkdir  testBundle ;   cd  testBundle\n \n \n Create an  env.json  file with the environment URLs and client credentials. The  clientId  and  clientSecret  are from steps 5 and 12 above. \n \n { \n    "coreBaseApi" :   "http://YOUR-HOST-NAME/entando-de-app" , \n    "k8ssvcApi" :   "http://YOUR-HOST-NAME/k8s" , \n    "clientId" :   "YOUR-CLIENT-ID" , \n    "clientSecret" :   "YOUR-CLIENT-SECRET" \n } \n Run the Bundler \n \n Create a child directory to hold the bundler output. Using the name  bundle  allows you to easily use the  ent prj  command with this bundle. \n \n mkdir  bundle\n \n \n Run the bundler command with your preferred settings. \n \n ent bundler from-env --location bundle --code my-test-bundle --description “My Test Bundle”\n \n The bundler will inspect the application using the Entando APIs, collect information about the individual components, construct the appropriate descriptor files, and finally assemble the top-level descriptor file. \n $ ls bundle\nassets      contentModels  contents         fragments  labels     pageModels  resources\ncategories  contentTypes   descriptor.yaml  groups     languages  pages       widgets\n \n At this point you have a full Entando project structure. You can inspect the output to edit the exported components or you could  deploy it to another Entando application . \n'},{title:"Add a GitHub Actions CI Workflow",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/create/pb/github-actions-workflow.html",relativePath:"next/tutorials/create/pb/github-actions-workflow.md",key:"v-2f907ba6",path:"/next/tutorials/create/pb/github-actions-workflow.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Create a Backend Workflow",slug:"create-a-backend-workflow"},{level:2,title:"Add a Frontend Job",slug:"add-a-frontend-job"},{level:2,title:"Extend the Frontend Job for Multiple MFEs",slug:"extend-the-frontend-job-for-multiple-mfes"}],lastUpdated:"4/9/2022, 3:24:21 PM",lastUpdatedTimestamp:1649532261e3,content:" Add a GitHub Actions CI Workflow \n Overview \n This tutorial shows how to use the JHipster  ci-cd  sub-generator to quickly create a basic GitHub Actions Workflow for the microservices and micro frontends (MFEs) generated by the Entando Component Generator. \n Prerequisites \n \n An existing project with a GitHub repository. See the  Entando Component Generator  to create a new one. \n GitHub Actions . These are enabled by default without additional configuration. Please note public repositories currently qualify for unlimited usage but private repositories can encounter usage restrictions. \n Use the  Entando CLI  to verify you have the command line prerequisites in place for this tutorial (e.g. npm, git, JHipster). \n Create a Backend Workflow \n \n Go to your main project folder in the shell \n Run the JHipster  ci-cd  subgenerator \n \n ent jhipster ci-cd\n \n \n Select  GitHub Actions \n Click ENTER to choose no  tasks/integrations  and generate the default workflow \n The initial workflow file is available at  .github/workflows/github-ci.yml \n Commit the workflow file and push it to GitHub. \n \n git   add  .github\n git  commit -m  \"Add the backend CI job\" \n git  push\n \n \n Since the workflow runs on  push  or  pull-request , you can immediately check the GitHub  Repository → Actions  tab to see the status of the corresponding jobs. The standard tests in a Blueprint-generated project can take a few minutes to run. \n \n \n You can review the logs for each step to diagnose CI failures. \n If the workflow fails or times out, you should receive an email notification. \n You can choose to skip the CI workflow by including  skip ci  or  ci skip  in your commit message. This can be customized in the job definition. \n See the  GitHub Actions  documentation for more information on alternative trigger options. \n \n Next, let's expand the workflow to also include the micro frontends. \n Add a Frontend Job \n We'll now add a second job to the workflow definition, specifically for the micro frontends. Optionally, you could also create a completely separate workflow file if you'd prefer. \n \n Add a new entry under  jobs: , paying attention to the YAML indentation. \n \n      micro-frontends : \n      name :  micro frontend job\n      runs-on :  ubuntu - latest\n      if :   \"!contains(github.event.head_commit.message, '[ci skip]') && !contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.pull_request.title, '[skip ci]') && !contains(github.event.pull_request.title, '[ci skip]')\" \n      steps : \n        -   uses :  actions/checkout@v2\n        -   uses :  actions/setup - node@v2.1.4\n          with : \n            node-version :   '14.15.0' \n        -   name :  Run tests\n          run :   | \n           cd ui/widgets/conference/detailsWidget\n           npm install\n           npm test \n \n \n (Optional) If your widget path differs from the standard Blueprint example, you should change the first command in  Run tests  to match your path. \n Commit and push the changes to GitHub. \n \n    git add .github\n   git commit -m \"Add the microfrontend CI job\"\n   git push\n \n \n Now check the GitHub  Repository → Actions  tab to see the status of the jobs. When the  micro-frontends  job is complete, you should see something like this: \n \n Test Suites: 2 passed, 2 total\nTests:       4 passed, 4 total\nSnapshots:   0 total\nTime:        2.911s\nRan all test suites.\n Extend the Frontend Job for Multiple MFEs \n You may have multiple micro frontends or widgets in your project. One option is to duplicate the job for each MFE, but you can also use the GitHub Actions matrix feature to avoid duplicating those definitions. \n \n Change your job definition to the following. Note the changes: \n \n \n The  job.name  is dynamically set using the MFE matrix name \n The  job.strategy  has been set to  fail-fast:false  so all MFEs will be tested, rather than stopping the job on the first failure \n The  job.strategy.matrix.mfe  provides the list of MFEs in this project. You should update this list to match your project. \n The first command in  Run tests  is parametrized to use the MFE matrix name \n \n      micro-frontends : \n      name :  $ { {  matrix.mfe  } }  micro frontend\n      runs-on :  ubuntu - latest\n      if :   \"!contains(github.event.head_commit.message, '[ci skip]') && !contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.pull_request.title, '[skip ci]') && !contains(github.event.pull_request.title, '[ci skip]')\" \n      strategy : \n        fail-fast :   false \n        matrix : \n          mfe : \n            -  ui/widgets/conference/detailsWidget\n            -  ui/widgets/conference/formWidget\n            -  ui/widgets/conference/tableWidget\n      steps : \n        -   uses :  actions/checkout@v2\n        -   uses :  actions/setup - node@v2.1.4\n          with : \n            node-version :   '14.15.0' \n        -   name :  Run tests\n          run :   | \n           cd ${{ matrix.mfe }}\n           npm install\n           npm run test \n \n \n Now check the GitHub  Repository → Actions  tab to see the status of the jobs. You should see that the tests were run for all configured MFEs with a summary message like this:  3 jobs completed . \n \n"},{title:"Build and Publish a Simple Bundle",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/create/pb/publish-simple-bundle.html",relativePath:"next/tutorials/create/pb/publish-simple-bundle.md",key:"v-4dafff61",path:"/next/tutorials/create/pb/publish-simple-bundle.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Create the Project Structure",slug:"create-the-project-structure"},{level:2,title:"Add a Simple Widget",slug:"add-a-simple-widget"},{level:2,title:"Create the Bundle Descriptor",slug:"create-the-bundle-descriptor"},{level:2,title:"Publish the Bundle",slug:"publish-the-bundle"},{level:3,title:"CLI Steps",slug:"cli-steps"},{level:3,title:"Manual Steps",slug:"manual-steps"},{level:2,title:"Install the Bundle into an Application",slug:"install-the-bundle-into-an-application"}],lastUpdated:"4/19/2022, 3:11:34 PM",lastUpdatedTimestamp:1650395494e3,content:' Build and Publish a Simple Bundle \n Overview \n In this tutorial, you will learn how to create a simple Entando Bundle and deploy it into the  Entando Component Repository  (ECR). This involves manually defining a bundle with a single widget, checking the bundle artifacts into Git, applying the Entando Bundle custom resource to Kubernetes, and then installing the bundle into an application. \n Prerequisites \n \n Use the  Entando CLI  to verify all dependencies are installed (e.g. Java, npm, Git). \n \n ent check-env develop\n \n \n Authenticated Git credentials, an empty Git repository and an available Entando instance are required for the commands below to execute without errors. \n \n Publishing a bundle can be simplified by using the  ent prj  command and its publication system (pbs) convenience methods. Both the CLI and manual commands are provided. \n Create the Project Structure \n First, create a parent project directory (e.g.  example-bundle ) along with a child bundle directory. In a project generated by the  Entando Component Generator , the microservice and micro frontend source files live under the parent directory. \n mkdir  -p example-bundle/bundle ;   cd  example-bundle/bundle\n Add a Simple Widget \n Create a widget directory \n mkdir  widgets\n \n Create a widget descriptor file within that directory \n touch  widgets/example-widget.yaml\n \n Populate the widget descriptor file  example-widget.yaml  with a simple definition. Make sure to retain the correct YAML indentation of 2 or 4 spaces. \n code :  example - widget\n titles : \n    en :  Example Widget\n    it :  Widget d\'esempio\n group :  free\n customUi :  <h2 > Hi from Example Widget</h2 > \n Create the Bundle Descriptor \n The main file processed by the Entando Component Repository is  descriptor.yaml , which describes all of the components within the bundle. The name of the bundle descriptor file must be  descriptor.yaml  and it must be stored in the child bundle directory (e.g.  example-bundle/bundle ). \n touch  descriptor.yaml\n \n Populate the bundle descriptor file with the following YAML definition \n code :  example - bundle\n description :  This is an example of an Entando bundle\n components : \n   widgets : \n     -  widgets/example - widget.yaml\n \n Component descriptor file names and locations (e.g.  widgets/example-widget.yaml ) are arbitrary since the bundle descriptor explicitly points to those files. Convention is to group components by type with all widgets in one directory, all page templates in another, etc. \n Publish the Bundle \n The bundle can be published using the CLI or the steps can be performed manually. \n CLI Steps \n \n Change to the project directory if needed \n \n cd  example-bundle\n \n \n Initialize the Entando project and accept the defaults \n \n ent prj init\n \n \n Initialize the publication system. This step requires the empty Git repository URL (ending in .git) and your Git credentials. \n \n ent prj pbs-init\n \n \n Publish the bundle to Git. By convention, the first version is assigned the tag  v0.0.1 , but the prefix "v" is optional. \n \n ent prj pbs-publish\n \n Running just the command  ent prj pbs-publish  will quickly push subsequent iterations of the bundle to Git. You will be asked to input the bundle version each time. You must be consistent with versioning format and alphanumeric precedence to ensure that iterations are listed in the correct order. \n \n The bundle can now be deployed into the Entando Component Repository with one command \n \n ent prj deploy\n \n The  prj deploy  command uses the Git repository URL and project name (e.g.  example-bundle ) to create the custom resource. \n Jump to  Install the Bundle into an Application  to finish installing your bundle. \n Manual Steps \n \n Change to the bundle directory if needed \n \n cd  example-bundle/bundle\n \n \n Run the following commands to initialize Git and commit the files \n \n git  init\n git   add   . \n git  commit -m  "Init Git repository" \n \n \n Add your remote repository as origin and push the bundle \n \n git  remote  add  origin https://your/remote/repository.git\n git  push -u origin master\n \n \n Publish a Git tag \n \n git  tag -a  "v0.0.1"  -m  "My first tag" \n git  push --tags\n \n \n Now that you\'ve published your bundle to Git, you can create the Kubernetes custom resource for it. \n \n Run the  ent bundler from-git  command, providing your remote Git repository URL via the  --repository  option and the correct namespace via  --namespace . You can also include a thumbnail for your bundle with  --thumbnail-file  or  --thumbnail-url . \n ent bundler from-git --name = example-bundle --namespace = entando --repository = https://your/remote/repository.git --dry-run  >  example-bundle.yaml\n \n \n Apply this definition to Kubernetes. You may need to first transfer the file to your VM, e.g with  multipass transfer . \n \n kubectl -n entando apply -f example-bundle.yaml\n \n \n Confirm the presence of your custom resource with the command  kubectl get EntandoDeBundle -n entando . \n Install the Bundle into an Application \n Your bundle should appear in  App Builder  →  Component Repository  in your Entando instance. Clicking  Install  should allow version selection if your bundle has multiple iterations. \n The Entando Platform will then download and install the components contained in the bundle. Once complete, you should see the  Install  button change to give you the option to  Uninstall  that specific version. If you navigate to  Components  →  Micro Frontends & Widgets , you should find your custom widget within the  User  section. \n'},{title:"Build and Publish a Project Bundle",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/create/pb/publish-project-bundle.html",relativePath:"next/tutorials/create/pb/publish-project-bundle.md",key:"v-85e64d9a",path:"/next/tutorials/create/pb/publish-project-bundle.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"CLI Steps",slug:"cli-steps"},{level:2,title:"Manual Steps",slug:"manual-steps"},{level:3,title:"Build a Docker Image for Microservices",slug:"build-a-docker-image-for-microservices"},{level:3,title:"Build Your Bundle and Publish to Git",slug:"build-your-bundle-and-publish-to-git"},{level:2,title:"Install the Bundle into an Application",slug:"install-the-bundle-into-an-application"},{level:2,title:"Use the Entando CLI",slug:"use-the-entando-cli"},{level:2,title:"Use the App Builder",slug:"use-the-app-builder"}],lastUpdated:"4/19/2022, 3:11:34 PM",lastUpdatedTimestamp:1650395494e3,content:' Build and Publish a Project Bundle \n Overview \n This tutorial demonstrates how to deploy an existing Entando project directory into the  Entando Component Repository  (ECR). This involves building a Docker image from your microservice, creating an Entando Bundle, checking your Bundle artifacts into Git, and deploying the Bundle into Kubernetes. \n The Entando CLI (ent) automates many of the tasks involved in deploying an Entando Bundle, but you can also choose to perform these tasks manually. \n Prerequisites \n \n Use the  Entando CLI  to verify you have the prerequisites in place (e.g. Java, npm, git) \n \n ent check-env develop\n \n \n Your Git credentials \n A Git repository \n An Entando instance \n An Entando project directory, either  developed by hand  or  generated by the Entando Component Generator \n CLI Steps \n The following steps make use of the Entando  ent prj  command and its publication system (pbs) convenience methods. See the  Manual Steps  section below for a more detailed description of the underlying tasks. \n \n Build the project using the  ent prj  command. This saves you from having to build each part of the project individually. If you are using a project directory with just a bundle child directory (e.g. a bundle with hand-built components or exported from another environment), then there is nothing to build and you should skip this step. \n \n ent prj build\n \n TIP \n The first run can take longer due to node downloads for any MFE widgets. You can use  ent prj fe-build  or  ent prj be-build  for subsequent runs to independently build just the frontend or backend components. \n \n \n Initialize the bundle directory \n \n ent prj pbs-init\n \n \n Publish the build artifacts to GitHub and Docker Hub \n \n ent prj pbs-publish\n \n \n Deploy the bundle into the ECR \n \n ent prj deploy\n \n Jump to  Install the Bundle into an Application  below to finish installing your bundle. \n Manual Steps \n Build a Docker Image for Microservices \n \n Build the project from the project directory \n \n ./mvnw -Pprod clean package jib:dockerBuild\n \n \n Note \n By default, the organization used to generate the Docker image is  entando . You can customize this value during project initialization by either changing the  pom.xml  file or providing the  -Djib.to.image=<org>/<name>:<version>  to the  jib:dockerBuild  command. \n \n \n Note \n The output image name is generated using the organization value defined during project initialization. You can override the provided values by altering the  pom.xml  file or by customizing the  -Djib.to.image  parameter used by the  ./mvnw  command. \n \n \n Warning \n If you manually override the target image of the Docker build, remember to update the plugin metadata accordingly. \n \n \n View your image and tag \n \n docker  images\n \n Output: \n REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE\nmyusername/example-app   0.0.1-SNAPSHOT      4ec7f05b2b27        33 seconds ago      213MB\n \n \n Publish the Docker image to Docker repository (Docker Hub or equivalent). You may need to first login via  docker login . \n \n docker  push  < name-of-the-image:tag > \n \n For example:  docker push myusername/example-app:0.0.1-SNAPSHOT \n \n Note \n All of the layers are pushed the first time you run this command, which takes time. Subsequent runs are much faster. \n \n Output: \n docker push myusername/example-app:0.0.1-SNAPSHOT\nThe push refers to repository [docker.io/myusername/example-app]\n545361404af4: Pushed\n...\nf1b5933fe4b5: Pushed\n0.0.1-SNAPSHOT: digest: sha256:804b3b91b83094c45020b4748b344f7199e3a0b027f4f6f54109cbb3b8a1f867 size: 2626\n Build Your Bundle and Publish to Git \n \n Populate the bundle with the generated micro frontends using  ./buildBundle.sh  or  npm run populate-bundle \n \n ./buildBundle.sh\n \n \n Important \nIt takes time to populate the bundle with micro frontends. You can watch the progress of this process on the console. \n \n \n \n The output of your bundle is in the top-level  bundle  directory of your microservice \n \n \n Commit your bundle files to Git, separate from the top-level project files \n \n \n echo  bundle  >>  .gitignore\n cd  bundle/\n git  init\n git   add   . \n git  commit -m  "Init Git repository" \n \n \n \n Create a new Git repository, e.g.  my-bundle \n \n \n Add your remote repository as origin and push the bundle \n \n \n git  remote  add  origin https://your/remote/repository.git\n git  push -u origin master\n \n \n Publish a Git tag \n \n git tag -a "v0.0.1" -m "My first tag"\ngit push --tags\n \n \n Generate a custom resource for your bundle. Update the following command with your bundle name, namespace and repository URL. \n \n ent bundler from-git --name = < bundle-name >  --namespace = entando --repository = < your-repository-url >  --dry-run  >  example-bundle.yaml\n \n \n Make your bundle available in Kubernetes \n \n kubectl apply -f example-bundle.yaml -n entando\n Install the Bundle into an Application \n You can either install the bundle through the ent CLI or the  App Builder . \n Use the Entando CLI \n \n In your project folder, run the following command \n \n ent prj  install \n \n \n If you have already installed the bundle, you can use  --conflict-strategy  to adopt a strategy for existing components (CREATE, SKIP, OVERRIDE) \n \n ent prj  install  --conflict-strategy = OVERRIDE\n \n \n Note \n In the event of a timeout or pod failure, refer to the errors captured by the quickstart-cm-deployment and plugin deployer logs. \n Use the App Builder \n \n \n Log into your App Builder and select  Repository  in the lower left \n \n \n Find your bundle and select  Install \n \n \n The Entando Platform downloads and installs the Docker image for your microservice and installs your micro frontends into the Entando Application. You can add these micro frontend widgets to the page(s) of your choice. You can either leverage a page provided by Entando or follow our  Page Management tutorial  to create your own page or page template. Note that your page template must include the UX fragment  keycloak_auth  because an application based on the Entando Blueprint expects a user to be authenticated. \n'},{title:"Install Bundles from a Private Git Repository",frontmatter:{},regularPath:"/next/tutorials/curate/ecr-private-git-repo.html",relativePath:"next/tutorials/curate/ecr-private-git-repo.md",key:"v-e4593a78",path:"/next/tutorials/curate/ecr-private-git-repo.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Using SSH keys with Git",slug:"using-ssh-keys-with-git"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"2/9/2022, 9:50:35 AM",lastUpdatedTimestamp:1644418235e3,content:' Install Bundles from a Private Git Repository \n Overview \n The standard deployment of the Entando Component Repository (ECR) assumes that bundles are checked out from public Git repositories. Public repositories do not require user authentication, but if a customer chooses to limit repository access to specific Git accounts, a private key is required. This document details how to allow the ECR to access a private Git repository. \n For more background information please consult \n \n Entando custom resource reference \n Entando Component Repository overview \n Using SSH keys with Git \n Entando supports connecting to Git repositories with SSH keys. While SSH Git URLs are accepted, HTTPS git URLs are not. For the private key to work correctly, the SSH syntax of  git@github.com:THE-REPO-OWNER-NAME/THE-REPO-NAME.git  must be used (the HTTPS syntax of  https://github.com/THE-REPO-OWNER-NAME/THE-REPO-NAME.git  is not permitted). \n Using the SSH method a developer can generate a public/private keypair, then register the public key with the Git server while securely storing the private key locally. An operation requiring authentication will trigger the Git command line utility to perform a search and compare between the local private key and the public key provided by the server. If the two keys are identical, the operation is allowed to complete. \n Entando allows a Kubernetes Secret containing a Git SSH private key to be mounted in the container hosting the Entando Component Manager service. This container is deployed with the EntandoApp and can be configured from the EntandoApp Custom Resource. To prepare a Secret, first generate the keypair locally using a Docker image, then create the Secret from the directory where the keypair was generated. \n Tutorial \n Below is the recommended flow on Linux. \n \n \n Navigate to a local folder where you intend to create the Secret \n \n \n Generate the SSH keypair from the known SSH client Docker image \n \n \n Run the Docker container in interactive mode and mount the default user SSH directory to a local directory \n docker run -it -v $PWD/entando_ssh:/root/.ssh kroniak/ssh-client /bin/bash \n \n \n \n Generate the keypair from the shell of the resulting container \n ssh-keygen\n \n Select all of the default options, e.g. no passphrase, etc. \n \n \n Attempt to add the fingerprint to the known_hosts file by connecting to your Git server and responding "yes" to the prompt \n ssh git@github.com\n \n This command is expected to fail. \n \n \n Run  exit \n \n \n \n \n Create the Secret. \n \n \n You are now back in the local operating system\'s shell and can navigate to the directory that was mounted using Docker. \n To give yourself access to this folder and create a Secret with the content\n\n1. Change the folder permissions\n\n    ```\n    sudo chmod ag+r entando_ssh -R\n    ```\n    \n2. Create a Secret from the directory\n\n    ```\n    kubectl create secret generic my-git-secret --from-file=entando_ssh -n <<your-namespace>>\n    ```\n    \n3. Confirm that the Secret exists and has at least two keys: known_hosts, and id_rsa. Without these two keys Entando cannot log into Git.\n    \n    ```\n    kubectl get secret my-git-secret -n <<your-namespace>> -o yaml\n    ```\n \n \n \n Link the resulting private key to the account of a user who has access to the applicable Git repositories. Ideally\nthis should be a dedicated service account user with restricted read only access. For GitHub\naccounts, you can follow the  official GitHub instructions. \nWhen prompted, provide the public key that was generated in the entando_ssh directory\n entando_ssh/id_rsa.pub \n \n \n Modify the EntandoApp resource you are deploying to mount the Secret in the  spec.ecrGitSshSecretName  property. Note: In Entando 7 the EntandoApp resource must be configured prior to installation. \n \n \n       kind: "EntandoApp"\n      metadata:\n        annotations: {}\n        labels: {}\n        name: "quickstart"\n      spec:\n        dbms: none\n        replicas: 1\n        ecrGitSshSecretName: my-git-secret\n        standardServerImage: wildfly\n        ingressPath: /entando-de-app\n        ingressHostName: ampie.apps.serv.run\n        environmentVariables:\n          - name: SPRING_PROFILES_ACTIVE\n            value: "default,swagger"\n \n '},{title:"Install Bundle Plugins from a Private Image Repository",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/curate/ecr-private-images.html",relativePath:"next/tutorials/curate/ecr-private-images.md",key:"v-6cf1a96e",path:"/next/tutorials/curate/ecr-private-images.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Tutorial",slug:"tutorial"},{level:2,title:"Troubleshooting",slug:"troubleshooting"}],lastUpdated:"4/18/2022, 11:02:29 AM",lastUpdatedTimestamp:1650294149e3,content:" Install Bundle Plugins from a Private Image Repository \n Overview \n The standard deployment of the Entando Component Repository assumes that plugin images are pulled from public repositories. Public repositores do not require user authentication in order to pull an image. The following tutorial will show you how to add secrets to your Kubernetes environment so you can successfully pull images from private repositories. \n Prerequisites \n \n A running Entando application \n A bundle containing a microservice plugin based on an image from a private repository. You can set this up by  creating a microservice bundle  and making the corresponding Docker Hub repository private. \n Tutorial \n The first step demonstrates how to create a Secret for Docker Hub but please see the  corresponding Kubernetes documentation  for other options. \n 1. Create the secret \nSupply the following parameters: \n \n the name of the new Secret, e.g.  my-docker-secret . \n the URL to your registry server. For Docker Hub this is currently  https://index.docker.io/v1/ \n your Docker Hub username, password, and email. \n the Entando namespace, e.g.  entando  for a quickstart environment. \n \n kubectl create secret docker-registry YOUR-SECRET-NAME --docker-server = YOUR-REGISTRY-SERVER --docker-username = YOUR-USERNAME --docker-password = YOUR-PASSWORD --docker-email = YOUR-EMAIL -n entando\n \n 2b. Deploy a new Entando Application \n If you're setting up a new Entando Application, you can  add the secret to the Entando Operator ConfigMap  under the property  entando.k8s.operator.image.pull.secrets . This is just a list containing the names of Docker Secrets in the operator's namespace. \n data :  \n   entando.k8s.operator.image.pull.secrets :   [ YOUR - SECRET - NAME ] \n \n 2b. Update an existing Entando Application \n If you're updating an existing Entando Application, you can add the new Secret to the  entando-plugin  serviceaccount. \n kubectl edit serviceaccount entando-plugin -n entando\n \n Add the secret to the serviceaccount. You can either add a new section if it's the first Secret or add another Secret to the list. \n apiVersion :  v1\n imagePullSecrets : \n   -   name :  YOUR - SECRET - NAME\n kind :  ServiceAccount\n metadata : \n   name :  entando - plugin\n \n If you describe the serviceaccount, it should list the Secret. \n kubectl describe serviceaccount entando-plugin -n entando\n \n Output: \n Name :                 entando - plugin\n Namespace :            entando\n Image pull secrets :   YOUR - SECRET - NAME\n \n If  (not found)  is listed next to the Secret name, then you may have added the Secret to the wrong namespace. \n 3. Install the Entando Bundle \n You can now install Entando Bundles from the  Entando App Builder  →  Entando Component Repository . The microservice plugin should now be able to successfully pull the image. \n Troubleshooting \n You may see an  ErrImagePull  status in  kubectl get pods  if a plugin is based on an image from a private repository and if there are any issues with the image URL or credentials, including a missing or incorrect Secret. \n"},{title:"Backing Up and Restoring Keycloak",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/devops/backing-restoring-keycloak.html",relativePath:"next/tutorials/devops/backing-restoring-keycloak.md",key:"v-d5729320",path:"/next/tutorials/devops/backing-restoring-keycloak.html",headers:[{level:2,title:"Prerequisites:",slug:"prerequisites"},{level:2,title:"Create a Backup of Keycloak Realm",slug:"create-a-backup-of-keycloak-realm"},{level:2,title:"Import the Keycloak Realm",slug:"import-the-keycloak-realm"}],lastUpdated:"4/14/2022, 1:19:13 PM",lastUpdatedTimestamp:1649956753e3,content:" Backing Up and Restoring Keycloak \n This tutorial describes how to backup an active Entando Identity Management Keycloak instance and restore it in another environment. \n Prerequisites: \n A Keycloak instance running on Entando with a database management system (DBMS) in the backend. This procedure will not work with an embedded database. \n Create a Backup of Keycloak Realm \n \n \n From the command line, get the pod name of the Keycloak server you wish to back up. In a quickstart environment, the pod name will begin with  default-sso-in-namespace-deployment . \n \n \n Use kubectl to start a bash shell in the pod: \n \n \n  kubectl exec -it YOUR-KEYCLOAK-POD-NAME -- /bin/bash\n \n \n Create a new directory in /tmp with: \n \n mkdir -p /tmp/export \n \n \n Run the following script to retrieve the data for the Entando realm and save it to a JSON file in the  export  directory. A new Keycloak server will run on a different port (offset=200) to avoid conflicts with the original Entando Keycloak instance. \n \n /opt/jboss/keycloak/bin/standalone.sh\n-Djboss.socket.binding.port-offset=200\n-Dkeycloak.migration.action=export \n-Dkeycloak.migration.provider=singleFile \n-Dkeycloak.migration.realmName=entando\n-Dkeycloak.migration.usersExportStrategy=DIFFERENT_FILES \n-Dkeycloak.migration.file=/tmp/export/entando-prod-realm.json\n \n \n If there are no errors, press Ctrl+C to stop the process. \n Type  exit  to close the bash shell in the pod. \n Execute this command to copy the realm data file to the proper location: \n \n kubectl cp YOUR-KEYCLOAK-POD-NAME:/tmp/export/ keycloak-backup\n Import the Keycloak Realm \n \n \n Login to the new Entando Keycloak server where the realm is to be restored. \n \n \n From the left sidebar, go to  Import . \n \n \n Click  Select file  button and  upload  the JSON file from the  keycloak-backup  directory. You will see the following page: \n \n \n \n \n You have now successfully imported the Keycloak realm to a new environment. \n \n Note \n If you are using a different environment, with a different hostname, you should import only users or set the flag for  If a resource exists  to  Skip . \n \n"},{title:"Backing Up and Restoring an Entando Application",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/devops/backing-up-and-restoring-your-environment.html",relativePath:"next/tutorials/devops/backing-up-and-restoring-your-environment.md",key:"v-424dcb66",path:"/next/tutorials/devops/backing-up-and-restoring-your-environment.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Create a Backup",slug:"create-a-backup"},{level:2,title:"Restore a Backup",slug:"restore-a-backup"},{level:3,title:"Build the Custom Image",slug:"build-the-custom-image"},{level:3,title:"Install the Application",slug:"install-the-application"}],lastUpdated:"4/19/2022, 11:37:04 AM",lastUpdatedTimestamp:1650382624e3,content:' Backing Up and Restoring an Entando Application \n Overview \n This tutorial demonstrates how to use an existing Entando Application as a launching point for creating new applications. An alternative is to  use the Entando Bundler  to extract specific content and functionality from an existing application. Entando Bundles are recommended as a more flexible option when a full copy of an application is not required. \n Prerequisites \n \n Java 11 \n Docker \n Maven \n Access to a Docker repository (docker.io or other) \n Create a Backup \n This step requires using a running Entando environment to take an application backup.\nThe output of this step is a local directory with the files (database and static assets) needed to restore the application later. \n \n \n Log into the App Builder \n \n \n Go to  Administration → Database \n \n \n Click on  Create A Backup  and wait for the process to complete. The static assets and database backup will be saved to a persistent volume on the server pod under  /entando-data . \n \n \n Transfer the files from the  server-deployment . The exact command will depend on your Kubernetes environment. \n \n \n \n \n \n kubectl \n OpenShift \n \n \n \n \n kubectl cp <pod>:<path> <local-path> \n oc rsync <pod>:<path> <localPath> \n \n \n e.g.  kubectl cp quickstart-deployment-7b8c699599-f84zq:/entando-data backup \n e.g. oc rsync app-entando-deployment-67fd5b9954-s72mb:/entando-data \n \n \n \n \n You should see 3 directories -  databases ,  protected , and  resources .\nThe  protected  directory contains the timestamped backup you triggered from the App Builder. The  resources  directory contains the static assets. \n Restore a Backup \n Restoring a backup requires creating and then deploying a custom image of an Entando Application with the\nbackup files included. \n Build the Custom Image \n \n Clone the Entando Application repository \n \n git  clone https://github.com/entando/entando-de-app\n \n \n Change into the  entando-de-app  directory: \n \n cd  entando-de-app\n \n \n (Optional) Checkout a branch for your desired Entando version. You can review  https://github.com/entando/entando-de-app/releases  to determine the correct tag to use. \n \n git  checkout -b my-test v7.0.0\n \n WARNING \n If you don\'t perform this step, you\'ll be creating an Entando Application based on the latest  entando-de-app  code, which may not yet be released. \n \n \n \n Move the  resources  and  protected  directory from your Entando backup into  src/main/webapp . You should override any existing content. \n \n \n Build the application \n \n \n mvn clean package\n \n \n \n Create a repository named  entando-de-app-wildfly  in Docker for the new application. The Entando Operator will expect this name when performing the initial install. \n \n \n Create a Docker image for the application. You\'ll need to provide your user name and version. \n \n \n docker  build  .  -f Dockerfile.wildfly -t YOUR- USER /entando-de-app-wildfly:YOUR-VERSION\n \n \n Push the image to Docker \n \n docker  push YOUR- USER /entando-de-app-wildfly:YOUR-VERSION\n Install the Application \n You can use your typical install steps (or the standard  Manual Install steps ) with one adjustment. When you get to the  Install namespace scoped resources  step, you\'ll need to configure the  namespace-resources.yaml  to use your image. \n \n Retrieve a copy of the  namespace-resources.yaml  for your Entando version \n \n   curl  -sfL https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/namespace-scoped-deployment/namespace-resources.yaml  >  namespace-resources.yaml\n \n \n Edit  namespace-resources.yaml  and update the  entando-de-app-wildfly  configuration with your user name and version \n \n entando-de-app-wildfly :   > - \n     { "version" : "YOUR-VERSION" , "executable - type" : "jvm" , "registry" : "docker.io" , "organization" : "YOUR-USER" } \n \n \n Now apply the namespace resources to K8s \n \n sudo  kubectl apply -n entando -f namespace-resources.yaml\n \n \n \n You can now continue with the rest of the install instructions \n \n \n Once deployed, review the App Builder or running application to confirm the backup was restored correctly. You can check the deployment logs for possible errors. \n \n \n'},{title:"Adding a new API to the core app",frontmatter:{},regularPath:"/next/tutorials/devops/add-rest-api.html",relativePath:"next/tutorials/devops/add-rest-api.md",key:"v-7d14b320",path:"/next/tutorials/devops/add-rest-api.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"1/26/2022, 3:04:16 PM",lastUpdatedTimestamp:1643227456e3,content:" Adding a new API to the core app \n Prerequisites \n \n \n Java 11 \n \n \n maven \n Overview \n This guide will take you through adding a new REST API to the Entando\ncore app. In some cases it is better to add new APIs to the core rather\nthan creating a new microservice. Some example cases where adding new\nAPIs to the core is recommended are: \n \n \n When extending or adding functionality to the WCMS \n \n \n When you have a simple use case requiring persistence that is\nspecific to only the application you’re working within \n \n \n When exposing configurations that are needed by the portal-ui during\npage rendering \n \n \n For small changes that don’t warrant a full stand-alone microservice \n \n \n You can build widgets and micro frontends that take advantage of these\nAPIs in the same way that your micro-frontends can invoke APIs exposed\nby other services. \n Tutorial \n Creating a controller and services \n \n \n Create a new java package in the project using your favorite IDE at\nthe path  org.entando.training . \n \n \n Under that package add packages for  controllers  and  services . \n \n \n Create a class called  DemoController.java  from the\ntraining package into the controllers package. \n \n This is a normal Spring rest controller and it will be\ndiscovered by annotations. \n \n \n \n Copy  DemoService.java  from the\ntraining package into the services package. \n \n This is a normal Spring service that will be autowired into the\ncontroller. The data in this service is hardcoded but this is\nwhere you can wire in external services or other parts of the\nEntando architecture to fetch the data. \n \n \n \n Copy  commonConfig.xml  to\n src/main/resources/spring/aps/managers . \n \n \n The goal is to enable package scanning for annotation driven\nspring services. This includes the package scan for your package\ndefined above. If you want to scan another package, then you\nneed to add another path to this file. This is the only spring\nXML you will need to change if you want to build annotation\ndriven beans in Entando. \n \n \n See also web.xml for deeper details. \n \n \n \n \n Review the code and annotations in the controller to understand how\nthe APIs are protected and integrated. \n \n \n @RestAccessControl  is a custom Entando annotation that can be used\nto restrict APIs by role. \n \n The rest of the annotations are normal Spring annotations. \n \n \n \n Restart your app using jetty. \n \n \n if you get an error add the entries below to\n src/main/conf/systemParams.properties  This is temporary \nParameters for Argon2 algorithm encryption\nalgo.argon2.type=ARGON2i\nalgo.argon2.hash.length=32\nalgo.argon2.salt.length=16\nalgo.argon2.iterations=4\nalgo.argon2.memory=65536\nalgo.argon2.parallelism=4\nalgo.default.key=changeit\n \n \n \n \n \n Go to Swagger \n \n \n Find the demo-controller and try your new endpoints out using\nswagger \n \n \n"},{title:"Building a Docker Image for the Entando Core",frontmatter:{},regularPath:"/next/tutorials/devops/build-core-image.html",relativePath:"next/tutorials/devops/build-core-image.md",key:"v-5ff106e2",path:"/next/tutorials/devops/build-core-image.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Introduction",slug:"introduction"},{level:2,title:"Setup",slug:"setup"}],lastUpdated:"2/9/2022, 9:50:35 AM",lastUpdatedTimestamp:1644418235e3,content:" Building a Docker Image for the Entando Core \n Prerequisites \n \n \n Java 11 \n \n \n Docker installed locally\n( https://docs.docker.com/docker-for-windows/install/ ) \n \n \n maven \n \n \n Access to a docker repository (docker.io or other) \n Introduction \n This tutorial will take you through the basic steps to create a docker\nimage from an Entando core application. A more detailed guide with\nadditional commands and configuration can be found here: \n https://github.com/entando/entando-de-app \n Setup \n \n \n Clone the application at:\n https://github.com/entando/entando-de-app  using \n git clone https://github.com/entando/entando-de-app\n \n \n \n On a command line, cd into the entando-de-app you just cloned: \n cd entando-de-app\n \n \n \n Build a docker image from the core app replacing the value of the tag in the  -t   with the tag you want to use for your image. \n mvn clean package\ndocker build . -f Dockerfile.wildfly -t <YOUR-USER>/<YOUR-REPO-NAME>:<YOUR-VERSION>\n \n \n \n Create a repository on your docker repository to house your new\napplication \n \n \n Push the Image to your Repository \n docker push <YOUR-USER>/<YOUR-REPO-NAME>:<YOUR-VERSION>\n \n \n \n"},{title:"Configure the Entando Operator",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/devops/entando-operator.html",relativePath:"next/tutorials/devops/entando-operator.md",key:"v-222d4c1e",path:"/next/tutorials/devops/entando-operator.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Add a new ConfigMap",slug:"add-a-new-configmap"},{level:2,title:"Update an existing ConfigMap",slug:"update-an-existing-configmap"}],lastUpdated:"4/13/2022, 11:21:22 AM",lastUpdatedTimestamp:1649863282e3,content:' Configure the Entando Operator \n This tutorial demonstrates how to provide the Entando Operator with a ConfigMap to customize its behavior. See the template file below for possible settings related to image timeouts, TLS/SSL configuration, and the default image repository. Some specific tutorials (e.g.  Plugin Configuration Profiles ) also require updates to the Entando Operator configuration. \n Prerequisites \n The Entando Operator makes use of an optional ConfigMap named  entando-operator-config . The ConfigMap must be present in the same namespace as the operator. In a quickstart environment, you can check for its presence with this command: \n kubectl get configmap -n entando\n Add a new ConfigMap \n If the ConfigMap doesn\'t already exist, you can use a template as a starting point. \n curl  -sfL  "https://raw.githubusercontent.com/entando/entando-releases/v7.0.0/dist/ge-1-1-6/samples/entando-operator-config.yaml" \n \n Edit  entando-operator-config.yaml  to adjust existing settings or add new ones. You can then apply it to Kubernetes. \n kubectl apply -f entando-operator-config.yaml -n entando\n \n The Entando Operator automatically reloads settings from the ConfigMap when the ConfigMap is created. You can verify the reload by checking the logs in the operator pod. \n Update an existing ConfigMap \n You can edit an existing ConfigMap to add or update settings. \n kubectl edit configmap/entando-operator-config -n entando\n \n The Entando Operator automatically reloads settings from the ConfigMap whenever it is modified. You can verify the reload by checking the logs in the operator pod. Some settings may only take effect when a deployment is first created, e.g. timeout settings or CPU limits. \n'},{title:"Change Default Datasources and Connections",frontmatter:{},regularPath:"/next/tutorials/devops/change-default-datasource.html",relativePath:"next/tutorials/devops/change-default-datasource.md",key:"v-e569c6f4",path:"/next/tutorials/devops/change-default-datasource.html",headers:[{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Create a Docker project for your own base image to Entando's standard base image(s)",slug:"_1-create-a-docker-project-for-your-own-base-image-to-entando-s-standard-base-image-s"},{level:3,title:"2. Customize the standalone.xml/standalone-openshift.xml file using environment variables.",slug:"_2-customize-the-standalone-xml-standalone-openshift-xml-file-using-environment-variables"},{level:3,title:"3. Build your own Docker base image",slug:"_3-build-your-own-docker-base-image"},{level:3,title:"4. Modify your Entando App project to use the new Docker base image",slug:"_4-modify-your-entando-app-project-to-use-the-new-docker-base-image"},{level:3,title:"5. Build and push your custom Docker image",slug:"_5-build-and-push-your-custom-docker-image"},{level:3,title:"6. Deploy your EntandoApp with the correct environment variables",slug:"_6-deploy-your-entandoapp-with-the-correct-environment-variables"}],lastUpdated:"2/15/2022, 1:12:18 PM",lastUpdatedTimestamp:1644948738e3,content:' Change Default Datasources and Connections \n Purpose \n This tutorial explains how to customize our EAP and Wildfly base Docker images, and then configure the EntandoApp custom resource to use these customizations. \n Requirements \n \n \n The Entando Operator is running in the target names \n \n \n Keycloak and the Entando Cluster Infrastructure have been deployed \n \n \n The required external databases and other services are up and running. \n \n \n Your own custom project as described in  the tutorial \n Steps \n 1. Create a Docker project for your own base image to Entando\'s standard base image(s) \n Create a project, ideally in Git repository, and put the following files in the folder \n 1.1. The standalone.xml/standalone-openshift.xml file of choice \n It is essential for your custom Docker image to use a file from one of the official Entando Docker base images. \n If you intend to use provide your own EAP based image, please use this\n standalone-openshift.xml \nfile. \n If you intend to use provide your own Wildfly based image, please use this\n standalone.xml \nfile. \n Please note that if you create your own base image with a different version of EAP or Wildfly, using these files\nmay have unintended consequences. \n 1.2. Any modules that may be required for your datasource or other connection resource \n If the resource you need to connect to requires some custom classes, such as JDBC drivers, please add these as \na module to Wildfly/EAP. \n 1.3 Dockerfile \n In your Dockerfile, please be sure to extend the correct base image, and add the correct configuration file to\nthe correct location in the target image. \n For EAP, a most basic Dockerfile would look like this: \n FROM entando/entando-eap71-clustered-base:6.1.2\nCOPY --chown=185:0 ./standalone-openshift.xml /opt/eap/standalone/configuration\n \n For Wildfly, a most basic Dockerfile would look like this: \n FROM entando/entando-eap71-clustered-base:6.1.2\nCOPY --chown=1001:0 ./standalone.xml /wildfly/standalone/configuration\n \n Please take note of the user ownership in these different Dockerfiles. This is quite important as Openshift will\nexpect the user/group ownership to be respected. \n 2. Customize the standalone.xml/standalone-openshift.xml file using environment variables. \n You can now modify your Wildfly/EAP configuration to meet your requirements. Where the configuration could differ\nfrom one environment to a next, we strongly advise using environment variable expressions ( ${env.VAR_NAME} ). The most likely change\nthat would be required in this file is the addition of a datasource. Here is an example of how to add a datasource\nto the datasources subsystem. All the environment variables starting with \'YOURDB\' can be specified from the Docker\ncontainer. \n    ...\n    <subsystem xmlns="urn:jboss:domain:datasources:5.0">\n      <datasources>\n        <datasource jndi-name="${env.YOURDB_JNDI}" enabled="true" use-java-context="true" pool-name="yourDbDataSource" use-ccm="true">\n          <connection-url>${env.YOURDB_URL}</connection-url>\n          <driver>${env.YOURDB_DRIVER}</driver>\n          <security>\n            <user-name>${env.YOURDB_USERNAME}</user-name>\n            <password>${env.YOURDB_PASSWORD}</password>\n          </security>\n        </datasource>\n \n Please take extra care not to remove any lines from these files. This is of particular importance in the case of the\nEAP image as, on startup, scripts in the official EAP look for certain placeholders in this file and populates them\nfrom other environment variables. \n 3. Build your own Docker base image \n You can now build your Docker base image. It is highly recommended that you consider using a dedicated CI/CD build\ntool such as Jenkins X to build the base image and maintain traceability between your source code and the resulting\nDocker image. One possible build command could look like this: \n docker build . -t your-docker-registry.com/your-org/your-base-image:1.0.0 \n 4. Modify your Entando App project to use the new Docker base image \n You can now modify your Entando App project that you have forked as described in the\n relevant tutorial . You would require two changes to the pom.xml file\nof the sample project. \n \n Firstly, you would need to change the variable  server.base.image  to reflect the fully\nqualified URI of your Docker image for EAP and/or Wildfly. For example, if you decided to extend the Wildfly image,\ngo to the Maven profile with the id  wildfly  and change the   server.base.image  to look like this: \n \n <server.base.image>your-docker-registry.com/your-org/your-base-image:1.0.0</server.base.image> \n \n Then you need to change the  <from>  element in the Fabric8 Maven Docker Plugin to reflect this variable.\nNavigate to the first  <image>  element in the pom.xml file. You have found the correct one\nif it contains the following xml: \n \n <from>entando/${server.base.image}:${entando.version}</from> \n Delete the  entando/  prefix and the  :${entando.version}  suffix: \n <from>${server.base.image}</from> \n Please note that, should you still require support for both Wildfly and EAP in your Maven pom, you may need to\nrepeat this exercise for both the  eap  and  wildfly  profiles. \n 5. Build and push your custom Docker image \n Before building your Docker image, it would be a good idea to change the name of the image you want to build. Navigate\nto the previously modified  <image>  element in the Fabric8 Maven Docker Plugin.You can change the  <name>  element\nto reflect your preferred name, e.g. \n <name>your-docker-registry.com/your-org/your-entando-app:1.0.0</name> \n Run: \n mvn clean package -Pwildfly -Pderby \n A new Docker image should now be available named  your-docker-registry.com/your-org/your-entando-app:1.0.0 \n Log into the Docker registry in question and then push the image: \n docker push your-docker-registry.com/your-org/your-entando-app:1.0.0 \n You are now ready to deploy this image. \n 6. Deploy your EntandoApp with the correct environment variables \n The final step is to configure your EntandoApp deployment with the correct environment variables. As is the case with\nall the Entando Custom Resources that result in actual deployments, the property  spec.environmentVariables  will be translated\ninto environment variables on each of the Containers in the Deployment\'s Pod. For an EntandoApp named \'my-app\',\nthe new state of the EntandoApp would could be placed in a file named  my-app.yaml  that would look something like this: \n       kind: "EntandoApp"\n      metadata:\n        name: "my-app"\n      spec:\n        dbms: postgresql\n        replicas: 1\n        customServerImage: your-docker-registry.com/your-org/your-entando-app:1.0.0\n        ingressPath: /your-entando-app\n        environmentVariables:\n          - name: YOURDB_JNDI\n            value: java/your-ds\n          - name: YOURDB_URL\n            value: "jdbc:postgresql://somehost.com:5432/mydb"\n          - name: YOURDB_DRIVER\n            value: postgresql\n          - name: YOURDB_USERNAME\n            value: my_user\n          - name: YOURDB_PASSWORD\n            value: mypassword\n      entandoStatus:\n        entandoDeploymentPhase: requested\n\n \n Notice how this Custom Resource specifies a  parameter  for each environment variable that was referenced from the\n standalone.xml  file referenced earlier. \n To apply the changes to your deployment, change the  entandoStatus.entandoDeploymentPhase  property to requested and\napply the file: \n kubectl apply -f my-app.yaml\n \n '},{title:"Caching and Clustering",frontmatter:{},regularPath:"/next/tutorials/devops/caching-and-clustering.html",relativePath:"next/tutorials/devops/caching-and-clustering.md",key:"v-5500b462",path:"/next/tutorials/devops/caching-and-clustering.html",headers:[{level:2,title:"Storage Requirements for Clustered Entando Apps",slug:"storage-requirements-for-clustered-entando-apps"},{level:2,title:"Clustering",slug:"clustering"},{level:3,title:"Prerequisites",slug:"prerequisites"},{level:3,title:"Creating a Clustered App Instance",slug:"creating-a-clustered-app-instance"},{level:3,title:"Validating Clustered Instances",slug:"validating-clustered-instances"},{level:3,title:"Caching Validation",slug:"caching-validation"},{level:2,title:"Configuring and Deploying with Redis",slug:"configuring-and-deploying-with-redis"},{level:3,title:"Deploy Redis to Kubernetes",slug:"deploy-redis-to-kubernetes"},{level:3,title:"Configure implementation",slug:"configure-implementation"}],lastUpdated:"4/19/2022, 3:16:00 PM",lastUpdatedTimestamp:165039576e4,content:" Caching and Clustering \n The tutorial below covers the basic steps to setup and validate a clustered instance of the Entando App Engine. \n NOTE \n When building your deployment architecture, it is important to review your goals, hardware, networking and application-specific setup. You must also optimize App Engine deployment for your environment. The configurations and tests below do not address every type of application or deployment, but they can be used as building blocks to create a deployment architecture that works for your application. \n Storage Requirements for Clustered Entando Apps \n In order to scale an Entando Application across multiple nodes, you must provide a storage class that supports\na  ReadWriteMany  access policy. There are many ways to accomplish this, including using dedicated storage providers like GlusterFS. Cloud Kubernetes providers also offer clustered storage options specific to their implementation, such as Google Cloud File in GKE or Azure Files in AKS. \n You can use two different storage classes for your clustered vs. non-clustered storage if your default class doesn't support  ReadWriteMany . Add the following properties to your ConfigMap for the operator: \n entando.k8s.operator.default.clustered.storage.class: [your clustered RWX storage class]\nentando.k8s.operator.default.non.clustered.storage.class: [your RWO storage class]\n \n Set both values to the appropriate storage class for your configuration. \n TIP \n A  ReadWriteOnce (RWO)  policy that ensures instances are all scheduled to the same node will scale an Entando Application without clustered storage and is accomplished via taints on other nodes. Be aware of the pros and cons of scheduling instances to the same node so you can maximize utilization of node resources and recover from an unreachable application instance. If the node terminates or is shutdown, your application will be down while Kubernetes reschedules the pods to a different node. \n Clustering \n This tutorial reviews setting up a clustered Entando App Engine in  entando-de-app . The goal is to deploy a clustered instance of the App Engine and verify the high availability and scalable deployment of the application. \n Prerequisites \n \n An existing deployment of an Entando App or the ability to create one.\n \n If you haven't created a deployment or don't have a YAML file for an Entando deployment, follow the  Quickstart instructions . \n \n \n The Entando deployment must use a Relational Database Management System (RDBMS) to organize data in a table structure. Clustered instances will not work correctly with in-memory databases. \n Sticky sessions are recommended when enabling a clustered Entando Application. For example, see  Manage NGINX  for related affinity settings. \n Creating a Clustered App Instance \n \n Create an Entando deployment via the operator config file or edit an existing deployment YAML file. \n Scale your Entando server application: \n \n kubectl scale deployment quickstart-deployment -n entando --replicas = 2 \n \n \n \n Run  kubectl get pods -n YOUR-NAMESPACE  to view the pods in your deployment. \n \n \n You should have two  quickstart-deployment  pods in your namespace. \n \n \n Look in the logs of the  quickstart-deployment  in either pod to see logging information related to different instances joining the cluster and balancing the data between the instances. See the screenshot for an example. Your actual logs will vary. \n Validating Clustered Instances \n This is an advanced exercise and not required or recommended for most deployment scenarios. The steps below validate that the clustered instances are working in your environment and that you have created a high availability deployment. \n \n Complete the  creating a clustered instance tutorial  above or have an existing clustered Entando App instance available for testing. \n Get the URL for your  entando-de-app  with  kubectl get ingress -n YOUR-NAMESPACE . \n Open the URL in the browser of your choice and ensure that the application is working. \n Open a new browser window in incognito or private browsing mode to ensure that no data is cached and you're receiving a copy of the running application.  Do not navigate to the app. \n Delete one of the server deployment pods in your clustered instance with  kubectl delete YOUR-POD-NAME -n YOUR-NAMESPACE .\n \n There are other ways to do this. You could also shell into the server-container and manually kill the running app process with  kill -9 357 . \n If you want to test at the hardware level, you could manually terminate a node in your cluster (ensuring that the pods are scheduled to different nodes). \n \n \n In your private/incognito browser window, open the URL to your  entando-de-app . \n Check that the application continues to render while the pod you deleted is no longer present. \n Wait for Kubernetes to restore your deleted pod. \n Check that the application continues to render after the pod is restored. \n Caching Validation \n Validating the shared cache can be done in a similar process to the clustered instance validation. The high level steps are: \n \n Deploy a clustered instance (see  creating a clustered instance tutorial ). \n Create data with the App Builder (pages, page templates, content etc.), using the external route for the application. \n Refer to the logs to note which instance processed the request. \n Terminate that instance. \n Fetch the recently created data and verify that the data are returned. \n Configuring and Deploying with Redis \n In this section, an Entando App Engine instance is deployed using Redis as a cache for data served by the App Engine. For more information on the cache configuration for the App Engine, see the  Caching and Clustering documentation . \n Deploy Redis to Kubernetes \n \n Create the Redis deployment and expose the endpoints: \n \n kubectl create deployment redis --image = redis:6\n \n \nkubectl expose deployment redis --port = 6379  --target-port = 6379  -n YOUR-NAMESPACE\n\n \n \n Install the Redis CLI for your environment per  https://redis.io/topics/rediscli . \n Get the IP for your Redis deployment: \n \n kubectl get  service  -n YOUR-NAMESPACE\n \n \n Validate your deployment: \n \n redis-cli -h  10.43 .99.198 -p  6379   ping \n \n \n Should respond PONG. \n \n redis-cli -h  10.43 .99.198 -p  6379  incr mycounter\n \n \n Should increment each time. \n Configure implementation \n \n Use git to clone the  entando-de-app  repository: \n \n git  clone https://github.com/entando/entando-de-app\n \n \n Fetch the tags, checkout the release tag and create a branch for your customization: \n \n git  fetch --tags\n \n git  checkout tags/v7.0.0 -b YOUR-7.0.0-redis\n \n \n \n Open the pom.xml file of the  entando-de-app . \n \n \n Add the Redis caching plugin to the pom.xml: \n \n \n <dependency>\n    <groupId>org.entando.entando.plugins</groupId>\n    <artifactId>entando-plugin-jpredis</artifactId>\n    <type>war</type>\n</dependency>\n \n \n Save the pom. \n Build and push a custom image for the  entando-de-app  with  Building a Docker Image Tutorial . \n Download the operator configuration deployment file: \n \n curl  -L -C - -O https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/namespace-scoped-deployment/orig/namespace-resources.yaml  >  namespace-resources.yaml\n \n \n \n Update the image for  entando-de-app-wildfly  in the  namespace-resources.yaml  file to point to your custom  entando-de-app  image with Redis. The line to change is in the ConfigMap named  entando-docker-image-info . \n \n \n Deploy your edited file with  kubectl . \n \n \n kubectl apply -f namespace-resources.yaml\n \n \n Download the  entando-app.yaml  template \n \n curl  -sLO  \"https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/samples/entando-app.yaml\" \n \n \n Add environment variables to the  EntandoApp  definition to match your Redis instance. The variables to create are REDIS_ACTIVE, REDIS_ADDRESS (e.g.  redis://localhost:6379 ), and REDIS_PASSWORD. \n \n \n NOTE: This example uses a Secret for the  REDIS_PASSWORD , which is recommended. You can also hardcode the password in the YAML for testing purposes, but the use of clear text passwords in deployment files is not recommended.  Create and use a Secret for the password as a best practice. \n \n data : \n   environmentVariables : \n     -   name :  REDIS_ACTIVE\n       value :   \"true\" \n     -   name :  REDIS_ADDRESS\n       value :  YOUR - REDIS - URL\n     -   name :  REDIS_PASSWORD\n       valueFrom : \n         secretKeyRef : \n           key :  password\n           name :  YOUR - REDIS - SECRET - NAME\n           optional :   false  \n \n \n Deploy your file \n \n kubectl apply -f entando-app.yaml\n \n "},{title:"Connect to an External Keycloak Instance",frontmatter:{},regularPath:"/next/tutorials/devops/external-id-management.html",relativePath:"next/tutorials/devops/external-id-management.md",key:"v-27500614",path:"/next/tutorials/devops/external-id-management.html",headers:[{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Get keycloak information",slug:"_1-get-keycloak-information"},{level:3,title:"2. Generate the secret",slug:"_2-generate-the-secret"},{level:3,title:"3. Upload the secret",slug:"_3-upload-the-secret"},{level:3,title:"4. Deploy the Entando application",slug:"_4-deploy-the-entando-application"},{level:2,title:"Conclusion",slug:"conclusion"}],lastUpdated:"4/19/2022, 11:37:04 AM",lastUpdatedTimestamp:1650382624e3,content:' Connect to an External Keycloak Instance \n Purpose \n This tutorial enables the Entando administrator to leverage an existing\nKeycloak instance. \n Requirements \n \n \n A Keycloak instance \n \n \n A realm named "entando" on that instance \n \n \n An admin user for the "entando" realm \n Steps \n 1. Get keycloak information \n Retrieve the relevant information from the Keycloak instance you want to\nuse. \n Specifically you will need: \n \n \n The username of the Keycloak admin that has admin rights to the\n"entando" realm, e.g entando-keycloak-admin \n \n \n The Keycloak admin password, e.g. password123 \n \n \n The base url for the Keycloak server, including the auth value, e.g.\nhttps://your-keycloak-instance.com/auth \n 2. Generate the secret \n You now need to generate a secret with name  keycloak-admin-secret \nusing the information retrieved from step 1. The Entando administrator\nwill automatically detect this secret by name, and use it to log onto\nthe provided Keycloak server. \n Here is an example of the secret you will need to construct: \n ---\napiVersion: v1\nstringData:\n    username: #the username of the Keycloak admin user for the "entando" realm\n    password: #the password of this Keycloak admin user\n    url: #the base url of the Keycloak service, typically ending with the path /auth\nkind: Secret\nmetadata\n    name: keycloak-admin-secret\n    namespace: YOUR-APP-NAMESPACE\ntype: Opaque\n \n \n Note \n To encode your values, in bash, you can do\n echo YOUR-VALUE | base64 \n 3. Upload the secret \n Next upload the secret to the namespace where you want to deploy your\nEntando instance. \n oc create -f YOUR-SECRET.yaml -n MY-APP-NAMESPACE\n 4. Deploy the Entando application \n Now you are ready to deploy your Entando application and the\nadministrator will reuse the  keycloak-admin-secret  secret to populate\nthe environment correctly. \n Conclusion \n You should now have a working Entando instance using an external\nKeycloak server. \n'},{title:"Tutorial: Connecting to an External Database",frontmatter:{},regularPath:"/next/tutorials/devops/external-db.html",relativePath:"next/tutorials/devops/external-db.md",key:"v-9b561e74",path:"/next/tutorials/devops/external-db.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"4/18/2022, 2:29:24 PM",lastUpdatedTimestamp:1650306564e3,content:" Tutorial: Connecting to an External Database \n Overview \n This document provides a guide to connecting an Entando Application to an external database. In\nmany production configurations, it is recommended to use a DBMS\noutside of the cluster where your Entando Application is running to\nsimplify maintenance, minimize duplication of resources, and establish a\nbackup workflow to scale with your application. \n Prerequisites \n \n \n An environment to install your Entando Application \n \n \n A running PostgreSQL, MySQL, or Oracle environment \n \n \n Administrator access to the database \n \n \n Network access from your Kubernetes cluster to your database \n Tutorial \n \n Create and install a secret or secrets for your database credentials \n Edit the EntandoApp and EntandoKeycloakServer custom resources. \n Set the value for  dbms  to  none  in both resources. \n Under  environmentVariables , you will need to provide database connection information for two Entando server databases and one connection for the Entando Component Repository. Example connection information for each of those databases is provided below: \n ECR \n - name: SPRING_DATASOURCE_URL\n  value: {ECRDB_URL}\n- name: SPRING_DATASOURCE_USERNAME\n  valueFrom:\n    secretKeyRef:\n      name: {ECRDB_DBMS_SECRET_NAME}\n      key: username\n      optional: false\n- name: SPRING_DATASOURCE_PASSWORD\n  valueFrom:\n    secretKeyRef:\n      name: {ECRDB_DBMS_SECRET_NAME}\n      key: password\n      optional: false\n- name: SPRING_JPA_DATABASE_PLATFORM\n  value: {ECRDB_DIALECT}\n Portal DB \n - name: PORTDB_URL\n  value: {PORTDB_URL}\n- name: PORTDB_USERNAME\n  valueFrom:\n    secretKeyRef:\n      name: {PORTDB_DBMS_SECRET_NAME}\n      key: username\n      optional: false\n- name: PORTDB_PASSWORD\n  valueFrom:\n    secretKeyRef:\n      name: {PORTDB_DBMS_SECRET_NAME}\n      key: password\n      optional: false\n- name: PORTDB_CONNECTION_CHECKER\n  value: {PORTDB_CONNECTION_CHECKER}\n- name: PORTDB_EXCEPTION_SORTER\n  value: {PORTDB_EXCEPTION_SORTER}\n Server DB \n - name: SERVDB_URL\n  value: {SERVDB_URL}\n- name: SERVDB_USERNAME\n  valueFrom:\n    secretKeyRef:\n      name: {SERVDB_DBMS_SECRET_NAME}\n      key: username\n      optional: false\n- name: SERVDB_PASSWORD\n  valueFrom:\n    secretKeyRef:\n      name: {SERVDB_DBMS_SECRET_NAME}\n      key: password\n      optional: false\n- name: SERVDB_CONNECTION_CHECKER\n  value: {SERVDB_CONNECTION_CHECKER}\n- name: SERVDB_EXCEPTION_SORTER\n  value: {SERVDB_EXCEPTION_SORTER}\n \n Set the values for placeholders in the templates above based on your database configuration. Here are examples: \n Postgresql \n XXX_URL:                      jdbc:postgresql://{DBMS_ADDRESS}:{DBMS_PORT}/{DBMS_DBNAME}\nXXX_CONNECTION_CHECKER:        org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLValidConnectionChecker\nXXX_EXCEPTION_SORTER:         org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLExceptionSorter\nSPRING_JPA_DATABASE_PLATFORM: org.hibernate.dialect.PostgreSQLDialect\n MySql \n XXX_URL:                      jdbc:mysql://{DBMS_ADDRESS}:{DBMS_PORT}/{DBMS_DBNAME}\nXXX_CONNECTON_CHECKER:        org.jboss.jca.adapters.jdbc.extensions.mysql.MySQLValidConnectionChecker\nXXX_EXCEPTION_SORTER:         org.jboss.jca.adapters.jdbc.extensions.mysql.MySQLExceptionSorter\nSPRING_JPA_DATABASE_PLATFORM: org.hibernate.dialect.MySQLDialect \n Oracle \n XXX_URL:                      jdbc:oracle:{driver_type}:@//{DBMS_ADDRESS}:{DBMS_PORT}/{DBMS_SERVICE_NAME}\nXXX_CONNECTON_CHECKER:        org.jboss.jca.adapters.jdbc.extensions.oracle.OracleValidConnectionChecker\nXXX_EXCEPTION_SORTER:         org.jboss.jca.adapters.jdbc.extensions.oracle.OracleExceptionSorter\nSPRING_JPA_DATABASE_PLATFORM: org.hibernate.dialect.Oracle \n \n "},{title:"Selecting the Default Databases",frontmatter:{},regularPath:"/next/tutorials/devops/default-database.html",relativePath:"next/tutorials/devops/default-database.md",key:"v-ad8a3fa8",path:"/next/tutorials/devops/default-database.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"1/26/2022, 3:04:16 PM",lastUpdatedTimestamp:1643227456e3,content:" Selecting the Default Databases \n Overview \n This document provides a guide to changing an Entando environment by selecting the default databases used.\nSee  External Database  to connect to a database outside of the cluster. \n Prerequisites \n \n An environment to install your Entando application \n Network access from your Kubernetes cluster to your database \n Tutorial \n If needed, you can set the desired component to use a specific DBMS by updating the Helm-generated yaml file from  Getting Started  as follows: \n \n open the chosen file and search for  EntandoApp  custom resource \n identify the component to update in the related list \n update the  spec.dbms  property with the desired value (you can specify different DBMS for different components) \n \n Repeat previous steps for all components you need to change used DBMS on. \n Valid values for  spec.dbms  property are:  none ,  embedded ,  postgresql ,  mysql ,  oracle . \n embedded  value will result in using an embedded database with in-file persistence strategy. \n Please note that using embedded databases into distributed systems forces to have only 1 replica per pod.\nThis happens because the volume claimed by each replica points to the same files,\nso the first container locking the files will prevent next replicas to obtain access to the DB files.\nNote that this affects also deployments rolling updates \n If you need to update your deployment, there is a known workaround consisting in setting the replicas number to 0, waiting for pod shutdown completion, update the deployment yaml file, then updating again to 1 the replicas value. In this way, the newly created containers will be able to startup correctly and access the embedded database files on the filesystem. \n These considerations lead us to discourage embedded database use into production environments. \n"},{title:"Plugin Configuration Profiles",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/devops/plugin-configuration.html",relativePath:"next/tutorials/devops/plugin-configuration.md",key:"v-07fe8602",path:"/next/tutorials/devops/plugin-configuration.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Profile Options",slug:"profile-options"},{level:2,title:"Configuration",slug:"configuration"},{level:3,title:"Retrieve the Plugin ID",slug:"retrieve-the-plugin-id"},{level:3,title:"Method 1: Inline Profile",slug:"method-1-inline-profile"},{level:3,title:"Method 2: Mapped Profile",slug:"method-2-mapped-profile"},{level:3,title:"Method 3: Default Profile",slug:"method-3-default-profile"},{level:2,title:"References",slug:"references"}],lastUpdated:"3/28/2022, 3:58:49 PM",lastUpdatedTimestamp:1648497529e3,content:' Plugin Configuration Profiles \n This tutorial describes three methods to utilize configuration profiles to specify resource allocation for Entando plugins. This provides a simple way to customize plugin deployment parameters for improved efficiency. \n Prerequisites \n \n Add an Entando Operator ConfigMap  if needed \n Enable this property under the  data  section so that the Entando Operator can manage resource settings. \n \n   entando.k8s.operator.impose.limits :   "true" \n Profile Options \n The three methods to insert configuration profiles are: \n \n Inline Profile \n Mapped Profile \n Default Profile \n \n Currently, the following resources for memory and CPU can be specified. When you specify a  limit  on a resource, it is the maximum allowed for the container. Resource settings help Kubernetes determine in which node a pod should be created. \n resources.limits.cpu :        integer ,  millicpus\n resources.limits.memory :     integer ,  mebibytes\n Configuration \n A profile is a set of configurations encoded as YAML but embedded in the  OperatorConfigMap  as a string, since ConfigMaps cannot be multilevel. The examples below use  YOUR-PLUGIN-ID  and  YOUR-PROFILE-NAME  as placeholders for your names. Also note  |-  in the sample codes to specify each new line is read as such. \n Retrieve the Plugin ID \n You will need to  retrieve the Plugin ID  which is calculated during installation and written to the EntandoPlugin Custom Resource as part of the deployment of the plugin microservice. Use the following command from the project directory \n ent prj get-plugin-id --auto\n \n If you just have a bundle, use this command with the appropriate parameters \n ent ecr get-plugin-id --autho --repo = YOUR-BUNDLE-REPO-URL\n \n Example: \n $ ent ecr get-plugin-id --auto --repo = https://github.com/entando-samples/entando-hub-application-bundle.git\npn-cee95efc-77ff566e-entandopsdh-entando-hub-catalog-ms\n Method 1: Inline Profile \n Add the parameters to the  OperatorConfigMap  as an inline profile at  data/entando.profile.plugins.YOUR-PLUGIN-ID . \n Example: \n data : \n   entando.profile.plugins.YOUR-PLUGIN-ID :   | - \n     resources.limits.cpu :   "1000" \n     resources.limits.memory :   "2000" \n Method 2: Mapped Profile \n \n Create the parameter profile in the  OperatorConfigMap  of the data profile at  data/entando.profile.YOUR-PROFILE-NAME . \n \n Example: \n data : \n   entando.profile.YOUR-PROFILE-NAME :   | - \n     resources.limits.cpu :   "1000" \n     resources.limits.memory :   "2000" \n \n \n Add a reference in the  profileMapping  file at  data/entando.plugins.profileMapping : \n \n data : \n   entando.plugins.profileMapping :   | - \n     your-plugin-id :  YOUR - PROFILE - NAME\n Method 3: Default Profile \n \n Add the profile to the  OperatorConfigMap  in the data section at  data/entando.profile.YOUR-PROFILE-NAME . \n \n data : \n   entando.profile.YOUR-PROFILE-NAME :   | - \n     resources.limits.cpu :   "1000" \n     resources.limits.memory :   "2000" \n \n \n Add a reference to the profile at  data/entando.plugins.defaultProfile : \n \n data : \n   entando.plugins.defaultProfile :  YOUR - PROFILE - NAME\n References \n Please refer to the  Kubernetes documentation on Resources  for more details. \n'},{title:"Tutorial: Invoking Entando Core APIs",frontmatter:{},regularPath:"/next/tutorials/devops/invoking-api.html",relativePath:"next/tutorials/devops/invoking-api.md",key:"v-8f854294",path:"/next/tutorials/devops/invoking-api.html",headers:[{level:2,title:"General Overview",slug:"general-overview"},{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Set up a Postman environment",slug:"_1-set-up-a-postman-environment"},{level:3,title:"2. Get an access token",slug:"_2-get-an-access-token"},{level:3,title:"2. Prepare a generic API request",slug:"_2-prepare-a-generic-api-request"},{level:2,title:"QE ready APIs",slug:"qe-ready-apis"},{level:2,title:"Notes on QE requests collections structure",slug:"notes-on-qe-requests-collections-structure"}],lastUpdated:"4/19/2022, 11:37:04 AM",lastUpdatedTimestamp:1650382624e3,content:' Tutorial: Invoking Entando Core APIs \n General Overview \n Entando supports Swagger and it is accessible, if activated, from its\nweb interface from the base application URL at /api/swagger-ui.html. A\ncomplete list of all available core APIs can be obtained from Swagger. \n Core APIs can be invoked directly from Swagger or from any other\nsuitable tool, i.e., curl or Postman are two common ones. Postman has\nbeen extensively used in API testing and automated API testing because\nof the possibilities it offers and it is the suggested tool. \n All Entando core APIs are accessible from the base URL, for example:\nlocalhost:8080/entando-de-app/api. For example, the Page Controller will\nbe available under /pages from the Base URL (i.e.\nlocalhost:8080/entando-de-app/api/pages), or the Page Template Controller\nwill available under /pageModels (i.e.\nlocalhost:8080/entando-de-app/api/pageModels) and so on. \n Before being able to perform any API request, we will first need to\nobtain an  authorization token , that is achieved with a specific POST\nrequest sent to the oauth/token endpoint, after successful\nauthentication, an access token is returned which grants access to all\nAPI endpoints and actions for which the authenticated user has defined\nprivileges. \n (Refer to  User Management Roles  for details) \n The best way to proceed in case of extensive testing with APIs with\nPostman, is to set up an environment and define a variable that will\nkeep the access token saved from the POST request to /oauth/token. \n Purpose \n Set up an environment ready to invoke Entando core APIs \n Requirements \n To complete this tutorial you will need: \n \n \n Postman \n \n \n A running Entando instance \n Steps \n 1. Set up a Postman environment \n Create a new Postman environment and define the following variables: \n access_token: #no value\nrefresh_token: #no value\nurl: #URL of your application (i.e. http://localhost:8080/entando-de-app)\n \n Be careful with the URL variable and make sure you do not have a\ntrailing slash. \n Set Postman to use this environment. \n 2. Get an access token \n Getting an access token is a prerequisite to be able to invoke any API.\nThe following is the required activity. \n \n \n create a Postman collection, name it for example "Access Token" \n \n \n create a new POST request with the following parameters: \n \n \n \n URL field\n{{url}}/api/oauth/token\n \n Note that we are calling the "url" environmental variable for\nconvenience. \n Autorization section\n   Type: Basic Auth\n   Username: #a valid Entando consumer must be defined in Entando (Refer to appropriate documentation on how to do that) (i.e. appbuilder)\n   Password: #password of the defined consumer (i.e. appbuilder_secret)\n\nHeaders section\n    Content-Type: application/x-www-form-urlencoded\n\nBody section\nSelect from the radio button the option: x-www-form-urlencoded\n    username: #valid Entando user (i.e. admin)\n    password: #password of the valid user\n    grant_type: password\n \n The tests section is convenient as we can then set any new API request\nin such a way to make use of that access token. The first line of code\ndefines a variable called "data", which hosts the JSON parsed\nresponseBody from the POST request just sent to /oauth/token; The second\nline sets the environment variable "access_token" to the value returned\nby the POST request. \n Tests section\n    var data = JSON.parse(responseBody);\n    postman.setEnvironmentVariable("access_token", data.access_token);\n \n Launch the POST request to test it, and if successful, you should get a\nresponse like this: \n {\n    "access_token": "b96096493a40b1a7364bd54a6ffb609b",\n    "token_type": "bearer",\n    "refresh_token": "79ff84062b5dc13663961a833b0788f9",\n    "expires_in": 3599\n}\n \n also if you open in edit the Postman environment, you should see that\nthe access_token and the refresh_token variables values have been\nupdated. \n 2. Prepare a generic API request \n Create a new request with the following parameters: \n Authorization section: Inherit auth from parent\n\nHeaders section:\n create the key Authorization with Value: Bearer{{access_token}}\n create the key Content-Type with Value: application/json\n \n Select the appropriate method (GET, DELETE, POST etc.) for your request\nand fill up the URL with appropriate values i.e.\n(localhost:8080/entando-de-app/api/pages) then add to the Body section,\nif needed, the appropriate payload in JSON format, remember to select\nraw and JSON (application/json). \n QE ready APIs \n QE has developed a set of collection requests to automate API testing,\nexamples of that are available on github at\n https://github.com/entando/entando-QE/tree/master/postman_API . \n To use them, first git clone the project and use the built in Postman\nimporting features. \n Import first the Postman Environment file which can be found under the\nenvironment folder. When imported, from Postman, open in edit that\nenvironment and change the "url" variable to the appropriate value for\nyour specific installation, i.e http://localhost:8080/entando-de-app/\nand save it. \n Import from Postman the collections you would like to use and they will\nbecome available in the Postman collections Panel ready to be run. \n Notes on QE requests collections structure \n Each collection is so designed to test a particular use case i.e.\n"Delete an existent page", "Delete a page which has children" etc. \n By design each QE Postman collection is: \n \n \n independent (does not require other collections) \n \n \n general (does not make any assumption on the specific Entando\napplication) \n \n \n can be run automatically, with Newman, please refer to\n https://github.com/entando/entando-QE  for details \n \n \n Following those requirements, each collection will need to "prepare" the\nenvironment for the actual test. That is achieved by using specific\nrequests, called "helpers", and their only purpose is to create/delete\nall the needed objects. \n Another class of helpers is used to check the persistence of the actions\nperformed by the APIs, i.e. check that after a DELETE, something really\nhas been deleted. \n The request that implements the use case, we can call it main request,\ndoes not contain the word "HELPER" in its name, and it is the only one\ninside a given collection. \n Because collections are designed primarily to run automatically, we have\ndone extensive use of collection variables, so variables like the API\nURL, object names, object codes or payloads are usually defined as a\ncollection variable and can be accessed by all requests inside the\ncollection. \n'},{title:"Manage NGINX",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/devops/manage-nginx.html",relativePath:"next/tutorials/devops/manage-nginx.md",key:"v-62081954",path:"/next/tutorials/devops/manage-nginx.html",headers:[{level:2,title:"Verify the NGINX Ingress Install",slug:"verify-the-nginx-ingress-install"},{level:2,title:"Customize the NGINX Configuration",slug:"customize-the-nginx-configuration"},{level:2,title:"Add the cert-manager for TLS Support",slug:"add-the-cert-manager-for-tls-support"},{level:3,title:"Installation",slug:"installation"},{level:3,title:"Configuration",slug:"configuration"},{level:3,title:"cert-manager References",slug:"cert-manager-references"}],lastUpdated:"4/21/2022, 1:23:40 PM",lastUpdatedTimestamp:165056182e4,content:' Manage NGINX \n There are environments where it\'s useful to use NGINX rather than the default ingress controller. This page shows how to verify and refine your NGINX configuration. \n See the following install guides if needed: \n \n Amazon Elastic Kubernetes Service (EKS) \n Azure Kubernetes Service (AKS) \n Google Kubernetes Engine (GKE) \n Verify the NGINX Ingress Install \n To verify that the ingress is working properly you can set up a test application. \n \n Create a simple application: \n \n kubectl create deployment hello-server --image=us-docker.pkg.dev/google-samples/containers/gke/hello-app:1.0\n \n \n Expose the  hello-app  deployment as a Service: \n \n kubectl expose deployment hello-server --type LoadBalancer --port 80 --target-port 8080\n \n \n Create this  ingress-resource.yaml  file: \n \n apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: ingress-resource\n  annotations:\n    kubernetes.io/ingress.class: nginx\n    nginx.ingress.kubernetes.io/ssl-redirect: "false"\nspec:\n  rules:\n  - http:\n      paths:\n      - path: /hello\n        pathType: Prefix\n        backend:\n          service:\n            name: hello-server\n            port: \n              number: 80\n \n \n Create the Ingress Resource: \n \n kubectl apply -f ingress-resource.yaml\n \n \n Verify that the Ingress Resource has been created: \n \n kubectl get ingress ingress-resource\n \n It may take several minutes to populate the  Address . \n \n Verify access to the web application using the  EXTERNAL-IP/hello  address of the  nginx-ingress-controller . You should see the following: \n \n Hello, world!\nVersion: 1.0.0\nHostname: hello-app\n \n Note that you will need the EXTERNAL-IP address of your ingress controller to configure the application. \n \n Verify that you configured the ingress class in the Operator  ConfigMap  so Entando knows which ingress controller should be used: \n \n entando.ingress.class: "nginx" \n \n To reduce costs, remove the test deployment, service, and ingress: \n \n kubectl delete deploy/hello-server service/hello-server ing/ingress-resource\n Customize the NGINX Configuration \n There are situations where the default NGINX ingress configuration isn\'t optimized for Entando, e.g. JWT tokens can be too large or  proxy-buffer-size  can be too small. A  502 Bad Gateway  error may indicate that the config needs to be modified. \n The NGINX controller can be configured for the entire cluster by editing the default NGINX  ConfigMap , called  ingress-nginx-controller  in the  ingress-nginx  namespace. Add the following to the data parameter: \n apiVersion: v1\ndata:\n  allow-snippet-annotations: "true"\n  proxy-buffer-size: 24k\nkind: ConfigMap\n \n Production environments may require additional common annotations: \n nginx.ingress.kubernetes.io/proxy-body-size: 200m # to upload large files (default is 10M)\nnginx.ingress.kubernetes.io/proxy-buffer-size: 64k # for the Keycloak auth-token (default is 16K)\nnginx.ingress.kubernetes.io/proxy-read-timeout: "600" # to increase the timeout when uploading large files\n \n Sticky sessions may be useful for  entando-de-app  deployments with multiple replicas. If you  set up clustering , the following options will enable sticky sessions in NGINX: \n nginx.ingress.kubernetes.io/affinity: cookie\nnginx.ingress.kubernetes.io/affinity-mode: balanced\n Add the  cert-manager  for TLS Support \n Follow the instructions below to install and configure  cert-manager  in Kubernetes environments.\n​ \n Installation \n ​\nCreate a namespace dedicated to  cert-manager : \n kubectl create ns cert-manager\n \n ​\nComplete the installation: \n kubectl apply  - f https : //github.com/jetstack/cert - manager/releases/download/v1.7.0/cert - manager.yaml\n Configuration \n ​\nTo enable  cert-manager  to generate certificates, add these annotations to the ingress:\n​ \n \n cert-manager.io/issuer: "[name of the issuer]"  for namespace-based issuers \n cert-manager.io/cluster-issuer: "[name of cluster issuer]"  for cluster-wide issuers \n \n and modify  spec : \n spec : \n   tls : \n   -   hosts : \n     -  example.example.com\n     secretName :  quickstart - example - tls  # this Secret will be autogenereted by cert-manager. \n Namespace Level Issuer \n ​\nUse the following configuration when deploying an issuer per namespace. This is useful for higher levels of customization.\n​ \n apiVersion :  cert - manager.io/v1\n kind :  Issuer\n metadata : \n   name :  letsencrypt - prod\n spec : \n   acme : \nThe ACME server URL \n     server :  https : //acme - v02.api.letsencrypt.org/directory\n     preferredChain :   "ISRG Root X1" \nEmail address used for ACME registration \n     email :  <your email > \nName of a secret used to store the ACME account privare key \n     privateKeySecretRef : \n       name :  letsencrypt - prod\nEnable the http-01 challenge provider \n     solvers : \n     -   http01 : \n         ingress : \n           class :  nginx\n​\n Cluster Level Issuer \n Use the following configuration when deploying an issuer per cluster: \n apiVersion :  cert - manager.io/v1\n kind :  ClusterIssuer\n metadata : \n   name :  letsencrypt - prod - cluster\n   namespace :  cert - manager\n spec : \n   acme : \nThe ACME server URL \n     server :  https : //acme - v02.api.letsencrypt.org/directory\n     preferredChain :   "ISRG Root X1" \nEmail address used for ACME registration \n     email :  <your email > \nName of a secret used to store the ACME account privare key \n     privateKeySecretRef : \n       name :  letsencrypt - cluster - prod\nEnable the http-01 challenge provider \n     solvers : \n     -   http01 : \n         ingress : \n           class :  nginx\n​\n  cert-manager  References \n \n Installation \n Supported releases \n \n'},{title:"Use Plugin Environment Variables to Customize Microservices",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/devops/plugin-environment-variables.html",relativePath:"next/tutorials/devops/plugin-environment-variables.md",key:"v-eddb4118",path:"/next/tutorials/devops/plugin-environment-variables.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Add Environment Variables to the Plugin Descriptor File",slug:"add-environment-variables-to-the-plugin-descriptor-file"},{level:2,title:"Verify the Environment Variables",slug:"verify-the-environment-variables"}],lastUpdated:"4/8/2022, 9:40:23 AM",lastUpdatedTimestamp:1649425223e3,content:" Use Plugin Environment Variables to Customize Microservices \n This tutorial describes how to use environment variables to customize the behavior of plugin microservices. Using environment variables as a configuration mechanism allows the same Linux image to run in development and production environments. This is especially useful when managing sensitive information via Kubernetes Secrets. \n Version 4 of the Entando plugin descriptor adds the ability to make environment variables available to a microservice via the plugin  descriptor.yaml  file. There are two options. \n \n Inject the variables using a key-value pair \n Inject a reference to an existing Kubernetes Secret \n \n This tutorial will demonstrate both of these options. The Entando Plugin will receive one environment value directly as plain text in the Pod YAML and the other indirectly via a referenced Secret. \n Prerequisites \n \n A project bundle  using the latest Entando Blueprint. \n Add Environment Variables to the Plugin Descriptor File \n \n Determine YOUR-BUNDLE-ID. You can do this from your project directory using this command: \n \n ent prj get-bundle-id\n \n Alternatively, supply the full bundle URL (including the .git suffix): \n ent ecr get-bundle-id https://github.com/YOUR-ACCOUNT/YOUR-PLUGIN-BUNDLE.git\n \n For example, here's the bundle ID for the first  Standard Banking Demo bundle : \n $ent ecr https://github.com/entando-samples/standard-demo-banking-bundle.git\n343826ca\n \n \n Now create a Secret named  YOUR-BUNDLE-ID-my-secret  with a key-value pair  mySecretKey=mySecretValue . Make sure to replace YOUR-BUNDLE-ID with the value from the previous step. \n \n kubectl create secret generic YOUR-BUNDLE-ID-my-secret --from-literal = mySecretKey = mySecretValue -n entando\n \n \n Verify that the plugin file  bundle/plugins/YOUR-PLUGIN.yaml  specifies  descriptorVersion: v4  or add it if you're upgrading an existing bundle. \n Insert the following  environmentVariables  section into  YOUR-PLUGIN.yaml  after replacing  YOUR-BUNDLE-ID  with the correct value. By convention, environment variables are all caps and K8s resource names are hyphenated. \n \n environmentVariables : \n   -   name :  SIMPLE_VAR\n     value :  mySimpleValue\n   -   name :  SECRET_VAR\n     valueFrom : \n       secretKeyRef : \n         name :  YOUR - BUNDLE - ID - my - secret\n         key :  mySecretKey\n \n \n Build and deploy  the updated bundle. \n Verify the Environment Variables \n \n When the installation is complete, open a terminal into the pod created by the plugin.  YOUR-PLUGIN-POD-NAME  will begin with  pn-  plus  YOUR-BUNDLE-ID  from above. \n \n kubectl  exec  -it YOUR-PLUGIN-POD-NAME -- /bin/bash\n \n \n Check for the environment variables using the command  env  or this command: \n \n echo   SIMPLE_VAR = $SIMPLE_VAR ,  SECRET_VAR = $SECRET_VAR \n \n Expected output: \n SIMPLE_VAR=mySimpleValue, SECRET_VAR=mySecretValue\n \n You have now learned to use environment variables with plugin microsevices on the Entando Platform. \n"},{title:"Installation on Azure Kubernetes Service (AKS)",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/getting-started/azure-install.html",relativePath:"next/tutorials/getting-started/azure-install.md",key:"v-f55e16e8",path:"/next/tutorials/getting-started/azure-install.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Cluster Setup",slug:"cluster-setup"},{level:3,title:"Setup and Connect to the Cluster",slug:"setup-and-connect-to-the-cluster"},{level:3,title:"Deploy NGINX Ingress Controller",slug:"deploy-nginx-ingress-controller"},{level:3,title:"Install the Entando Custom Resources",slug:"install-the-entando-custom-resources"},{level:3,title:"Configure the Entando Application",slug:"configure-the-entando-application"},{level:2,title:"Deploy your Entando Application",slug:"deploy-your-entando-application"},{level:2,title:"Appendix A - Troubleshooting",slug:"appendix-a-troubleshooting"}],lastUpdated:"4/19/2022, 3:32:52 PM",lastUpdatedTimestamp:1650396772e3,content:" Installation on Azure Kubernetes Service (AKS) \n The steps below walk you through installing the Entando Platform in an Azure Kubernetes Services (AKS) cluster. \n \n Create a single AKS cluster \n Install NGINX as an ingress controller \n Install the Entando Custom Resources \n Configure the Entando Application \n Deploy Entando \n \n If you're already comfortable setting up an AKS cluster and installing NGINX, then you may be able to skip to  setting up Entando . \n Prerequisites \n \n Azure account \n If you choose not to use the Azure Cloud Shell, you'll also need the Azure command line tool. \n \n TIP \n If you're using an Azure free account, you may need to upgrade your account to enable pay-as-you-go billing. The Azure free account default quota allows just 1-4 vCPU which is not sufficient for this tutorial. There may be a delay before the quotas are updated when you upgrade your account. \n Cluster Setup \n Setup and Connect to the Cluster \n \n Login to Azure:  https://portal.azure.com/ \n Select the  Kubernetes services  icon\n \n If the icon isn't visible, click  More services  on the right and search for Kubernetes \n \n \n Click  Create  in the upper left corner \n Select  Create a Kubernetes cluster . You'll start with the  Basics  tab. \n Select a  Resource group  or create one with the  Create new  link, e.g. YOUR-RESOURCE-GROUP \n Enter a name of your choice for the Kubernetes cluster name, e.g. YOUR-CLUSTER \n Pick your  Region  if it wasn't automatically selected for you. \n In the  Availability zones  dropdown, pick  one and only one  availability zone\n \n Generally, you could pick more than one but it will result in a failure in a quickstart environment. If you chose more than one availability zone you will have to provision storage, manage node affinity, and provide the correct network configuration to ensure your application deploys. We recommend only doing this for production clusters. \n \n \n Select an  Entando-compatible Kubernetes version , e.g. 1.21.x \n Keep the default  Node size , e.g. Standard DS2 v2 \n Keep the  Scale Method  set to  Autoscale  and the  Node count range  set from  1  to  5 \n (Optional) If you're familiar with AKS, you can change settings under other tabs (e.g.  Node Pools ,  Access ) as desired but the defaults should work. Entando uses base Kubernetes APIs, so as long as you follow the Entando configuration instructions below, you can tune your cluster infrastructure to meet your goals. \n Click  Review + Create  then  Create . It may take several minutes for your cluster to initialize. \n \n Note: A different storage class can be configured for  Clustered Storage . \n Deploy NGINX Ingress Controller \n \n Navigate to your cluster by clicking  Go to Resource  from the results page, or go to  Home  →  Kubernetes service  and click on your cluster. \n Select  Connect \n Select  Open Cloud Shell \n \n With a new Azure account, you may see a warning:  You have no storage mounted . Follow the instructions to create a new storage account. \n \n \n If it wasn't done automatically, run the first two commands (e.g.  az account set...  and  az aks get-credentials... ) to connect to your cluster. This should only be needed the first time you run the Azure Cloud Shell.\n \n The following instructions assume you will use the Azure Cloud Shell but you can also run the commands in a local environment via  kubectl \n \n \n Deploy the NGINX controller to enable access to the cluster \n \n kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.1.3/deploy/static/provider/aws/deploy.yaml \n \n \n Get the external IP address for your ingress controller \n \n kubectl get services -n ingress-nginx\n \n For example: \n NAME                      TYPE          CLUSTER-IP    EXTERNAL-IP                        \ningress-nginx-controller  LoadBalancer  10.0.28.197   20.120.54.243\n \n The value of the external URL (EXTERNAL-IP) should be available within a few minutes. You'll need this address for  YOUR-HOST-NAME  in the steps below. \n TIP \n NGINX is working correctly if a  404 Not Found  error page is generated when accessing  YOUR-HOST-NAME  from your browser. For a more complete test, you can  set up a simple test application  using Azure Cloud Shell or your local  kubectl . You can also  customize the NGINX ingress  to optimize the configuration for Entando. \n \n See the  Install Guide for NGINX on Azure  for more information. \n Install the Entando Custom Resources \n \n Apply the cluster-scoped custom resource definitions (CRDs). This is required only once per cluster. \n \n kubectl apply -f https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/namespace-scoped-deployment/cluster-resources.yaml\n \n \n Create the namespace for the Entando Application \n \n kubectl create namespace entando\n \n \n Download the  entando-operator-config  template so you can configure the  Entando Operator \n \n curl  -sLO  \"https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/samples/entando-operator-config.yaml\" \n \n \n Edit the  entando-operator-config.yaml  to add two properties \n \n data : \n    entando.requires.filesystem.group.override :   \"true\" \n    entando.ingress.class :   \"nginx\" \n \n \n Apply the  ConfigMap \n \n kubectl apply -f entando-operator-config.yaml -n entando\n \n \n Apply the namespace-scoped custom resources \n \n kubectl apply -n entando -f https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/namespace-scoped-deployment/namespace-resources.yaml\n \n \n You can use  kubectl get pods -n entando --watch  to see the initial pods start up. Use  Ctrl+C  to exit. \n \n $ kubectl get pods -n entando\nNAME                                   READY   STATUS    RESTARTS   AGE\nentando-k8s-service-86f8954d56-mphpr   1/1     Running   0          5m53s\nentando-operator-5b5465788b-ghb25      1/1     Running   0          5m53s\n Configure the Entando Application \n \n Download the  entando-app.yaml  template \n \n curl  -sLO  \"https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/samples/entando-app.yaml\" \n \n \n Edit  entando-app.yaml . Replace  YOUR-HOST-NAME  with  EXTERNAL-IP + .nip.io . See  the EntandoApp custom resource overview  for additional options. \n \n spec : \n   ingressHostName :  YOUR - HOST - NAME\n \n e.g.  ingressHostName: 20.120.54.243.nip.io \n Deploy your Entando Application \n \n You can now deploy your application to your AKS cluster \n \n kubectl apply -n entando -f entando-app.yaml\n \n \n It can take around 10 minutes for the application to fully deploy. You can watch the pods warming up with the command below. Use  Ctrl+C  to exit the command. \n \n kubectl get pods -n entando --watch\n \n \n Once all the pods are in a running state, access the Entando App Builder at the following address \n \n http://YOUR-HOST-NAME/app-builder/\n \n See the  Getting Started guide  for helpful login instructions and next steps. \n Appendix A - Troubleshooting \n If you get an error like:  0/5 nodes are available: 5 node(s) had volume node affinity conflict  or if several deployments fail to start, then you should check your availability zones. By default, an Azure cluster will include nodes from multiple zones, but Azure may not automatically provision their storage. \n You can confirm this error in the AKS console as well: \n \n In your cluster, select  Workloads  in the left nav \n Click on the deployment for your server application. This is  quickstart-deployment  by default. \n Click on the deployment name inside that application. \n Click on the tab labeled  Conditions \n If you see an error that says  0/5 nodes are available: 5 node(s) had volume node affinity conflict , then you need to reconfigure your cluster to have nodes in one zone, or work with your Azure operations team to provision storage to match node affinity. \n \n"},{title:"Installation on Kubernetes",frontmatter:{},regularPath:"/next/tutorials/getting-started/kubernetes-install.html",relativePath:"next/tutorials/getting-started/kubernetes-install.md",key:"v-d7817940",path:"/next/tutorials/getting-started/kubernetes-install.html",headers:[{level:2,title:"Infrastructure Requirements",slug:"infrastructure-requirements"},{level:2,title:"Minimum Hardware Requirements",slug:"minimum-hardware-requirements"},{level:3,title:"For Entando install only:",slug:"for-entando-install-only"},{level:3,title:"For Entando + Microservices:",slug:"for-entando-microservices"},{level:3,title:"For Entando with CMS:",slug:"for-entando-with-cms"},{level:2,title:"Backup Strategies",slug:"backup-strategies"},{level:2,title:"Notes",slug:"notes"}],lastUpdated:"3/25/2022, 2:40:32 PM",lastUpdatedTimestamp:1648233632e3,content:" Installation on Kubernetes \n Infrastructure Requirements \n These are the minimum infrastructure requirements to install Entando directly on a Kubernetes (K8s) cluster: \n \n A working DNS server configured to resolve internal and external names. If you choose to configure K8s with a global wildcard domain name for the entire cluster, be sure it points to the public IP address of the external Load Balancer of the worker nodes. \n A default  Storage Class  is needed for the Entando Operator to create the correct Persistent Volume Claims (PVC) for each pod. \n Nginx  Ingress-Controller  is needed to expose the Entando applications. \n Minimum Hardware Requirements \n The minimum hardware requirements depend on how you intend to use Entando. The more functionality you need, such as a content management system (CMS), the more you will need. \n For Entando install only: \n \n 6 vCPU or virtual central processing unit  (6000 millicores) \n 6 GB of RAM \n 5 GB of allocated storage distributed in many PVCs \n \n Configure a single worker node with the requirements above or designate 3 worker nodes with the minimum of 2 PVC and 4 GB of RAM each. \n For Entando + Microservices: \n \n 500 millicores per microservice or \n 1000 millicores per microservice with a database \n \n The tested instance was generated with a JHipster Entando blueprint. \n For Entando with CMS: \n To install Entando with CMS, the hardware requirements depend on the complexity and number of pages and contents. The minimum requirements are: \n \n 9 vCPU for a single CMS instance. To scale up, you need 4 vCPU per replica. \n 8 GB of RAM for a single CMS instance. To scale up, you need 4 GB of RAM per replica. \n A minimum of 50 GB of storage for all the static resources generated by the use of Entando CMS. \n Backup Strategies \n The recommended method to secure your content is to use database services that automate backups and restores on a Kubernetes cluster like Azure, Red Hat OpenShift, Google K8s Service or Amazon Elastic. If this is not an option, there are tools like  Velero  and  Cloudcase  to manage them. \n Note: Some DevOps teams warn against running databases inside pods in production environments. \n If using the Entando CMS, be sure to protect related schemas ( port  and  serv ) with a valid disaster recovery plan. Protect all volumes containing your static resources with daily snapshots. \n Notes \n See the  Entando compatibility guide  for compatible Kubernetes versions. \n"},{title:"Installation on Amazon Elastic Kubernetes Service (EKS)",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/getting-started/eks-install.html",relativePath:"next/tutorials/getting-started/eks-install.md",key:"v-fae665e0",path:"/next/tutorials/getting-started/eks-install.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Create and Connect the EKS Cluster",slug:"create-and-connect-the-eks-cluster"},{level:3,title:"Configure an Identity and Access Management (IAM) Role",slug:"configure-an-identity-and-access-management-iam-role"},{level:3,title:"Create the EKS Cluster",slug:"create-the-eks-cluster"},{level:3,title:"Add a Node Group to the Cluster",slug:"add-a-node-group-to-the-cluster"},{level:3,title:"Connect to the Cluster",slug:"connect-to-the-cluster"},{level:3,title:"Install the NGINX Ingress Controller",slug:"install-the-nginx-ingress-controller"},{level:3,title:"Install the Entando Custom Resources",slug:"install-the-entando-custom-resources"},{level:3,title:"Configure the Entando Application",slug:"configure-the-entando-application"},{level:2,title:"Deploy your Entando Application",slug:"deploy-your-entando-application"},{level:2,title:"Appendix A - Troubleshooting",slug:"appendix-a-troubleshooting"}],lastUpdated:"4/20/2022, 3:15:21 PM",lastUpdatedTimestamp:1650482121e3,content:' Installation on Amazon Elastic Kubernetes Service (EKS) \n This tutorial walks you through installing the Entando Platform in an EKS cluster. The steps are: \n \n Configure an IAM Role  to allow Kubernetes to manage the cluster \n Create the EKS cluster \n Install NGINX  as an ingress controller \n Install the Entando Custom Resources \n Configure the Entando Application \n Deploy the Entando Application \n \n If you\'re already comfortable setting up an EKS cluster and installing NGINX, then you may be able to skip to  setting up Entando . \n Prerequisites \n \n AWS CLI \n AWS account \n kubectl \n Create and Connect the EKS Cluster \n These steps use the AWS console to create the cluster. Experienced AWS users may choose to use the equivalent CLI commands. \n Configure an Identity and Access Management (IAM) Role \n \n \n Login to AWS  as a non- super admin  user \n \n It is not recommended to use a  super admin  account since clusters created that way may have restrictions that complicate your installation. \n The user account needs access to EKS and the minimum permissions to create a cluster. You may need additional policies for Amazon Route 53 or other services, depending on your configuration. \n \n \n \n Create an IAM role for the cluster so that AWS can provision assets \n \n From Services,  IAM  →  Create Role \n Select  AWS Service  for the type of trusted entity \n Click  EKS  from the  Use cases \n Check  EKS - Cluster \n Click  Next \n Verify that the  AmazonEKSClusterPolicy  is set \n Click  Next \n Name your role (you’ll need this later), e.g. YOUR-EKS-ROLE \n Click  Create role \n \n \n \n Refine the role to enable  Node Group  management and add elastic load balancer (ELB) access so the cluster can deploy the ELB for NGINX \n \n Go to  IAM  →  Roles  →  YOUR-EKS-ROLE \n Under  Add permissions , click  Attach policies \n Find each of these named policies and then click  Attach policies   \n AmazonEKSWorkerNodePolicy   \n AmazonEKS_CNI_Policy   \n AmazonEC2ContainerRegistryReadOnly   \n ElasticLoadBalancingFullAccess \n Go to  Trust Relationships  →  Edit trust policy  →  Add new statement . Add  ec2.amazonaws.com  so the cluster can manage the EC2 resources. \n \n \n \n Go to  Identity Management and Access on EKS  for more details on roles. \n Create the EKS Cluster \n \n Go to  Services  and select  Elastic Kubernetes Service \n Click  Add cluster  →  Create \n Add a cluster name, e.g. YOUR-CLUSTER-1 \n Select 1.21 for the Kubernetes version \n For  Cluster Service Role , select the role you created above, e.g. YOUR-EKS-ROLE \n Click  Next \n Use the defaults for  Networking  (Step 2) and click  Next \n Use the defaults for  Configure Logging  (Step 3) and click  Next \n Review your settings and then click  Create . Cluster provisioning may take several minutes. \n \n See  Creating an Amazon EKS Cluster  for more detailed information. \n Add a Node Group to the Cluster \n \n Go to  Services  →  Elastic Kubernetes Service  →  Clusters  and select YOUR-CLUSTER-NAME \n Go to  Configuration  →  Compute \n Click  Add Node Group  and supply the following fields\n \n Name : Give your group a name, e.g. YOUR-NODE-1 \n Node IAM Role : Select the cluster role you created above. If the role doesn\'t appear, verify that you modified the trust policy as noted above. \n Click  Next \n \n \n Review the  Node Group compute and scaling configuration . These AWS defaults will work fine:\n \n AMI type:  Amazon Linux 2 \n Instance type:  t3.medium \n \n \n Set the  Maximum size  to  5 . This is over-resourced for a Getting Started instance but offers capacity for adding microservices to your cluster without modifying the Node Group.\n \n Click  Next \n \n \n For  Node Group network configuration , the subnets should already be set up and selected \n Select  Configure SSH access to nodes . Follow the links to create a new SSH key pair if you don\'t already have one. \n Select  All  to allow all source IPs \n Click  Next \n Review your settings and then click  Create . It may take a few minutes for the Node Group to be created. \n Connect to the Cluster \n \n Note:  If this is a brand new setup, you will need to configure the AWS CLI using the user account from the steps above. You\'ll need to provide your Access Key ID, Secret Key, and Region. \n \n aws configure\n \n \n Set up your Kubernetes context \n \n aws eks --region REGION-CODE update-kubeconfig --name YOUR-CLUSTER-1\n \n For example:  aws eks --region us-east-2 update-kubeconfig --name cluster-1 . More details and troubleshooting can be found here.  https://docs.aws.amazon.com/eks/latest/userguide/create-kubeconfig.html \n \n Your current context should now be configured for your AWS cluster. Run the command below to check. \n \n kubectl config current-context\n \n Your output should look something like this:  arn:aws:eks:us-east-2:483173223614:cluster/cluster-1 \n Install the NGINX Ingress Controller \n Add the NGINX controller for the ingress. This step relies on your role having permissions for Elastic Load Balancing (ELB). \n \n Create the NGINX ingress controller \n \n kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.1.3/deploy/static/provider/aws/deploy.yaml\n \n \n Get the ELB external URL for your NGINX install \n \n kubectl get services -n ingress-nginx\n \n For example: \n NAME                                 TYPE           CLUSTER-IP       EXTERNAL-IP                        \ningress-nginx-controller             LoadBalancer   10.100.102.83    ad234bd11a1ff4dadb44639a6bbf707e-0e0a483d966405ee.elb.us-east-2.amazonaws.com\n \n The value of the external URL (EXTERNAL-IP) should be available within a few minutes. You\'ll use this address for YOUR-HOST-NAME in the steps below. \n TIP \n NGINX is working correctly if a  404 Not Found  NGINX error page is generated when accessing  http://YOUR-HOST-NAME  from your browser. For a more complete test, you can  set up a simple test application  using your local  kubectl . You can also  customize the NGINX ingress  to optimize the configuration for Entando. \n \n See the  NGINX AWS Guide  and  NGINX EKS Guide  for more details. \n Install the Entando Custom Resources \n \n Apply the cluster-scoped custom resource definitions (CRDs). This is required only once per cluster. \n \n kubectl apply -f https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/namespace-scoped-deployment/cluster-resources.yaml\n \n \n Create the namespace for the Entando Application \n \n kubectl create namespace entando\n \n \n Download the  entando-operator-config  template so you can configure the  Entando Operator . \n \n curl  -sLO  "https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/samples/entando-operator-config.yaml" \n \n \n Edit the  entando-operator-config.yaml  to set  data/entando.requires.filesystem.group.override: "true" \n \n data : \n    entando.requires.filesystem.group.override :   "true" \n    entando.ingress.class :   "nginx" \n \n \n Apply the  ConfigMap \n \n kubectl apply -f entando-operator-config.yaml -n entando\n \n \n Apply the namespace-scoped custom resources \n \n kubectl apply -n entando -f https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/namespace-scoped-deployment/namespace-resources.yaml\n \n \n You can use  kubectl get pods -n entando --watch  to see the initial pods start up. Use  Ctrl+C  to exit. \n \n $ kubectl get pods -n entando\nNAME                                   READY   STATUS    RESTARTS   AGE\nentando-k8s-service-86f8954d56-mphpr   1/1     Running   0          5m53s\nentando-operator-5b5465788b-ghb25      1/1     Running   0          5m53s\n Configure the Entando Application \n \n Download the  entando-app.yaml  template \n \n curl  -sLO  "https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/samples/entando-app.yaml" \n \n \n Edit  entando-app.yaml  and replace YOUR-HOST-NAME with the NGINX address from above. See the  Custom Resources overview  for details on other  EntandoApp  options. \n \n spec : \n   ingressHostName :  YOUR - HOST - NAME\n Deploy your Entando Application \n \n You can now deploy your application to your EKS cluster \n \n kubectl apply -n entando -f entando-app.yaml\n \n \n It can take around 10 minutes for the application to fully deploy. You can watch the pods warming up with this command: \n \n kubectl get pods -n entando --watch\n \n Use  Ctrl+C  to exit the command. \n \n Once all the pods are in a running state, access the Entando App Builder at the following address: \n \n http://YOUR-HOST-NAME/app-builder/\n \n Congratulations! To continue your journey with Entando, see the  Getting Started guide  for helpful login instructions and next steps. \n Appendix A - Troubleshooting \n IAM and Roles \n \n Installing aws-iam-authenticator \n AccessDenied error during AssumeRole operation \n \n NGINX \n \n Using NGINX as the ingress controller on EKS \n \n For more details and troubleshooting, see  Create a kubeconfig for Amazon EKS . \n'},{title:"Installation on Google Kubernetes Engine (GKE)",frontmatter:{},regularPath:"/next/tutorials/getting-started/gke-install.html",relativePath:"next/tutorials/getting-started/gke-install.md",key:"v-80517bb0",path:"/next/tutorials/getting-started/gke-install.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Cluster Setup",slug:"cluster-setup"},{level:3,title:"Install the NGINX Ingress Controller",slug:"install-the-nginx-ingress-controller"},{level:3,title:"Install the Entando Custom Resources",slug:"install-the-entando-custom-resources"},{level:3,title:"Configure the Entando Application",slug:"configure-the-entando-application"},{level:2,title:"Deploy Your Entando Application",slug:"deploy-your-entando-application"},{level:2,title:"Appendix: Configuring Clustered Storage",slug:"appendix-configuring-clustered-storage"},{level:3,title:"Clustered Storage Using GCP Cloud Filestore",slug:"clustered-storage-using-gcp-cloud-filestore"}],lastUpdated:"4/19/2022, 3:32:52 PM",lastUpdatedTimestamp:1650396772e3,content:' Installation on Google Kubernetes Engine (GKE) \n Prerequisites \n \n Google Cloud account:  http://cloud.google.com \n If you choose not to use the Google Cloud Shell, install the  Google Cloud SDK \n Cluster Setup \n These steps only need to be completed once per cluster. \n \n \n Login to your Google Cloud account:  https://cloud.google.com/ \n \n \n Go to  Kubernetes Engine  →  Clusters \n \n \n Select an existing project or create a new one \n \n \n Click  Enable  for the  Kubernetes Engine API \n \n \n Once the API is enabled, click  Create  to create a cluster \n \n \n Click the  Configure  button for the  GKE Standard  option. Unless otherwise indicated, you can keep the default configuration options. \n \n \n In the left menu, select  default-pool  →  Nodes \n \n \n Select "e2-standard-2" as the  Machine Type  if you are setting up a basic test cluster for a single Entando Application. Additional CPU and memory may be required for a shared cluster containing multiple Entando Applications or to improve performance. Refer to  Appendix A  for details on clustered storage. \n \n \n Click  Create . It may take a few minutes for the cluster to initialize. \n \n \n Click  Connect \n \n \n Click  Run in Cloud Shell . Alternatively, connect your local  kubectl  to the GKE cluster. \n \n \n Run  kubectl get node  to verify your connection. The output should list the nodes in your cluster. \n Install the NGINX Ingress Controller \n The following steps install the NGINX ingress controller to manage the ingresses for Entando services deployed by the operator. This is a simpler and more adaptable configuration for most users and environments. Users who require the GKE ingress controller (this is rare) can follow\n the integration instructions provided by GKE  and then customize the service definition created by the Entando operator. \n These are the mimimum instructions to prepare the NGINX ingress using the Google Cloud Shell.\nFor installation using your local  kubectl  or to vary other settings, refer to the  Ingress with NGINX guide  or the  GCE-GKE tutorial . \n \n Initialize your user as a cluster-admin \n \n kubectl create clusterrolebinding cluster-admin-binding --clusterrole cluster-admin  \\ \n--user  $( gcloud config get-value account ) \n \n \n Install the ingress controller pods \n \n kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/provider/cloud/deploy.yaml\n \n \n Get the external IP address for your ingress controller, e.g. the EXTERNAL-IP value of  nginx-ingress-controller , once the ingress-nginx pods are all running. Use  Ctrl+C  to exit the command once the EXTERNAL-IP is displayed. \n \n kubectl get  service  -n ingress-nginx --watch\n \n TIP \n NGINX is working correctly if a  404 Not Found  NGINX error page is generated when accessing the EXTERNAL-IP from your browser. For a more complete test, you can  set up a simple test application  using your local  kubectl . You can also  customize the NGINX ingress  to optimize the configuration for Entando. \n Install the Entando Custom Resources \n \n Download and apply the custom resource definitions (CRDs) to the cluster. This must be done once per cluster. \n \n kubectl apply -f https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/namespace-scoped-deployment/cluster-resources.yaml\n \n \n Create a namespace for the Entando Application. Here we call the namespace "entando". If you choose a different name, update the following commands whenever a namespace is provided. \n \n kubectl create namespace entando\n \n \n Download the  entando-operator-config  template so you can configure the  Entando Operator \n \n curl  -sLO  "https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/samples/entando-operator-config.yaml" \n \n \n Edit the  entando-operator-config.yaml  to add two properties \n \n data : \n    entando.requires.filesystem.group.override :   "true" \n    entando.ingress.class :   "nginx" \n \n \n Apply the  ConfigMap \n \n kubectl apply -f entando-operator-config.yaml -n entando\n \n \n Install the namespace-scoped resources \n \n kubectl apply -n entando -f https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/namespace-scoped-deployment/namespace-resources.yaml\n \n \n You can use  kubectl get pods -n entando --watch  to see the initial pods start up. Use  Ctrl+C  to exit. \n \n $ kubectl get pods -n entando\nNAME                                   READY   STATUS    RESTARTS   AGE\nentando-k8s-service-86f8954d56-mphpr    1 /1     Running    0           95s\nentando-operator-5b5465788b-ghb25       1 /1     Running    0           95s\n Configure the Entando Application \n \n Download the  entando-app.yaml  template \n \n curl  -sLO  "https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/samples/entando-app.yaml" \n \n \n Edit  entando-app.yaml . Replace  YOUR-HOST-NAME  with  EXTERNAL-IP + .nip.io . See  the EntandoApp custom resource overview  for additional options. \n \n spec : \n   ingressHostName :  YOUR - HOST - NAME\n \n e.g.  ingressHostName: 20.120.54.243.nip.io \n Deploy Your Entando Application \n You can now deploy your application to your GKE cluster. \n \n Deploy the Entando Application \n \n kubectl apply -n entando -f entando-app.yaml\n \n \n It can take around 10 minutes for the application to fully deploy. You can watch the pods warming up with the command below. Use  Ctrl+C  to exit. \n \n kubectl get pods -n entando --watch\n \n \n Once all the pods are in a running state, access the Entando App Builder at the following address \n \n http://YOUR-HOST-NAME/app-builder/\n \n See the  Getting Started guide  for helpful login instructions and next steps. \n Appendix: Configuring Clustered Storage \n In order to scale an Entando Application across multiple nodes, you must provide a storage class that supports\na  ReadWriteMany  access policy, e.g. by using a dedicated storage provider like GlusterFS. \n The example below uses the GCP Cloud Filestore to provide clustered storage. However, it is best practice to expose an existing enterprise clustered file solution as a StorageClass. \n TIP \n You do not need clustered storage to scale an Entando Application if you schedule all instances to the same node using a  ReadWriteOnce (RWO)  policy and taints on other nodes. Be aware of the impact to node resource allocation, as well as recovery if your application fails or becomes unreachable. Note that if the node fais or is shutdown, your application will be unresponsive while Kubernetes reschedules the pods to a different node. \n Clustered Storage Using GCP Cloud Filestore \n \n \n In the left menu of the GCP portal, find the Storage section and select  Filestore  ->  Instances \n \n \n Enable the Filestore if you haven\'t already \n \n \n Select  Create Instance \n \n \n Adjust the field values from the defaults as needed. Take note of your instance ID. \n \n \n Once the instance is created on the Filestore main page, note the IP address of your NFS \n \n \n Install the provisioner that creates the StorageClass to enable deployment of Entando Applications. Use the commands below, replacing YOUR-NFS-IP and YOUR-NFS-PATH with your instance ID and the IP address of your cluster. \n \n \n helm repo add nfs-subdir-external-provisioner https://kubernetes-sigs.github.io/nfs-subdir-external-provisioner/\n \n helm install nfs-subdir-external-provisioner nfs-subdir-external-provisioner/nfs-subdir-external-provisioner \\\n    --set nfs.server=YOUR-NFS-IP \\\n    --set nfs.path=YOUR-NFS-PATH\n \n Learn about the provisioner and additional configuration options here:\n https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner \n \n Verify that your client provisioned successfully by running the following command and looking for the storage class  nfs-client \n \n kubectl get sc\n \n Example output: \n NAME                 PROVISIONER                                     RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE\nnfs-client           cluster.local/nfs-subdir-external-provisioner   Delete          Immediate              true                   37m\npremium-rwo          pd.csi.storage.gke.io                           Delete          WaitForFirstConsumer   true                   27h\nstandard (default)   kubernetes.io/gce-pd                            Delete          Immediate              true                   27h\nstandard-rwo         pd.csi.storage.gke.io                           Delete          WaitForFirstConsumer   true                   27h\n \n \n Add these two variables to your operator  ConfigMap : \n \n entando.k8s.operator.default.clustered.storage.class: "nfs-client"\nentando.k8s.operator.default.non.clustered.storage.class: "standard"\n \n \n Deploy your Entando Application using the  instructions above . The server instances will automatically use the clustered storage. \n \n'},{title:"Installation on Red Hat OpenShift using the Operator",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/getting-started/openshift-install-by-operator.html",relativePath:"next/tutorials/getting-started/openshift-install-by-operator.md",key:"v-2f689e20",path:"/next/tutorials/getting-started/openshift-install-by-operator.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Add the Entando Operator to the OperatorHub",slug:"add-the-entando-operator-to-the-operatorhub"},{level:2,title:"Scenario 1 - Embedded Database",slug:"scenario-1-embedded-database"},{level:2,title:"Scenario 2 - PostgreSQL",slug:"scenario-2-postgresql"},{level:2,title:"Scenario 3 - PostgreSQL plus OpenShift SSL",slug:"scenario-3-postgresql-plus-openshift-ssl"},{level:2,title:"Scenario 4 - PostgreSQL plus Self-Signed SSL",slug:"scenario-4-postgresql-plus-self-signed-ssl"},{level:2,title:"Next Steps",slug:"next-steps"}],lastUpdated:"4/14/2022, 4:02:21 PM",lastUpdatedTimestamp:1649966541e3,content:" Installation on Red Hat OpenShift using the Operator \n Overview \n The following tutorial shows how to install an Entando Application using the Entando Operator and covers a few common enterprise configurations. You may also find the alternative  manual instructions  useful. \n Scenario 1 is similar to the Entando quickstart style of deployment which can be applied in many environments, including on developer laptops. The subsequent scenarios build on that initial setup but can also be performed independently. Unless otherwise noted, you have the freedom to keep or modify the default options when installing the Entando Operator and other resources. \n Prerequisites \n \n OpenShift 4.8.x \n Cluster-admin access to OpenShift for initial installation of the Entando Operator \n Familiarity with the OpenShift console and operation \n Add the Entando Operator to the OperatorHub \n A cluster admin can add the 7.0 version of the Entando Operator into the local OperatorHub using the following command. \n oc apply -f https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/samples/openshift-catalog-source.yaml\n Scenario 1 - Embedded Database \n The initial scenario deploys the operator and Entando Application into a single namespace. We start with the smallest application footprint by using an embedded database, although this is not recommended for production use cases. \n \n Locate the Entando Operator in the  Operators  →  OperatorHub . Make sure to select the appropriate version. \n Click  Install  to view the Entando Operator install options \n Select  A specific namespace on the cluster  for the  Installation mode \n Choose an empty namespace for  Installed Namespace . You can create one from  Home  →  Projects  first, if needed, e.g.  entando-one . \n Click  Install  to install the operator into your target namespace \n The install may take a few minutes to complete, after which you can click  View Operator  to see the operator in your namespace. You can also go to  Operators  →  Installed Operators  at any time and select it from there. \n Now go to  EntandoApp  and click  Create EntandoApp \n \n Keep the default  my-app  as your application name or select your own \n Select the EntandoApp version:  7.0 \n \n \n Provide an  Ingress Host Name  specific to your namespace, e.g.  my-app.YOUR-BASE-OPENSHIFT-URL . In CRC you can keep the default  entando.apps-crc.testing  for your first project. \n Change the  DBMS  value to  embedded . This is the lightest and quickest way to test a full Entando Application. However, a non-embedded relational database is strongly recommended for production use. \n Click  Create . The Entando Operator proceeds to deploy the appropriate resources. \n Go to  EntandoApp  →  my-app  to check the status of the deploy \n \n See the  Next Steps  below to continue your work with Entando. \n Scenario 2 - PostgreSQL \n For this scenario we prepare a more production-like configuration. Here we switch from an embedded on-disk database to a dedicated PostgreSQL database. This scenario starts where step 6 ends in the previous scenario. If you already ran Scenario 1, you can either go to that project and remove the EntandoApp and ProvidedCapabilities via  Installed Operators  →  Entando Operator  or prepare a new project using steps 1-5 above. \n Now create a new application, this time using PostgreSQL. \n \n Go to  EntandoApp  and click  Create instance \n \n Keep the default  my-app  as your application name or select your own \n Select the EntandoApp version:  7.0 \n \n \n Set the  Ingress Host Name  as in Scenario 1 above \n Keep the default  DBMS  value of  postgresql \n Click  Create . The Entando Operator now deploys the appropriate resources as in Scenario 1 but with the addition of a PostgreSQL database deployment. \n \n See the  Next Steps  below to continue your work with Entando. \n Scenario 3 - PostgreSQL plus OpenShift SSL \n This scenario sets up PostgreSQL, like Scenario 2, but also enables SSL using OpenShift's internal Certificate Authority (CA). As a starting point, you can either remove the EntandoApp and ProvidedCapabilities using the Entando Operator or you can prepare a new project per steps 1-5 in Scenario 1. \n \n Using your browser, examine and save the SSL certificate for your environment\n \n In Chrome, go to any OpenShift console page and click on  View Site Information  next to the URL. Note that it may be labeled  Not secure . \n Go to  Details  ->  Copy to File  and save the certificate as a Base-64 encoded X.509 file, e.g.  openshift.cer . \n \n \n Go to  Workloads  →  Secrets  →  Create  and select  Key/value secret \n Set the  Secret Name , e.g.  entando-ca-cert-secret \n Set the  Key , e.g.  openshift.cer \n Set the  Value  by clicking  Browse...  and loading the file you saved in Step 1 \n Click  Create \n Next, go to  Workloads  →  ConfigMaps  and create or update the ConfigMap named  entando-operator-config . This is the ConfigMap used by the operator to configure the deployments. You can  download the Entando Operator template  as a starting point. Set the \"data/entando.ca.secret.name\" to match the name from step 3. \n \n data : \n  entando.ca.secret.name :  entando - ca - cert - secret\n  entando.use.auto.cert.generation :   'true' \n \n \n Click  Create \n \n Now let's create a new application similar to Scenario 2, but with OpenShift SSL in place. \n \n Go to  EntandoApp  and click  Create instance \n \n Keep the default  my-app  as your application name or select your own \n Select the EntandoApp version:  7.0 \n Set the  Ingress Host Name  as in Scenario 1 above \n Keep the default  DBMS  value of  postgresql \n \n \n Click  Create . The Entando Operator proceeds to deploy the appropriate resources. \n \n Once the deployment is complete, you can confirm that all routes use HTTPS with OpenShift's CA. You may still see security warnings in the browser. \n See the  Next Steps  below to continue your work with Entando. \n Scenario 4 - PostgreSQL plus Self-Signed SSL \n This scenario is similar to Scenario 3, but here you'll use a self-signed certificate instead of a certificate provided by OpenShift's internal Certificate Authority. As a starting point, you can either remove the EntandoApp and Provided Capabilities from the previous scenarios or prepare a new project per steps 1-5 in Scenario 1. \n Start by creating a self-signed certificate and then prepare the Secrets and ConfigMap to match. There are various ways to create an X.509 self-signed certificate, so you can use your preferred mechanism. \n \n Using  OpenSSL , create a certificate for your application. You'll need to adjust the Common Name (CN) value to match the  Ingress Host Name  for your project. \n \n openssl req -nodes -x509 -newkey rsa:4096 -keyout tls.key -out tls.crt -days  365  -subj  \"/CN=entando.apps-crc.testing\" \n \n You should see output similar to this: \n Generating a RSA private key\n .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .++++\n .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ++++\nwriting new private key to  'tls.key' \n-----\n \n Now you can create a TLS Secret using the generated files. \n \n Go to  Workloads  →  Secrets  →  Create  and select  From YAML . Use the following YAML as a starting point and then click  Create . \n \n kind :  Secret\n apiVersion :  v1\n metadata : \n   name :  entando - tls - secret\n data : \n   tls.key :   '' \n   tls.crt :   '' \n type :  kubernetes.io/tls\n \n \n Click on  Actions  →  Edit Secret  and use the  Browse...  buttons to upload the key and cert files. \n \n Now create the  entando-ca-cert-secret  Secret, similar to what was done in Scenario 3, but this time using the self-signed certificate. \n \n Go to  Workloads  →  Secrets  →  Create  and select  Key/value secret \n Set the  Secret Name , e.g.  entando-ca-cert-secret \n Set the  Key , e.g.  tls.crt \n Set the  Value  by clicking  Browse...  and loading the cert file from Step 1, e.g.  tls.crt \n Click  Create \n Next, go to  Workloads  →  ConfigMaps  and update or create a ConfigMap named  entando-operator-config . This is the ConfigMap used by the operator to configure the deployments. You can  download the Entando Operator template  as a starting point. Set the \"data/entando.ca.secret.name\" and \"data/entando.tls.secret.name\" to match the names from above. \n \n data : \n  entando.ca.secret.name :  entando - ca - cert - secret\n  entando.tls.secret.name :  entando - tls - secret\n \n \n Click  Create \n \n Now let's create a new application similar to Scenario 3, but with the self-signed SSL certificate. \n \n Go to  EntandoApp  and click  Create instance \n \n \n Keep the default  my-app  as your application name or select your own \n Select the EntandoApp version:  7.0 \n Set the  Ingress Host Name  as in Scenario 1 above. It should match the CN used to generate the certificate in step 1. \n Keep the default  DBMS  value as  postgresql \n \n \n Click  Create . The Entando Operator now proceeds to deploy the appropriate resources. \n \n Once the deployment is complete, you can confirm that all routes use HTTPS with the self-signed certificate. You may still see security warnings in the browser. \n See the  Next Steps  below to continue your work with Entando. \n Next Steps \n Once you've completed any of the scenarios above, you have several options. \n \n Check out  Networking  →  Routes  to see the URLs for the running services. Common starting points include the Entando App Builder (e.g.  http://entando.apps-crc.testing/app-builder/ ) or the Entando Application itself (e.g.  http://entando.apps-crc.testing/entando-de-app/ ). \n See the  Entando Operator Configuration  for options related to timeout settings and the default image registry. \n This suggested  list of next steps  could also be useful. \n \n \n"},{title:"Installation on OpenShift",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/getting-started/openshift-install.html",relativePath:"next/tutorials/getting-started/openshift-install.md",key:"v-cb6fc90c",path:"/next/tutorials/getting-started/openshift-install.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:3,title:"Local Installation",slug:"local-installation"},{level:2,title:"Create the Project",slug:"create-the-project"},{level:2,title:"Configure the Project",slug:"configure-the-project"},{level:2,title:"Configure the Entando Application",slug:"configure-the-entando-application"},{level:2,title:"Deploy the Entando Application",slug:"deploy-the-entando-application"},{level:2,title:"Next Steps",slug:"next-steps"},{level:2,title:"Appendix - Troubleshooting and Common Errors",slug:"appendix-troubleshooting-and-common-errors"},{level:3,title:"Permission Errors",slug:"permission-errors"},{level:3,title:"Forbidden Error Installing Entando Custom Resource Definitions in CRC",slug:"forbidden-error-installing-entando-custom-resource-definitions-in-crc"},{level:3,title:"Network Issues",slug:"network-issues"}],lastUpdated:"4/20/2022, 3:43:01 PM",lastUpdatedTimestamp:1650483781e3,content:" Installation on OpenShift \n Overview \n This tutorial shows how to manually install Entando into OpenShift 4.8.x.  Installation via the  Entando Operator is highly recommended for OpenShift 4.6+.  See the  Installation on Red Hat OpenShift using the Operator tutorial  for specific instructions. \n Prerequisites \n \n An OpenShift 4.8.x installation \n The  OpenShift CLI , e.g.  oc \n Local Installation \n You can run OpenShift 4.8.x in your local development environment with Code Ready Containers (CRC). Use the local development version for the cluster where you intend to deploy your application. See  https://developers.redhat.com/products/codeready-containers/download  for more details. \n Create the Project \n The steps in this section require cluster admin access. If you are using CRC, make sure to use the administrator login provided when you started your local instance. \n \n Login to your OpenShift environment. There are two options: \n \n \n Use the  oc login  command, which can be found under the profile menu in OpenShift. \n \n oc login --token = sha256~TO3QCeoLSbprlGZARBOBVAoaKFeb9Ag0RxztYifAcjE --server = https://api.cluster-4bb2.4bb2.example.opentlc.com:6443\n \n \n Use the command line interface from the OpenShift Console. \n \n \n Install the cluster-scoped custom resource definitions (CRDs). This step is only required once per cluster. \n \n oc apply -n entando -f https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/namespace-scoped-deployment/cluster-resources.yaml\n \n \n Create the project for your application \n \n oc new-project entando\n \n Note: If you choose a different name for your project, adjust the commands below to supply your project name (e.g.  -n YOUR-PROJECT ) or use the  oc project  command to select the project. \n The remaining steps in this tutorial can be performed by a user with project-level access, rather than a cluster admin. \n Configure the Project \n \n Install the namespace-scoped custom resources \n \n oc apply -n entando -f https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/namespace-scoped-deployment/namespace-resources.yaml\n \n \n (Optional) A ConfigMap can be used to modify the behavior of the Entando Operator. Refer to the  Entando Operator  page for more information. \n Configure the Entando Application \n \n Download the  entando-app.yaml  template \n \n curl  -sLO  \"https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/samples/entando-app.yaml\" \n \n \n Determine the hostname for your application, YOUR-HOST-NAME \n \n \n If you're deploying to a managed cluster:\n \n Determine the default hostname of your cluster. If you're unsure of the default hostname, please check with your cluster administrator. \n Add a prefix with the name of your project or application. For example, YOUR-HOST-NAME could be  my-app.apps.cluster-4bb2.4bb2.example.opentlc.com , where  apps.cluster-4bb2.4bb2.example.opentlc.com  is the hostname of the OpenShift cluster. \n Entando creates the application using this address and relies on wildcard DNS resolution. \n \n \n If you're using CRC:\n \n Determine the IP address (YOUR-IP) of your cluster with  crc ip \n Your IP-based YOUR-HOST-NAME should follow this pattern:  quickstart.YOUR-IP.nip.io , e.g.  quickstart.192.168.64.33.nip.io . The suffix  .nip.io  makes use of the free  nip.io  DNS service so that any requests to this host name will resolve to your CRC instance. The prefix  quickstart  is arbitrary. \n \n \n \n \n Edit  entando-app.yaml  and replace YOUR-HOST-NAME with the address from above. See the  Custom Resources overview  for details on other  EntandoApp  options. \n \n spec : \n   ingressHostName :  YOUR - HOST - NAME\n \n \n (Optional) If you used a name other than \"entando\" for your project, you'll also want to update the metadata/namespace property in  entando-app.yaml  to match. \n Deploy the Entando Application \n \n Deploy Entando \n \n oc apply -n entando -f entando-app.yaml\n \n \n It can take around 10 minutes for the application to fully deploy. You can watch the pods warming up with this command: \n \n oc get pods -n entando --watch\n \n Use  Ctrl+C  to exit the command. \n \n Once all the pods are in a running state, access the Entando App Builder at the following address: \n \n http://YOUR-HOST-NAME/app-builder/\n Next Steps \n Congratulations! To continue your journey with Entando, see the  Getting Started guide  for helpful login instructions and next steps. \n Appendix - Troubleshooting and Common Errors \n Permission Errors \n If deploying your Entando Application into your OpenShift namespace generates permission errors, make sure the namespace you're deploying to has the  escalate  and  bind  verbs on Roles. Before installing Entando, run  oc auth can-i escalate role  with your given user in the targeted namespace. If  yes  is returned, the installation should complete. Note that access is only required in the namespace where you are deploying your Entando Application. No cluster level access is required. \n Check with your cluster administrator if you need help assigning Roles. Generally, this requires the creation of a Role, preferably a ClusterRole with the above permissions. Your Entando installer needs to be given this Role in the target namespace, in accordance with how administrators manage security. For example, if the ClusterRole is  entando-installer  and the user's name is John, you can add the Role to the user with this command:\n oc policy add-role-to-user entando-installer john -n <your-namespace> . \n Forbidden Error Installing Entando Custom Resource Definitions in CRC \n If installing the CRDs in your local instance generates an error like the one below, you need to login as an administrator. \n /opt/ocInstallLocal$ oc create -f dist/crd/\nError from server (Forbidden): error when creating \"dist/crd/EntandoAppCRD.yaml\": customresourcedefinitions.apiextensions.k8s.io is forbidden: User \"developer\" cannot create resource \"customresourcedefinitions\" in API group \"apiextensions.k8s.io\" at the cluster scope\n \n Administrator credentials are printed when you start your local cluster. For example: \n To access the cluster, first set up your environment by following 'crc oc-env' instructions\nINFO Then you can access it by running 'oc login -u developer -p developer https://api.crc.testing:6443'\nINFO To login as an admin, username is 'kubeadmin' and password is xxxx-xxxx-xxxx-xxxx\n Network Issues \n If you see errors when images are being retrieved (such as ErrImagePull or ImagePullBackOff), you may want to start CRC using  crc start -n \"8.8.8.8 , or configure the nameserver with  crc config set nameserver 8.8.8.8  before running  crc start . This will allow the cluster to perform DNS lookups via Google's public DNS server. \n If you're on Windows, you should also check out these  Tips and Tricks  since CRC relies on Windows Hyper-V by default. This can result in network issues when the host computer is restarted. \n"},{title:"Entando Hub",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/solution/entando-hub.html",relativePath:"next/tutorials/solution/entando-hub.md",key:"v-e707fb34",path:"/next/tutorials/solution/entando-hub.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Installation",slug:"installation"},{level:3,title:"Prerequisites",slug:"prerequisites"},{level:3,title:"Automatically Access the Hub from the App Builder",slug:"automatically-access-the-hub-from-the-app-builder"},{level:3,title:"Manual Installation Steps",slug:"manual-installation-steps"},{level:2,title:"Configuration",slug:"configuration"},{level:2,title:"Using the Hub",slug:"using-the-hub"},{level:3,title:"Concepts",slug:"concepts"},{level:3,title:"Roles",slug:"roles"},{level:3,title:"Bundle Group Version Status",slug:"bundle-group-version-status"},{level:3,title:"Bundle Group Creation",slug:"bundle-group-creation"},{level:3,title:"Bundle Group Versions",slug:"bundle-group-versions"},{level:2,title:"Application Details",slug:"application-details"},{level:3,title:"Micro Frontends / Widgets",slug:"micro-frontends-widgets"},{level:3,title:"Microservices",slug:"microservices"},{level:3,title:"Content",slug:"content"},{level:3,title:"Integration",slug:"integration"},{level:2,title:"Resources",slug:"resources"},{level:3,title:"Source Code",slug:"source-code"}],lastUpdated:"4/18/2022, 2:36:36 PM",lastUpdatedTimestamp:1650306996e3,content:' Entando Hub \n Overview \n The Entando Hub enables a team to share components across Entando Applications. It can be installed in Entando 6.3.2 or higher and includes API-level integration with the Entando 7.0 App Builder. \n The Hub allows users to: \n \n Centralize components and business capabilities for use across teams, groups, or clients. \n Publish, manage and communicate component features, versions and metadata. \n Perform business-level assessment of component readiness. \n \n This tutorial covers: \n \n Installation \n Configuration \n Using the Hub \n Application Details \n Resources \n Installation \n The Hub is installed using the Entando Component Repository (ECR) and two Entando Bundles.  The first bundle contains the Hub micro frontends and microservices, and the second sets up the initial content and pages for the Hub user experience. \n Prerequisites \n \n An Entando Application on any Kubernetes provider. Follow the  tutorials  appropriate to your environment to install the Entando platform. \n The  ent command line tool , installed and connected to your Kubernetes instance. \n Automatically Access the Hub from the App Builder \n \n Login to your App Builder \n Go to  Repository  →  Select Registry \n Choose  New Registry \n In the pop-up window, enter  Entando Hub  and  https://entando.com/entando-hub-api/appbuilder/api  for the URL, then  Save \n Click on the Hub in the Registry and continue with the tutorial at Step 4 below \n Manual Installation Steps \n \n Apply the Custom Resource Definitions for the Hub component bundles. \n \n ent ecr deploy --repo="https://github.com/entando-samples/entando-hub-application-bundle.git"\n \n ent ecr deploy --repo="https://github.com/entando-samples/entando-hub-content-bundle.git"\n \n \n \n Log into your App Builder instance. \n \n \n Select  Repository  from the menu on the left. Your bundles will be visible in the repository as shown in the screenshot below. \n \n \n \n \n \n Select  Install  for each bundle, where order of installation is important. The  entando-hub-application-bundle  must be installed first because it provides the  entando-hub-content-bundle  with MFEs. It may take several minutes to download the Docker images for the microservices and install related assets. \n \n \n Set up permissions to configure the service: \n \n Login to your Keycloak instance  as an admin. \n Give at least one user the ability to manage the Hub by granting the  eh-admin  role. Assign the  eh-admin  role for the  pn-cee95efc-77ff566e-entandopsdh-entando-hub-catalog-ms-server  client. See  Role Assignment in ID Management  for more details. \n Give the generated plugin client permission to manage users.\n \n From the left sidebar, go to  Clients  and select client ID  pn-cee95efc-77ff566e-entandopsdh-entando-hub-catalog-ms-server . \n Click the  Service Account  tab at the top of the page and select  realm-management  from the  Client Roles  field. \n Choose  realm-admin  from  Available Roles . Click  Add selected . It should appear as an  Assigned Role . \n \n \n \n \n \n Access the Hub from the App Builder by navigating to  Pages → Management , finding  Entando Hub  in the page tree, and clicking  View Published Page  from its actions. \n Configuration \n TIP \n (New with Entando 7.0.0) Any Hub instance can be accessed from the Entando App Builder of another Entando Application. Configure the App Builder to access the desired Hub instance via the endpoint  BASEURL/entando-hub-api/appbuilder/api , where the BASEURL is the URL for the Entando Application. \n Using the Hub \n Concepts \n The key entities in the Entando Hub are: \n \n Bundle Group : A Bundle Group is a group of one or more Entando Bundles. \n Bundle Group Version : A Bundle Group can have one or more versions, each with a particular status. \n Bundle : A Bundle is the deployment unit within an Entando Application. A Bundle can contain one or multiple components such as micro frontends, microservices, or any of the  component types  available in Entando. \n Category : Each Bundle Group belongs to a specific category. The initial possible categories are Solution Template, Packaged Business Capability (PBC), or Component Collection. An admin of an Entando Hub can refine the available categories as desired. \n Organization : Bundle Groups belong to a single organization. Authors and managers can only update Bundle Groups for their own organization. \n User : User identity is managed within Keycloak, where users are granted roles within the Hub. Users must be assigned to a specific organization. \n \n Notes: \n \n A private repository can be used for a Bundle, but this requires  an additional Kubernetes secret  before deployment via the App Builder. \n Roles \n Three roles are used to provide access to the Hub features: \n \n eh-author : An author can create and edit Bundle Groups for their organization and submit them for publication. \n eh-manager : A manager has the permissions of an author, but can also approve a publication request for their organization. \n eh-admin : An admin has full access to create, update, and delete Bundle Groups for the entire Hub instance. An admin can also create categories and organizations, and assign users to an organization. \n guest : Any user without one of the preceding roles is considered a guest in the Entando Hub and is given a read-only view of the public catalog. This is also true for unauthenticated users. \n Bundle Group Version Status \n The possible statuses for the versions of a Bundle Group are: \n \n Draft : This is the default status for the first version of a Bundle Group. \n Publication Request : An eh-author sets a version to this status to request an eh-manager or eh-admin to review the version and mark it for publication. An eh-manager or eh-admin may edit versions with this status. \n Published : Versions with this status are visible in the home page list of available Bundle Groups and also available in the App Builder-facing API. An eh-manager or eh-admin may edit Published versions. \n Archived : Previously Published versions are assigned this status. No edits can be made on an Archived version. \n Deletion Request : An eh-manager or eh-admin can delete versions once this status has been set. \n \n Notes: \n \n An eh-author can change any field except Organization while a version is in Draft. \n There is no automated notification process when a Publication Request is made for a Bundle Group version. \n Bundle Group Creation \n Clicking the  Add +  button at the top of the page displays the form for creating a new Bundle Group: \n Bundle Group Versions \n The list of Bundle Group Versions can be seen by clicking  View Versions  on any entry in the catalog: \n \n Notes: \n \n Once the first version of a group is published, the organization, name, and category can no longer be changed. \n A new version of a Bundle Group can be created (via the  New Version  option) after the first version has been published. \n There can be at most two active versions: one Draft or Publication Requested version and one Published version. \n When a new version is published, the previous version is set to Archived. \n Archived versions are only visible in the versions view and are not shown elsewhere in the user interface. \n Application Details \n The Hub includes the following key components: \n Micro Frontends / Widgets \n \n Entando Hub App : This is the main micro frontend which contains the management UI for the Hub entities noted above. \n Entando Hub Login : This is an optional login component which can be used in a page’s top navigation. \n Microservices \n A single Spring Boot microservice provides two REST endpoints: \n \n The first is a backend-for-a-frontend (BFF) service for the Hub UI and contains the various entity APIs. \n The second provides methods that support the Entando App Builder integration (7.0.0+). \n Content \n The Hub content bundle ( entando-hub ) includes a custom template and a page preconfigured with the main Hub micro frontends. \n Integration \n The Entando App Builder should be configured using the endpoint  BASEURL/entando-hub-api/appbuilder/api , where the BASEURL is the URL for the Entando Application. \n Resources \n Source Code \n Entando open source examples and tutorials are available on GitHub. Reference the Hub sample project for instructions to build the project from source code: \n \n https://github.com/entando-samples/entando-hub \n \n'},{title:"Entando Customer Portal",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/solution/customer-portal.html",relativePath:"next/tutorials/solution/customer-portal.md",key:"v-3f00ca34",path:"/next/tutorials/solution/customer-portal.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Installation",slug:"installation"},{level:3,title:"Prerequisites",slug:"prerequisites"},{level:3,title:"Automatic Install via the Entando Hub",slug:"automatic-install-via-the-entando-hub"},{level:3,title:"Manual Install",slug:"manual-install"},{level:2,title:"Configuration",slug:"configuration"},{level:3,title:"Administrators",slug:"administrators"},{level:3,title:"Jira Service Management",slug:"jira-service-management"},{level:3,title:"Configure the Customer Portal",slug:"configure-the-customer-portal"},{level:3,title:"Entando Identity Management System",slug:"entando-identity-management-system"},{level:2,title:"Managing the Customer Portal",slug:"managing-the-customer-portal"},{level:2,title:"Using the Customer Portal",slug:"using-the-customer-portal"},{level:2,title:"Resources",slug:"resources"}],lastUpdated:"4/18/2022, 2:36:36 PM",lastUpdatedTimestamp:1650306996e3,content:' Entando Customer Portal \n Overview \n The Entando Customer Portal enables an organization to quickly provide a modern, self-service customer-facing application for managing subscriptions. It includes a lightweight integration to Jira Service Management for access to service tickets and a role based access control (RBAC) design for granting users varying levels of access. \n Key Features: \n \n Customizable service ticket tracking system with Jira Service Management \n Role based access control with Entando Identity Management System \n Integrated user, customer, project, and subscription management \n \n This tutorial covers: \n \n Installation \n Configuration \n Managing the Customer Portal \n Using the Customer Portal \n Resources \n Installation \n Prerequisites \n \n A working instance of Entando running on Kubernetes. See  Getting Started  for more information or  install Entando on any Kubernetes provider . \n Use the Entando CLI command  ent check-env develop  to verify all dependencies. \n A Jira Service Management account. \n Automatic Install via the Entando Hub \n Install the Customer Portal in two steps by integrating the Entando Hub into your App Builder. \n \n \n Log into your  App Builder  →  Repository  →  Select Registry  → choose  Entando Hub  if it has been configured. \n \n If not, choose  New Registry \n In the pop-up window, enter  Entando Hub  and  https://entando.com/entando-hub-api/appbuilder/api  for the URL, then  Save \n Click on the Hub in the Registry \n \n \n \n From the Hub Catalog,  Deploy  and  Install  the Customer Portal application first, then the content bundle. \n \n \n Set up permissions to configure the service: \n \n Login to your Keycloak instance  as an admin. \n Give at least one user the ability to manage the Customer Portal by granting the  cp-admin  role. Assign the  cp-admin  role for the  pn-a71d68dd-166dc0f4-entandodemo-customerportal-server  client. See  Role Assignment in ID Management  for more details. \n Give the generated plugin client permission to manage users.\n \n From the left sidebar, go to  Clients  and select client ID  pn-a71d68dd-166dc0f4-entandodemo-customerportal-server . \n Click the  Service Account  tab at the top of the page and select  realm-management  from the  Client Roles  field. \n Choose  realm-admin  from  Available Roles . Click  Add selected . It should appear as an  Assigned Role . \n \n \n \n \n \n To navigate to your CP: \n \n From the sidebar →   Page  →  Management \n Find the  Customer Portal  folder \n From the  Actions  pull-down menu →   View Published Page \n Manual Install \n \n To install the Customer Portal manually, run the following commands. \n \n ent ecr deploy --repo = "https://github.com/entando-samples/customerportal-application-bundle.git" \n \n ent ecr deploy --repo = "https://github.com/entando-samples/customerportal-content-bundle.git" \n \n \n \n Log into the App Builder. \n \n \n Go to the  Repository  from the left sidebar. Two Customer Portal bundles will be visible there.  Install  the  customerportal-application-bundle  first, then the  customerportal-content-bundle . \n \n \n To navigate to your CP: \n \n From the sidebar →  Page  →  Management \n Find the  Customer Portal  folder \n From the  Actions  pull-down menu →  View Published Page \n Configuration \n Administrators \n In order to configure the Customer Portal and its users, the administrator will need Jira Service Management and Entando Identity Management System credentials. In this step, the admin connects the CP to Jira and customizes its features. \n Note: \n \n The built-in mapper for email must be enabled on the server client so that user accounts can be retrieved from Jira and new tickets can use that account information. \n Jira Service Management \n The administrator utilizes Jira Service Management to create users and projects, define the organization, and configure the service ticket system. \n Users who need access to the Customer Portal, beyond subscription and project information, must have a Jira Service Management account. \n \n Go to Customers to add organizations and projects. Once added, click on the name of the organization to get the ID, needed later, from the URL.  \ne.g. example.com/jira/servicedesk/projects/ECS/organization/3 → the Organization ID is “3” \n Configure the Customer Portal \n The Customer Portal must be configured to accommodate a specific Jira Service Management instance. The  CP Admin Config  page is where you will establish the Jira connection, manage product versions, define subscription levels, and customize ticket types. \n To access the  CP Admin Config  page, you must be given the  cp-admin  role in the  Entando Identity Management System  as outlined below. \n Go to the  CP Admin Config  page: \n \n In the App Builder, go to  Pages  and select  Management . \n Open the Customer Portal folder and find  CP Admin Config . \n From the  Action  drop-down menu on the right, go to  View Published Page . \n \n \nOnce the Ticketing System Connection is set up with Jira and the correct URL, default parameters such as product versions and ticket types will be displayed. Open each section with the down arrow to add and edit the fields as needed. \n Entando Identity Management System \n Logging into the Entando Identity Management System, you will see the landing page shown here. Like the App Builder, the left navigation bar is your guide for managing users, groups, and most importantly, roles. Using the RBAC model, define what access users have by the roles and groups they are assigned. Some important guidelines are noted below. \n \n \n \n Define the Realm Setting .  \nThe  Realm  is a set of users, credentials, roles, and groups. A user belongs to and logs into a  Realm . \n \n \n Create Roles \nYou can use the default roles by clicking on  Client Roles  and choosing  entandodemo-customerportal-server . Access for each role is defined as follows: \n \n cp-customer  -  assigned directly to specific projects for a single customer \n cp-partner  - assigned directly to specific projects for multiple customers \n cp-support  -  read only view of all customer projects \n cp-admin  - admin access for the Customer Portal \n \n \n \n Create New Users : \n \n \n \n \n From the sidebar, go to  Users . Click  Add User  at right. \n \n \n Complete the form as needed but note the requirements for these fields: \n Username : a unique name \n Email : must use the same address used in Jira \n User Enabled  → On \n Save \n \n \n Send an email to the user to activate their account and set a new password:  \nGo to the  Credentials  header  \nUnder  Credential Reset , in the  Reset Actions  →  Update Password    \nClick  Send Email \n \n \n Go to Role Mapping: \n \n Select the appropriate roles from  Available Roles  and click  Add Selected  to assign. \n Choose  entandodemo-customerportal-server  from the  Client Roles  pull-down options to assign default roles. \n A full administrative user will need the  realm-admin  role under  Client Roles  →  realm-management  in order to manage users in the Portal. \n Check the  Effective Roles  column on the right to ensure the correct roles have been assigned. \n \n \n \n \n \n Under  Groups , assign roles to groups as needed. Roles are additive. \n Managing the Customer Portal \n As administrator for the Customer Portal, you can create and manage users, customers, projects, and subscriptions. You can assign projects to users who have activated their account on Jira and have been assigned roles in the Entando Identity Management System. \n \n \n Create a Customer or Partner \nCreating a  Customer  and  Partner  is a similar process. Below are the steps for adding a  Customer . Follow the same procedure for adding a  Partner . \n \n \n Click  Add a Customer \n Fill in the details. Note the following:\n \n The  Customer Number  must be unique \n The  Notes  field is visible only to  support  and  admin  users \n \n \n \n \n \n Create and Assign Projects \n \n \n From the CP landing page, click on any customer to see the associated project list. \n To create a new project:\n \n Click  Add a Project . \n Enter the  Project  information. \n Provide the Organization ID from Jira. Each project must have a unique Organization ID. \n Click  Save . \n \n \n To assign  Projects :\n \n From the  Action  drop-down menu →   Manage Users . \n Select the user for the  Project . \n Click  Submit . \n \n \n \n \n Manage Partners and Subscriptions   \nUse the  Action  drop-down menu to manage Partners, and request and manage subscriptions. \n Using the Customer Portal \n To access the Customer Portal, your organization administrator needs to provide you with the proper user credentials. You can then create and track service tickets as well as request subscriptions. \n Once you login to the Customer Portal, you will see a list of customers. Click on a customer to view details and track their projects. \n \n To create a  Service Ticket  for a project:  \nfrom the  Action  pull-down menu →  Open Ticket . \n \n \n \n To request a Subscription or track Tickets:  \nuse the  Action  pull-down menu and select the corresponding option. \n Resources \n \n \n Go to  Jira Service Management  for more information. \n \n \n The  source code  for the Entando Customer Portal can be found with our other open source examples and tutorials on GitHub at:  https://github.com/entando-samples/customer-portal/ \n \n \n'},{title:"Entando Standard Banking Demo",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/solution/install-standard-demo.html",relativePath:"next/tutorials/solution/install-standard-demo.md",key:"v-8adc6c34",path:"/next/tutorials/solution/install-standard-demo.html",headers:[{level:2,title:"Installation",slug:"installation"},{level:3,title:"Prerequisites",slug:"prerequisites"},{level:3,title:"Automatic Install via the Entando Hub",slug:"automatic-install-via-the-entando-hub"},{level:3,title:"Manual Install",slug:"manual-install"},{level:2,title:"Application Details",slug:"application-details"},{level:3,title:"Micro Frontends (MFE)",slug:"micro-frontends-mfe"},{level:3,title:"Configuration Micro Frontends",slug:"configuration-micro-frontends"},{level:3,title:"Microservices",slug:"microservices"},{level:3,title:"Static Widgets",slug:"static-widgets"},{level:3,title:"Static CMS Content",slug:"static-cms-content"},{level:2,title:"Source Code",slug:"source-code"}],lastUpdated:"4/18/2022, 2:36:36 PM",lastUpdatedTimestamp:1650306996e3,content:' Entando Standard Banking Demo \n This tutorial will guide you through installing a demo application using the Entando Component Repository (ECR) and a set of Entando\nbundles. This solution template includes: \n \n microservices \n micro frontends \n multiple pages \n CMS content \n \n The goal of this exercise is to demonstrate how Entando bundles can be used to: \n \n quickly install and create functionality in an Entando Application \n enable packaged business capabilities \n allow developers to reuse full stack operations via bundles \n \n Some of the key elements of the template are reviewed in the  Application Details section  below. \n Installation \n There are numerous assets installed as part of the Standard Banking Demo. Entando Bundles can include more or less components, depending on objectives. It is recommended that organizations develop guidelines for bundle sizing that fit the goals of their applications and teams. \n Prerequisites \n \n A working instance of Entando running on Kubernetes.  Install Entando on any Kubernetes provider  or see  Getting Started  for more information. \n The ent command line tool, installed and connected to your Kubernetes instance. \n Automatic Install via the Entando Hub \n Install the Standard Banking Demo by integrating the Entando Hub into your App Builder. \n \n \n Log into your  App Builder  →  Repository  →  Select Registry  → choose  Entando Hub  if it has been configured. \n \n If not, choose  New Registry \n In the pop-up window, enter  Entando Hub  and https://entando.com/entando-hub-api/appbuilder/api for the URL, then  Save \n Click on the Hub in the Registry \n \n \n \n From the Hub Catalog,  Deploy  and  Install  the four Standard Banking Demo bundles, where order of installation is important. The  standard-demo-content-bundle  will need to be installed last, as it relies on MFEs from the other bundles to set up each of the pages. \n \n standard-demo-banking-bundle \n standard-demo-customer-bundle \n standard-demo-manage-users-bundle \n standard-demo-content-bundle \n \n \n \n To navigate to the Standard Demo: \n \n From the sidebar →   Page  →  Management \n Find  Home SD  in the page tree \n From the  Actions  pull-down menu →   View Published Page \n Manual Install \n \n Apply the definitions for the four bundles that comprise the Standard Banking Demo. \n \n ent ecr deploy --repo="https://github.com/entando-samples/standard-demo-banking-bundle.git"\n \n ent ecr deploy --repo="https://github.com/entando-samples/standard-demo-customer-bundle.git"\n \n ent ecr deploy --repo="https://github.com/entando-samples/standard-demo-manage-users-bundle.git"\n \n ent ecr deploy --repo="https://github.com/entando-samples/standard-demo-content-bundle.git"\n \n \n \n Log into your App Builder instance. \n \n \n Select  Repository  from the menu on the left. Your bundles will be visible in the repository as shown in the screenshot below.\n \n \n \n Select  Install  for each bundle, where order of installation is important. The  standard-demo-content-bundle  will need to be installed last, as it relies on MFEs from the other bundles to set up each of the pages.\n \n \n \n Each installation can take several minutes while the application downloads the Linux images for the microservices and installs the related assets. The  standard-demo-banking-bundle  and  standard-demo-customer-bundle  include microservices that require the initialization of containers and will take longer to install. \n In the unlikely event you encounter conflicts during an initial installation, you will be presented with an Installation Plan like the one shown below. Select  Update All  in the upper right after making your selections.\n \n \n Access the Standard Banking Demo via one of the following options: \n \n Option 1  If you\'d like to make the Standard Banking Demo your default home page, go to  App Builder → Pages → Settings . In\nthe dropdown for Home Page, select  Home / Home SD  and click  Save .\n \n You can now navigate to your application\'s home page using the home icon in the upper right of the App Builder. \n Option 2  Alternatively, you can view the Standard Banking Demo home page by going to  Pages → Management , finding  Home SD  in the page tree, and clicking  View Published Page  from its actions. \n Application Details \n The Entando Standard Banking Demo application demonstrates a number of the major features of the Entando platform, including: \n \n Keycloak integration for role based access controls \n Micro frontends implemented using React and Angular and co-existing on the same dashboard page \n Micro frontend communication techniques \n Microservices via Spring Boot \n Entando Content Management \n Micro Frontends (MFE) \n The application includes six MFEs in which the above features complement one another to achieve custom functionality. These are described below. \n 1. Card \n \n \n The Card MFE is a React micro frontend that is visible on the My Dashboard page. The MFE makes an API call to the banking microservice to fetch a numeric result depending on the configured card type. The displayed value will change as the configuration is changed. \n The MFE is authorization-aware and will pass the bearer token to the microservice for authorization and authentication. If you render the dashboard page and you aren\'t authenticated, the widget displays an error message. \n This MFE emits events that are consumed by the Transaction Table widget. \n 2. Card NG \n \n \n The Card NG MFE is an Angular widget that is similar to the Card widget above, except for the choice of frontend technology. \n This MFE communicates with the Transaction Table widget, which is implemented in React. \n 3. Manage Users \n \n The Manage Users MFE makes an API call to Keycloak to fetch user information. When the user is logged into the app, the MFE is visible from the dropdown under the username. \n By default, application users are not granted Keycloak authorization to manage users. This demonstrates role based access control for an MFE using Keycloak. To enable the Manage Users widget, login to Keycloak and assign the realm-management client\'s  view-users  and  manage-users  roles to the desired user. \n \n Authorized View\n \n Not Authorized View\n 4. Transaction Table \n \n This MFE is a React micro frontend that consumes events from the Card MFEs detailed above. \n The Transaction Table widget makes an API call to the banking microservice to fetch transaction data for the user. \n 5. Sign Up \n \n \n The Sign Up MFE is a form widget that makes an API call to the customer microservice to create a new user. The Sign Up MFE is visible on the sign up page, and can be accessed from any page when a user is not authenticated. \n 6. Alert Icon \n \n The Alert Icon MFE displays an icon on the dashboard page. It includes a configuration MFE to allow the user to select the appropriate icon and datatype to display. \n In the default deployment, the Alert Icon MFE makes an API call to the banking microservice to fetch data. \n Configuration Micro Frontends \n When placed on a page, many of the MFEs detailed above include configuration screens visible in the App Builder at  Components → Micro frontends & Widgets . To see the rendered config screen, place the MFE on a new page. \n Microservices \n The application includes two microservices (service paths:  /banking  and  /customer ) to support the data visible in the MFEs detailed above. Both microservices demonstrate the automated deployment and linking of a microservice to an Entando Application via the Entando Operator. \n The data for the microservices are created with Liquibase, demonstrating the use of the Operator and Liquibase + Spring Boot to automatically provision data into an environment. The demo data is available in the source code for the microservices on GitHub. \n Static Widgets \n The application uses static HTML, FreeMarker, and JavaScript widgets to display content, e.g. headers, footers, images, etc. To view the static widgets, log into the App builder and select  Components → Micro frontends & Widgets . \n Static CMS Content \n The application makes extensive use of the Entando CMS. This includes the creation of content templates, content types, and content. If you want to learn more about the Entando CMS in the application, log into the App Builder and select  Content →  Templates ,  Content → Management , or  Content → Types . \n Source Code \n The source code for the Entando Standard Banking Demo can be found on GitHub  here , along with our other open source examples and tutorials. \n'},{title:"PDA Architecture",frontmatter:{},regularPath:"/next/tutorials/solution/pda-architecture.html",relativePath:"next/tutorials/solution/pda-architecture.md",key:"v-27bb2d68",path:"/next/tutorials/solution/pda-architecture.html",headers:[{level:2,title:"PDA MFEs",slug:"pda-mfes"},{level:2,title:"PDA API",slug:"pda-api"},{level:2,title:"PDA Core",slug:"pda-core"},{level:2,title:"PAM Impl",slug:"pam-impl"}],lastUpdated:"3/18/2022, 4:02:27 PM",lastUpdatedTimestamp:1647633747e3,content:" PDA Architecture \n This document describes the components that comprise the Process Driven Applications (PDA) plugin architecture with respect to\ndeployment, as well as how they interact with each other. \n The image below shows the high level components. \n PDA MFEs \n The PDA micro frontends run on the browser, rendering the custom UI\ncomponents the user interacts with. These components are written in React and fetch data from the PDA API, passing the Keycloak token for authentication. \n The MFEs also make calls to the Entando Core API to retrieve the\nsettings required for the UI configuration. These components are available to assist with page creation after the PDA plugin bundle is installed. \n The source code for this component:\n https://github.com/entando/entando-process-driven-plugin/tree/master/widgets \n PDA API \n The PDA API is a Spring Boot application that communicates with the BPM engine, and BPM engine data is made available in a Rest API. Subject to deployment configuration, the PDA API interacts with Keycloak to validate the token, retrieving the connection and sensitive data. Instead of calling specific engine classes directly, the application calls the abstractions defined in the PDA Core library. \n The engine implementation is determined at runtime based on the connection details provided. It is important to note that the PDA API does not have a database and is therefore stateless. All data available in the API are retrieved\nfrom the BPM engine. After bundle installation, the API is deployed as a\nmicroservice in the Kubernetes infrastructure. An Ingress is also created to\nmake the API available to the MFEs, as described by the Entando Plugin custom\nresource. \n The source code for this component:\n https://github.com/entando/entando-process-driven-plugin \n PDA Core \n The PDA Core is the library that defines the interface and abstraction implementations that interact with specific BPM engines. It allows multiple engine implementations to exist simultaneously. \n The source code for this component:\n https://github.com/entando/pda-core-engine \n PAM Impl \n The PAM Impl is the Red Hat PAM implementation for the PDA Core library. If the connection maps\nto a PAM engine, these are the classes that are executed when the\nPDA API requests engine operations. This implementation communicates with\nthe Kie Server, which executes the defined process operations. \n The source code for this component:\n https://github.com/entando/pda-redhatpam-engine \n"},{title:"Entando Solution Templates",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/solution/landing-page.html",relativePath:"next/tutorials/solution/landing-page.md",key:"v-4ec0b1a8",path:"/next/tutorials/solution/landing-page.html",headers:[{level:2,title:"Entando Customer Portal",slug:"entando-customer-portal"},{level:2,title:"Entando Hub",slug:"entando-hub"},{level:2,title:"Entando Process Driven Applications Plugin",slug:"entando-process-driven-applications-plugin"},{level:2,title:"Entando Standard Banking Demo",slug:"entando-standard-banking-demo"}],lastUpdated:"1/29/2022, 1:14:41 PM",lastUpdatedTimestamp:1643480081e3,content:" Entando Solution Templates \n The Entando Application Composition Platform offers several Solution Templates to demonstrate various business capabilities and integrations: \n \n Entando Customer Portal \n Entando Hub \n Entando Process Driven Applications Plugin \n Entando Standard Banking Demo \n \n Each open source Solution Template was built with Entando and can be used as-is, reviewed for common development practices, or leveraged as a useful starting point for a related application. \n The following Solution Templates and other sets of components are available in the  public Entando Hub  for installation in a user environment, where turnkey functionality can be customized and extended. \n Entando Customer Portal \n The  Entando Customer Portal  streamlines development of a customer-facing, self-service subscription management application. The platform integrates Keycloak role based access control and Jira Service Management as a ticket tracking system. \n Entando Hub \n The  Entando Hub  empowers a team to share and collaborate on proprietary or Entando open source components. Capabilities, versions and metadata can be transparently analyzed, managed and published. \n Entando Process Driven Applications Plugin \n The  Entando Process Driven Applications Plugin  provides a comprehensive and versatile automation scheme for Business Process Management. It comprises a custom UX layer, a Spring Boot Backend for Frontend microservice interface, and integration with the  Red Hat Process Automation Manager . \n Entando Standard Banking Demo \n The  Entando Standard Banking Demo  showcases the benefits and possibilities of a composable application built from modular components. The example banking environment integrates a transaction table, sign up form, alert icon, and summary cards to demonstrate MFE communication and capabilities. Prominent features include Keycloak role based access control, coexistence of React and Angular MFEs, and pluggable Spring Boot microservices. \n \n TIP \n Check out our  Concepts  page to explore Entando's approach to composability, or visit  Getting Started  to put these components and capabilities in action! \n \n"},{frontmatter:{pageClass:"entando-landing-page"},regularPath:"/openshift.html",relativePath:"openshift.md",key:"v-087c5f39",path:"/openshift.html",lastUpdated:"2/8/2022, 8:58:16 AM",lastUpdatedTimestamp:1644328696e3,content:" "},{frontmatter:{},regularPath:"/tutorials/",relativePath:"tutorials/README.md",key:"v-ff78147a",path:"/tutorials/",lastUpdated:"4/20/2022, 4:10:39 PM",lastUpdatedTimestamp:1650485439e3,content:" Redirecting to the current Tutorials...\n \n"},{title:"PDA Plugin Technical Guide",frontmatter:{},regularPath:"/next/tutorials/solution/pda-technical-guide.html",relativePath:"next/tutorials/solution/pda-technical-guide.md",key:"v-5c97d4f4",path:"/next/tutorials/solution/pda-technical-guide.html",headers:[{level:2,title:"Task Forms",slug:"task-forms"},{level:2,title:"Widgets",slug:"widgets"},{level:2,title:"Code Style",slug:"code-style"},{level:2,title:"Sonar",slug:"sonar"}],lastUpdated:"1/25/2022, 4:09:16 PM",lastUpdatedTimestamp:1643144956e3,content:' PDA Plugin Technical Guide \n This page explores PDA plugin structure and functionality in greater detail. The sample code and linked resources instruct the user in the versatility and usability of: \n \n Task Forms \n Widgets \n Code Style \n Sonar \n Task Forms \n Widgets employ JSON schema to dynamically create any forms they contain. The JSON schemas are converted into React components using the  react-jsonshema-form  library. Entando\'s initial implementation utilizes Material UI components derived from the Material UI theme library ( rjsf-material-ui ) as a baseline, and includes templates, widgets and fields ( react-jsonshema-form  terms for forms components) that are specific to Entando. \n This section will introduce the basic form configuration, but if you would like to learn more, please refer to the  react-jsonshema-form   documentation . \n The themed JSON Form is created using the  withTheme()  method from the  react-jsonschema-form  package: \n import { withTheme } from \'react-jsonschema-form\';\nimport { Theme as MuiRJSForm } from \'rjsf-material-ui\';\n\nconst JSONForm = props => {\n\n  const ThemedForm = withTheme(MuiRJSForm);\n\n  // ...\n\n  return (\n    <ThemedForm\n    schema={formSchema}\n    uiSchema={uiSchema}\n    {...customTemplates}\n    widgets={customWidgets}\n    formData={formData}\n    onSubmit={e => onSubmitForm(e)}\n    >\n  );\n};\n\nexport default JSONForm;\n \n A form schema provides the JSON definition of the form’s structure and is mandatory for a JSON Form to function. Users can supply form data via the  formData  variable, which should follow the structure of JSON schema. UI schema can be supplied via the  uiSchema  variable, which allows users to customize the form’s UI (e.g. components, rules, types). \n You can test the JSON schema, UI schema and form data in the  react-jsonschema-form  sandbox environment. Entando templates, widgets, and fields allow customization of form layout using Grid components. The size parameter in the UI schema’s  ui:options  object specifies the fill area of a field or subform. \n Size refers to the Material UI’s grid column widths (see the Material UI documentation), where the area the form can occupy is divided into 12 columns. A value of 12 (the default value if size is not provided) means the field or subform should take up all 12 columns. If two adjacent fields have size values of 8 and 4, respectively, they will share one row and the first field will be twice as wide as the second. \n In addition, the user can provide an innerSize parameter to scale the input fields inside the columns. This helps with formatting when a user wants to make nonuniform adjustments to sizing. \n Multicolumn layout can also be achieved via  generateColumnedOFT  ( columnSize ) functionality, which assigns the default  columnSize  to the created form. The function  generateColumnedOFT  returns an  ObjectFieldTemplate  that is used as a template for all object fields (fields that contain properties). \n To explain the mapping between JSON schema and UI schema let\'s define an example\nschema: \n {\n  "$schema": "http://json-schema.org/draft-07/schema#",\n  "$id": "http://entando.org/schemas/pda-form.json",\n  "title": "Mortgage Application Form",\n  "type": "object",\n  "properties": {\n    "Application": {\n      "title": "Application",\n    "type": "object",\n    "required": [],\n    "properties": {\n        "mortgageamount": {\n          "type": "integer",\n          "title": "Mortgage amount",\n          "description": "Mortgage amount"\n        },\n        "downpayment": {\n          "type": "integer",\n          "title": "Down Payment",\n          "description": "Down Payment"\n        },\n        "applicant": {\n          "title": "Applicant",\n          "type": "object",\n          "required": [],\n          "properties": {\n            "name": {\n              "type": "string",\n              "title": "Name",\n              "description": "Name",\n              "maxLength": 100\n            },\n            "annualincome": {\n              "type": "integer",\n              "title": "Annual Income",\n              "description": "Annual Income"\n            }\n          }\n        },\n        "property": {\n          "title": "Property",\n          "type": "object",\n          "required": [],\n          "properties": {\n            "age": {\n              "type": "integer",\n              "title": "Age of property",\n              "description": "Age of property"\n            },\n            "address": {\n              "type": "string",\n              "title": "Address of property",\n              "description": "Address of property",\n              "maxLength": 100\n                }\n          }\n        }\n      }\n    },\n    "inlimit": {\n      "type": "boolean",\n    "title": "Is mortgage application in limit?"\n    }\n  }\n}\n \n From this JSON (you can copy & paste it into the  react-jsonschema-form \nsandbox) we can see that there is a main form with a title “Mortgage\nApplication Form." The root form  Mortgage Application Form  has two\nproperties: one is a subform called  Application  and the other is a\ncheckbox field (field ID is  inlimit ). \n The  Application  subform contains two fields:  Mortgage Amount  with field ID  mortgageamount  and  Down Payment  with field ID  downpayment . It also contains two subforms:  Applicant  with field ID  applicant  and  Property  with field ID  property . \n The  Applicant  subform contains two fields:  Name  with field ID  name  and  Annual Income  with field ID  annualincome . The  Property  subform also contains two fields:  Age of property  with field ID  age  and  Address of property  with field ID  address . \n By default (without providing UI schema), these are listed as one field per row. To use Entando’s implementation of Grid layout, users have to\nprovide UI schema with details about each field. For example, if we\nwould like to have a layout that looks like this (fields are marked\n [ field name ] ): \n +----------------------------------------------------------------------------+\n| Mortgage Application Form                                                  |\n+----------------------------------------------------------------------------+\n| Application                                                                |\n+----------------------------------+-----------------------------------------+\n| [Mortgage amount]                | [Down Payment]                          |\n+----------------------------------+-----------------+-----------------------+\n| Applicant                                          | Property              |\n+----------------------------------+-----------------+-----------------------+\n| [Name]                           | [Annual Income] | [Age of property]     |\n+----------------------------------+-----------------+-----------------------+\n|                                                    | [Address of property] |\n+----------------------------------------------------+-----------------------+\n \n To set up the UI schema, you need to use field IDs to define each field you want to customize. For example, to add options to the  Name  field, create an object tree beginning at the root:  Application  —>  Applicant  —>  Name  (equivalent to  Application.Applicant.Name ). The UI schema for the table layout defined above looks like this: \n {\n  Application: {\n    \'ui:options\': {\n      size: 12, // <-- this value is not mandatory; size is 12  columns wide by default\n    },\n    mortgageamount: {\n      \'ui:disabled\': true, // <-- user can define fields disabled at UI schema level\n      \'ui:options\': {\n        size: 6, // <-- Mortgage Amount field should take up half of the row\n      },\n    },\n    downpayment: {\n      \'ui:options\': {\n         size: 4, // <-- Down Payment field should take up the other half of the row\n       },\n    },\n    applicant: {\n      \'ui:options\': {\n         size: 8, // <-- Applicant subform should take up 8 out of 12 columns\n      },\n      name: {\n        \'ui:options\': {\n          size: 8, // <-- Applicant Name field should take up 8 of the 8 columns that Applicant subform occupies\n        },\n      },\n      annualincome: {\n        \'ui:options\': {\n           size: 4, // <-- Annual Income field should take up the remaining 4 columns\n        },\n      },\n    },\n     property: {\n      \'ui:options\': {\n        size: 4, // <-- Property subform should take up the remaining 4 out of 12 columns\n      },\n      // note that Property field occupancy is not specified, defaulting to use all 12 of the columns available\n    },\n  },\n};\n \n As Material UI components are used for field templates, there might be a need to pass some Material UI options into the field. This can be done by adding the  muiProps  object to  ui:options . \n For example, if you would like to make the down payment field resizable, you can add  multiline: true  to the  muiProps  option. If you want the field to take up multiple rows by default, add the fields  rows  and  rowsMax . The latter limits how many rows can be added until the scroll bar is shown. \n downpayment: {\n  \'ui:options\': {\n    size: 4,\n    muiProps: {\n      multiline: true,\n      rows: 2,\n      rowsMax: 4\n    }\n  }\n}\n Widgets \n Different types of widgets can be applied by passing the type via\n ui:widget . This property specifies the widget to use when the form\nrenders a UI field. See the documentation to learn about widgets supported by the  react-jsonschema-form . \n Code Style \n Refer to:  https://github.com/entando/entando-code-style \n Sonar \n Refer to:  https://sonarcloud.io/organizations/entando/projects \n'},{title:"Entando Platform",frontmatter:{sidebarDepth:0},regularPath:"/v6.1/docs/",relativePath:"v6.1/docs/README.md",key:"v-6696675c",path:"/v6.1/docs/",headers:[{level:2,title:"Entando Architecture",slug:"entando-architecture"},{level:2,title:"Why Kubernetes?",slug:"why-kubernetes"}],lastUpdated:"6/29/2020, 11:12:12 AM",lastUpdatedTimestamp:1593443532e3,content:" Entando Platform \n Entando is a  micro frontend platform for Kubernetes  that helps enterprises innovate faster with parallel development teams that have end-to-end autonomy across the entire stack. \n With native support for Javascript app development, a micro frontend and microservices architecture, deployment of apps in containers that can be individually scaled up and down, and automated management of containers with Kubernetes, we simplify the move for enterprises looking to modernize across on-prem and cloud infrastructures. \n Entando Architecture \n \n The Entando platform includes the following major elements: \n \n Entando App Engine : assemble micro frontends & microservices and compose them on a page. \n Entando App Builder : the user interface to build and design applications. \n Entando Component Generator : provide advanced data modeling capabilities and automatically generate the corresponding microservices and micro frontends. \n Entando Component Repository : a shared, internal repository to encourage code reuse across the enterprise. \n Entando Identity Management : token-based authentication across multiple domains and connect service providers with identity providers. \n Entando WCMS : a web content management system that supports headless CMS. \n (optional)  Entando Business Automation Bundle : workflow and task automation including out of the box integration with Red Hat Process Automation Manager (PAM). \n Why Kubernetes? \n Instead of you doing the work to ensure your apps and services stay up and running, Kubernetes does the work for you. For each app or service, you can set resource limits, the number of pods you want backing each service, upgrade strategy, and auto-scaling. Kubernetes actively manages your cluster to match your defined resource utilization and ensures your site doesn't go down. \n How Google Runs Containers in Production \n Each week, Google deploys over 2 billion containers in production to run all of its services like Gmail, YouTube, and Search. Kubernetes is Google's open source solution to automate the management of containers at scale. \n \n Over 50% of Fortune 500 companies use Kubernetes with product offerings from Amazon Elastic Kubernetes Service (EKS), Google Cloud Platform (GKE), IBM (Red Hat) OpenShift, Microsoft Azure (AKS), and VMWare Pivotal (PKS). \n"},{title:"Entando Process Driven Applications Plugin",frontmatter:{sidebarDepth:2},regularPath:"/next/tutorials/solution/pda-tutorial.html",relativePath:"next/tutorials/solution/pda-tutorial.md",key:"v-674ce676",path:"/next/tutorials/solution/pda-tutorial.html",headers:[{level:2,title:"Introduction",slug:"introduction"},{level:2,title:"Installation",slug:"installation"},{level:3,title:"Prerequisites",slug:"prerequisites"},{level:3,title:"Automatic Install via the Entando Hub",slug:"automatic-install-via-the-entando-hub"},{level:3,title:"Manual Install",slug:"manual-install"},{level:2,title:"Configuration",slug:"configuration"},{level:2,title:"Application Details",slug:"application-details"},{level:3,title:"Micro Frontends (MFEs)",slug:"micro-frontends-mfes"},{level:3,title:"Process Automation Manager (PAM)",slug:"process-automation-manager-pam"},{level:3,title:"Backend for Frontend (BFF)",slug:"backend-for-frontend-bff"},{level:2,title:"Customization and Extension",slug:"customization-and-extension"},{level:3,title:"Styling",slug:"styling"},{level:3,title:"Implementing a New Engine or Integrating a New Task Source",slug:"implementing-a-new-engine-or-integrating-a-new-task-source"},{level:2,title:"Resources",slug:"resources"},{level:3,title:"Source Code",slug:"source-code"}],lastUpdated:"4/18/2022, 2:36:36 PM",lastUpdatedTimestamp:1650306996e3,content:' Entando Process Driven Applications Plugin \n Introduction \n The Entando Process Driven Applications (PDA) plugin is engineered to provide a rich and full-featured user experience while facilitating the management and completion of business processes and automation.  This solution template includes: \n \n A general purpose UX layer created from micro frontends that can be implemented for any business process or task engine. The UX layer can serve data via the included Entando integration adapter or by implementing a set of interfaces on the server side. \n A Spring Boot microservice backend providing a pluggable interface for the injection of underlying processes or automation toolkits. The interfaces and steps for creating a new PDA backend implementation are described in further detail  here . \n \n This tutorial will guide you through installing the PDA plugin using the Entando Component Repository (ECR) and an Entando Bundle. This exercise demonstrates the scope of process automation enabled by integrating the following: \n \n Custom Micro Frontends (MFEs) \n Backend for Frontend (BFF) microservice \n Red Hat Process Automation Manager  (PAM) \n \n Key elements of the template are reviewed in the  Application Details section  below. \n Installation \n There are numerous assets installed as part of the Entando PDA plugin. Entando Bundles can include more or less components, depending on objectives. It is recommended that organizations develop guidelines for bundle sizing that fit the goals of their applications and teams. \n Prerequisites \n \n An Entando Application on any Kubernetes provider. Follow one of the  tutorials  appropriate to your environment to install the Entando platform. \n The ent command line tool, installed and connected to your Kubernetes instance. \n Red Hat PAM \n Automatic Install via the Entando Hub \n \n \n Log into your  App Builder  →  Repository  →  Select Registry  → choose  Entando Hub  if it has been configured. \n \n If not, choose  New Registry \n In the pop-up window, enter  Entando Hub  and https://entando.com/entando-hub-api/appbuilder/api for the URL, then  Save \n Click on the Hub in the Registry \n \n \n \n From the Hub Catalog,  Deploy  and  Install  the PDA bundle. The installation may take several minutes while the application downloads the Linux image for the microservice and installs the related assets. \n \n \n To finish the tutorial, skip to the  Configuration Steps  below. \n Manual Install \n \n Apply the Custom Resource Definition for the PDA plugin component bundle. \n \n ent ecr deploy --repo="https://github.com/entando-samples/entando-process-driven-plugin-bundle.git"\n \n \n \n Log into your App Builder instance. \n \n \n Select  Repository  from the menu on the left. Your bundles will be visible in the repository as shown in the screenshot below. \n \n \n \n \n Select  Install  to install the bundle. The installation may take several minutes while the application downloads the Linux image for the microservice and installs the related assets. \n Configuration \n Follow the steps below to configure service permissions and connections. \n \n \n Login to your Keycloak instance  as an admin. \n \n \n Set up permissions to configure the service: \n \n Select  pn-efbd66b6-b0ceabd7-entando-pda-plugin-server  from  Client Roles . \n Select all roles from  Available Roles  and click  Add selected . See  Role Assignment in ID Management  for more details. \n \n \n \n Log in to the App Builder and configure the PDA connection. \n \n \n \n Go to  Pages  →  Management , find  PDA Connections  in the page tree and select  View Published Page  from the Actions. This redirects you to the browser tab opened for PDA Connections. \n Click on  Create new connection  in the upper right corner. The  Name* ,  Engine*  and  Timeout*  fields are prepopulated with base values.\n \n The default name value  pam-demo  may be edited, but the datasource names of other widgets must match your edit. Go to  Pages  →  Management  and select  Design  from the Actions of each page below. The Actions of affected widgets will include a  Settings  option, from which you can update the  Knowledge Source  field.\n \n PDA Dashboard \n PDA Process Definition \n PDA Smart Inbox \n PDA Task Details \n \n \n Leave  pam  as the engine name. This value is appropriate for jBPM or PAM. \n Leave the timeout as  60000 , which is in milliseconds. \n Provide your connection URL to the KIE Server rest services, e.g. \'http://my.server.net:8080/kie-server/services/rest/server\'. \n Username/password should be for a jBPM or PAM service account user, e.g. \'krisv\'. \n \n \n \n Go to the Smart Inbox to begin working with the PDA plugin. It can be accessed from the App Builder by navigating to  Pages → Management , finding  PDA Smart Inbox  in the page tree and clicking  View Published Page  from its Actions. \n Application Details \n The Entando PDA plugin demonstrates several of the major features of the Entando platform, the configuration and capabilities of which are summarized below. For a discussion of these components in the context of deployment, see  PDA Deployment Architecture . \n Micro Frontends (MFEs) \n This section provides a brief description of each MFE available to the PDA plugin. Details specific to the PAM implementation of an MFE are included where appropriate. MFE behavior and datasources must be defined if the integration layer is extended to other engines or custom implementations. \n Task List \n The Task List MFE provides the user with a list of visible tasks that are\neither assigned to or could be claimed by that user. In the default implementation, the visible tasks are limited to a\nsingle process instance. At configuration time, the application designer\nis given the option to select a set of columns that will be visible in\nthe task list for that page. \n \n The default PAM implementation exposes the top level task fields in the task list for selection. It is possible to fetch task and process variables from the task list for rendering, but this is disabled by default to optimize performance. \n Task Details \n The Task Details MFE renders detailed information about a task in a read only grid. It is intended to give the end user the information necessary to process the task. See the Styling section below to customize the layout. \n \n The PAM implementation renders task variables in the task details widget. \n Task Comments \n The Task Comments MFE enables the user to view and add the notes attached\nto a task. \n \n The PAM implementation reads and publishes notes to the comments endpoint. \n Task Form \n The Task Form can be accessed by clicking on the Task Overview link found in the Task Details MFE. Its implementation renders a form specific to a task and enables\nthe user to complete that form. It is a\nwrapper around a JSON schema that describes the layout, style and\ncontent of the form. The backend implementation provides the mapping\nto the schema and default UX layout needed to render the form. See the\n technical documentation  for more on the JSON schema\nimplementation. \n The PAM implementation of forms depends on the presence of a form definition for the PAM task. The Entando PAM engine implementation transforms the PAM format to the JSON schema to render the form. It also transforms the API format back to the PAM format. There are some limitations on form customization due to the format required to return data to PAM. See the Task Forms section in the technical documentation for more information. \n Attachments \n The Attachments MFE enables the user to view and add documents attached to a task, case or process. After selecting an entry in the Smart Inbox task list, use the App Builder to add the Attachment MFE to that entry\'s page by navigating to  Pages → Management ; select  Design  from the  PDA Smart Inbox  actions and drag the "PDA - Task Attachments" widget into its placeholder. \n \n The PAM implementation posts the documents to the PAM endpoints for storage. \n New Process Form \n The New Process Form renders a form enabling the end user to instantiate a new business process instance. The same technology is used to generate a New Process Form and the JSON schema definition for a Task Form. \n \n The PAM implementation relies on a form definition attached to the process definition. Entando transforms the PAM representation into a JSON schema form that can be rendered to the end user. \n Summary Cards \n The Summary Card MFEs provide a view into aggregate data for the process\nimplementation. The rendered information includes a total value, a trend\nvalue, and a timeframe selector. The Summary Card provides the\nthe option to request rendering information. This request maps to a call in the underlying engine and provides the summarized data. \n \n The PAM implementation of the Summary Card widget relies on the PAM custom query functionality. The PAM PDA engine exposes a configuration file where the custom query can be defined. This allows user customization of the data rendered on the summary cards. The application contains a "properties" file where the user can submit a custom query for each of the cards. \n Totals Over Time \n The Totals Over Time MFE provides a dual axis line/bar graph displaying\ntrend information about the process environment. Three summary values can be compared over a single time period. \n \n The PAM implementation of the Totals Over Time MFE utilizes custom queries to fetch the summary data rendered in the chart. The queries used in the implementation are defined in configuration files in the MFE and can be updated to render implementation specific data. \n Process Automation Manager (PAM) \n The Entando PDA is built on Process Automation Manager, which is a business process automation engine built and maintained by Red Hat. \n Backend for Frontend (BFF) \n A microservice architecture allows teams to iterate quickly and\ndevelop technology to scale rapidly. Backend for Frontend\nis an architecture pattern built with microservices. The key\ncomponent of this pattern is an application connecting the frontend\nof an application with the backend. The BFF Code Pattern helps to build that component according to IBM’s best practices. \n Customization and Extension \n This section describes how the PDA plugin can be customized and extended via: \n \n Styling \n Implementing a new engine \n Integrating a new task source \n \n For an in-depth discussion of the PDA architecture, refer to the  PDA Technical Guide . \n Styling \n The Entando PDA MFEs are styled via a Material UI theme. That theme can\nbe downloaded and updated  here . \n Implementing a New Engine or Integrating a New Task Source \n Implementing a new engine for Process Driven Applications means\ncreating a new Java project and implementing the interfaces defined in the\n pda-core-engine  project. The new project should therefore include the\n pda-core-engine  as a dependency. \n To see an implementation in action, consider the  pda-redhatpam-engine  project, which implements the Red Hat PAM engine integration. The resultant JAR file should be available in the classpath for the  entando-process-driven-plugin , which is the project that\nis ultimately executed and exposes the Rest APIs for the frontend\napplication. \n One way to achieve this is by publishing the engine\nimplementation to a Maven repository and adding it as a dependency to\nthe  entando-process-driven-plugin  project. Below are the descriptions of\nthe engine class and key interfaces in the  pda-core-engine  project that must be inherited or implemented when creating a new engine\nimplementation. \n Classes \n Engine : represents a Business Process Management (BPM) engine and exposes the services that are available for that specific implementation. It is intended to be inherited, and the subclass should provide the implementation for each service by calling the superclass constructor with the service implementations as arguments. If any service is not supported, a null value should be passed to the corresponding constructor argument. The engine can provide implementations for service interfaces. \n Interfaces \n TaskService : defines service methods for task retrieval from the BPM engine. \n TaskDefinitionService : defines service methods related to task definition. A task definition specifies which fields or columns are available for all task instances. \n TaskCommentService : defines service methods related to task comment manipulation. It should be implemented if the task comment is supported by the engine. \n TaskAttachmentService : defines service methods to operate on task attachments. It should be implemented if the engine supports file attachment on the task. \n TaskFormService : defines service methods for task form operations, like retrieving the form definition and submitting a form. The Form object can be used to render a form dynamically. \n TaskLifecycleService : defines service methods related to the task lifecycle. The lifecycle operations move the task from one state to another. \n TaskLifecycleBulkService : defines methods for bulk lifecycle operations. Like the TaskLifecycleService, these methods move the task from one state to another, but this interface works with multiple tasks at a time. \n ProcessService : defines service methods for process definitions operations. \n ProcessFormService : defines service methods for process form operations, like retrieving the form definition and submitting a form. The Form object can be used to render a form dynamically. \n GroupService : defines service methods related to groups in the BPM engine. \n Resources \n Source Code \n The source code for the Entando PDA plugin can be found on GitHub, along with our other open source examples and tutorials. Reference the component projects for instructions to build from source code: \n \n https://github.com/entando/entando-process-driven-plugin \n https://github.com/entando/entando-process-driven-plugin/tree/master/widgets \n https://github.com/entando/pda-redhatpam-engine \n https://github.com/entando/pda-core-engine \n \n'},{title:"Overview",frontmatter:{},regularPath:"/v6.1/docs/concepts/",relativePath:"v6.1/docs/concepts/README.md",key:"v-43768dc5",path:"/v6.1/docs/concepts/",headers:[{level:2,title:"Entando App Engine",slug:"entando-app-engine"},{level:2,title:"Entando App Builder",slug:"entando-app-builder"},{level:2,title:"Entando Component Generator",slug:"entando-component-generator"},{level:2,title:"Entando Component Repository",slug:"entando-component-repository"},{level:2,title:"Entando Identity Management",slug:"entando-identity-management"},{level:2,title:"Entando WCMS",slug:"entando-wcms"},{level:2,title:"Entando Cluster Citizens",slug:"entando-cluster-citizens"},{level:3,title:"Architecture diagram",slug:"architecture-diagram"},{level:3,title:"Members of the cluster",slug:"members-of-the-cluster"},{level:2,title:"Entando Ingresses",slug:"entando-ingresses"},{level:3,title:"What is an ingress",slug:"what-is-an-ingress"},{level:3,title:"How ingresses are used in an Entando Cluster",slug:"how-ingresses-are-used-in-an-entando-cluster"},{level:3,title:"Default Ingress HTTP Routes",slug:"default-ingress-http-routes"},{level:3,title:"Exposing plugins in the EntandoApp domain",slug:"exposing-plugins-in-the-entandoapp-domain"},{level:3,title:"How to check ingresses in my cluster",slug:"how-to-check-ingresses-in-my-cluster"},{level:3,title:"Learn more",slug:"learn-more"}],lastUpdated:"12/8/2021, 3:47:16 PM",lastUpdatedTimestamp:1638996436e3,content:' Overview \n A portal, website, web app, or mobile app built with Entando is called an Entando application.\nAn Entando application is an assembly of out of the box and/or custom built components running on the\nEntando Platform. Components can be widgets, micro frontends, microservices, page templates,\nWCMS content or WCMS content types. \n Entando App Engine \n The Entando App Engine is the heart of the Entando Platform by providing the primary out-of-the-box services for\ndeveloping applications. Key features: \n \n Expose the APIs the Entando App Builder uses to provide the page and content management interface for your application. \n Handle the work of assembling micro frontends and microservices and combining them on specific pages as defined by the Entando App Builder. \n Provide the data access layer to persist the page and application design. \n Manage the cluster infrastructure. \n \n See also:  APIs tutorial \n Entando App Builder \n The Entando App Builder is the feature-rich management interface used to design and build pages for Entando applications. \n See also:  Widget Tutorial \n Entando Component Generator \n The Entando Component Generator is Entando\'s implementation of  JHipster  that allows users to\nquickly and efficiently generate the skeleton of an Entando Component. The Entando Component Generator provides advanced\ndata modeling capabilities including object relational mapping and automatic generation of micro frontends and microservices.\nThe generated skeleton serves as a starting point to help a development team swiftly meet the needs of the business. \n See also:  Entando JHipster Blueprint \n Entando Component Repository \n The Entando Component Repository (ECR) is used to store and retrieve shareable components so they can be used in multiple\nEntando applications across the enterprise. \n See also:  ECR Overview \n Entando Identity Management \n Entando Identity Management is the  Keycloak -based token-based authentication mechanism used by the\nEntando platform. It provides the ability to add Single Sign On capabilities across multiple domains and to connect service\nproviders with identity providers. \n See also:  Entando Authentication \n Entando WCMS \n The Entando Web Content Management System (WCMS) is a lightweight content and digital asset management system with support\nfor headless operation. It allows management of widgets and html fragments so they can be placed within an Entando application. \n See also:  Content Types  or  Content Templates \n Entando Cluster Citizens \n The purpose of this guide is to give an overview of the members of an Entando cluster and their role. \n Architecture diagram \n Let’s start with a picture of an Entando6 cluster and how the various\nmembers interact with each other. \n Members of the cluster \n An Entando 6 cluster is composed of various citizens which interact with\neach other. Most of these citizens have a Custom Resource Definition\nfile associated with them and are deployable on Kubernetes using the\nEntando operator and controllers. \n Entando app \n An Entando app is composed of three parts: \n \n \n App Builder : the replacement for the Admin Console and entry\npoint to customize and build an Entando application, as well as\nproviding a method to interact with the Entando Component\nRepository. \n \n \n Entando core : the backend APIs providing access to Entando\nservices. \n \n \n Entando component manager : the service providing the Entando\nComponent Repository functionality, e.g. listing the available\nbundles, install/uninstall a bundle, etc. Check the  dedicated\nsection  for more details \n \n \n The interaction between these three components (and the rest of the\nEntando cluster) use the authorization/authentication features provided\nby Keycloak. \n Entando Component Manager \n As briefly introduced before, the Entando component manager is able to\nlist the EntandoDeBundles accessible from the EntandoApp and provide the\ninstall/uninstall services to install a bundle on an Entando App. All of\nthese services are made possible by the communication with the Entando\nKubernetes service, the only service of the entando ecosystem (other\nthan the operator itself) able to interact with the cluster and some of\nthe Entando custom resources. \n Entando Kubernetes Service \n The Entando Kubernetes Service is part of the Entando cluster\ninfrastructure custom resource, and provides an access point to some of\nthe custom resources defined by Entando, in particular: \n \n \n Entando applications \n \n \n Entando plugins \n \n \n Entando links \n \n \n Entando Component Repository bundles \n \n \n Some of the main services provided by the Entando Kubernetes Service\nare: \n \n \n Provide a list of the available EntandoDeBundles to the\ncomponent-manager \n \n \n Deploy a plugin during the installation of a bundle or discovery of\nan already available plugin and expose that to an app \n \n \n Create a link between an EntandoApp and an EntandoPlugin to expose\nthe plugin’s APIs to the EntandoApp and the micro frontends (MFEs) \n Entando Component Repository bundles \n An EntandoDeBundle - or Component Repository bundle - is a package with\na set of Entando components and resources. The Entando component manager\nis able to read these kind of packages and install the components to\nextend the functionalities of an EntandoApp. For more details on the\nEntandoDeBundle and the Entando Component Repository, check the\n component repository overview \ndocumentation \n Entando plugin \n An Entando plugin is a microservice that exposes APIs reusable by one or\nmore Entando apps. Usually the plugin services are exposed to the\nEntando developer and the end users via micro frontends. Check the\n micro frontends  tutorials for more details. You can\nquickly generate an Entando plugin using the  Entando JHipster Blueprint . The generated project\nwill be ready to work in an Entando environment providing the\nintegration with Keycloak, generating a set of default micro frontends\nand exposing the plugin’s logic via an EntandoDeBundle (check the\nreferences for details). \n Keycloak \n Keycloak in Entando 6 is responsible for authorization and\nauthentication All the members of an Entando 6 cluster interact with\nkeycloak to verify user/service authorization to perform any specific\ntask. Check out the references below for more details on keycloak. \n Entando Ingresses \n What is an ingress \n An Ingress is a Kubernetes resource which purpose is to expose HTTP and HTTPS routes from outside the cluster to services within the cluster. Traffic routing is controlled by rules defined on the Ingress resource. \n How ingresses are used in an Entando Cluster \n When deploying an Entando Cluster, ingresses are generated for the resources that requires to be exposed to the outside world. The process of creating an ingress, setup the correct routes and the certificates is done by the via the Entando Operator and the entando custom resource controllers. \n Keycloak ingress \n An dedicated ingress is created for keycloak to expose the authentication and authorization functionalities. Having a dedicated ingress is required to guarantee that both token issuing and token validation work correctly, even when the services using the keycloak instance are on different namespaces. \n Cluster infrastructure ingress \n Another ingress is created for the cluster infrastructure services in order to expose the api endpoint to interact with the cluster correctly \n Entando App ingress \n Another ingress is automatically created to expose App builder, App engine and the Entando component manager, a service part of the ECR.\nThe three containers are served under the same domain, and this is beneficial as they are able to interact without cross-origin issues. \n The Entando App ingress is also used when linking an Entando Plugin with and Entando App, operation that usually happens when a bundle containing an Entando Plugin is installed via the ECR in an Entando App. Check out the dedicated section for details. \n Entando Plugin ingress \n Also Entando Plugins are automatically exposed via an ingress when deployed in an Entando Cluster. \n Default Ingress HTTP Routes \n In this table you can see what are the default routes that are exposed for each ingress\n \n \n \n \n \n \n \n Ingress \n Ingress Http route \n Application \n \n \n \n \n Keycloak ingress \n /auth \n Keycloak \n \n \n Entando cluster infrastructure ingress \n /k8s \n Entando K8S service \n \n \n Entando App ingress \n /entando-de-app \n App engine \n \n \n /app-builder/ \n App builder \n \n \n /digital-exchange \n Entando component manager \n \n \n /<plugin-ingressPath> \n Entando plugin linked to the app \n \n \n Entando plugin ingress \n /<plugin-ingressPath> \n Entando plugin \n \n \n \n Note : The Entando plugin  ingressPath  variable is defined in the Entando Plugin custom resource under the  spec  element. The plugin ingress path is also used to expose the plugin under the Entando App domain \n Exposing plugins in the EntandoApp domain \n The process of exposing an Entando Plugin under the same domain (ingress) of the Entando App is made possible from the creation of an  EntandoAppPluginLink  custom resource and the corresponding controller. \n Once the link between the Entando App and the Entando Plugin is created, the controller reads the specification of such link and automatically creates the HTTP routes in the Entando App so that the plugin is exposed on the same domain as the App builder, App engine and Component manager. \n This allows the Microfrontend developers that need to access the plugin to not worry about CORS policy or knowing what is the full path where the plugin is exposed. The plugin is referencable using relative urls. \n How to check ingresses in my cluster \n Using the Openshift dashboard \n On the Openshift dashboard, Ingresses are not exposed directly as pods and deployments. The dashbaord provides direct access to the Ingress Routes (or simply routes) under the  Applications > Routes  menu. \n \n To see the ingress resources, you need to access them from the  Resources > Other resources  menu. From the dropdown you should select the  Ingress  resource and therefore you should be able to see the ingress available on that specific project/namespace \n Using kubectl from the command line \n From the command line, getting the ingress is very easy. Once you know the namespace(s) where your Entando Cluster is deployed, you simply need to use the \n kubect get ingresses.extensions -n <namespace>\n \n Here an example of the result in a test namespace \n > kubectl get ingresses.extensions -n local\n\nNAME               CLASS    HOSTS                               ADDRESS     PORTS   AGE\nqst-eci-ingress   <none>   qst-eci-local.192.168.1.9.nip.io   127.0.0.1   80      2d1h\nqst-ingress       <none>   qst-local.192.168.1.9.nip.io       127.0.0.1   80      2d1h\nqst-kc-ingress    <none>   qst-kc-local.192.168.1.9.nip.io    127.0.0.1   80      2d1h\n \n To get more details about a specific ingress, you can use the  get  command specifing the ingress name you want to check and the  yaml  output format \n > kubectl get ingresses.extensions -n local qst-ingress -o yaml\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  creationTimestamp: "2020-05-13T15:27:08Z"\n  generation: 1\n  labels:\n    EntandoApp: qst\n  managedFields:\n  - apiVersion: extensions/v1beta1\n    fieldsType: FieldsV1\n    fieldsV1:\n      f:status:\n        f:loadBalancer:\n          f:ingress: {}\n    manager: nginx-ingress-controller\n    operation: Update\n    time: "2020-05-13T15:27:08Z"\n  name: qst-ingress\n  namespace: local\n  ownerReferences:\n  - apiVersion: entando.org/v1\n    blockOwnerDeletion: true\n    controller: true\n    kind: EntandoApp\n    name: qst\n    uid: aa7053e1-fd8b-419f-bdee-df3018c013fa\n  resourceVersion: "16802097"\n  selfLink: /apis/extensions/v1beta1/namespaces/local/ingresses/qst-ingress\n  uid: e9b6f027-369a-4b84-b4b1-736a6e49f180\nspec:\n  rules:\n  - host: qst-local.192.168.1.9.nip.io\n    http:\n      paths:\n      - backend:\n          serviceName: qst-server-service\n          servicePort: 8080\n        path: /entando-de-app\n        pathType: ImplementationSpecific\n      - backend:\n          serviceName: qst-server-service\n          servicePort: 8083\n        path: /digital-exchange\n        pathType: ImplementationSpecific\n      - backend:\n          serviceName: qst-server-service\n          servicePort: 8081\n        path: /app-builder/\n        pathType: ImplementationSpecific\nstatus:\n  loadBalancer:\n    ingress:\n    - ip: 127.0.0.1\n Learn more \n For more details about ingress concept in Kubernetes please refer to the official documentation: \n \n Kubernetes Ingress documentation \n Openshift Routes documentation \n \n'},{title:"PDA Architecture",frontmatter:{},regularPath:"/v6.1/docs/concepts/pda-architecture.html",relativePath:"v6.1/docs/concepts/pda-architecture.md",key:"v-7a0c5c26",path:"/v6.1/docs/concepts/pda-architecture.html",headers:[{level:2,title:"PDA MFEs",slug:"pda-mfes"},{level:2,title:"PDA API",slug:"pda-api"},{level:2,title:"Sidecar",slug:"sidecar"},{level:2,title:"PDA Core",slug:"pda-core"},{level:2,title:"PAM Impl",slug:"pam-impl"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:" PDA Architecture \n The objective of this document is to provide an explanation for the components\nthat compose the Process Driven Applications plugin (PDA) architecture from a\ndeployment perspective as well as how they interact with each other. \n The image below shows the components in high level: \n PDA MFEs \n The PDA Micro Frontends run on the browser and they render the UI custom\ncomponents the user interacts with. These components are written in React and\nthey fetch data from the PDA API, passing the Keycloak token for authentication.\nThe MFEs also make calls to the Entando Core API in order to retrieve the\nsettings required for the configuration UI. These components will be available\non Entando App Builder after the PDA plugin bundle is installed and the user\ncan create pages with them. \n The source code for this component:\n https://github.com/entando/entando-process-driven-plugin/tree/master/widgets \n PDA API \n The Spring Boot application that communicates with the engine and make its data\navailable in a Rest API. It interacts with Keycloak to validate the token and\nwith the sidecar to retrieve the connections/sensitive data, depending on how it\nwas deployed. The application shouldn't call specific engine classes directly,\ninstead it always calls the abstractions defined in PDA Core library. The engine\nimplementation to use is decided at runtime based on the connection details\nprovided. It is important to note that the PDA API application is stateless,\nsince it doesn't have a database. All data available on the API is retrieved\nfrom the BPM engine. After bundle installation, it will be deployed as a\nmicroservice in the Kubernetes infrastructure and an Ingress will be created to\nmake the API available to the MFEs, as described by the Entando Plugin custom\nresource. \n The source code for this component:\n https://github.com/entando/entando-process-driven-plugin \n Sidecar \n The sidecar is another application (docker container) deployed in the same Pod\nas the PDA API. It exposes services to manage connection details, which will be\nstored as secrets in Kubernetes. The PDA API communicates with the sidecar to\nmanage BPM engine connection details. \n The source code for this component:\n https://github.com/entando/entando-plugin-sidecar \n PDA Core \n This is the library that defines the interfaces and abstractions that should be\nimplemented to interact with specific BPM engines. This way it is possible to\nhave multiple engine implementations at the same time. \n The source code for this component:\n https://github.com/entando/pda-core-engine \n PAM Impl \n The Red Hat PAM implementation for the PDA Core library. If the connection maps\nto a PAM engine, these are the classes that are going to be executed when the\nPDA API requests for engine operations. This implementation communicates with\nthe Kie Server, which executes the defined process operations. \n The source code for this component:\n https://github.com/entando/pda-redhatpam-engine \n"},{title:"Entando's Custom Resources for Kubernetes",frontmatter:{},regularPath:"/v6.1/docs/concepts/custom-resources.html",relativePath:"v6.1/docs/concepts/custom-resources.md",key:"v-68d2c0e6",path:"/v6.1/docs/concepts/custom-resources.html",headers:[{level:2,title:"Objective",slug:"objective"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"The Core Entando Custom Resources",slug:"the-core-entando-custom-resources"},{level:2,title:"EntandoKeycloakServer",slug:"entandokeycloakserver"},{level:3,title:"Overview",slug:"overview-2"},{level:3,title:"Example",slug:"example"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties"},{level:2,title:"EntandoClusterInfrastructure",slug:"entandoclusterinfrastructure"},{level:3,title:"Overview",slug:"overview-3"},{level:3,title:"Example",slug:"example-2"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-2"},{level:2,title:"EntandoApp",slug:"entandoapp"},{level:3,title:"Overview",slug:"overview-4"},{level:3,title:"Example",slug:"example-3"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-3"},{level:2,title:"EntandoPlugin",slug:"entandoplugin"},{level:3,title:"Overview",slug:"overview-5"},{level:3,title:"Example",slug:"example-4"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-4"},{level:2,title:"EntandoAppPluginLink",slug:"entandoapppluginlink"},{level:3,title:"Overview",slug:"overview-6"},{level:3,title:"Example",slug:"example-5"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-5"},{level:2,title:"EntandoDatabaseService",slug:"entandodatabaseservice"},{level:3,title:"Example",slug:"example-6"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-6"},{level:2,title:"EntandoCompositeApp",slug:"entandocompositeapp"},{level:3,title:"Overview",slug:"overview-7"},{level:3,title:"Example",slug:"example-7"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-7"}],lastUpdated:"12/15/2021, 2:22:26 PM",lastUpdatedTimestamp:1639596146e3,content:' Entando\'s Custom Resources for Kubernetes \n Objective \n This document provides an overview of the Entando Kubernetes Custom Resources and their semantics in Entando 6. \n Prerequisites \n \n Basic knowledge of Kubernetes and how to deploy Docker images to it \n Basic knowledge of Helm and how Helm Charts use YAML templates for parameterized deployments to Kubernetes \n Overview \n Amongst the many features it offers, Kubernetes also comes with a REST API that for dozens of different resources types.\nGenerally these API off full Create/Retrieve/Update/Delete (CRUD) access to each of the resource types. We\ntypically format these resources in YAML or JSON and use commandline tools such as\n kubectl  or  oc  to manage them. Each of these resources has a clearly defined structure\nthat is well documented in the  Kubernetes API  .\nKubernetes  also allows clients to subscribe to events generated as these resources get updated. These subscriptions\nare called \'watches\' and allow clients to be notified whenever the state of a resource changes. Kubernetes also\nenforces very strong role based access control (RBAC) support on all resources, with permissions down to the level\nof granularity of operation (Create/Retrieve/Update/Delete/Watch) per resource. \n The basic architecture for Kubernetes worked so well for the developers of Kubernetes that they decided to also make it\navailable to third  party developers. Kubernetes now offers a mechanism to allow 3rd parties to provide its own custom\nresource types that still leverage the CRUD support, event subscriptions and RBAC provided by Kubernetes out of the box.\nThis mechanism is referred to as Custom Resources. \n Custom Resources are very commonly used with Kubernetes Operators. Operators are Docker images that have been\ndeployed to Kubernetes Deployments. The generally observe a set of custom resources and perform some operations against\nthe Kubernetes API to reflect the state changes in the Custom Resource. We can say that the Custom Resources are associated\nwith specific semantics in how they are translated to \n One can introduce a new Custom Resource into Kubernetes by registering a Custom Resource Definition (CRD). This is really\njust another yaml or json resource that defines the structure of the Custom Resource to be installed using the OpenAPI\nJSON Schema format. When talking about Custom Resources, it is very important to distinguish between Custom Resource\nDefinitions and Custom Resources. CRD\'s are static type definitions provided by an Operator\nprovider such as Entando. For those familiar with programming languages, CRD\'s are like class definitions, whereas\nCustom Resources are actual instances of that class. \n Entando introduces two groups of Custom Resources. On the one hand, there are the core Entando Custom Resources required\nfor a basic installation of Entando in a Kubernetes cluster. These Custom Resources directly result in other\nKubernetes resources being deployed in the cluster. On the other hand, there are the Custom Resources specific\nto the Entando Component Repository that serve primarily as metadata for other Entando components. \n The Core Entando Custom Resources \n The Entando Operator observes all the Core Entando Custom Resources in one or more namespaces. This means that if a Core\nEntando Custom Resource is created, updated or deleted, the Entando Operator will trigger a new run-to-completion Pod\nthat will translate that state change into a state change in the actual Kubernetes Cluster. Often, this will\nresult in the Deployment of one or more Docker images, but also one or more Services and sometimes and Ingress\ntoo. We refer to the Docker Images that implement these run-to-completion Pods as Entando Kubernetes Controllers. \n The Entando Operator itself is also implemented as a Docker Image. You can have a closer look at how it works in the\n entando-k8s-controller-coordinator  project on Github.\nApart from the normal Maven, Java and Docker files one would expect, you will also notice the\n entando-k8s-controller-coordinator Helm Chart .\nThis Helm Chart is basically the entrypoint for installations of Entando 6 on Kubernetes. More detailed instructions\non how to install the Entando 6 Operator are available in our\n installation instructions \n EntandoKeycloakServer \n The EntandoKeycloakServer Custom Resource is used to deploy and configure a Red Hat Keycloak Server instance on the\ncluster. After deploying this Keycloak instance, the Entando Operator will create a Kubernetes Secret that provides\nthe necessary information for subsequent deployment operations to access the Keycloak instance as the Admin user. This\nallows the rest of the Entando Kubernetes Controllers to create a Keycloak OIDC client for every HTTP service that\ngets deployed. If you already have a Keycloak instance that you would use, you can skip this custom resource entirely\nand simply create the `keycloak-admin-secret\' in the operator\'s namespace as specified in\n this tutorial \n Overview \n \n Entando Cluster Citizen:  Keycloak \n Custom Resource Definition:  EntandoKeycloakServer \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-keycloak-controller \n Github Repo:  entando-k8s/entando-k8s-keycloak-controller \n \n \n Deployment Details:\n \n Docker image:  entando/entando-keycloak \n Github Repo:  entando/entando-keycloak \n \n \n Possible Database Images:\n \n MySQL:  docker.io/centos/mysql-57-centos7 \n PostgreSQL:  docker.io/centos/postgresql-96-centos7 \n Example \n ---\nkind: "EntandoKeycloakServer"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-keycloak"\n  namespace: "keycloak-namespace"\nspec:\n  dbms: "postgresql"\n  imageName: "entando/entando-keycloak"\n  ingressHostName: "test-keycloak.ampie.dynu.net"\n  isDefault: true\n  parameters: \n    KEYCLOAK_WELCOME_THEME: my-custom-theme\n  tlsSecretName: my-tls-secret\n  replicas: 1\n Explanation of properties \n \n spec.dbms  is used to select the database management of choice. If this value matches up to the  spec.dbms  property\nof a previously  configured  EntandoDatabaseService ,\nthe Keycloak image will be configured to use this service.\nAlternatively, the Entando Operator will use this value to deploy a dedicated Database instance in this namespace\nfor Keycloak to use. If left empty, or given value of \'none\', Keycloak will be deployed using its own internal\nH2 database. \n spec.imageName  is used to provide a customized image. By default, the operator will use the  entando/entando-keycloak \ndiscussed above. When using the default image, please refer to the\n relevant section \nin the README of the Entando Operator to determine how the Docker registry and version of this image will be calculated.\nWhen you need to customize the theme or add extensions to Keycloak, you can create your own custom image and provide\nthe value in this property. In this custom image, make sure you use the default image ( entando/entando-keycloak )\nas a base image. You can then add your customizations and build your own image. Please use a fully qualified\nDocker image name here. \n spec.ingressHostName  is the hostname of the Kubernetes Ingress to be created for Keycloak. Please ensure that this is\naccessible using the default routing suffix of your Entando Operator Deployment, or a DNS name previously\nregistered with your DNS provider. \n spec.isDefault  is \'true\' by default and this should suffice for most conditions. This will result in the standard\n keycloak-admin-secret  being replaced by a Secret connecting you to this newly created Keycloak instance.\nTheoretically one could use multiple Keycloak instances in a cluster, in which case this property should be false. \n spec.parameters  is a Map of environment variables to pass to the Keycloak Docker image. For example, this could\nbe used to select a specific theme for Keycloak to use using the variable KEYCLOAK_WELCOME_THEME. These parameters\nare applied to the container\'s environment variables after all variables have been calculated. It can therefore\nalso be used as a mechanism to override any of the default environment variables that need customization. \n spec.tlsSecretName  is the name of a standard Kubernetes\n TLS Secret  that will be used for the\nresulting Ingress. This is only required if the\n globally configured TLS Secret \nfor the Operator is absent or has not been created with a wildcard hostname that supports this Keycloak instance\'s hostname. \n spec.replicas  - the number of replicas to be made available on the Deployment of this Keycloak Server \n EntandoClusterInfrastructure \n The EntandoClusterInfrastructure custom resource can be used to create the shared services that Entando requires in a cluster.\nAt the time of the writing of this document, there is really only one service, which is the Entando K8S Service, but this\nmay change in future. Deployments resulting from this custom resources are configured to use the default Keycloak\nServer specified in the  keycloak-admin-secret  using the  entando  realm. An Ingress will also be created as part of this\ndeployment. At this point, there is no way to customize the image in question. \n Overview \n \n Entando Cluster Citizen:  Entando Kubernetes Service \n Custom Resource Definition:  EntandoClusterInfrastructure \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-cluster-infrastructure-controller \n Github Repo:  entando-k8s/entando-k8s-keycloak-controller \n \n \n Deployment Details:\n \n Docker image:  entando/entando-k8s-service \n Github Repo:  entando-k8s/entando-k8s-service \n \n \n Possible Database Images: none \n Example \n ---\nkind: "EntandoClusterInfrastructure"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-eci"\n  namespace: "eci-namespace"\nspec:\n  keycloakSecretToUse: some-keycloak-secret\n  ingressHostName: "test-keycloak.ampie.dynu.net"\n  isDefault: true\n  parameters: \n    KEYCLOAK_WELCOME_THEME: my-custom-theme\n  tlsSecretName: my-tls-secret\n  replicas: 1\n Explanation of properties \n \n spec.keycloakSecretToUse  is used to determine which Kubernetes Secret to use to connect to the correct\nKeycloak instance. If not specified, the default Secret  keycloak-admin-secret  will be used. Only useful\nif you have more than one Keycloak server in your cluster. \n spec.ingressHostName  is the hostname of the Kubernetes Ingress to be created for the Entando K8S Service. Please\nensure that this is accessible using the default routing suffix of your Entando Operator Deployment, or a DNS\nname previously registered with your DNS provider. \n spec.isDefault  is \'true\' by default and this should suffice for most conditions. This will result in the standard\n entando-cluster-infrastructure-secret  being replaced by a Secret connecting you to this newly created\nEntando K8S Service.  Theoretically one could use multiple Entando K8S Services in a cluster, in which\ncase this property should be false for new Entando K8S Services that should not override the default Secret. \n spec.parameters  is a Map of environment variables to pass to the Entando K8S Service Docker image. For example, this could\nbe used to override the ENTANDO_NAMESPACES_TO_OBSERVE variable that configures the set of Kubernetes namespaces\nthis service should read EntandoDeBundles from. Also note that all of the\n Spring variables in entando-k8s-service project \ncan also be overridden here by specifying the equivalent SNAKE_CASE names of the dot-delimited Spring properties.\nThese parameters are applied to the container\'s environment variables after all variables have been calculated.\nIt can therefore also be used as a mechanism to override any of the default environment variables that need customization. \n spec.tlsSecretName  is the name of a standard Kubernetes\n TLS Secret  that will be used for the\nresulting Ingress. This is only required if the\n globally configured TLS Secret \nfor the Operator is absent or has not been created with a wildcard hostname that supports this Keycloak instance\'s hostname. \n spec.replicas  - the number of replicas to be made available on the Deployment of this Entando K8S Service \n EntandoApp \n An EntandoApp is a Deployment of a Docker image that hosts an Entando and Java based web application. Entando offers two\nstandard images that can be used, but generally we expect our customers to provide their own images here. An EntandoApp\nDeployment packages three images into a single Pod: the Entando App Image in question, AppBuilder and Component Manager. \n Overview \n \n Custom Resource Definition:  EntandoApp \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-app-controller \n Github Repo:  entando/entando-k8s-app-controller \n \n \n Deployment Details - Entando App:\n \n Docker image:  entando/entando-de-app-wildfly   or    entando/entando-de-app-eap \n Github Repo:  entando-k8s/entando-de-app \n Entando Cluster Citizen:  Entando App \n \n \n Deployment Details - AppBuilder:\n \n Docker image:  entando/app-builder \n Github Repo:  entando/app-builder \n \n \n Deployment Details - ComponentManager:\n \n Docker image:  entando/entando-component-manager \n Github Repo:  entando-k8s/entando-component-manager \n Entando Cluster Citizen:  Component Manager \n \n \n Possible Database Images:\n \n MySQL:  docker.io/centos/mysql-57-centos7 \n PostgreSQL:  docker.io/centos/postgresql-96-centos7 \n Example \n ---\nkind: "EntandoApp"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-app"\n  namespace: "my-namespace"\nspec:\n  standardServerImage: wildfly\n  customServerImage: your-org/your-image:4.3.2\n  dbms: "postgresql"\n  ingressPath: my-app\n  keycloakSecretToUse: some-kc-secret\n  clusterInfrastructureToUse: some-eci-secret  \n  ingressHostName: "test-app.my-routing-suffix.com"\n  parameters: \n    ENTANDO_VAR1: my-var1\n  tlsSecretName: my-tls-secret\n  replicas: 1\n Explanation of properties \n \n spec.standardServerImage  can be either wildfly  or  eap . This instructs the Entando Operator to use one of the\ntwo standard Entando App images.\n \n For  wildfly  it will deploy the  entando/entando-de-app-wildfly  image \n For  eap  it will deploy the  entando/entando-de-app-eap  image\nThis property and the  spec.customServerImage  are  assumed to be mutually exclusive. Only provide a value to\none of the two. Please refer to the\n relevant section \nin the README of the Entando Operator to determine how the Docker registry and version of these images will be calculated. \n \n \n spec.customServerImage  can be used to deploy the Docker image containing your own custom Entando App. Please\nfollow the instructions on how to  build your own image . \nThis property and the  spec.standardServerImage  are  assumed to be mutually exclusive. Only provide a\nvalue to one of the two. \n spec.dbms  is used to select the database management of choice. If left empty, a default value of  postgresql \nis assumed. The value  none  is not supported. If this value matches up to the  spec.dbms  property\nof a previously configured  EntandoDatabaseService ,\nthe Entando App will be configured to use this service.\nAlternatively, the Entando Operator will use this value to deploy a dedicated Database instance in this namespace\nfor the EntandoApp to use. \n spec.ingressPath  specifies the web context of the Entando App to be deployed. This is required to create a single\npath entry in the Ingress that is used to expose the Entando App. The default behaviour of Wildfly and\nJBoss EAP is to use the name of the WAR file that is deployed, but it is possible to override this in the EntandoApp\nproject itself using a  jboss-web.xml  file .\nIn the absence of the  jboss-web/xml  file, the web context  would be the the\nMaven artifactId of the Entando Opp project. It is also possible to modify this by changing the  <finalName>  element\nin the Maven  pom.xml \n spec.clusterInfrastructureToUse  is the name of the Kubernetes Secret that provides the connection details to the\nEntandoClusterInfrastructure containining the Entando Component Repository for this App to use. This is only\nrequired if more than one EntandoClusterInfrastructure is available and this value can be omitted entirely under\nmost conditions. \n spec.keycloakSecretToUse  is used to determine which Kubernetes Secret to use to connect to the correct\nKeycloak instance. If not specified, the default Secret  keycloak-admin-secret  will be used. Only useful\nif you have more than one Keycloak server in your cluster. \n spec.ingressHostName  is the hostname of the Kubernetes Ingress to be created for the Entando App. Please\nensure that this is accessible using the default routing suffix of your Entando Operator Deployment, or a DNS\nname previously registered with your DNS provider. Keep in mind that EntandoPlugins linked to this app will\nalso be made available on this host. \n spec.parameters  is a Map of environment variables to pass to the EntandoApp Docker image. For example, this could\nbe used to provide connection details for custom datasources or message queues as discussed in the\n custom datasources tutorial . Also note that all of the\n Spring variables in an Entando project \ncan also be overridden here by specifying the equivalent SNAKE_CASE names of the dot-delimited Spring properties.\nThese parameters are applied to the container\'s environment variables after all variables have been calculated.\nIt can therefore also be used as a mechanism to override any of the default environment variables that need customization.\nKeep in mind that these parameters will be passed to each of the three containers in this Pod as environment\nvariables, and that care needs to be taken to avoid conflicting variable names. \n spec.tlsSecretName  is the name of a standard Kubernetes\n TLS Secret  that will be used for the\nresulting Ingress. This is only required if the\n globally configured TLS Secret \nfor the Operator is absent or has not been created with a wildcard hostname that supports this Keycloak instance\'s hostname. \n spec.replicas  - the number of replicas to be made available on the Deployment of this Entando App \n EntandoPlugin \n An Entando Plugin is a microservice that can be made available to one or more EntandoApps in the cluster. Please follow\nour instructions on using our blueprint to  build your own EntandoPlugin . The\nDeployment resulting from an EntandoPlugin is also a multi-container Pod deployment, and will include both the\nplugin Docker image specified and the EntandoPluginSidecar Docker Image \n Overview \n \n Custom Resource Definition:  EntandoPlugin \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-plugin-controller \n Github Repo:  entando/entando-k8s-plugin-controller \n \n \n Deployment Details - plugin:\n \n Docker image: as provided by user \n Entando Cluster Citizen:  Plugin \n \n \n Deployment Details - EntandoPluginSidecar:\n \n Docker image:  entando/entando-plugin-sidecar \n Github Repo:  entando/entando-plugin-sidecar \n \n \n Possible Database Images:\n \n MySQL:  docker.io/centos/mysql-57-centos7 \n PostgreSQL:  docker.io/centos/postgresql-96-centos7 \n Example \n ---\nkind: "EntandoPlugin"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-plugin"\n  namespace: "my-namespace"\nspec:\n  image: your-org/your-image:4.3.2\n  securityLevel: lenient\n  ingressPath: /my-plugin\n  healthCheckPath: /actuator/health\n  dbms: "postgresql"\n  keycloakSecretToUse: some-kc-secret\n  clusterInfrastructureToUse: some-eci-secret  \n  ingressHostName: "test-app.my-routing-suffix.com"\n  roles:\n    - code: admin\n      name: Administrators\n    - code: user\n      name: Users\n  permissions: \n    - clientId: some-keycloak-client \n      role: some-admin\n    - clientId: another-keycloak-client \n      role: another-admin\n  parameters: \n    ENTANDO_VAR1: my-var1\n  tlsSecretName: my-tls-secret\n  replicas: 1\n Explanation of properties \n \n spec.image  is the Docker image you can provide for the plugin you want to deploy. Please follow\nour instructions on using our blueprint to  build your own EntandoPlugin \nCurrently only Docker images hosting Spring Boot applications are supported. It is therefore of  utmost\nimportance to start off with our blueprint and ensure that the resulting Spring Boot application respects\nthe Spring variables to be set from the Entando Operator. \n spec.dbms  is used to select the database management of choice. If left empty, or if the value is  none , it\nis assumed that the plugin in question does not required a database. If this value matches up to\nthe  spec.dbms  property  of a previously  configured\n EntandoDatabaseService ,\nthe Entando Plugin will be configured to use this service.\nAlternatively, the Entando Operator will use this value to deploy a dedicated Database instance in this namespace\nfor the Entando Plugin to use. \n spec.ingressPath  specifies the web context where the Entando Plugin will be made available when linked to EntandoApps.\nPlease ensure this is in sync with the  server.servlet.context-path  property set on your Spring Boot application. \n spec.clusterInfrastructureToUse  is the name of the Kubernetes Secret that provides the connection details to the\nEntandoClusterInfrastructure this Plugin will use. This is only\nrequired if more than one EntandoClusterInfrastructure is available and this value can be omitted entirely under\nmost conditions. \n spec.keycloakSecretToUse  is used to determine which Kubernetes Secret to use to connect to the correct\nKeycloak instance. If not specified, the default Secret  keycloak-admin-secret  will be used. Only useful\nif you have more than one Keycloak server in your cluster. \n spec.ingressHostName  is the hostname of the Kubernetes Ingress to be created for the Entando Plugin. Please\nensure that this is accessible using the default routing suffix of your Entando Operator Deployment, or a DNS\nname previously registered with your DNS provider. This hostname will not be used from your Widgets that you\nhave implemented for this plugin as these widgets will use the hostname of the EntandoApp they are being used from.\nThis hostname is useful for embedded web user interfaces used only on this plugin, such as admin user interfaces\nor diagnostic user interface. \n spec.roles  specifies the set of roles that this plugin expects. At deployment time, the Entando Operator ensures\nthat each of these roles are created on Keycloak for the Keycloak client representing this EntandoPlugin. It is\nup to the Plugin provider to ensure that Spring Security has been set up to enforce the access rules implied\nby the individual roles. Each role has a unique  code  and a more human readable   name  as property. \n spec.permissions  specifies the set of permissions this plugin requires on other services with known Keycloak Clients.\nAt deployment time, the Entando Operator will use the service account user of this EntandoPlugin\'s Keycloak Client\nand create the necessary role bindings on the specified client id of the service to be used.\nEach permission specifies the  clientId  in Keycloak of the target service, and the  role  that this EntandoPlugin\nshould be bound to in that Keycloak client. \n spec.parameters  is a Map of environment variables to pass to the EntandoPlugin Docker image.\nIt is entirely up to the plugin provider to determine the semantics of each variable. We strongly suggest for\nplugin provider  to use  the standard Spring Property Resolver syntax for Spring variables, as this would allow\nany of these variables to be overridden here by specifying the equivalent SNAKE_CASE names of the dot-delimited\nSpring properties.\nThese parameters are applied to the container\'s environment variables after all variables have been calculated.\nIt can therefore also be used as a mechanism to override any of the default environment variables that need customization.\nKeep in mind that these parameters will be passed to both containers in this Pod as environment\nvariables, and that care needs to be taken to avoid conflicting variable names. \n spec.tlsSecretName  is the name of a standard Kubernetes\n TLS Secret  that will be used for the\nresulting Ingress. This is only required if the\n globally configured TLS Secret \nfor the Operator is absent or has not been created with a wildcard hostname that supports this Keycloak instance\'s hostname. \n spec.replicas  - the number of replicas to be made available on the Deployment of this Entando Plugin \n EntandoAppPluginLink \n The EntandoAppPluginLink custom resource is created when an AppBuilder user links an EntandoPlugin to the current\nEntandoApp, or deploys an EntandoPlugin for use in the current EntandoApp. The Entando Operator processes the resulting\nEntandoAppPluginLink and creates a path for the Plugin on the Ingress that exposes the EntandoApp in question. This path\nis determined by the  spec.ingressPath  property on the EntandoPlugin custom resource itself. If the EntandoPlugin\nresides in a namespace other than the namespace of the EntandoApp, the EntandoOperator creates a Kubernetes\nService in the namespace of the EntandoApp that simply delegates to the Service in the namespace of the EntandoPlugin. \n Overview \n \n Custom Resource Definition:  EntandoAppPluginLink \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-app-plugin-link-controller \n Github Repo:  entando/entando-k8s-app-plugin-link-controller \n Example \n ---\nkind: "EntandoAppPluginLink"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-link"\n  namespace: "my-namespace"\nspec:\n  entandoAppName: my-app\n  entandoAppNamespace: my-namespace\n  entandoPluginName: my-app\n  entandoPluginNamespace: my-namespace\n Explanation of properties \n \n spec.entandoAppName  specifies the name of the EntandoApp that requires the plugin, found in  EntandoApp.metadata.name \n spec.entandoAppNamespace  specifies the namespace of the EntandoApp that requires the plugin, found in  EntandoApp.metadata.namespace \n spec.entandoPluginName  specifies the name of the EntandoApp that requires the plugin, found in  EntandoPlugin.metadata.name \n spec.entandoPluginNamespace  specifies the namespace of the EntandoApp that requires the plugin, found in  EntandoPlugin.metadata.namespace \n EntandoDatabaseService \n By default, the Entando Operator deploys one of either the MySQL or PostgreSQL database Docker images for every custom\nresource that requires a database. Many customers may however have existing infrastructure for their databases which\nthey may want to leverage. The EntandoDatabaseService custom resource allows customers to deploy a Service that points\nto an external database. When deploying one of the Entando custom resources that require a database, the Entando\nOperator will look for EntandoDatabases in the same namespace, and if it finds one with the same  spec.dbms  setting\nas the database required by the custom resource , it will create a dedicated schema/username/password combination\nfor the custom resource and point the deployment emanating from custom resource to this external database. \n \n Custom Resource Definition:  EntandoDatabaseService \n Example \n ---\nkind: "EntandoDatabaseService"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-database-service"\n  namespace: "my-namespace"\nspec:\n  dbms: "osracle"\n  host: 10.0.12.41\n  port: 1521\n  databaseName: mydb \n  tablespace: \n  secretName: some-secret\n  jdbcParameters:\n    maxStatements: 300 \n    loginTimeout: 180\n Explanation of properties \n \n spec.dbms  is used to select the database management of choice. If this value matches up to the  spec.dbms  property\nof the Entando custom resource that will use it. Valid values are  oracle ,  postgresql  and  mysql . \n spec.host  can either be a valid IPv4 address, or a hostname. Where an IP address is provided, the Entando Operator\nwill create a Kubernetes Service with an associated EndPoints resource to allow for routing to this address. Where\na hostname is provided, the Entando Operator will simply create a Kubernetes Service of type  cname \n spec.port  is the port that the external database service is running on. This value is optional in which case we will\nuse the default port for the DBMS vendor in question \n spec.databaseName  is the name of the database that the Entando Operator should be creating schemas in. This property\nis only for use with PostgreSQL and Oracle, as MySQL doesn\'t distinguish between schemas and databases. \n spec.tablespace  is only required for Oracle so that Schemas can be created in different tablespaces. \n spec.secretName  should be the name ( Secret.metadata.name ) of a Kubernetes Secret in the same namespace that has\na  username  key and a  password  key that will provide the Entando Operator with the necessary access and permissions\nto create Schemas and users on the database in question. \n spec.jdbcParameters  is a map of name/value pairs that will be appended to the JDBC connection string to allow for\nfurther customization of the actual connection to the database. \n EntandoCompositeApp \n The EntandoCompositeApp custom resource can be used to package a collection of Entando Core Custom Resources in a\nsingle YAML file for sequential deployment. Keep in mind that one can already use standard YAML syntax to package\na set of Kubernetes resources in a single file, separating each resource with a triple dash ( --- ). The purpose\nof this custom resource is therefor specifically to ensure that the deployment of the previous \'component\' has\ncompleted, and that  the resulting Pod is up and running before commencing deploying on the \'component\'. \n The primary use case of this custom resource is to package a full Entando App and all its supporting service and\nplugins for easy installation as is often required for demos and POCs. Creating this kind of dependency for typical\nproduction deployments is not advised, as it will inevitably result in a violation of pipeline isolation. The\nmore commonly recommended approach is for your Entando Apps and Plugins to be fully deployable in isolation. Use this\ncustom resource with care. \n Overview \n \n Custom Resource Definition:  EntandoCompositeApp \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-composite-app-controller \n Github Repo:  entando/entando-k8s-composite-app-controller \n Example \n ---\nkind: "EntandoCompositeApp"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-composite-app"\n  namespace: "my-namespace"\nspec:\n  components:\n    - kind: "EntandoKeycloakServer"\n         metadata:\n           name: "my-kc"\n         spec:\n           dbms: postgresql\n           isDefault: true\n           replicas: 1\n       - kind: "EntandoClusterInfrastructure"\n         metadata:\n           name: "my-eci"\n         spec:\n           dbms: postgresql\n           replicas: 1\n           isDefault: true\n       - kind: "EntandoApp"\n         metadata:\n           name: "my-app"\n         spec:\n           dbms: postgresql\n           replicas: 1\n           standardServerImage: wildfly\n           ingressPath: /entando-de-app\n       - kind: "EntandoPlugin"\n         metadata:\n           name: "my-pda"\n         spec:\n           image: "docker.io/entando/entando-process-driven-plugin:latest"\n           replicas: 1\n           dbms: "mysql"\n Explanation of properties \n \n spec.components  specifies the list of Entando Core Custom Resources to be deployed  in sequence . Please note\nthat only the Entando Custom Resources discussed in this section can be used in this list. Custom resources\nrelated to the Entando Component Repository never result in actual deployments on the Kubernetes cluster and\ntherefore do not need to be specified in any sequence. You can use the normal triple dash YAML notation to\ninclude them in the same YAML file \n \n'},{title:"Add a New Datasource in EAP Server",frontmatter:{},regularPath:"/v6.1/docs/reference/add_datasource_to_eap_image.html",relativePath:"v6.1/docs/reference/add_datasource_to_eap_image.md",key:"v-3469f1cc",path:"/v6.1/docs/reference/add_datasource_to_eap_image.html",headers:[{level:2,title:"Other resources",slug:"other-resources"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:' Add a New Datasource in EAP Server \n With EAP should be enough to add a set of parameters the EntandoApp\ncustom resource. \n \n \n Set the standardServerImage to eap \n \n \n Add a  parameters  object \n \n \n \n Parameters environment variables reference \n \n \n \n \n \n \n \n Env variable \n Value \n Example with PortDB \n \n \n \n \n DATASOURCES \n "PORTDB,SERVDB, <YOUR-DS-PREFIX>" \n \n \n \n <YOUR-DS-PREFIX>_NONXA \n Defines the datasource as a non-XA datasource. Defaults to  false \n PORTDB_NONXA="true" \n \n \n <YOUR-DS-PREFIX>_JTA \n Defines Java Transaction API (JTA) option for the non-XA datasource. The XA datasources are already JTA capable by default Defaults to  true \n PORTDB_JTA="false" \n \n \n <YOUR-DS-PREFIX>_URL \n Defines connection URL for the datasource. \n PORTDB_URL="jdbc:derby:/entando-data/databases/entandoPort;create=true" \n \n \n <YOUR-DS-PREFIX>_JNDI \n Defines the JNDI name for the datasource. This setting is useful if you want to override the default generated JNDI name \n PORTDB_JNDI="java:jboss/datasources/entandoPortDataSource" \n \n \n <YOUR-DS-PREFIX>_DRIVER \n Defines Java database driver for the datasource \n PORTDB_DRIVER="derby" \n \n \n <YOUR-DS-PREFIX>_USERNAME \n Defines the username for the datasource \n PORTDB_USERNAME="agile" \n \n \n <YOUR-DS-PREFIX>_PASSWORD \n Defines the password for the datasource \n PORTDB_PASSWORD="agile" \n \n \n <YOUR-DS-PREFIX>_SERVICE_HOST \n Defines the database server’s host name or IP address to be used in the datasource’s connection-url property. \n PORTDB_SERVICE_HOST="dummy" \n \n \n <YOUR-DS-PREFIX>_SERVICE_PORT \n Defines the database server’s port for the datasource. \n PORTDB_SERVICE_PORT="1527" \n \n \n \n \n Note \n For more details on other standard variables check the  EAP\ndocumentation \n \n Here a potential example \n apiVersion: entando.org/v1\nkind: "EntandoApp"\nmetadata:\n  annotations: {}\n  labels: {}\n  name: "quickstart"\nspec:\n  dbms: #tbd\n  replicas: 1\n  standardServerImage: eap\n  ingressPath: /entando-de-app\n  parameters:\n    DATASOURCES: "PORTDB,SERVDB,MYDATASOURCE"\n    MYDATASOURCE_NONXA: "true"\n    MYDATASOURCE_JTA: "false"\n    ...\n Other resources \n \n EAP Official Documentation: Runtime\nArtifacts/Datasources \n \n'},{title:"Quick Reference",frontmatter:{},regularPath:"/v6.1/docs/getting-started/quick-reference.html",relativePath:"v6.1/docs/getting-started/quick-reference.md",key:"v-9e5cc7e8",path:"/v6.1/docs/getting-started/quick-reference.html",headers:[{level:2,title:"Quick Reference",slug:"quick-reference"}],lastUpdated:"2/3/2022, 5:40:38 PM",lastUpdatedTimestamp:1643928038e3,content:" Quick Reference \n Just the steps, for advanced users. \n \n Install  Multipass \n Launch VM \n multipass launch --name ubuntu-lts --cpus  4  --mem 8G --disk 20G\n \n Open Ubuntu shell \n multipass shell ubuntu-lts\n \n Install k3s \n curl  -sfL https://get.k3s.io  |   sh  -\n \n Check for node ready \n sudo  kubectl get  node \n \n Download custom resource definitions \n curl  -L -C - https://developer.entando.com/assets/yaml/custom-resources.tar.gz  |   tar  -xz\n \n Create custom resources \n sudo  kubectl create -f custom-resources\n \n Create namespace \n sudo  kubectl create namespace entando\n \n Download Helm chart \n curl  -L -C - -O https://developer.entando.com/assets/yaml/entando.yaml\n \n Configure external access to your cluster with your VM IP \n IP = $( hostname  -I  |   awk   '{print $1}' ) \n \n sed  -i  \"s/192.168.64.25/ $IP /\"  entando.yaml\n \n Deploy Entando \n sudo  kubectl create -f entando.yaml\n \n Check for quickstart-composite-app-deployer  Completed \n sudo  kubectl get pods -n entando --watch\n \n Get URL to access Entando App Builder from your browser \n sudo  kubectl get ingress -n entando -o  jsonpath = \\ \n '{.items[2].spec.rules[*].host}{.items[2].spec.rules[*].http.paths[2].path}{\"\\n\"}' \n \n "},{title:"Get Started with Entando in 3 Easy Steps",frontmatter:{sidebarDepth:2},regularPath:"/v6.1/docs/getting-started/",relativePath:"v6.1/docs/getting-started/README.md",key:"v-65cd12ed",path:"/v6.1/docs/getting-started/",headers:[{level:2,title:"Install Kubernetes",slug:"install-kubernetes"},{level:3,title:"Enable Hypervisor",slug:"enable-hypervisor"},{level:3,title:"Launch Ubuntu VM",slug:"launch-ubuntu-vm"},{level:3,title:"Run Kubernetes",slug:"run-kubernetes"},{level:2,title:"Prepare Kubernetes Environment",slug:"prepare-kubernetes-environment"},{level:3,title:"Add Custom Resources",slug:"add-custom-resources"},{level:3,title:"Create Namespace",slug:"create-namespace"},{level:3,title:"Download Helm Chart",slug:"download-helm-chart"},{level:3,title:"Configure Access to Your Cluster",slug:"configure-access-to-your-cluster"},{level:2,title:"Deploy Entando",slug:"deploy-entando"}],lastUpdated:"2/3/2022, 5:40:38 PM",lastUpdatedTimestamp:1643928038e3,content:" Get Started with Entando in 3 Easy Steps \n New to Kubernetes, hypervisors, and Helm charts? \n This in-depth guide takes a learn-as-you-go approach, and will give you a working knowledge of Kubernetes as you get Entando up and running in a local environment. \n \n Install Kubernetes \n Prepare Kubernetes Environment \n Deploy Entando \n \n Note: For advanced or long-time Entando users, check out our  Quick Reference  install guide with just the steps. \n Install Kubernetes \n Since Entando is designed to run on Kubernetes, let's get started by installing our own instance of Kubernetes locally. \n We've tested a variety of Kubernetes implementations including Minikube, Minishift, CodeReady Containers, K3s, and Microk8s to find the best combination of low cpu/memory usage, fast startup times, and minimal configuration so we can get started quickly. After downloading the necessary files, we'll have our own instance of Kubernetes up and running in < 60 seconds. \n What's Needed to Run Kubernetes \n Kubernetes is a container orchestrator designed to manage a server cluster. It requires at least one master node running a Linux OS. We'll be using Multipass to create a lightweight Ubuntu VM in seconds that runs on a bare metal hypervisor for speed and performance. \n Enable Hypervisor \n TIP \n Hypervisors allow you to create and run virtual machines. Virtualization software that run on top of your operating system like VirtualBox or VMWare Workstation are Type 2 hypervisors. Type 1 hypervisors run on bare metal. \n \n Let's install a bare metal hypervisor for optimal performance. \n Mac:  Install  hyperkit . \n brew  install  hyperkit\n \n Windows:   Install Hyper-V \n \n What if my machine doesn't support hyperkit or Hyper-V? \n Use a Type 2 hypervisor that runs on top of your operating system: \n \n Install Virtual Box:\n Mac \n Windows \n Launch Ubuntu VM \n TIP \n Multipass is a tool developed by the publishers of Ubuntu to create lightweight Ubuntu VMs in seconds. \n \n \n \n Install  Multipass \n \n \n Launch VM \n \n \n multipass launch --name ubuntu-lts --cpus  4  --mem 8G --disk 20G\n \n \n Open a shell \n \n multipass shell ubuntu-lts\n Run Kubernetes \n TIP \n K3s is a certified Kubernetes distribution designed for production workloads in resource-constrained environments. \n It's packaged as a single <40MB binary that reduces the dependencies and steps needed to install, run and auto-update a production Kubernetes cluster. \n \n \n Install  k3s \n \n curl  -sfL https://get.k3s.io  |   sh  -\n \n \n Check for  Ready   STATUS . \n \n sudo  kubectl get  node \n \n \n What's running out of the box? \n sudo  kubectl get pods -A\n \n \n \n Congratulations! \n You now have a local instance of Kubernetes up and running. \n Prepare Kubernetes Environment \n To install Entando, we'll add  Custom Resources , create a  Namespace , download a  Helm  chart, and configure external access to our cluster. \n Add Custom Resources \n TIP \n Standard resources in Kubernetes include things like  Pods , which are a group of one or more containers,  Services , the way to call or access your pods, and  Ingresses , for managing external access to your cluster. \n Custom resources let you store and retrieve structured data.  Combining a custom resource with a custom controller allows you to define a desired state to automate the running of your applications or services in a Kubernetes cluster. \n \n Examples of custom resources in Entando are: \n \n Entando App Engine \n Entando Identity Management System \n \n From your Ubuntu shell: \n \n Download custom resource definitions. \n \n wget  -c https://developer.entando.com/assets/yaml/custom-resources.tar.gz -O -  |   tar  -xz\n \n \n Create custom resources \n \n sudo  kubectl create -f custom-resources\n Create Namespace \n TIP \n Kubernetes supports multiple virtual clusters backed by the same physical cluster. These virtual clusters are called namespaces. \n You can use namespaces to allocate resources and set cpu/memory limits for individual projects or teams. They can also encapsulate projects from one another. \n \n sudo  kubectl create namespace entando\n Download Helm Chart \n TIP \n Helm is a package manager for Kubernetes that helps you define, install, and upgrade Kubernetes applications. \n \n curl  -L -C - -O https://developer.entando.com/assets/yaml/entando.yaml\n Configure Access to Your Cluster \n TIP \n Entando sets up  Ingresses  in Kubernetes to access services from outside your server cluster. We'll use this to access Entando from a local browser. \n \n To set up external access to your cluster, you'll need to replace the value of  ENTANDO_DEFAULT_ROUTING_SUFFIX  with your Ubuntu IP. You can look up your Ubuntu IP, and edit the YAML file manaully, but running the below commands will automatically update the IP address for you. \n IP = $( hostname  -I  |   awk   '{print $1}' ) \n \n sed  -i  \"s/192.168.64.25/ $IP /\"  entando.yaml\n Deploy Entando \n Deploying the Helm chart will deploy all of the Kubernetes resources required for Entando to run. \n sudo  kubectl create -f entando.yaml\n \n sudo  kubectl get pods -n entando --watch\n \n \n What does a successful startup look like? \n \n First, you'll see the Entando operator:  ContainerCreating  >  Running \n Next, the Entando composite app deployer:  Pending  >  ContainerCreating  >  Running \n Then, Keycloak:  kc-deployer  >  kc-db-deployment \n \n Jobs / Deployments \n \n Jobs, like  kc-db-preparation-job  run once, and are  Completed :  0/1 \n Database deployments, like  kc-db-deployment , should end up as  Running :  1/1 \n The Keycloak server deployment  kc-server-deployment , should end up as  Running :  1/1 \n The  quickstart-server-deployment  should end up as  3/3 \n \n Lifecycle Events \n \n Each line represents an event:  Pending ,  ContainerCreating ,  Running  or  Completed \n Restarts should ideally be  0 ; otherwise, there was a problem with your cluster, and Kubernetes is trying to self-heal \n \n ubuntu@test-vm : ~ $   sudo  kubectl get pods -n entando --watch \n NAME                                   READY   STATUS              RESTARTS   AGE\nquickstart-operator-8556c9c6f8-9ghwg   0/1     ContainerCreating   0          3s\nquickstart-operator-8556c9c6f8-9ghwg   0/1     Running             0          49s\nquickstart-composite-app-deployer-picaju7bf0   0/1     Pending             0          0s\nquickstart-composite-app-deployer-picaju7bf0   0/1     Pending             0          0s\nquickstart-composite-app-deployer-picaju7bf0   0/1     ContainerCreating   0          0s\nquickstart-composite-app-deployer-picaju7bf0   1/1     Running             0          20s\nquickstart-kc-deployer-mx7ms3sc2l              0/1     Pending             0          0s\nquickstart-kc-deployer-mx7ms3sc2l              0/1     Pending             0          0s\nquickstart-kc-deployer-mx7ms3sc2l              0/1     ContainerCreating   0          0s\nquickstart-operator-8556c9c6f8-9ghwg           1/1     Running             0          88s\nquickstart-kc-deployer-mx7ms3sc2l              1/1     Running             0          19s\nquickstart-kc-db-deployment-c57f75d7f-wxmqr    0/1     Pending             0          0s\nquickstart-kc-db-deployment-c57f75d7f-wxmqr    0/1     Pending             0          7s\nquickstart-kc-db-deployment-c57f75d7f-wxmqr    0/1     ContainerCreating   0          7s\nquickstart-kc-db-deployment-c57f75d7f-wxmqr    0/1     Running             0          77s\nquickstart-kc-db-deployment-c57f75d7f-wxmqr    1/1     Running             0          87s\nquickstart-kc-db-preparation-job-1d6ab9b6-7    0/1     Pending             0          0s\nquickstart-kc-db-preparation-job-1d6ab9b6-7    0/1     Pending             0          0s\nquickstart-kc-db-preparation-job-1d6ab9b6-7    0/1     Init:0/1            0          0s\nquickstart-kc-db-preparation-job-1d6ab9b6-7    0/1     Init:0/1            0          13s\nquickstart-kc-db-preparation-job-1d6ab9b6-7    0/1     PodInitializing     0          15s\nquickstart-kc-db-preparation-job-1d6ab9b6-7    0/1     Completed           0          17s\nquickstart-kc-server-deployment-66484d596d-qr78q   0/1     Pending             0          0s\nquickstart-kc-server-deployment-66484d596d-qr78q   0/1     Pending             0          0s\nquickstart-kc-server-deployment-66484d596d-qr78q   0/1     ContainerCreating   0          0s\nquickstart-kc-server-deployment-66484d596d-qr78q   0/1     Running             0          3m\nquickstart-kc-server-deployment-66484d596d-qr78q   1/1     Running             0          4m36s\nquickstart-kc-deployer-mx7ms3sc2l                  0/1     Completed           0          6m50s\nquickstart-eci-deployer-kx9nhop22g                 0/1     Pending             0          0s\nquickstart-eci-deployer-kx9nhop22g                 0/1     Pending             0          0s\nquickstart-eci-deployer-kx9nhop22g                 0/1     ContainerCreating   0          0s\nquickstart-eci-deployer-kx9nhop22g                 1/1     Running             0          5s\nquickstart-eci-k8s-svc-deployment-7c58c78b55-z52xj   0/1     Pending             0          0s\nquickstart-eci-k8s-svc-deployment-7c58c78b55-z52xj   0/1     Pending             0          0s\nquickstart-eci-k8s-svc-deployment-7c58c78b55-z52xj   0/1     ContainerCreating   0          0s\nquickstart-eci-k8s-svc-deployment-7c58c78b55-z52xj   0/1     Running             0          97s\nquickstart-eci-k8s-svc-deployment-7c58c78b55-z52xj   1/1     Running             0          2m7s\nquickstart-eci-deployer-kx9nhop22g                   0/1     Completed           0          2m15s\nquickstart-deployer-os19rw3eto                       0/1     Pending             0          0s\nquickstart-deployer-os19rw3eto                       0/1     Pending             0          0s\nquickstart-deployer-os19rw3eto                       0/1     ContainerCreating   0          1s\nquickstart-deployer-os19rw3eto                       1/1     Running             0          6s\nquickstart-db-deployment-7fff4c8479-qf469            0/1     Pending             0          0s\nquickstart-db-deployment-7fff4c8479-qf469            0/1     Pending             0          4s\nquickstart-db-deployment-7fff4c8479-qf469            0/1     ContainerCreating   0          4s\nquickstart-db-deployment-7fff4c8479-qf469            0/1     Running             0          7s\nquickstart-db-deployment-7fff4c8479-qf469            1/1     Running             0          19s\nquickstart-db-preparation-job-5a55b267-6             0/1     Pending             0          0s\nquickstart-db-preparation-job-5a55b267-6             0/1     Pending             0          0s\nquickstart-db-preparation-job-5a55b267-6             0/1     Init:0/4            0          0s\nquickstart-db-preparation-job-5a55b267-6             0/1     Init:0/4            0          4s\nquickstart-db-preparation-job-5a55b267-6             0/1     Init:1/4            0          5s\nquickstart-db-preparation-job-5a55b267-6             0/1     Init:1/4            0          8s\nquickstart-db-preparation-job-5a55b267-6             0/1     Init:2/4            0          9s\nquickstart-db-preparation-job-5a55b267-6             0/1     Init:2/4            0          6m42s\nquickstart-db-preparation-job-5a55b267-6             0/1     Init:3/4            0          7m20s\nquickstart-db-preparation-job-5a55b267-6             0/1     Init:3/4            0          7m22s\nquickstart-db-preparation-job-5a55b267-6             0/1     PodInitializing     0          7m23s\nquickstart-db-preparation-job-5a55b267-6             0/1     Completed           0          7m25s\nquickstart-server-deployment-5597597575-gtptz        0/3     Pending             0          0s\nquickstart-server-deployment-5597597575-gtptz        0/3     Pending             0          4s\nquickstart-server-deployment-5597597575-gtptz        0/3     ContainerCreating   0          4s\nquickstart-server-deployment-5597597575-gtptz        0/3     Running             0          2m35s\nquickstart-server-deployment-5597597575-gtptz        1/3     Running             0          2m37s\nquickstart-server-deployment-5597597575-gtptz        2/3     Running             0          2m38s\nquickstart-server-deployment-5597597575-gtptz        3/3     Running             0          3m5s\nquickstart-deployer-os19rw3eto                       0/1     Completed           0          11m\nquickstart-composite-app-deployer-picaju7bf0         0/1     Completed           0          20m\n \n \n \n Press  Ctrl-C  to exit the watch command once everything is up and running. \n \n What pods come out of the box? \n sudo  kubectl get pods -n entando\n \n NAME                                                 READY   STATUS      RESTARTS   AGE\nquickstart-operator-8556c9c6f8-9ghwg                 1/1     Running     0          132m\nquickstart-kc-db-deployment-c57f75d7f-wxmqr          1/1     Running     0          130m\nquickstart-kc-db-preparation-job-1d6ab9b6-7          0/1     Completed   0          129m\nquickstart-kc-server-deployment-66484d596d-qr78q     1/1     Running     0          128m\nquickstart-kc-deployer-mx7ms3sc2l                    0/1     Completed   0          130m\nquickstart-eci-k8s-svc-deployment-7c58c78b55-z52xj   1/1     Running     0          123m\nquickstart-eci-deployer-kx9nhop22g                   0/1     Completed   0          124m\nquickstart-db-deployment-7fff4c8479-qf469            1/1     Running     0          121m\nquickstart-db-preparation-job-5a55b267-6             0/1     Completed   0          121m\nquickstart-server-deployment-5597597575-gtptz        3/3     Running     0          113m\nquickstart-deployer-os19rw3eto                       0/1     Completed   0          121m\nquickstart-composite-app-deployer-picaju7bf0         0/1     Completed   0          131m\n Log in to Entando \n Now that we've installed Entando, let's log in to  Entando App Builder . \n TIP \n Ingress exposes HTTP routes from outside the cluster to services within the cluster. \n \n Get the URL to access Entando from your local browser. \n sudo  kubectl get ingress -n entando -o  jsonpath = \\ \n '{.items[2].spec.rules[*].host}{.items[2].spec.rules[*].http.paths[2].path}{\"\\n\"}' \n \n \n Example URL: \n \n quickstart-entando.192.168.64.33.nip.io/app-builder/\n \n \n \n \n Username: admin \n Password: adminadmin \n \n After login, change your password to activate your account. \n \n Note: If the login process hangs for more than 5 seconds, refresh the browser. \n \n \n The App Builder is where we'll compose our micro frontends alongside CMS pages and content. \n Congratulations! \n We now have Entando up and running on Kubernetes in our local environment. \n \n \n For Developers: Learn how Ingresses work behind the scenes. \n\n``` bash\nsudo kubectl describe ingress -n entando\n```\n\n``` shell-session\nName:             quickstart-kc-ingress\nNamespace:        entando\nAddress:          192.168.64.33\nDefault backend:  default-http-backend:80 ( )\nRules:\n  Host                                        Path  Backends\n  ----                                        ----  --------\n  quickstart-kc-entando.192.168.64.33.nip.io\n                                              /auth   quickstart-kc-server-service:8080 (10.42.0.14:8080)\n```\n\nThe Ingress provides the `Host` and `Path` to access our `Services`.\n\n#### Identity Management\n\n1. Find the URL to the Keycloak server.\n\n``` shell-session\n  Host                                        Path  Backends\n  ----                                        ----  --------\n  quickstart-kc-entando.192.168.64.33.nip.io\n                                              /auth   quickstart-kc-server-service:8080 (10.42.0.14:8080)\n```\n\n- Example URL:\n\n``` bash\nhttp://quickstart-kc-entando.192.168.64.33.nip.io/auth/\n```\n\nNote: Replace the first part of the URL with the value of your `Host`\n\n2. Get the Kubernetes `Secret` for the login and password.\n\n``` bash\nsudo kubectl get secrets -n entando\n```\n\nWe're interested in the `keycloak-admin-secret`:\n\n``` shell-session\nNAME                                                 TYPE                                  DATA   AGE\nquickstart-kc-db-admin-secret                        Opaque                                2      78m\nquickstart-kc-db-secret                              Opaque                                2      76m\nquickstart-kc-admin-secret                           Opaque                                2      76m\nquickstart-kc-realm                                  Opaque                                1      76m\nkeycloak-admin-secret                                Opaque                                3      70m\n```\n\n3. Decode the secret.\n\n``` bash\nsudo kubectl get secret keycloak-admin-secret -n entando -o jsonpath=\\\n'{\"\\n Username: \"}{.data.username | base64decode}{\"\\n Password: \"}{.data.password | base64decode}{\"\\n\"}'\n\"{{println}}Username: {{.data.username | base64decode}}{{println}}Password: {{.data.password | base64decode}}{{println}}{{println}}\"\n```\n\n- Example Username and Password:\n\n``` shell-session\nUsername: entando_keycloak_admin\nPassword: MZ8bY4phMd\n```\n\n4. In your Keycloak browser, click `Administration Console`\n\nEnter the Username and Password from your shell.\n\n#### Entando App Builder\n\n``` bash\nsudo kubectl describe ingress -n entando\n```\n\n``` shell-session\nName:             quickstart-ingress\nNamespace:        entando\nAddress:          192.168.64.33\nDefault backend:  default-http-backend:80 ( )\nRules:\n  Host                                     Path  Backends\n  ----                                     ----  --------\n  quickstart-entando.192.168.64.33.nip.io\n                                           /entando-de-app     quickstart-server-service:8080 (10.42.0.22:8080)\n                                           /digital-exchange   quickstart-server-service:8083 (10.42.0.22:8083)\n                                           /app-builder/       quickstart-server-service:8081 (10.42.0.22:8081)\n                                           /pda                quickstart-pda-server-service:8081 (10.42.0.28:8081)\n```\n\n- Example URL:\n\n``` bash\nhttp://quickstart-entando.192.168.64.33.nip.io/app-builder/\n```\n\n \n\n--- --\x3e\n"},{title:"The Entando Core APIs",frontmatter:{},regularPath:"/v6.1/docs/reference/core-swagger.html",relativePath:"v6.1/docs/reference/core-swagger.md",key:"v-2fb94430",path:"/v6.1/docs/reference/core-swagger.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Setup",slug:"setup"},{level:2,title:"Overview",slug:"overview"},{level:3,title:"API structure",slug:"api-structure"},{level:3,title:"Models",slug:"models"},{level:2,title:"Tutorial:",slug:"tutorial"}],lastUpdated:"12/15/2021, 2:22:26 PM",lastUpdatedTimestamp:1639596146e3,content:" The Entando Core APIs \n Prerequisites \n \n \n Java 8 \n \n \n maven \n Setup \n \n \n Clone the Entando sample app if you don’t already have it. \n git clone https://github.com/entando/entando-de-app\n \n \n \n Start the app for local execution and enable the swagger profile by\npassing  -Dspring.profiles.active=swagger  to the jetty command. Set\nthe value of  -Djetty.port  to something available on your machine\ne.g. 8081. \n mvn clean package jetty:run-war -Pjetty-local -Pderby -Dspring.profiles.active=swagger -Djetty.port=8085 -Dorg.slf4j.simpleLogger.log.org.eclipse.jetty.annotations.AnnotationParser=error \n \n \n \n Note: If you don't have docker installed or running add  -DskipDocker=true  to the command above \n \n \n \n Wait for the app to start. \n \n \n Once started, navigate to the swagger ui in a browser. \n \n \n \n http://localhost:[your port]/entando-de-app/api/swagger-ui.html\n Overview \n The Entando core exposes REST APIs for every action that can be taken in\nthe App Builder and Admin Console environments. For example, you can use\nthese apis to create pages, create page models or to add widgets to\npages. The APIs can be used to support automation, testing, or\nintegrations with external systems. \n API structure \n All of the APIs share a common top level structure. Each response will\ncontain a top level entry for  errors ,  metadata , and  payload . \n The  errors  will always contain code and a message string indicating an\nerror condition in the request. The  metadata  section is used for\npaging, sorting, filtering and data that is distinct from the body. The\nbody of each response is included in the  payload  section of the\nresponse and varies according to each API. \n Models \n All of the model classes returned by the Entando core are annotated so\nthat the model definition is included in the swagger documentation. At\nthe bottom of the swagger page all of the model classes returned by the\nAPI endpoints can be found. \n Tutorial: \n \n \n Stop the Entando instance if it is running. \n \n \n In the project open  src/main/conf/systemParams.properties . \n \n \n Change the value of this property to reflect the port you are using\nto run the app. \n \n \n applicationBaseURL \n \n \n For example if running on 8085 you would have\n applicationBaseURL=http://localhost:8085/${entando.engine.web.context}/ \n \n \n \n \n Login to the admin console at\n http://localhost:8085/entando-de-app/do/login . \n \n \n Once logged in go to Integration -→ API Management -→ Consumers. \n \n \n Select the kebab button on the row labeled swagger. \n \n \n On that screen enable the button for  client_credentials . \n \n \n On that screen enter  swagger  as the value for the secret. \n \n \n Hit save \n \n \n Return to swagger  your\nport /entando-de-app/api/swagger-ui.html \n \n \n Hit authorize \n \n \n Enter \n \n \n User: admin \n \n \n PW: adminadmin \n \n \n client: swagger \n \n \n client_secret: swagger \n \n \n \n \n Use the  Try it out  button on the APIs \n \n \n Scroll to  widget-controller \n \n \n Select the blue GET row \n \n \n Select  Try it out \n \n \n Look at the results in the window \n \n \n \n \n"},{title:"Accessing Entando APIs",frontmatter:{sidebarDepth:0},regularPath:"/v6.1/docs/reference/entando-apis.html",relativePath:"v6.1/docs/reference/entando-apis.md",key:"v-5787385a",path:"/v6.1/docs/reference/entando-apis.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Setup",slug:"setup"},{level:2,title:"Overview",slug:"overview"},{level:3,title:"API structure",slug:"api-structure"},{level:3,title:"Models",slug:"models"},{level:2,title:"Tutorial:",slug:"tutorial"}],lastUpdated:"12/15/2021, 2:22:26 PM",lastUpdatedTimestamp:1639596146e3,content:" Accessing Entando APIs \n Prerequisites \n \n \n Java 8 \n \n \n maven \n Setup \n \n \n Clone the Entando sample app if you don’t already have it. \n git clone https://github.com/entando/entando-de-app\n \n \n \n Start the app for local execution and enable the swagger profile by\npassing  -Dspring.profiles.active=swagger  to the jetty command. Set\nthe value of  -Djetty.port  to something available on your machine\ne.g. 8081. \n mvn clean package jetty:run-war -Pjetty-local -Pderby -Dspring.profiles.active=swagger -Djetty.port=8085 -Dorg.slf4j.simpleLogger.log.org.eclipse.jetty.annotations.AnnotationParser=error \n \n \n \n Note: If you don't have docker installed or running add  -DskipDocker=true  to the command above \n \n \n \n Wait for the app to start. \n \n \n Once started, navigate to the swagger ui in a browser. \n \n \n \n http://localhost:[your port]/entando-de-app/api/swagger-ui.html\n Overview \n The Entando core exposes REST APIs for every action that can be taken in\nthe App Builder and Admin Console environments. For example, you can use\nthese apis to create pages, create page models or to add widgets to\npages. The APIs can be used to support automation, testing, or\nintegrations with external systems. \n API structure \n All of the APIs share a common top level structure. Each response will\ncontain a top level entry for  errors ,  metadata , and  payload . \n The  errors  will always contain code and a message string indicating an\nerror condition in the request. The  metadata  section is used for\npaging, sorting, filtering and data that is distinct from the body. The\nbody of each response is included in the  payload  section of the\nresponse and varies according to each API. \n Models \n All of the model classes returned by the Entando core are annotated so\nthat the model definition is included in the swagger documentation. At\nthe bottom of the swagger page all of the model classes returned by the\nAPI endpoints can be found. \n Tutorial: \n \n \n Stop the Entando instance if it is running. \n \n \n In the project open  src/main/conf/systemParams.properties . \n \n \n Change the value of this property to reflect the port you are using\nto run the app. \n \n \n applicationBaseURL \n \n \n For example if running on 8085 you would have\n applicationBaseURL=http://localhost:8085/${entando.engine.web.context}/ \n \n \n \n \n Login to the admin console at\n http://localhost:8085/entando-de-app/do/login . \n \n \n Once logged in go to Integration -→ API Management -→ Consumers. \n \n \n Select the kebab button on the row labeled swagger. \n \n \n On that screen enable the button for  client_credentials . \n \n \n On that screen enter  swagger  as the value for the secret. \n \n \n Hit save \n \n \n Return to swagger  your\nport /entando-de-app/api/swagger-ui.html \n \n \n Hit authorize \n \n \n Enter \n \n \n User: admin \n \n \n PW: adminadmin \n \n \n client: swagger \n \n \n client_secret: swagger \n \n \n \n \n Use the  Try it out  button on the APIs \n \n \n Scroll to  widget-controller \n \n \n Select the blue GET row \n \n \n Select  Try it out \n \n \n Look at the results in the window \n \n \n \n \n"},{title:"Release Notes Entando 6.1.0",frontmatter:{},regularPath:"/v6.1/docs/releases/",relativePath:"v6.1/docs/releases/README.md",key:"v-4678a3b6",path:"/v6.1/docs/releases/",headers:[{level:2,title:"Highlights",slug:"highlights"},{level:3,title:"Helm Based Getting Started",slug:"helm-based-getting-started"},{level:3,title:"Micro Frontend Configuration in App Builder",slug:"micro-frontend-configuration-in-app-builder"},{level:3,title:"New Process Driven Applications Micro Frontends",slug:"new-process-driven-applications-micro-frontends"},{level:3,title:"Entando Blueprint Bundle Generation",slug:"entando-blueprint-bundle-generation"},{level:3,title:"Entando Blueprint Local Development Updates",slug:"entando-blueprint-local-development-updates"},{level:3,title:"CMS Enhancements in the App Builder",slug:"cms-enhancements-in-the-app-builder"},{level:3,title:"New and Updated CMS REST APIs",slug:"new-and-updated-cms-rest-apis"},{level:3,title:"Operator and Kubernetes Infrastructure Updates",slug:"operator-and-kubernetes-infrastructure-updates"},{level:3,title:"Added the Ability to Integrated Google Analytics in Progressive Web App",slug:"added-the-ability-to-integrated-google-analytics-in-progressive-web-app"},{level:2,title:"Tech Preview",slug:"tech-preview"},{level:2,title:"Released Image Versions",slug:"released-image-versions"},{level:2,title:"Known Issues",slug:"known-issues"},{level:3,title:"Key Open Issues",slug:"key-open-issues"},{level:2,title:"Previous Releases",slug:"previous-releases"}],lastUpdated:"2/14/2022, 9:18:26 AM",lastUpdatedTimestamp:1644848306e3,content:" Release Notes Entando 6.1.0 \n Highlights \n Helm Based Getting Started \n With the release of 6.1 Entando is using a Helm 2 client to assist in\nthe generation and installation of the full suite of Entando 6\ncapability. The new getting started simplifies the process of installing\nEntando 6 and automatically generates everything needed to install a\nfull Entando instance in your Kuberentes environment. Check out the helm\nbased getting started here:  Getting Started \n Micro Frontend Configuration in App Builder \n The App Builder now gives developers the ability to create a micro\nfrontend to render configuration to the App Builder user when you add a\nwidget to a page. The configuration is stored in the Entando application\ndatabase and can be referenced by the runtime micro frontend via custom\ntags or an API call. Tutorials and more details in documentation:\n Widget Configuration \n New Process Driven Applications Micro Frontends \n With the release of Entando 6.1 we are introducing an all new set of\nmicro frontends for Process Driven Applications (PDAs). The release\nincludes eight micro frontends (smart task inbox, task details, notes,\nattachments, form generation, summary card, and over time dashboard)\nthat integrate with your underlying process automation engine. The\nrelease also includes a default integration with Red Hat PAM. More on\nthe new PDA functionality in 6.1.0:\n PDA Architecture \n Entando Blueprint Bundle Generation \n The Entando Blueprint now includes scripts and functionality to assist\ndevelopers in automatically generating a bundle for the ECR. The scripts\nbuild micro frontends and generate the Kubernetes custom resource\ndefinitions needed to deploy components created using the blueprint to\nthe ECR. \n Entando Blueprint Local Development Updates \n With Entando 6.1 developers can now launch their blueprint generated\napplications without any changes. In prior versions developers were\nrequired to update CORs settings, add Options call support to security\nconfiguration, and to create environmental configuration to run their\nEntando Blueprint generated applications:  Blueprint \n CMS Enhancements in the App Builder \n With Entando 6.1 the Entando CMS has been enhanced to include image\nediting and cropping, additional attribute types, updated layouts and\nuser interaction, an updated editor for hypertext content, and new asset\nsearch. The App Builder CMS also now includes the widgets that will\nallow a user to configure and render their content via the app builder\npage configuration screen. See documentation on the Entando 6.1 CMS here:\n CMS Content Types \n New and Updated CMS REST APIs \n Entando 6.1 includes updates to the REST APIs exposed by the Entando\nCMS. In particular, updated support for advanced filtering and updates\nto APIs for image and document storage. Checkout the Entando Swagger\ndefinition for more details:  Reference \n Operator and Kubernetes Infrastructure Updates \n The infrastructure in Entando 6.1 includes significant changes to the\ndeployment workflow internal to the Entando infrastructure. Many of the\njobs performed by the operator have been updated to short lived run to\ncompletion pods to minimize resource utilization and to speed up overall\ndeployment time. \n Added the Ability to Integrated Google Analytics in Progressive Web App \n The Entando Progressive Web App shell now provides support for including\na Google Analytics token to track page and content views in the\napplication. These changes are available as part of a manual upgrade to\na 5.x version of the PWA. \n Tech Preview \n The release of Entando 6.1 also includes a new command line tool to\nsupport all of the operations needed to interact with the Entando\nplatform. Checkout the tech preview version of the tool and its usage\nhere  https://github.com/entando/entando-cli \n Released Image Versions \n app-builder:  Image Version: 6.0.99\nentando-component-manager:  Image Version: 6.0.27\nentando-de-app:  Image Version: 6.0.45\nentando-de-app-eap:  Image Version: 6.0.45\nentando-de-app-wildfly:  Image Version: 6.0.45\nentando-k8s-app-controller:  Image Version: 6.0.33\nentando-k8s-app-plugin-link-controller:  Image Version: 6.0.9\nentando-k8s-cluster-infrastructure-controller:  Image Version: 6.0.27\nentando-k8s-composite-app-controller:  Image Version: 6.0.22\nentando-k8s-controller-coordinator:  Image Version: 6.0.66\nentando-k8s-dbjob:  Image Version: 6.0.32\nentando-k8s-keycloak-controller:  Image Version: 6.0.33\nentando-k8s-plugin-controller:  Image Version: 6.0.19\nentando-k8s-service:  Image Version: 6.0.17\nentando-keycloak:  Image Version: 6.0.11\nentando-plugin-sidecar:  Image Version: 6.0.2\nentando/entando-pam-app-wildfly:  Image Version:  6.1.0\nentando/entando-process-driven-plugin:  Image Version: 6.1.0\n Known Issues \n This section includes key known open items against the components\nreleased in Entando 6.1 that can impact user experience. The list is not\ncomprehensive. Check with your customer or professional services\nrepresentative for a full list or for questions. \n Key Open Issues \n \n \n In the App Builder some composite list content types do not render\nor persist correctly ( Tracking ENG - 383, ENG-385, and ENG-363) \n \n \n An available workaround is to use the legacy admin console to\ninteract with composite list content types and other content types\nnot yet supported \n \n \n Page preview in the app builder when deployed on the default EAP and\nWildfly images doesn’t render correctly (Tracking ENG-338) \n \n \n The page settings link on the page configuration screen doesn’t\npersist correctly As a workaround use the page settings under Page\nTree → Select Page → Edit \n \n \n Editing an image that has been uploaded via the app builder can\nresult in errors (ENG-382) As a workaround use the image editing\ncapability in the legacy admin console \n Previous Releases \n Documentation for prior versions.\n \n   \n \n \n"},{title:"jACMS Aps Core Tag Library",frontmatter:{},regularPath:"/v6.1/docs/reference/freemarker-tags/freemarker-JACMS-tags.html",relativePath:"v6.1/docs/reference/freemarker-tags/freemarker-JACMS-tags.md",key:"v-3c0fba7f",path:"/v6.1/docs/reference/freemarker-tags/freemarker-JACMS-tags.html",headers:[{level:2,title:"Tag content",slug:"tag-content"},{level:3,title:"Tag Class com.agiletec.plugins.jacms.aps.tags.ContentTag",slug:"tag-class-com-agiletec-plugins-jacms-aps-tags-contenttag"},{level:3,title:"Description",slug:"description"},{level:3,title:"Attributes",slug:"attributes"},{level:2,title:"Tag contentInfo",slug:"tag-contentinfo"},{level:3,title:"Tag Class com.agiletec.plugins.jacms.aps.tags.ContentInfoTag",slug:"tag-class-com-agiletec-plugins-jacms-aps-tags-contentinfotag"},{level:3,title:"Description",slug:"description-2"},{level:3,title:"Attributes",slug:"attributes-2"},{level:2,title:"Tag contentList",slug:"tag-contentlist"},{level:3,title:"Tag Class com.agiletec.plugins.jacms.aps.tags.ContentListTag",slug:"tag-class-com-agiletec-plugins-jacms-aps-tags-contentlisttag"},{level:3,title:"Description",slug:"description-3"},{level:3,title:"Attributes",slug:"attributes-3"},{level:2,title:"Tag contentListFilter",slug:"tag-contentlistfilter"},{level:3,title:"Tag Class Tag class: com.agiletec.plugins.jacms.aps.tags.ContentListFilterTag",slug:"tag-class-tag-class-com-agiletec-plugins-jacms-aps-tags-contentlistfiltertag"},{level:3,title:"Description",slug:"description-4"},{level:3,title:"Attributes",slug:"attributes-4"},{level:2,title:"Tag contentListUserFilterOption",slug:"tag-contentlistuserfilteroption"},{level:3,title:"Tag Class Tag class: com.agiletec.plugins.jacms.aps.tags.ContentListUserFilterOptionTag=",slug:"tag-class-tag-class-com-agiletec-plugins-jacms-aps-tags-contentlistuserfilteroptiontag"},{level:3,title:"Description",slug:"description-5"},{level:3,title:"Attributes",slug:"attributes-5"},{level:2,title:"Tag searcher",slug:"tag-searcher"},{level:3,title:"Tag Class com.agiletec.plugins.jacms.aps.tags.SearcherTag",slug:"tag-class-com-agiletec-plugins-jacms-aps-tags-searchertag"},{level:3,title:"Description",slug:"description-6"},{level:3,title:"Attributes",slug:"attributes-6"},{level:2,title:"Tag rowContentList",slug:"tag-rowcontentlist"},{level:3,title:"Tag Class Tag class: com.agiletec.plugins.jacms.aps.tags.RowContentListTag",slug:"tag-class-tag-class-com-agiletec-plugins-jacms-aps-tags-rowcontentlisttag"},{level:3,title:"Description",slug:"description-7"},{level:3,title:"Attributes",slug:"attributes-7"}],lastUpdated:"11/3/2020, 4:20:16 AM",lastUpdatedTimestamp:1604395216e3,content:' jACMS Aps Core Tag Library \n \n \n Version: 2.3 \n \n \n Short Name: jacmsaps \n \n \n URI: /jacms-aps-core \n Tag  content \n Tag Class  com.agiletec.plugins.jacms.aps.tags.ContentTag \n Description \n Displays the content given its ID. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n contentId \n false \n ID of the content to display. It can accept "expression language". \n \n \n modelId \n false \n Id of the model to use to display the content. The model ID can be either specified explicitly (the model must match the content to serve) or the type name ("list" or "default"); in the latter case the model specified in the configuration will be used. The model must adhere to the content being returned. "Expression language" is accepted. \n \n publishExtraTitle \n false \n Toggles the insertion of the values of the titles in the Request Context. The title values are extracted from the attribute marked with the role "jacms:title". Admitted values are (true, false), default \'false\'. \n \n \n var \n false \n Inserts the rendered content in a variable of the page context with the name provided. \n \n \n attributeValuesByRoleVar \n false \n Inserts the map of the attribute values indexed by the attribute role, in a variable of the page context with the name provided. \n Tag  contentInfo \n Tag Class  com.agiletec.plugins.jacms.aps.tags.ContentInfoTag \n Description \n Return information of a specified content. The content can will be extracted by id from widget parameters or from request parameter. The tag extract any specific parameter (by "param" attribute) or entire ContentAuthorizationInfo object (setting "var" attribute and anything on "param" attribute). \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n contentId \n false \n ID of the content \n \n \n param \n false \n Admitted values for "param" attribute are: \'contentId\' (returns the code of content id), \'mainGroup\' (returns the code of owner group), \'authToEdit\' (returns true if the current user can edit the content, else false). \n \n \n var \n false \n Inserts the required parameter (or the entire authorization info object) in a variable of the page context with the name provided. \n Tag  contentList \n Tag Class  com.agiletec.plugins.jacms.aps.tags.ContentListTag \n Description \n Loads a list of contents IDs by applying the filters (if any). Only the IDs of the contents accessible in the portal can be loaded. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n listName \n true \n Name of the variable in the page context that holds the search result. \n \n \n contentType \n false \n Sets the code of the content types to search. The name must match the configured one, respecting capital letters and spaces. \n \n \n category \n false \n Identifier string of the category of the content to search. \n \n \n cacheable \n false \n Toggles the system caching usage when retrieving the list. Admitted values (true, false), default "true". \n \n \n titleVar \n false \n Inserts the title on a variable of the page context with the name provided. \n \n \n pageLinkVar \n false \n Inserts the code of the page to link on a variable of the page context with the name provided. \n \n \n pageLinkDescriptionVar \n false \n Inserts the description of the page to link on a variable of the page context with the name provided. \n \n \n userFilterOptionsVar \n false \n Name of the variable in the page context that holds the user filter options \n Tag  contentListFilter \n Tag Class  Tag class: com.agiletec.plugins.jacms.aps.tags.ContentListFilterTag \n Description \n "ContentListTag" sub-tag, it creates a filter to restrict the result of the content search. Please note that the filters will be applied in the same order they are declared and the result of the search will reflect this fact. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n key \n true \n String used to filter and sort the contents. This string can be: - the name of a content attribute compatible with the type declared in the "contentListTag" (it requires the "attributeFilter" attribute to be "true") - the ID of one of the content metadata (the "attributeFilter" must be false) The allowed filter key that can be applied to content metadata are: - "created" allows sorting by date of creation of content - "modified" allows sorting by date of modification of content. \n \n \n attributeFilter \n true \n Decides whether the filter must be applied to an attribute or to a content metadata, admitted values are (true, false). The "key" attribute will be checked for validity if the filter is going to be applied to a metadata \n \n \n value \n false \n The filtering value. \n \n \n start \n false \n Filters the contents by attribute type or by the field specified with the key (respect the following matches): Text field -→ start Text Text attribute type -→ start Text Numeric attribute type -→ start Numeric date attribute type -→ start data If the data filter is used: - today, oggi or odierna will select all the contents with a date greater or equal to the system date - using date with the pattern "dd/MM/yyyy" will select all the contents with a date greater or equal to the one inserted. \n \n \n end \n false \n Similar the the "start" attribute but with the opposite behavior. \n \n \n order \n false \n Specifies the sorting behavior of the IDs found: "ASC"ending or "DESC"ending. By default no ordering is performed. \n \n \n likeOption \n false \n Toggles the \'like\' functionality. Admitted values: (true, false). Default: false. The option is available for metadata and on Text Content attributes. \n Tag  contentListUserFilterOption \n Tag Class  Tag class: com.agiletec.plugins.jacms.aps.tags.ContentListUserFilterOptionTag = \n Description \n "ContentListTag" sub-tag, it creates a custom user filter to restrict the result of the content search by front-end user. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n key \n true \n The key of the filter. This string can be: - the name of a content attribute compatible with the type declared in the "contentListTag" (it requires the "attributeFilter" attribute to be "true") - the ID of one of the content metadata (the "attributeFilter" must be false) The allowed filter key that can be applied to content metadata are: - "fulltext" allows filter by full-text search<br /> - "category" allows filter by a system category. \n \n \n attributeFilter \n true \n Decides whether the filter must be applied to an attribute or to a content metadata, admitted values are (true, false). The "key" attribute will be checked for validity if the filter is going to be applied to a metadata. \n Tag  searcher \n Tag Class  com.agiletec.plugins.jacms.aps.tags.SearcherTag \n Description \n Generates a list of content IDs, restricting them to the key word contained in the "search" parameter of the http request. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n listName \n yes \n Name of the variable, stored in the page context, containing the list of content IDs. \n Tag  rowContentList \n Tag Class  Tag class: com.agiletec.plugins.jacms.aps.tags.RowContentListTag \n Description \n Publish a list of contents. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n listName \n true \n Name of the variable in the page context that holds the contents (list of properties of key "contentId" and "modelId"). \n \n \n titleVar \n false \n Inserts the title on a variable of the page context with the name provided. \n \n \n pageLinkVar \n false \n Inserts the code of the page to link on a variable of the page context with the name provided. \n \n \n pageLinkDescriptionVar \n false \n Inserts the description of the page to link on a variable of the page context with the name provided. \n \n \n \n'},{title:"Entando Deployment Structure",frontmatter:{},regularPath:"/v6.1/docs/reference/deployment-structure.html",relativePath:"v6.1/docs/reference/deployment-structure.md",key:"v-d6de65ec",path:"/v6.1/docs/reference/deployment-structure.html",headers:[{level:2,title:"entando-operator",slug:"entando-operator"},{level:2,title:"database init containers",slug:"database-init-containers"},{level:2,title:"entando-de-app",slug:"entando-de-app"},{level:2,title:"app-builder",slug:"app-builder"},{level:2,title:"component-manager",slug:"component-manager"},{level:2,title:"entando-k8s-service",slug:"entando-k8s-service"},{level:2,title:"keycloak",slug:"keycloak"},{level:2,title:"Other Key Repositories",slug:"other-key-repositories"},{level:3,title:"entando-core",slug:"entando-core"},{level:3,title:"entando-cms",slug:"entando-cms"},{level:3,title:"entando-components",slug:"entando-components"},{level:3,title:"Entando Kubernetes Controllers",slug:"entando-kubernetes-controllers"}],lastUpdated:"12/15/2021, 2:22:26 PM",lastUpdatedTimestamp:1639596146e3,content:" Entando Deployment Structure \n This page provides a high level overview of the key Entando GitHub repositories along with a brief description\nof how those repositories are realized in a running Entando deployment. The descriptions provided here are meant\nas a guide for identifying opportunities to dig deeper into the architecture and how things are structured\nrather than a panacea for understanding the architecture. \n entando-operator \n The Entando operator coordinates the installation and configuration of all of the components of an Entando\nCluster. The operator can be installed once per Entando Cluster and used to coordinate the plugin lifecycle for\nmultiple Entando applications across many namespaces. \n \n GitHub:  https://github.com/entando-k8s/entando-k8s-controller-coordinator/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-k8s-controller-coordinator \n Customization \n It is unlikely that the operator will be customized as part of an Entando implementation. It is not built to\nbe extended inside the codebase. The most common pattern will be to use the existing custom resources that the\noperator knows how to deploy to extend the Entando platform. \n database init containers \n During installation an Entando application needs to create several databases and also to initialize those\ndatabases with information when deploying from a backup in your images. At initialization the  entando-k8s-dbjob \nwill be run 5 times in total. Once for keycloak, twice for the entando application (port and serv dbs), once to\npopulate the Entando application database, and once to create the Component Repository database. \n \n GitHub:  https://github.com/entando-k8s/entando-k8s-dbjob \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-k8s-dbjob \n \n The screenshot below highlights the init containers for the Entando application schema creation, db\ninitialization, and component repository database. \n \n Many managed kubernetes instances like OpenShift won’t show init containers in their dashboards. So if you’re\ntroubleshooting you may need to look deeper. When fetching logs for an init container using kubectl you must\npass the container name as an argument to the call. For example, \n     kubectl logs <pod> -c <container> -n <namespace>        \n    kubectl logs quickstart-kc-db-preparation-job-ddbdbddb-a  -c quickstart-kc-db-schema-creation-job -n sprint1-rc\n Customization \n It is unlikely that the init containers will be customized as part of an Entando project. The init containers\nwill automatically restore a backup included in your application so that you can create custom images that\ninclude your application setup.\nSee  Backing Up and Restoring Your Environment . \n entando-de-app \n The  entando-de-app  is a J2EE application and is an instance of the  entando-core  (see a description of the\n entando-core  repo below). Reviewing the dependencies of this application in the pom.xml will reveal the\ndependencies on the  entando-core ,  entando-engine , and  admin-console  which encompass the core\nfunctionality in versions of Entando prior to Entando 6. In a quickstart deployment the  entando-de-app  is deployed as part of the  entando-composite-app  multi\ncontainer pod. \n \n GitHub:  https://github.com/entando/entando-de-app/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-de-app-eap , https://hub.docker.com/repository/docker/entando/entando-de-app-wildfly \n Customization \n The  entando-de-app  is very likely to be customized as part of an Entando implementation. This image can be\ncustomized with new APIs, legacy Entando plugins, new database tables, or other extensions to the  entando-core .\nIt is highly recommended that most extensions to the platform in Entando 6 occur in microservices. However, legacy\nintegrations, extensions to the CMS, and migrations from earlier Entando versions may require changes to the  entando-de-app . \n app-builder \n The  app-builder  is the front end of the  entando-de-app . It communicates with the  entando-de-app  via  REST\nAPIs . The  app-builder  is a React JS application and is served via node in the default\ndeployment. In a quickstart deployment the  app-builder  container is deployed in the  entando-composite-app \nmultiple container pod. The  app-builder  also communicates with the Component Manager via REST API to fetch\ninformation about Entando Bundles deployed to the Entando Component Repository (ECR). \n \n GitHub:  https://github.com/entando/app-builder/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/app-builder/ \n Customization \n The  app-builder  is built to be customized and will be customized as part of many Entando implementations.\nThe  app-builder  can be customized at runtime via micro frontends\n widget configuration . The  app-builder  can also be\ncustomized via the integration of custom modules that are added at\n build time . \n component-manager \n The  component-manager  provides the link between the entando-de-app (or your custom core instance) and the\nEntando Component Repository (ECR). The  component-manager  queries the entando-k8s service to fetch available\nbundles that have been deployed as custom resources inside of an Entando cluster.\nThe  component-manager  also manages the relationships between an Entando application and the\ninstalled plugins. This can be seen in the plugin link custom resources in Kubernetes. \n \n GitHub:  https://github.com/entando-k8s/entando-component-manager/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-component-manager/ \n Customization \n It is unlikely that the  component-manager  will be customized as part of an Entando implementation. \n entando-k8s-service \n The  entando-k8s-service  acts as an abstraction layer to fetch data from kubernetes APIs. The primary\nfunctionality is in discovering and making available for installation Entando plugins. The\n entando-k8s-service  is invoked by the  component-manager . \n \n GitHub:  https://github.com/entando-k8s/entando-k8s-service/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-k8s-service/ \n Customization \n It is very unlikely that the  entando-k8s-service  will be customized as part of an Entando implementation. \n keycloak \n The  entando-keycloak  project is an extension of the base Keycloak images. The extension provides the default\nthemes for Entando, a customized realm and clients, and adds the Oracle ojdbc jars for connection to Oracle\ndatabases. \n \n GitHub:  https://github.com/entando/entando-keycloak/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-keycloak/ \n Customization \n The keycloak image will often be customized as part of an Entando implementation. Common extensions will\ninclude changing the theme, adding default connections, adding default social logins, adding default clients,\nor other changes. \n Other Key Repositories \n entando-core \n The entando-core project is a J2EE application that exposes APIs for the Entando CMS, includes the legacy\nadmin console, and includes the portal-ui project that performs the server side composition for pages\nrendered via an Entando application. Note that only the composition is performed server side.\nJavascript code is rendered on the client. The entando-core is realized via an instance that includes the\nWAR files generated from a core build as dependencies. In a default deployment this is the  entando-de-app . \n \n GitHub:  https://github.com/entando/entando-core/ \n DockerHub: None (deployed to maven central) \n Customization \n For users familiar with versions prior to Entando 6 there will be cases where the  entando-core  is customized.\nIn most cases these customizations will be delivered via WAR overlay in the instance project.\nUsing WAR overlay is a functional approach for users already  familiar with the process but it is highly\nrecommended to extend the platform using microservices for new projects. \n entando-cms \n The  entando-cms  project is the  app-builder  (React JS) side of the Entando WCMS. It is bundled into the\n app-builder  at build time and will be included in the default deployment of the  app-builder  in almost all cases. \n \n GitHub:  https://github.com/entando/entando-cms/ \n DockerHub: None (deployed to npm) \n Customization \n In some cases the  entando-cms  may be customized if new custom features are added to CMS specific\nfunctionality. However, most cases will use the more general  app-builder  extension points noted above.\nThe  entando-cms  does not expose any dedicated extension interfaces outside of those already provided by the\n app-builder . \n entando-components \n The entando-components project is a collection of legacy plugins for Entando 5 and earlier. These plugins are deployed as WAR dependencies in an entando-core instance. \n \n GitHub:  https://github.com/entando/entando-components/ \n DockerHub: None (deployed to maven central) \n Entando Kubernetes Controllers \n There are a number of controllers that are available to the Entando operator to manage installations and\ncomponents in an Entando Cluster. Those controllers are small and lightweight images that are executed as\nrun to completion pods to manage the installation flow for different parts of the infrastructure. The\ncontrollers are implemented using Quarkus. For more information on the controllers, the Entando custom\nresources, and configuring your Entando deployment see also:\n Custom Resources . \n GitHub: \n \n https://github.com/entando-k8s/entando-k8s-composite-app-controller/ \n https://github.com/entando-k8s/entando-k8s-plugin-controller/ \n https://github.com/entando-k8s/entando-k8s-cluster-infrastructure-controller/ \n https://github.com/entando-k8s/entando-k8s-app-controller/ \n https://github.com/entando-k8s/entando-k8s-app-plugin-link-controller/ \n \n DockerHub: \n \n https://hub.docker.com/repository/docker/entando/entando-k8s-composite-app-controller/ \n https://hub.docker.com/repository/docker/entando/entando-k8s-plugin-controller/ \n https://hub.docker.com/repository/docker/entando/entando-k8s-cluster-infrastructure-controller/ \n https://hub.docker.com/repository/docker/entando/entando-k8s-app-controller/ \n https://hub.docker.com/repository/docker/entando/entando-k8s-app-plugin-link-controller/ \n Customization \n It is unlikely that the controllers will be customized as part of an Entando implementation. \n"},{title:"Aps Core Tag Library",frontmatter:{},regularPath:"/v6.1/docs/reference/freemarker-tags/freemarker-core-tags.html",relativePath:"v6.1/docs/reference/freemarker-tags/freemarker-core-tags.md",key:"v-c8257a16",path:"/v6.1/docs/reference/freemarker-tags/freemarker-core-tags.html",headers:[{level:2,title:"Tag action",slug:"tag-action"},{level:3,title:"Description",slug:"description"},{level:3,title:"Example",slug:"example"},{level:3,title:"Attributes",slug:"attributes"},{level:3,title:"Tag class",slug:"tag-class"},{level:2,title:"Tag categories",slug:"tag-categories"},{level:3,title:"Description",slug:"description-2"},{level:3,title:"Example",slug:"example-2"},{level:3,title:"Attributes",slug:"attributes-2"},{level:3,title:"Tag class",slug:"tag-class-2"},{level:2,title:"Tag checkHeadInfoOuputter",slug:"tag-checkheadinfoouputter"},{level:3,title:"Description",slug:"description-3"},{level:3,title:"Attributes",slug:"attributes-3"},{level:3,title:"Tag class",slug:"tag-class-3"},{level:2,title:"Tag cssURL",slug:"tag-cssurl"},{level:3,title:"Description",slug:"description-4"},{level:3,title:"Example",slug:"example-3"},{level:3,title:"Attributes",slug:"attributes-4"},{level:3,title:"Tag class",slug:"tag-class-4"},{level:2,title:"Tag currentPage",slug:"tag-currentpage"},{level:3,title:"Description",slug:"description-5"},{level:3,title:"Example",slug:"example-4"},{level:3,title:"Attributes",slug:"attributes-5"},{level:3,title:"Tag class",slug:"tag-class-5"},{level:2,title:"Tag currentWidget",slug:"tag-currentwidget"},{level:3,title:"Description",slug:"description-6"},{level:3,title:"Example",slug:"example-5"},{level:3,title:"Attributes",slug:"attributes-6"},{level:3,title:"Tag class",slug:"tag-class-6"},{level:2,title:"Tag fragment",slug:"tag-fragment"},{level:3,title:"Description",slug:"description-7"},{level:3,title:"Attributes",slug:"attributes-7"},{level:3,title:"Tag class",slug:"tag-class-7"},{level:2,title:"Tag freemarkerTemplateParameter",slug:"tag-freemarkertemplateparameter"},{level:3,title:"Description",slug:"description-8"},{level:3,title:"Attributes",slug:"attributes-8"},{level:3,title:"Tag class",slug:"tag-class-8"},{level:2,title:"Tag headInfo",slug:"tag-headinfo"},{level:3,title:"Description",slug:"description-9"},{level:3,title:"Example",slug:"example-6"},{level:3,title:"Attributes",slug:"attributes-9"},{level:3,title:"Tag class",slug:"tag-class-9"},{level:2,title:"Tag i18n",slug:"tag-i18n"},{level:3,title:"Description",slug:"description-10"},{level:3,title:"Example",slug:"example-7"},{level:3,title:"Attributes",slug:"attributes-10"},{level:3,title:"Tag class",slug:"tag-class-10"},{level:2,title:"Tag ifauthorized",slug:"tag-ifauthorized"},{level:3,title:"Description",slug:"description-11"},{level:3,title:"Example",slug:"example-8"},{level:3,title:"Attributes",slug:"attributes-11"},{level:3,title:"Tag class",slug:"tag-class-11"},{level:2,title:"Tag imgURL",slug:"tag-imgurl"},{level:3,title:"Description",slug:"description-12"},{level:3,title:"Example",slug:"example-9"},{level:3,title:"Attributes",slug:"attributes-12"},{level:3,title:"Tag class",slug:"tag-class-12"},{level:2,title:"Tag info",slug:"tag-info"},{level:3,title:"Description",slug:"description-13"},{level:3,title:"Example",slug:"example-10"},{level:3,title:"Attributes",slug:"attributes-13"},{level:3,title:"Tag class",slug:"tag-class-13"},{level:2,title:"Tag internalServlet",slug:"tag-internalservlet"},{level:3,title:"Description",slug:"description-14"},{level:3,title:"Example",slug:"example-11"},{level:3,title:"Attributes",slug:"attributes-14"},{level:3,title:"Tag class",slug:"tag-class-14"},{level:2,title:"Tag nav",slug:"tag-nav"},{level:3,title:"Description",slug:"description-15"},{level:3,title:"Example",slug:"example-12"},{level:3,title:"Attributes",slug:"attributes-15"},{level:3,title:"Tag class",slug:"tag-class-15"},{level:2,title:"Tag outputHeadInfo",slug:"tag-outputheadinfo"},{level:3,title:"Description",slug:"description-16"},{level:3,title:"Attributes",slug:"attributes-16"},{level:3,title:"Tag class",slug:"tag-class-16"},{level:2,title:"Tag pageInfo",slug:"tag-pageinfo"},{level:3,title:"Description",slug:"description-17"},{level:3,title:"Attributes",slug:"attributes-17"},{level:3,title:"Tag class",slug:"tag-class-17"},{level:2,title:"Tag pager",slug:"tag-pager"},{level:3,title:"Description",slug:"description-18"},{level:3,title:"Example",slug:"example-13"},{level:3,title:"Attributes",slug:"attributes-18"},{level:3,title:"Tag class",slug:"tag-class-18"},{level:2,title:"Tag parameter",slug:"tag-parameter"},{level:2,title:"Tag pager",slug:"tag-pager-2"},{level:3,title:"Description",slug:"description-19"},{level:3,title:"Example",slug:"example-14"},{level:3,title:"Attributes",slug:"attributes-19"},{level:3,title:"Tag class",slug:"tag-class-19"},{level:2,title:"Tag printHeadInfo",slug:"tag-printheadinfo"},{level:3,title:"Description",slug:"description-20"},{level:3,title:"Attributes",slug:"attributes-20"},{level:3,title:"Tag class",slug:"tag-class-20"},{level:2,title:"Tag resourceURL",slug:"tag-resourceurl"},{level:3,title:"Description",slug:"description-21"},{level:3,title:"Example",slug:"example-15"},{level:3,title:"Attributes",slug:"attributes-21"},{level:3,title:"Tag class",slug:"tag-class-21"},{level:2,title:"Tag show",slug:"tag-show"},{level:3,title:"Description",slug:"description-22"},{level:3,title:"Example",slug:"example-16"},{level:3,title:"Attributes",slug:"attributes-22"},{level:3,title:"Tag class",slug:"tag-class-22"},{level:2,title:"Tag url",slug:"tag-url"},{level:3,title:"Description",slug:"description-23"},{level:3,title:"Example",slug:"example-17"},{level:3,title:"Attributes",slug:"attributes-23"},{level:3,title:"Tag class",slug:"tag-class-23"},{level:2,title:"Tag pageWithWidget",slug:"tag-pagewithwidget"},{level:3,title:"Description",slug:"description-24"},{level:3,title:"Example",slug:"example-18"},{level:3,title:"Attributes",slug:"attributes-24"},{level:3,title:"Tag class",slug:"tag-class-24"},{level:2,title:"Tag currentUserProfileAttribute",slug:"tag-currentuserprofileattribute"},{level:3,title:"Description",slug:"description-25"},{level:3,title:"Attributes",slug:"attributes-25"},{level:3,title:"Tag class",slug:"tag-class-25"},{level:2,title:"Tag userProfileAttribute",slug:"tag-userprofileattribute"},{level:3,title:"Description",slug:"description-26"},{level:3,title:"Attributes",slug:"attributes-26"},{level:3,title:"Tag class",slug:"tag-class-26"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:' Aps Core Tag Library \n \n \n Version: 2.3 \n \n \n Short Name: wp \n \n \n URI: /aps-core \n Tag  action \n Description \n Build the URL to call a jsp or a functionality of a servlet defined\nwithin the system. This tag can use the ParameterTag sub-tag to add url\nparameters. \n Example \n (<@wp.action path="/do/my.action" var="myaction" />)  or\n (<@wp.action path="/JSP/my.jsp" var="my.jsp"/>) \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n path \n no \n The relative path of jsp or servlet to invoke, relative to the context of web-application \n \n \n var \n no \n Name of the page-scoped variable where to place the URL. \n Tag class \n com.agiletec.aps.tags.ActionURLTag \n Tag  categories \n Description \n Return the list of the system categories on SelectItem objects. \n Example \n <@wp.categories var="systemCategories" titleStyle="prettyFull" root="$\\{userFilterOptionVar.userFilterCategoryCode}" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n titleStyle \n no \n The style of the single select item. Currently it can be \'default\' (single title node), \'full\' (title with all parents) or \'prettyFull\' (title with all parents in form of \'..\'). The default when none is given is \'default\'. \n \n \n fullTitleSeparator \n no \n The separator beetwen the titles when \'titleStyle\' is \'full\' or \'prettyFull\'. \n \n \n var \n no \n Name of the page-scoped variable where to place the list of categories. \n \n \n root \n no \n The root of the categories to show. The default is the system root categories \n Tag class \n com.agiletec.aps.tags.CategoriesTag \n Tag  checkHeadInfoOuputter \n Description \n This sub-tag verifies the availability of the information to display.\nThis sub-tag can be used only in a page model, in conjunction with\n\'outputHeadInfo\'. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n type \n yes \n Specifies the type of information to analyse. \n Tag class \n com.agiletec.aps.tags.CheckHeadInfoOutputterTag \n Tag  cssURL \n Description \n Extension of the ResourceURL tag. It returns the URL of the css files. \n Example \n <@wp.cssURL />href="<@wp.cssURL />myportal.css" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n Tag class \n com.agiletec.aps.tags.CssURLTag \n Tag  currentPage \n Description \n Returns the requested information held by the current page bean. \n Example \n <@wp.currentPage param="code" var="currentViewCode" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n param \n false \n The wanted parameter: actually can be either "title", "owner" (group), "code", "hasChild" or "childOf" (with attribute "targetPage"). The default when none is given is "title". \n \n \n langCode \n no \n Code of the language to use for the page information being returned. \n \n \n var \n no \n Name of the page context variable where the information are placed. Please note that the in this case the special characters will not be escaped. \n \n \n targetPage \n no \n Target page when "param" is "childOf". \n \n \n escapeXml \n no \n Decides whether to escape the special characters in the information retrieved or not. Value admitted (true, false), the default is true. \n Tag class \n com.agiletec.aps.tags.CurrentPageTag \n Tag  currentWidget \n Description \n Returns information about the widget where the tag resides. To obtain\ninformation about a widget placed in a frame other than the current, use\nthe "frame" attribute. \n Example \n <@wp.currentWidget param="config" configParam="name" var="configName" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n param \n yes \n The requested parameter. It can assume one of the following values: - "code" returns the code of the associated widget type (empty if none associated) - "title" returns the name of the associated widget type (empty if none associated) - "config" returns the value of the configuration parameter declared in the "configParam" attribute. The default is "title". \n \n \n configParam \n no \n Name of the configuration parameter request. This attribute is mandatory when the attribute "param" is set to "config". \n \n \n var \n no \n Name of the page context variable where the requested information is pushed. In this case the special characters will not be escaped. \n \n \n frame \n false \n Id of the frame hosting the widget with the desired information. \n \n \n escapeXml \n no \n Toggles the escape of the special characters. Admitted value are (true, false), the default is "true". \n Tag class \n com.agiletec.aps.tags.CurrentWidgetTag \n Tag  fragment \n Description \n Print a gui fragment by the given code. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n code \n true \n The code of the fragment to return. \n \n \n var \n false \n Name of the page context variable where the requested information is pushed. In this case the special characters will not be escaped. \n \n \n escapeXml \n false \n Toggles the escape of the special characters. Admitted value are (true, false), the default is "true". \n Tag class \n org.entando.entando.aps.tags.GuiFragmentTag \n Tag  freemarkerTemplateParameter \n Description \n Add a parameter into the Freemarker’s TemplateModel Map. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n var \n true \n Name of the variable where the requested information is pushed. \n \n \n valueName \n true \n Name of the variable of the page context where extract the information. \n \n \n removeOnEndTag \n false \n Whether to remove the parameter on end of Tag. Possible entries (true, false). Default value: false. \n Tag class \n org.entando.entando.aps.tags.FreemarkerTemplateParameterTag \n Tag  headInfo \n Description \n Declares the information to insert in the header of the HTML page. The\ninformation can be passed as an attribute or, in an indirect manner,\nthrough a variable of the page context. It is mandatory to specify the\ntype of the information. \n Example \n <@wp.headInfo type="JS" info="entando-misc-bootstrap/bootstrap.min.js" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n type \n yes \n Declaration of the information type. Currently only "CSS" is currently supported. \n \n \n info \n no \n Information to declare. This is an alternative of the "var" attribute. \n \n \n var \n no \n Name of the variable holding the information to declare. This attribute is the alternative of the "info" one. This variable can be used for those types of information that cannot be held by an attribute. \n Tag class \n com.agiletec.aps.tags.HeadInfoTag \n Tag  i18n \n Description \n Return the string associated to the given key in the specified language.\nThis string is either returned (and rendered) or can be optionally\nplaced in a page context variable. This tag can use the ParameterTag\nsub-tag to add label parameters. \n Example \n <@wp.i18n key="COPYRIGHT" escapeXml="false" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n key \n yes \n Key of the label to return. \n \n \n lang \n no \n Code of the language requested for the lable. \n \n \n var \n no \n Name of the variable (page scope) where to store the wanted information. In this case the special characters will not be escaped. \n \n \n escapeXml \n no \n Toggles the escape of the special characters of the returned label. Admitted values (true, false), the default is true. \n Tag class \n com.agiletec.aps.tags.I18nTag \n Tag  ifauthorized \n Description \n Toggles the visibility of the elements contained in its body, depending\non user permissions. \n Example \n <@wp.ifauthorized permission="enterBackend"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n permission \n no \n The code of the permission required. \n \n \n groupName \n no \n The name of the group membership required. \n \n \n var \n no \n The name of the (boolean) page context parameter where the result of the authorization check is placed. \n Tag class \n com.agiletec.aps.tags.CheckPermissionTag \n Tag  imgURL \n Description \n Extension of the ResourceURL tag. It returns the URL of the images to\ndisplay as static content outside the cms. \n Example \n <@wp.imgURL />entando-logo.png" alt="Entando - Access. Build. Connect." /> \n Attributes \n Tag class \n com.agiletec.aps.tags.ImgURLTag \n Tag  info \n Description \n Returns the information of the desired system parameter. \n Example \n <@wp.info key="systemParam" paramName="applicationBaseURL" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n key \n yes \n Key of the desired system parameter, admitted values are: "startLang" returns the code of start language of web browsing "defaultLang" returns the code of default language "currentLang" returns the code of current language "langs" returns the list of the languages defined in the system "systemParam" returns the value of the system param specified in the "paramName" attribute. \n \n \n var \n no \n Name of the variable where to store the retrieved information (page scope). In this case the special characters will not be escaped. \n \n \n paramName \n no \n Name of the wanted system parameter; it is mandatory if the "key" attribute is "systemParam", otherwise it is ignored. \n \n \n escapeXml \n no \n Toggles the escape of the special characters in the information returned. Admitted values are (true,false), the former being the default value. \n Tag class \n com.agiletec.aps.tags.InfoTag \n Tag  internalServlet \n Description \n Tag for the "Internal Servlet" functionality. Publishes a function\nserved by an internal Servlet; the servlet is invoked from a path\nspecified in the attribute "actionPath" or by the widget parameter\nsharing the same name. This tag can be used only in a widgets. \n Example \n <@wp.internalServlet actionPath="/ExtStr2/do/jpuserreg/UserReg/initRegistration" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n actionPath \n false \n The init action path. \n \n \n staticAction \n false \n Whether to execute only the given action path. Possible entries (true, false). Default value: false. \n Tag class \n com.agiletec.aps.tags.InternalServletTag \n Tag  nav \n Description \n Generates through successive iterations the so called "navigation" list.\nFor every target/page being iterated (inserted in the page context) are\nmade available the page code, the title (in the current language) and\nthe link. Is it also possible to check whether the target page is empty\n-that is, with no configured positions- or not. \n Example \n <@wp.nav var="page"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n spec \n no \n Declares the set of the pages to generate. \n \n \n var \n yes \n Name of the page context variable where the data of target being iterated are made available. \n Tag class \n com.agiletec.aps.tags.NavigatorTag \n Tag  outputHeadInfo \n Description \n Iterates over various information in HTML header displaying them; this\ntag works in conjunction with other specific sub-tags. Please note that\nthe body can contain only a sub-tag, or information, at once. This tag\nmust be used only in a page model. E.g (<@wp.outputHeadInfo\ntype="CSS">) \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n type \n yes \n Specifies the type of information to return, in accordance with the sub-tag to use. \n Tag class \n com.agiletec.aps.tags.HeadInfoOutputterTag \n Tag  pageInfo \n Description \n Returns the information of the specified page. This tag can use the\nsub-tag "ParameterTag" to add url parameters if the info attribute is\nset to \'url\'. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n pageCode \n true \n The code of the page. \n \n \n info \n false \n Code of required page parameter. Possible entries: "code" (default value) , "title", "owner" (group), "url", "hasChild" or "childOf" (with attribute "targetPage"). \n \n \n langCode \n false \n Code of the language to use for the returned information. \n \n \n var \n false \n Name used to reference the value pushed into the pageContext. In this case, the system will not escape the special characters in the value entered in pageContext. \n \n \n targetPage \n no \n Target page when "param" is "childOf". \n \n \n escapeXml \n false \n Whether to escape HTML. Possible entries (true, false). Default value: true. \n Tag class \n com.agiletec.aps.tags.PageInfoTag \n Tag  pager \n Description \n List pager. \n Example \n <@wp.pager listName="result" objectName="groupContent" max="10" pagerIdFromFrame="true" advanced="true" offset="5"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n max \n no \n The maximum value for each object group. \n \n \n listName \n yes \n Name of the list as found in the request. \n \n \n objectName \n yes \n Name of the object currently iterated. The following methods are exposed:  getMax, getPrevItem, getNextItem, getCurrItem, getSize, getBegin, getEnd, getMaxItem, getPagerId. \n \n \n pagerId \n no \n Sets the ID of the pager itself, it has to be used when two or more pagers exist in the same page. This attributes overrides "pagerIdFromFrame". \n \n \n pagerIdFromFrame \n no \n Sets the ID of the pager (mandatory when two or more pagers share the same page) based upon the frame where the tag is placed. Admitted values are (true, false), the latter being the default. Please note that the "pagerId" attribute takes precedence over this one. \n \n \n advanced \n no \n Toggles the pager in advanced mode. Admitted values are (true, false). the advanced mode of the tag is used when the list to iterate over is huge. \n \n \n offset \n no \n This attribute is considered only when the pager is in advanced mode. This is the numeric value of the single step increment (or decrement) when iterating over the list \n Tag class \n com.agiletec.aps.tags.PagerTag \n Tag  parameter \n Tag  pager \n Description \n This tag can be used to parameterise other tags. The parameter value can\nbe added through the \'value\' attribute or the body tag. When you declare\nthe param tag, the value can be defined in either a value attribute or\nas text between the start and the ending of the tag. \n Example \n <@wp.parameter name="resourceName"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n name \n true \n The name of the parameter. \n \n \n value \n false \n The value of the parameter. \n Tag class \n com.agiletec.aps.tags.ParameterTag \n Tag  printHeadInfo \n Description \n Returns the information to display. This sub-tag must be used only in a\npage model, in conjunction with \'outputHeadInfo\'. \n Attributes \n Tag class \n com.agiletec.aps.tags.HeadInfoPrinterTag \n Tag  resourceURL \n Description \n Returns URL of the resources. \n Example \n <@wp.resourceURL />static/js/entando-misc-html5-essentials/html5shiv.js"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n root \n no \n Declares the resource root. If not otherwise specified, the value of SystemConstants.PAR_RESOURCES_ROOT_URL is used. \n \n \n folder \n no \n Declares a specific directory for the desired resources. Unless specified, the value "" (empty string) is used in the generation of the URL. \n Tag class \n com.agiletec.aps.tags.ResourceURLTag \n Tag  show \n Description \n Defines the position of inclusion of a widget. This tag can be used only\nin a page model. \n Example \n <@wp.show frame="0" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n frame \n yes \n The positional number of the frame, starting from 0. \n Tag class \n com.agiletec.aps.tags.WidgetTag \n Tag  url \n Description \n Generates the complete URL of a portal page. The URL returned is either\nreturned (and rendered) or placed in the given variable. To insert\nparameters in the query string the sub-tag "ParameterTag" is provided. \n Example \n <@wp.url paramRepeat="true" > \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n page \n no \n Code of the destination page. The default is the current page. \n \n \n lang \n no \n Code of the language to use in the destination page. \n \n \n var \n no \n Name of the page-scoped variable where to place the URL. \n \n \n paramRepeat \n no \n Repeats in the URL all the parameters of the actual request. \n \n \n excludeParameters \n no \n Sets the list of parameter names (comma separated) to exclude from repeating. By default, this attribute excludes only the password parameter of the login form. Used only when paramRepeat="true". \n Tag class \n com.agiletec.aps.tags.URLTag \n Tag  pageWithWidget \n Description \n Search and return the page (or the list of pages) with the given widget\ntype. When "filterParamName" and "filterParamValue" attributes are\npresent, the returned list will be filtered by a specific widget\nconfiguration. \n Example \n <@wp.pageWithWidget widgetTypeCode="userprofile_editCurrentUser" var="userprofileEditingPageVar" listResult="false" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n var \n true \n Attribute_description: \n \n \n widgetTypeCode \n true \n The code of the widget to search \n \n \n filterParamName \n false \n Optional widget config param name \n \n \n filterParamValue \n false \n Optional widget config param value \n \n \n listResult \n false \n Optional, dafault false. When true the result is a list of pages, when false the returned page is the first occurence \n Tag class \n com.agiletec.aps.tags.PageWithWidgetTag \n Tag  currentUserProfileAttribute \n Description \n Current User Profile tag. Return a attribute value of the current user\nprofile. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n attributeName \n false \n the name of the attribute from which extract the value. \n \n \n attributeRoleName \n false \n the name of the attribute role from which extract the value. \n \n \n var \n false \n Name used to reference the value pushed into the pageContext. \n \n \n escapeXml \n false \n Decides whether to escape the special characters in the information retrieved or not. Value admitted (true, false), the default is true. \n Tag class \n org.entando.entando.aps.tags.CurrentUserProfileAttributeTag \n Tag  userProfileAttribute \n Description \n User Profile tag. Return a attribute value from the profile givea an\nusername. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n username \n true \n the username \n \n \n attributeName \n false \n the name of the attribute from which extract the value. \n \n \n attributeRoleName \n false \n the name of the attribute role from which extract the value. \n \n \n var \n false \n Name used to reference the value pushed into the pageContext. \n \n \n escapeXml \n false \n Decides whether to escape the special characters in the information retrieved or not. Value admitted (true, false), the default is true. \n Tag class \n org.entando.entando.aps.tags.UserProfileAttributeTag \n'},{title:"Hello World Widget in the App builder",frontmatter:{},regularPath:"/v6.1/tutorials/cms/app-builder/hello-world.html",relativePath:"v6.1/tutorials/cms/app-builder/hello-world.md",key:"v-81742dfa",path:"/v6.1/tutorials/cms/app-builder/hello-world.html",headers:[{level:2,title:"Basic Widget Tutorial",slug:"basic-widget-tutorial"},{level:2,title:"Simple Fragment tutorial",slug:"simple-fragment-tutorial"},{level:2,title:"Freemarker Basics in Entando",slug:"freemarker-basics-in-entando"},{level:2,title:"Useful Links",slug:"useful-links"}],lastUpdated:"7/9/2020, 6:19:25 AM",lastUpdatedTimestamp:1594289965e3,content:' Hello World Widget in the App builder \n This tutorial will take you through the basics of creating an Entando\nwidget and placing it on a page. This document will also review the\nbasics of fragments which are re-usable pieces of a user interface. \n Basic Widget Tutorial \n For this example you will use the Entando App Builder to build and\nassign your widget on a page. In a production system or a larger\ndevelopment environment you would build and deploy widgets differently,\nhowever this example provides a quick idea of the building blocks. \n \n \n In the App Builder menu, at the top, Go To: UX Patterns -→ Widgets \n \n \n Select NEW \n \n \n The Custom UI Field is a freemarker template where you can put raw\nhtml and include freemarker logic, \n \n \n It allows you to import javascript, css, or any normal HTML \n \n \n Example, put <h2>Hello World</h2> into your widget, give it\na name and save it \n \n \n \n \n Go To: Page Designer -→ Page Settings \n \n \n In the Home Page dropdown select Home / Service and select SAVE \n \n \n Now place the widget on the page \n \n \n Go To: Page Designer -→ Page Tree \n \n \n On the row that says "Service", on the far right side, select the\nKebab button and select CONFIGURE \n \n \n Find the widget created in step 5 on the right hand side \n \n \n Drag and drop the widget onto the open frame of the page \n \n \n Select PUBLISH at the bottom of the screen \n \n \n Then select GO TO HOME PAGE in the upper right \n \n \n You should see "Hello World" on the page \n Simple Fragment tutorial \n A fragment is a way to take a common piece of front end code and reuse\nit across multiple pages or widgets. Common elements such as basic html,\njavascript, or freemarker logic can be stored as fragments and\nreferenced via the  <@wp.fragment …​  tag. \n Starting from the simple widget tutorial above: \n \n \n In the app builder Go To: UX Patterns -→ Fragments \n \n \n Enter the code for the fragment as  test \n \n \n In the  Gui Code  enter  <h2>This is a fragment</h2> \n \n \n Next place the fragment on a page \n \n \n Go To: Ux Patterns -→ Page Models \n \n \n On the row for  service , select EDIT \n \n \n Use the fragment tag to place the fragment on the page\n <@wp.fragment code="test"/> \n \n \n SAVE the page model \n \n \n Go To: homepage (assuming you’ve set the service page to the\nhomepage) \n \n \n Note that the fragment is printed including the HTML tags. By\ndefault html embedded via a fragment tag is escaped so you get it\nrendered exactly as you enter it. You’ll need to un-escape it to get\nit to render correctly. \n \n \n Go back to your page model (UX Patterns -→ Page Models) select\nSERVICE and EDIT \n \n \n Change the tag to:  <@wp.fragment code="test" escapeXml=false/> \n \n \n Go back to the homepage \n \n \n See correctly rendered fragment \n Freemarker Basics in Entando \n The freemarker templating language gives you a lot of flexibility and\npower in how pages are rendered. You can include conditional logic,\ninject information from the backend, check for query parameters and\nroute to different pages. \n For example, to check for a query parameter you can use:\n <#if RequestParameters.myParam?exists > …​ \n To check the current username, use:\n <#if (Session.currentUser.username != "guest") > \n When you need dynamic behavior in your widgets consider using the power\nof freemarker. \n Useful Links \n https://freemarker.apache.org \n'},{title:"Tutorials Overview",frontmatter:{},regularPath:"/v6.1/tutorials/",relativePath:"v6.1/tutorials/README.md",key:"v-5c03f9d0",path:"/v6.1/tutorials/",headers:[{level:2,title:"How to Use This Guide",slug:"how-to-use-this-guide"},{level:2,title:"Frontend Developers",slug:"frontend-developers"},{level:2,title:"Backend Developers",slug:"backend-developers"},{level:2,title:"DevOps",slug:"devops"}],lastUpdated:"6/29/2020, 11:12:12 AM",lastUpdatedTimestamp:1593443532e3,content:" Tutorials Overview \n Entando simplifies the development of modern apps: \n \n Built using modern JavaScript frameworks \n Backed by microservices deployed in containers, and \n Orchestrated by Kubernetes for fully automated DevOps lifecycles \n \n \n Entando supports full stack micro frontend and microservice architectures for codebases that are easier to undestand, maintain, and debug across large, distributed teams, and comes with a private component repository that makes it easy for teams to share and reuse components. \n How to Use This Guide \n Use the categories on the left to find step-by-step tutorials for common tasks. Or check out our learning paths for a more structured approach. \n Frontend Developers \n \n \n \n Basics \n Intermediate \n Advanced \n \n \n \n \n Create a React Micro Frontend \n Connect to a Microservice \n Generate Micro Frontends and Microservices Based on a Database Entity \n \n \n Create an Angular Micro Frontend \n Publish and Listen to Events \n Deploy Your Micro Frontend to a Shared, Private Repository \n \n \n Add Your Micro Frontend to a Page \n Add a Configuration Screen \n Backend Developers \n \n \n \n Basics \n Intermediate \n Advanced \n \n \n \n \n Deploy a Microservice to Your Kubernetes Instance \n Generate a Microservice Application From a Database Entity \n Use JDL Studio to Create a Complex Database Entity (Coming Soon) \n \n \n Call a Microservice From a Micro Frontend \n Set Up a Persistent Volume for Storage \n DevOps \n \n \n \n Basics \n Intermediate \n Advanced \n \n \n \n \n Set Up Entando on a Local Kubernetes Instance \n Setting Up Your Entando Component Repository \n Automate Integration Testing With a CI/CD Pipeline   (Coming Soon) \n \n \n \n Backing Up and Restoring Your Entando Environment \n \n \n \n \n"},{title:"Content Templates",frontmatter:{},regularPath:"/v6.1/tutorials/cms/content-models-tutorial.html",relativePath:"v6.1/tutorials/cms/content-models-tutorial.md",key:"v-55cdae2c",path:"/v6.1/tutorials/cms/content-models-tutorial.html",headers:[{level:2,title:"Objective",slug:"objective"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"How to define a Content Templates",slug:"how-to-define-a-content-templates"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:" Content Templates \n Objective \n This document provides a description of Content Templates and how they\nare defined and used. \n Overview \n The purpose of Content Templates is to define how the information,\nenclosed in the Content, displayed to the end user, after the content is\npublished within the pages. Simplifying the concept, Content Templates\nprovide styling and layout for the Contents Types; consequently they\nallow to show the same content in different ways. \n The Content Templates can be managed using the App Builder’s user\ninterface, in which the Web CMS has been integrated. The interface: \n \n \n displays the list of the content models already existing, for each\nContent Types to which they refer. \n \n \n provides the tools to create a new content model; the model is\nwritten using the Velocity language. \n How to define a Content Templates \n Creating a Content Template is fairly simple. From the App Builder\napplication \n \n Select the CMS section and click on Content Templates subsection \n \n \n \n Click on the Add  Content Model button  to create a new Content\nTemplate and to add it to the list. \n \n \n \n \n Access the Add Content Template page, where you can \n \n \n Choose the Content Type in the dropdown list. \n \n \n Edit the Code. It is the unique identifier of the content model.\nYou can insert up to 10 numbers. It’s mandatory. \n \n \n Edit the Name. It is the name or description of the content\nmodel. \n \n \n Edit the HTML model based on Velocity language \n \n \n Define the CSS style sheet file (this is an optional parameter) \n \n \n Press the Save button \n \n \n \n \n \n"},{title:"Objective",frontmatter:{},regularPath:"/v6.1/tutorials/backend-developers/generate-microservices-and-micro-frontends.html",relativePath:"v6.1/tutorials/backend-developers/generate-microservices-and-micro-frontends.md",key:"v-81215fb4",path:"/v6.1/tutorials/backend-developers/generate-microservices-and-micro-frontends.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Setup for Blueprint Dev mode",slug:"setup-for-blueprint-dev-mode"},{level:2,title:"Start keycloak using docker-compose",slug:"start-keycloak-using-docker-compose"},{level:3,title:"Notes:",slug:"notes"},{level:2,title:"Start the microservice",slug:"start-the-microservice"},{level:3,title:"Notes:",slug:"notes-2"},{level:2,title:"Start the table widget",slug:"start-the-table-widget"},{level:2,title:"Start the form widget",slug:"start-the-form-widget"},{level:3,title:"Form widget notes:",slug:"form-widget-notes"},{level:2,title:"Start the details widget",slug:"start-the-details-widget"},{level:3,title:"Widget Details notes:",slug:"widget-details-notes"},{level:2,title:"Notes",slug:"notes-3"},{level:3,title:"Change keycloak dev settings",slug:"change-keycloak-dev-settings"},{level:3,title:"The service-url Variable",slug:"the-service-url-variable"},{level:3,title:"User is not authenticated message",slug:"user-is-not-authenticated-message"},{level:2,title:"Open the project in an IDE",slug:"open-the-project-in-an-ide"}],lastUpdated:"7/7/2020, 9:57:56 AM",lastUpdatedTimestamp:1594130276e3,content:' Objective \n The objective of this lab is to briefly introduce the Entando JHipster Blueprint and to provide an introduction to using the blueprint to generate a microservice and micro-frontends for deployment into an Entando application. \n Prerequisites \n \n \n Java 1.8 \n \n \n Maven 3.0.5+ \n \n \n npm 6+ \n \n \n git \n \n \n Docker \n \n \n node 10+ (or LTS) \n Setup for Blueprint Dev mode \n \n \n Install JHipster  npm install -g generator-jhipster@6.9.1 \n \n \n Clone the entando blueprint project to a location of your choice \n \n \n git clone https://github.com/entando/entando-blueprint\ncd entando-blueprint\ngit checkout -b v6.1.1\n \n \n \n Run this command from within entando-blueprint:  npm link \n \n \n Create a new empty directory in a location of your choice outside of existing projects. Don’t create this inside the entando-blueprint project (as example create the folder:  /entando/hello-world ) \n \n \n This will be the directory where you create your plugin. \n \n \n It is important that the commands below are run in the directory you are creating. \n \n \n \n \n On a command line change into the directory that you just created and run  npm link generator-jhipster-entando \n \n \n Create a plugin using the blueprint. Run the following command  jhipster --blueprints entando \n \n \n Select the following options (if nothing is specified in this list you can choose any available option) \n \n \n Microservice application \n \n \n Name of application: training (Or whatever you want) \n \n \n Port: 8081 \n \n \n Default package: com.entando (or whatever you want) \n \n \n SQL \n \n \n MySQL or Postgres \n \n \n H2 with disk based persistence \n \n \n Yes, with the Caffeine implementation \n \n \n 2nd level cache: Yes \n \n \n Maven \n \n \n Do not select any other technologies \n \n \n Accept the provided suggestion for the bundle name \n \n \n i18n: Yes \n \n \n Pick a default language \n \n \n Pick other languages you want \n \n \n Don’t add any other testing frameworks \n \n \n No other generators from the marketplace \n \n \n \n \n Adding an Entity and Creating the Micro-Frontends. In your new project run the following command  jhipster entity Conference \n \n \n Select Yes for “Do you want to add a field to your entity” \n \n \n For the name of the field use: conferenceName \n \n \n Select String for type \n \n \n Select No for validation rules \n \n \n Select Yes for “Do you want to add a field to your entity” \n \n \n For the name of the field use: location \n \n \n Select String for type \n \n \n Select No for validation rules \n \n \n Select No for adding relationships \n \n \n Select No for Do you want to use separate service class for your\nbusiness logic? \n \n \n You can choose any option you want here \n \n \n \n \n Repeat the steps above for other entities that you want to add. Also, review the content and documentation around the JHipster Design Language (JDL)  https://start.jhipster.tech/jdl-studio/ \n Start keycloak using docker-compose \n \n \n Startup the Keycloak server: \n docker-compose -f src/main/docker/keycloak.yml up\n Notes: \n if you have to install docker compose you can follow this guide:\n https://docs.docker.com/compose/install/ \n Start the microservice \n \n \n Start the generated Microservice executing the command: \n ./mvnw\n Notes: \n If you want to reset the widget data (as example if you deleted all rows from the table widget) if during the generation of the microservice you selected "H2 with disk-based persistence" you can delete the target folder, restart the microservice and the data will be regenerated. \n Start the table widget \n Now you can start your generated table widget: \n \n \n Go to the table widget folder in your project: \n cd ui/widgets/<your-entity-name>/tableWidget\n \n \n \n Then install and start your widget executing the command: \n npm install && npm start\n \n \n \n When the widget is started a browser window is opened and the widget URL is loaded \n \n \n If you’re not logged in you’re redirected to the login page. \n \n \n Log in using: \n Username: user\nPassword: user\n \n \n \n After the login process you’ll be redirected to the widget page and you can see the table widget with some generated data. \n Start the form widget \n Now you can start your generated form widget: \n \n \n If you are running another widget, stop it clicking  Ctrl+C  in your widget command line window \n \n \n Go to the form widget folder in your project: \n cd ui/widgets/<your-entity-name>/formWidget\n \n \n \n Then install and start your widget executing the command: \n npm install && npm start\n \n \n \n When the widget is started a browser window is opened with and the widget URL is loaded \n \n \n If you’re not logged in you’re redirected to the login page. \n \n \n Log in using: \n Username: user\nPassword: user\n \n \n \n You’ll be redirected to the widget page and you can see the widget form with the ID 1 loaded. \n Form widget notes: \n If you want to load other data you have to change the index.html file in the folder: \n cd ui/widgets/<your-entity-name>/formWidget/public\n \n and change the id attribute in this line: \n <my-entity-form service-url="%REACT_APP_SERVICE_URL%" id="1" />\n Start the details widget \n You can also start your generated details widget: \n \n \n If you are running another widget, stop it clicking  Ctrl+C  in your widget command line window \n \n \n Go to the details widget folder in your project: \n cd ui/widgets/<your-entity-name>/detailsWidget\n \n \n \n Then install and start your widget executing the command: \n npm install && npm start\n \n \n \n When the widget is started a browser window is opened with and the widget URL is loaded \n \n \n If you’re not logged in you’re redirected to the login page. \n \n \n Log in using: \n Username: user\nPassword: user\n \n \n \n You’ll be redirected to the widget page and you can see the widget form with the ID 1 loaded. \n Widget Details notes: \n If you want to load other data you have to change the index.html file in the public folder: \n cd ui/widgets/<your-entity-name>/detailsWidget/public\n \n and change the "id" attribute in this line: \n <my-entity-details service-url="%REACT_APP_SERVICE_URL%" id="1" />\n Notes \n Change keycloak dev settings \n If you want to change your keycloak settings to use another keycloak installation (not the docker compose pre configured one) or if you want to change the service-url of your widget you can change the parameters set in the .env.local file that was generated by the entando-blueprint in the root folder of your react widgets: \n cd ui/widgets/<your-entity-name>/tableWidget\n \n then edit the file  .env.local \n By default this variables are set to: \n REACT_APP_SERVICE_URL=http://localhost:8081/services/<your-application-name>/api\nREACT_APP_KEYCLOAK_URL=http://localhost:9080/auth\nREACT_APP_KEYCLOAK_REALM=jhipster\nREACT_APP_KEYCLOAK_CLIENT_ID=web_app\n The service-url Variable \n The  service-url  variable is the api Microservice API URL. \n User is not authenticated message \n When you run the widgets if you see the message:  User is not authenticated . This means that probably your keycloak application is not running so please check if the docker-compose command is still in execution. \n Open the project in an IDE \n This section just walks through the anatomy of the project and the micro frontends.\nYou can skip this or review later as desired. The top level project is a normal Spring Boot application.\nYou can look through the code and configuration in src/main/java to get a view of the server side.\nThe micro frontends are in the ui folder. Each entity gets an MFE for details, table, and form. \n'},{title:"Hello World for a Widget Using the App builder",frontmatter:{},regularPath:"/v6.1/tutorials/cms/custom-html-widgets.html",relativePath:"v6.1/tutorials/cms/custom-html-widgets.md",key:"v-126467b2",path:"/v6.1/tutorials/cms/custom-html-widgets.html",headers:[{level:2,title:"Basic Widget Tutorial",slug:"basic-widget-tutorial"},{level:2,title:"Simple Fragment tutorial",slug:"simple-fragment-tutorial"},{level:2,title:"Freemarker Basics in Entando",slug:"freemarker-basics-in-entando"},{level:2,title:"Useful Links",slug:"useful-links"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:' Hello World for a Widget Using the App builder \n This tutorial will take you through the basics of creating an Entando\nwidget and placing it on a page. This document will also review the\nbasics of fragments which are re-usable pieces of a user interface. \n Basic Widget Tutorial \n For this example you will use the Entando App Builder to build and\nassign your widget on a page. In a production system or a larger\ndevelopment environment you would build and deploy widgets differently,\nhowever this example provides a quick idea of the building blocks. \n \n \n In the App Builder menu, at the top, Go To: UX Patterns -→ Widgets \n \n \n Select NEW \n \n \n The Custom UI Field is a freemarker template where you can put raw\nhtml and include freemarker logic, \n \n \n It allows you to import javascript, css, or any normal HTML \n \n \n Example, put <h2>Hello World</h2> into your widget, give it\na name and save it \n \n \n \n \n Go To: Page Designer -→ Page Settings \n \n \n In the Home Page dropdown select Home / Service and select SAVE \n \n \n Now place the widget on the page \n \n \n Go To: Page Designer -→ Page Tree \n \n \n On the row that says "Service", on the far right side, select the\nKebab button and select CONFIGURE \n \n \n Find the widget created in step 5 on the right hand side \n \n \n Drag and drop the widget onto the open frame of the page \n \n \n Select PUBLISH at the bottom of the screen \n \n \n Then select GO TO HOME PAGE in the upper right \n \n \n You should see "Hello World" on the page \n Simple Fragment tutorial \n A fragment is a way to take a common piece of front end code and reuse\nit across multiple pages or widgets. Common elements such as basic html,\njavascript, or freemarker logic can be stored as fragments and\nreferenced via the  <@wp.fragment …​  tag. \n Starting from the simple widget tutorial above: \n \n \n In the app builder Go To: UX Patterns -→ Fragments \n \n \n Enter the code for the fragment as  test \n \n \n In the  Gui Code  enter  <h2>This is a fragment</h2> \n \n \n Next place the fragment on a page \n \n \n Go To: Ux Patterns -→ Page Models \n \n \n On the row for  service , select EDIT \n \n \n Use the fragment tag to place the fragment on the page\n <@wp.fragment code="test"/> \n \n \n SAVE the page model \n \n \n Go To: homepage (assuming you’ve set the service page to the\nhomepage) \n \n \n Note that the fragment is printed including the HTML tags. By\ndefault html embedded via a fragment tag is escaped so you get it\nrendered exactly as you enter it. You’ll need to un-escape it to get\nit to render correctly. \n \n \n Go back to your page model (UX Patterns -→ Page Models) select\nSERVICE and EDIT \n \n \n Change the tag to:  <@wp.fragment code="test" escapeXml=false/> \n \n \n Go back to the homepage \n \n \n See correctly rendered fragment \n Freemarker Basics in Entando \n The freemarker templating language gives you a lot of flexibility and\npower in how pages are rendered. You can include conditional logic,\ninject information from the backend, check for query parameters and\nroute to different pages. \n For example, to check for a query parameter you can use:\n <#if RequestParameters.myParam?exists > …​ \n To check the current username, use:\n <#if (Session.currentUser.username != "guest") > \n When you need dynamic behavior in your widgets consider using the power\nof freemarker. \n Useful Links \n https://freemarker.apache.org \n'},{title:"Contents",frontmatter:{},regularPath:"/v6.1/tutorials/cms/contents-tutorial.html",relativePath:"v6.1/tutorials/cms/contents-tutorial.md",key:"v-5815c43c",path:"/v6.1/tutorials/cms/contents-tutorial.html",headers:[{level:2,title:"Objective",slug:"objective"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"How to create a Content",slug:"how-to-create-a-content"},{level:2,title:"!image",slug:"image-extracted-media-media-content4-png"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:" Contents \n Objective \n This document provides an overview of Contents and how to create them in\norder to be displayed in your application’s pages. \n Overview \n The App Builder application provides the interface to manage Contents to\nthe final user, using the WEB CMS integrated with the App Builder. \n How to create a Content \n To manage Contents through the Web CMS \n \n Select the CMS section and click on the Content subsection; all\ncontents already existing are displayed in a table list. \n \n \n To create an additional Content and add it to the list \n \n Select the  Add Content  button. A drop-down list will let you\nchoose which Content Type the content will be based on. \n \n \n You will be asked to provide the information in distinct sections \n \n \n Info \n \n \n Content Type . The information is pre-filled, it is the\ncontent type on which the content is based. \n \n \n Description . It’s the content ‘s name or description. It is\nmandatory. \n \n \n \n \n Groups \n \n \n Owner Group.  A drop-down list will let you choose the\navailable users group that can administrate /manage the content.\nIt is mandatory. \n \n \n Join Group.  A drop-down list will let you choose the\navailable users group to share the content with. They can’t\nadministrate it. It is not mandatory. \n \n \n Categories.  You can select the categories to join the\ncontents to provide a classification schema of them. It is not\nmandatory. \n \n \n Content Attributes.  You must fill out the attributes fields\ndefined by the content types on which the content is based. It\nis mandatory. \n \n \n \n \n \n At least the additional content is added and displayed in the list by\nselecting \n \n \n Save  button. The content will be saved in a draft version. \n \n \n Save and Approve  button. The content will be saved, approved and\npublished. \n  \n You can list the contents by filtering with \n \n \n All . All created contents are displayed (Draft, To Approve and\nApproved/Published) \n \n \n Draft.  All created contents and saved by only clicking on the\n Save  or  Save and Continue  button. The content is not\napproved and consequently it is not ready to be published. \n \n \n To Approve.  All created contents, moved in  Ready  status,\nthen saved by clicking on the Save or  Save and Continue  button.\nThe content is ready for review but has not yet been approved and\nconsequently it has not been published. \n \n \n Approved . All created contents that have been saved and approved\nby clicking on the  Save and Approve  button. It has been\npublished. \n \n \n \n In the table list, contents are listed with several parameters: Name,\nCreated by, Last Edited, Type, Created Date, Owner Group, Join Group,\nStatus, Restrictions, Code, Actions. They can be shown, by setting them\nin the Columns filter. \n \n For every content in the list, you have access to a set of actions\nthrough the  Actions  kebab button, from which you can: \n \n \n Edit, update the information data related to the content \n \n \n Delete, remove the content \n \n \n Publish, making the content visible \n \n \n Clone, replicate the content \n \n \n Unpublish, making the content invisible \n \n \n \n The contents list can be saved in your file system by clicking the\nDownload button and selecting CSV or XLS format. \n \n"},{title:"Adding a new API to the core app",frontmatter:{},regularPath:"/v6.1/tutorials/customize-the-platform/add-rest-api.html",relativePath:"v6.1/tutorials/customize-the-platform/add-rest-api.md",key:"v-4ed657b8",path:"/v6.1/tutorials/customize-the-platform/add-rest-api.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:" Adding a new API to the core app \n Prerequisites \n \n \n Java 8 \n \n \n maven \n Overview \n This guide will take you through adding a new REST API to the Entando\ncore app. In some cases it is better to add new APIs to the core rather\nthan creating a new microservice. Some example cases where adding new\nAPIs to the core is recommended are: \n \n \n When extending or adding functionality to the WCMS \n \n \n When you have a simple use case requiring persistence that is\nspecific to only the application you’re working within \n \n \n When exposing configurations that are needed by the portal-ui during\npage rendering \n \n \n For small changes that don’t warrant a full stand-alone microservice \n \n \n You can build widgets and micro frontends that take advantage of these\nAPIs in the same way that your micro-frontends can invoke APIs exposed\nby other services. \n Tutorial \n Creating a controller and services \n \n \n Create a new java package in the project using your favorite IDE at\nthe path  org.entando.training . \n \n \n Under that package add packages for  controllers  and  services . \n \n \n Create a class called  DemoController.java  from the\ntraining package into the controllers package. \n \n This is a normal Spring rest controller and it will be\ndiscovered by annotations. \n \n \n \n Copy  DemoService.java  from the\ntraining package into the services package. \n \n This is a normal Spring service that will be autowired into the\ncontroller. The data in this service is hardcoded but this is\nwhere you can wire in external services or other parts of the\nEntando architecture to fetch the data. \n \n \n \n Copy  commonConfig.xml  to\n src/main/resources/spring/aps/managers . \n \n \n The goal is to enable package scanning for annotation driven\nspring services. This includes the package scan for your package\ndefined above. If you want to scan another package, then you\nneed to add another path to this file. This is the only spring\nXML you will need to change if you want to build annotation\ndriven beans in Entando. \n \n \n See also web.xml for deeper details. \n \n \n \n \n Review the code and annotations in the controller to understand how\nthe APIs are protected and integrated. \n \n \n @RestAccessControl  is a custom Entando annotation that can be used\nto restrict APIs by role. \n \n The rest of the annotations are normal Spring annotations. \n \n \n \n Restart your app using jetty. \n \n \n if you get an error add the entries below to\n src/main/conf/systemParams.properties  This is temporary \nParameters for Argon2 algorithm encryption\nalgo.argon2.type=ARGON2i\nalgo.argon2.hash.length=32\nalgo.argon2.salt.length=16\nalgo.argon2.iterations=4\nalgo.argon2.memory=65536\nalgo.argon2.parallelism=4\nalgo.default.key=changeit\n \n \n \n \n \n Go to Swagger \n \n \n Find the demo-controller and try your new endpoints out using\nswagger \n \n \n"},{title:"Content Types",frontmatter:{},regularPath:"/v6.1/tutorials/cms/content-types-tutorial.html",relativePath:"v6.1/tutorials/cms/content-types-tutorial.md",key:"v-1f495540",path:"/v6.1/tutorials/cms/content-types-tutorial.html",headers:[{level:2,title:"Objective",slug:"objective"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"How to create a Content Type",slug:"how-to-create-a-content-type"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:" Content Types \n Objective \n This document provides an overview of the Content Types, as well as how\nthey are created and represented. \n Overview \n The Content Type is a construct used to represent or to model a Content.\nIt is characterized by a set of Attribute Types[1] , each of which\ndefines the value of their properties, called attributes. A Content is\nan instance or specialization of the Content Type. \n How to create a Content Type \n Creating Contents Types is fairly simple. The Content Types are managed\nthrough the Web CMS, its user interface is made available in the App\nBuilder application. \n \n From App Builder, select the CMS section and click on Content Types\nsubsection. \n \n \n \n Click on the Add  Content Type button  to create a new Content\nType and to add it to the list. \n \n \n \n \n You be asked to provide \n \n \n Code . The code is the unique identifier of the content type,\nthat must be 3 uppercase letters, (e.g. CNN). It’s mandatory. \n \n \n Name.  The name must be max 50 characters uppercase and\nlowercase letters, including numbers and special characters,\n(e.g. Conference_News). It’s mandatory. \n \n \n \n \n \n \n \n Select the  Save  button, then you’ll see \n \n \n Content Type Information : \n \n \n Code . The value is pre-filled. \n \n \n Name . The name is pre-filled. \n \n \n \n \n Metadata \n \n \n Page for on-the-fly publishing \n \n \n Default content model \n \n \n Default content model for lists \n \n \n \n \n \n \n “Default content model” and “Default content model for lists” are used\nrespectively to show the detailed view of the Content and its\nrepresentation as an element in a list, will be created later, during\nthe creation and the content. \n \n Attributes \n \n In the Attributes section, select the  Type  from the drop-down list.\nThe list contains all the available attributes types that define which\nproperties/attributes will characterize the Content. \n \n The Add button will start the configuration of the single attribute\ntype. Even every attribute type has its own configuration. \n For example, to configure the  Text  Attribute Type, choose Text from\nthe Types drop-down menu and then press the blue Add button. \n \n \n \n You should specify the following fields \n \n \n Type:  the value is the pre-filled. It represents the selected\nattribute type \n \n \n Code : Title. You should insert the name of the attribute. (You\ncan insert max 10 characters uppercase and lowercase letters,\nnumbers, and special characters _ ). (e.g. title) \n \n \n Name : Title. You should insert the description of the attribute.\n(You can insert max 50 characters uppercase and lowercase letters,\nincluding numbers and special characters). (e.g. Title). \n \n \n You should declare if the attribute is  mandatory ,\n searchable , and  to be used as a filter in the list. \n \n \n The  Roles  section it is possible to assign the  jacms:title\nAttribute Role  to this attribute; in this way other plugins or\nservices will know that within the CNG entity this attribute is a\ntitle, whatever the key is; however, for sake of clarity, the Code\nof the attribute is Title. \n \n \n The remaining fields related to  Sections  and  Validation -\nOGNL  sections are not mandatories, you can leave empty. \n \n \n Press the  Continue  button. The Text attribute type requires no\nadditional configuration step. \n \n \n You can add other Attributes Types. \n \n \n Press the Save button. The Content type will be saved and displayed\nin the table list \n \n \n [1] Consult the “List of Content Types” document for more details. \n"},{title:"Publish A Content",frontmatter:{},regularPath:"/v6.1/tutorials/cms/publish-a-content-tutorial.html",relativePath:"v6.1/tutorials/cms/publish-a-content-tutorial.md",key:"v-2982c900",path:"/v6.1/tutorials/cms/publish-a-content-tutorial.html",headers:[{level:2,title:"Objective",slug:"objective"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"How to publish a Content",slug:"how-to-publish-a-content"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:" Publish A Content \n Objective \n This document provides an overview of how to publish a Content in your\napplication page. \n Overview \n The App Builder application provides the capabilities to publish\ncontents in your application page to the final user. \n How to publish a Content \n To publish a Content, through the App Builder application, in your page \n \n Create a new page[1] clicking  Add  button in Page Tree subsection\ninside the Page Designer section. Before pressing the Add button,\nselect the hierarchical placement of the page, selecting an already\npresent page, or you will be asked for that afterwards. \n \n \n A page must have a title, a code, a placement in the page tree, an owner\ngroup, a join group and a page model. When you create a new page, you\nmust to \n \n \n Provide a title and a code in the Info section. \n \n \n Provide, selecting them from the dropdown menus, an Owner Group and\na Join Group in the Page Groups section, \n \n \n Select a Page Template from the available templates. \n \n \n \n \n Click the green “ Save and Configure ” button. This brings you to\nthe configuration section, which lists all the frames defined in the\npage model you associated with that page. \n \n \n \n Add widgets, available in the right pane, to the page, by dragging\nand dropping them in the desired frame. Regarding the content, you\ncan drag and drop in an available frame, the WEB CMS Widget\n“ Publish a Content ”. A Widget setting page will be shown. \n \n \n \n \n In the Search field, you can type the name of the content that you\nwould like to publish and then hit the plus  (+)  button. Remember\nthat in order to publish the content on your page, it must be saved\nand approved. \n \n \n Choose the suitable content template from the Content Template\ndrop-down list \n \n \n Press the blue  Save  button. \n \n \n \n \n Click on the  Preview  button in Configuration Page to show its\npreview with the published content. \n \n \n \n Finally, click on the  Publish  button to publish the page and\nshow your Content \n \n \n [1] More details about pages and page models will be provide in a\ndedicated document. \n"},{title:"Hello World for a Widget Using the App builder",frontmatter:{},regularPath:"/v6.1/tutorials/customize-the-platform/app-builder/hello-world.html",relativePath:"v6.1/tutorials/customize-the-platform/app-builder/hello-world.md",key:"v-8794784e",path:"/v6.1/tutorials/customize-the-platform/app-builder/hello-world.html",headers:[{level:2,title:"Basic Widget Tutorial",slug:"basic-widget-tutorial"},{level:2,title:"Simple Fragment tutorial",slug:"simple-fragment-tutorial"},{level:2,title:"Freemarker Basics in Entando",slug:"freemarker-basics-in-entando"},{level:2,title:"Useful Links",slug:"useful-links"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:' Hello World for a Widget Using the App builder \n This tutorial will take you through the basics of creating an Entando\nwidget and placing it on a page. This document will also review the\nbasics of fragments which are re-usable pieces of a user interface. \n Basic Widget Tutorial \n For this example you will use the Entando App Builder to build and\nassign your widget on a page. In a production system or a larger\ndevelopment environment you would build and deploy widgets differently,\nhowever this example provides a quick idea of the building blocks. \n \n \n In the App Builder menu, at the top, Go To: UX Patterns -→ Widgets \n \n \n Select NEW \n \n \n The Custom UI Field is a freemarker template where you can put raw\nhtml and include freemarker logic, \n \n \n It allows you to import javascript, css, or any normal HTML \n \n \n Example, put <h2>Hello World</h2> into your widget, give it\na name and save it \n \n \n \n \n Go To: Page Designer -→ Page Settings \n \n \n In the Home Page dropdown select Home / Service and select SAVE \n \n \n Now place the widget on the page \n \n \n Go To: Page Designer -→ Page Tree \n \n \n On the row that says "Service", on the far right side, select the\nKebab button and select CONFIGURE \n \n \n Find the widget created in step 5 on the right hand side \n \n \n Drag and drop the widget onto the open frame of the page \n \n \n Select PUBLISH at the bottom of the screen \n \n \n Then select GO TO HOME PAGE in the upper right \n \n \n You should see "Hello World" on the page \n Simple Fragment tutorial \n A fragment is a way to take a common piece of front end code and reuse\nit across multiple pages or widgets. Common elements such as basic html,\njavascript, or freemarker logic can be stored as fragments and\nreferenced via the  <@wp.fragment …​  tag. \n Starting from the simple widget tutorial above: \n \n \n In the app builder Go To: UX Patterns -→ Fragments \n \n \n Enter the code for the fragment as  test \n \n \n In the  Gui Code  enter  <h2>This is a fragment</h2> \n \n \n Next place the fragment on a page \n \n \n Go To: Ux Patterns -→ Page Models \n \n \n On the row for  service , select EDIT \n \n \n Use the fragment tag to place the fragment on the page\n <@wp.fragment code="test"/> \n \n \n SAVE the page model \n \n \n Go To: homepage (assuming you’ve set the service page to the\nhomepage) \n \n \n Note that the fragment is printed including the HTML tags. By\ndefault html embedded via a fragment tag is escaped so you get it\nrendered exactly as you enter it. You’ll need to un-escape it to get\nit to render correctly. \n \n \n Go back to your page model (UX Patterns -→ Page Models) select\nSERVICE and EDIT \n \n \n Change the tag to:  <@wp.fragment code="test" escapeXml=false/> \n \n \n Go back to the homepage \n \n \n See correctly rendered fragment \n Freemarker Basics in Entando \n The freemarker templating language gives you a lot of flexibility and\npower in how pages are rendered. You can include conditional logic,\ninject information from the backend, check for query parameters and\nroute to different pages. \n For example, to check for a query parameter you can use:\n <#if RequestParameters.myParam?exists > …​ \n To check the current username, use:\n <#if (Session.currentUser.username != "guest") > \n When you need dynamic behavior in your widgets consider using the power\nof freemarker. \n Useful Links \n https://freemarker.apache.org \n'},{title:"List of Attribute Types",frontmatter:{},regularPath:"/v6.1/tutorials/cms/list-of-Content-attributes.html",relativePath:"v6.1/tutorials/cms/list-of-Content-attributes.md",key:"v-1d83e0c0",path:"/v6.1/tutorials/cms/list-of-Content-attributes.html",headers:[{level:2,title:"Objective",slug:"objective"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"Simple Attribute Types",slug:"simple-attribute-types"},{level:2,title:"Composed attribute types",slug:"composed-attribute-types"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:" List of Attribute Types \n Objective \n This document provides a list and an overview of all available attribute\ntypes. \n Overview \n Attributes can be seen as the smallest elements that compose a Content\nType. In other words, a Content Type is just a collection of different\nattributes. Attributes are responsible for carrying the actual\ninformation inside a Content in Entando and could be of different types.\nIn this chapter, we will review and describe the different attribute\ntypes. \n Firstly, we can distinguish simple attribute types from composite\nattribute types. In the first case, the attribute type carries a single\npiece of information (for example, an image), while the latter is an\naggregation of simple attribute types (for example, a set of images). \n Simple Attribute Types \n Attach \n This represents the information carried by a file, which is attached to\nthe content. \n It consists of an URL corresponding to the desired file present in the\nsystem’s resources, and a text which can either indicate the description\nor the name of the file. \n This attribute type is rendered as a button named “Add”. By pushing that\nbutton, the user is prompted to select a desired file present in the\nsystem’s Digital Assets Attachments list. \n Boolean \n This attribute type represents a boolean value which can either be true\nor false. This attribute type is rendered as two radio buttons labeled\n“Yes” and “No”. \n Checkbox \n This attribute type behaves in the same way as a Boolean does – it is\nactually an alternative to the Boolean attribute type - but it is\nrendered with a checkbox labeled “Yes” or “No”. \n Date \n This attribute type represents a date, tracking time within a content;\nit is often used to filter contents appearing in lists by publication\ndate, etc. \n It is rendered as a datepicker. \n Timestamp \n This attribute type is specialized for the Date attribute, allowing you\nto also specify the hour, minute and second. \n It is rendered as a datepicker for the date, and a select for hours,\nminutes and seconds. \n Enumerator \n The enumerator attribute type represents textual information with a\npredefined set of choices; it is defined by: \n \n \n Elements which are mandatory and declares the set of available\nchoices; \n \n \n Separator, which is optional and declares the character to use to\nseparate the arguments of the enumerator. By default the comma “,”\nis used. \n \n \n ExtractorBean: this parameter represents the name of the Spring bean\nto use to process the values of the enumerator. The name must\nexactly match the id of the bean as defined in the Spring\nconfiguration file. \n \n \n It is rendered as a select list. \n Enumerator Map \n The enumerator map attribute type represent textual information with a\npredefined set of choices; it is defined by: \n \n \n Elements in the form of a separated list of key=value pairs, (i.e.\nkey1=value1,key2=value2) \n \n \n Separator, which is optional and declares the character to use to\nseparate the key, values pairs. By default the comma is used. \n \n \n It is rendered as a select list which shows the available values. \n Hypertext \n This attribute type holds HTML tagged text; it retains a single value\nfor all languages. \n Even if this attribute type could support all HTML tags, we strongly\nrecommend using only tags which provide meaning and avoid those which\ndecorate or add graphics. \n Hypertext attributes are rendered as a text area in the content edit\npage; if the CKEditor is active, the user has access to a set of\nadditional functionalities from a dedicated editor’s toolbar. Such as\ntable insertion and table manipulation, special characters insertion,\nstring formatting, links creation. \n Image \n This attribute type binds an image resource to the content. \n The image is always taken from the Digital Assets images list. The user\nwill need to specify the description accompanying the image. \n Usually attributes of type Image are not indexed and are not used to\nfilter contents. \n It is rendered as a button named “Add” that, when pushed, allows the\nuser to select an image from the Digital Assets images list. Once\nselected the user is presented with a preview, as a thumbnail, of the\nimage and has the possibility to define some parameters: \n \n \n Text which is mandatory and by default takes the name of the\nselected image \n \n \n legend (optional) \n \n \n alt (optional) \n \n \n description (optional) \n \n \n title (optional) \n \n \n Link \n This attribute type represents an hypertext link; it is normally used to\ninclude a link in your content: it is possible to define up to three\ndifferent types of links: \n \n \n external links: a link pointing to a location external to the Entando\nportal \n \n \n link to page: a link which points to a page of the portal \n \n \n link to a content: a link to another content \n \n \n It is rendered as a button named “Add” that when pushed opens up a modal\nwindow from which the user can select the link type. \n Longtext \n This attribute type represents a simple unformatted text; it supports\nseveral languages and is normally used for small descriptions, when a\nshort string won’t suffice. \n It supports minimum length , maximal length and regular expressions as\noptional parameters. \n It is rendered as a textarea. \n Monotext \n Monotext represents the information in textual form, but supports only a\nlanguage; it is used for all \n those fields which do not require localization. \n It supports minimum length, maximal length, and regular expressions as\noptional parameters. \n It is rendered as a textfield. \n Number \n This attribute type holds an integer number; it retains a single value\nfor all languages. \n Supports the optional parameters: From, To, and Equal to. \n It is rendered as a textfield. \n Text \n This attribute type holds a string; it retains a single value for all\nlanguages. \n It supports minimum length, maximal length, and regular expressions as\noptional parameters. \n It is rendered as a textfield. \n ThreeState \n Conceptually similar to the Boolean attribute, this attribute type\nallows a third status “Both” to be present. \n It is rendered as a radio button with “Yes”, “No”, “Both” options. \n Composed attribute types \n All the attributes types of the previous chapter can only retain a\nsingle type of information, but sometimes it is desirable to aggregate\ndifferent types of attributes into one attribute: this is where composed\nattributes are used. \n From a functional point of view, it would be perfectly legal to build a\ncontent type specifying all the attributes back to back: the content\nwould be formally complete, but from a logical point of view the\nattributes would appear mutually unrelated and, worse, the relationship\nbetween them would not be explicit. \n Entando offers three types of composed attributes: List, Monolist,\nComposite. \n List \n This Attribute Type represents a set of independent and homogeneous\nelementary Attribute types, each associated with one of the languages\ndefined in the system. \n An immediate consequence is that this kind of list can handle only\nmono-language basic attributes. \n It is rendered with a button named “Add” that if pushed presents the\nuser a prompt to select or define the single elements which compose the\nlist. \n Monolist \n This attribute type is a list that is common to all the system\nlanguages; this kind of list handles multi-language and mono-language\nattributes. \n It is rendered with a button named “Add” that, if pushed, presents the\nuser with a prompt to select or define the single elements that compose\nthe monolist. \n Composite \n This attribute type is an aggregate of different, non-homogeneous,\nsimple attributes types. The aggregation of different types is treated\nas a single unit. \n It is rendered as a combination of the elementary attribute types, where\neach attribute type presents the proper rendering. \n"},{title:"Tutorial: Extending the App Builder",frontmatter:{},regularPath:"/v6.1/tutorials/customize-the-platform/app-builder/tutorial-extending-app-builder.html",relativePath:"v6.1/tutorials/customize-the-platform/app-builder/tutorial-extending-app-builder.md",key:"v-2992138f",path:"/v6.1/tutorials/customize-the-platform/app-builder/tutorial-extending-app-builder.html",headers:[{level:2,title:"Creating a Basic Application",slug:"creating-a-basic-application"},{level:2,title:"Understanding the Stand Alone Environment",slug:"understanding-the-stand-alone-environment"},{level:2,title:"Customizing the Menu",slug:"customizing-the-menu"},{level:2,title:"Customizing the menu labels",slug:"customizing-the-menu-labels"},{level:2,title:"Customizing the Routes",slug:"customizing-the-routes"},{level:2,title:"state",slug:"state"},{level:2,title:"Customizing the Reducers",slug:"customizing-the-reducers"},{level:2,title:"userList",slug:"userlist"},{level:3,title:"connecting to the store",slug:"connecting-to-the-store"},{level:2,title:"Page Models",slug:"page-models"},{level:3,title:"Connecting to the Store",slug:"connecting-to-the-store-2"},{level:2,title:"Adding the API Calls",slug:"adding-the-api-calls"},{level:2,title:"Creating the Thunk",slug:"creating-the-thunk"},{level:2,title:"changing the mapDispatchToProps in the containers",slug:"changing-the-mapdispatchtoprops-in-the-containers"},{level:2,title:"Updating the List components",slug:"updating-the-list-components"},{level:2,title:"clear the default value of the reducer",slug:"clear-the-default-value-of-the-reducer"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:" Tutorial: Extending the App Builder \n Apps for the Entando App Builder are developed as standalone\napplications which can be run using  npm start  in standalone mode. \n Each application should be deployed in npm using the  @entando \nnamespace and will export into their dist folder several items used by\nthe App Builder when integrating it into the full application. \n Creating a Basic Application \n To create a basic application, use the  entando\nfpg  running the\n npx @entando/fpg ab-app <appName>  command. \n the  appName  should only contain alphanumeric characters and\nunderscores, and should begin with a letter. \n This will create inside the working directory, a boilerplate app-builder\napp in a directory named  <appName>  argument. \n i.e. \n using the command  npm @entando/fpg ab-app testing  inside your home\ndirectory, a directory named  testing  will be created containing the\napp. \n All dependencies will already be installed allowing you to  cd  inside\nthe project directory and run  npm start  to start the app running. \n Understanding the Stand Alone Environment \n Each app for the App Builder, can run in both a stand alone mode and an\nintegrated mode. Using  npm start  will use standalone mode. \n In this environment you’ll be looking at the user interface of the app\ninside a default page. This page, which includes a default menu, will\nnot be exported and therefore can be customized. \n To better understand which elements and components are being exported to\nApp Builder, it is best to understand the anatomy of the app. \n Exports \n Each app will have a  babel.js  export file similar to: \n      import  menu  from   'ui/common/LinkMenu' ; \n     import   {  cms  as  state  }   from   'state/rootReducer' ; \n     import   {  routes ,  routesDir  }   from   'ui/App' ; \n     import  en  from   'locales/en' ; \n     import  it  from   'locales/it' ; \n\n     const  testing  =   { \n       id :   'testing' , \n      menu , \n      state , \n      routes , \n      routesDir , \n       locales :   { \n        en , \n        it , \n       } , \n     } ; \n\n     export   default  testing ; \n id: is the app id. \n This parameter is used by App Builder to differentiate all integrated\napps. \n menu: is a React component containing all the menu elements. \n These elements are used inside the standalone environment and inside the\nintegrated environment as a second level menu. The boilerplate app\ncontains a basic menu. \n      import  React  from   'react' ; \n     import   {  LinkMenuItem  }   from   '@entando/menu' ; \n     import   {  FormattedMessage  }   from   'react-intl' ; \n\n     const   LinkMenu   =   ( )   =>   ( \n       < > \n         < LinkMenuItem\n          id = \"menu-SECTION_ID\" \n          label = { < FormattedMessage id = \"testing.menu.SECTION_NAME\"  defaultMessage = \"SECTION_NAME\"   / > } \n          to = '/use/const/here/imported/from/routes' \n         / > \n       < / > \n     ) ; \n\n     export   default  LinkMenu ; \n Customizing the Menu \n For this exercise, we will create two links inside the menu. The first\nwill link to a page listing all the users inside the entando instance.\nThe second will list all the existing page models inside the Entando\ninstance. \n For this example we’re using existing APIs from the Entando core just\nfor simplicity, you can instead call any API or data source. \n In your app project, open  src/ui/common/LinkMenu.js  and update the\nconst to the code below. \n      const   LinkMenu   =   ( )   =>   ( \n       < > \n         < LinkMenuItem\n          id = \"menu-userList\" \n          label = { < FormattedMessage id = \"testing.menu.userList\"  defaultMessage = \"User List\"   / > } \n          to = '/use/const/here/imported/from/routes' \n         / > \n         < LinkMenuItem\n          id = \"menu-pageModelList\" \n          label = { < FormattedMessage id = \"testing.menu.pageModelList\"  defaultMessage = \"Page Model List\"   / > } \n          to = '/use/const/here/imported/from/routes' \n         / > \n       < / > \n     ) ; \n \n it is important that both the  <LinkMenuItem>  id property and the\n`<FormattedMessage>`properties inside label have the correct values\nassigned, i.e.: \n the LinkMenuItem id will be  menu-userList  while the FormattedMessage\nid will be  testing.menu.userList  and the defaultMessage will be\n User List . \n locales \n The locales files are objects that contain all of the i18n locales of\nthe app. \n By default the boilerplate contains both the english and italian i18n\nfiles. \n In your app project in  src/locales/en.js  and  src/locales/it.js  you\ncan see your labels. \n      export   default   { \n       locale :   'en' , \n       messages :   { \n         'testing.title' :   '' , \n         'testing.label.errors' :   '' , \n         'testing.label.cancel' :   '' , \n         'testing.chooseAnOption' :   '' , \n         'testing.tip' :   '' , \n         'testing.new' :   '' , \n         'testing.save' :   '' , \n         'testing.saveAndApprove' :   '' , \n         'testing.unpublish' :   '' , \n         'testing.setContentAs' :   '' , \n         'testing.cancel' :   '' , \n         'testing.saveAndContinue' :   '' , \n         'testing.stickySave.status' :   '' , \n         'testing.stickySave.lastAutoSave' :   '' , \n       } , \n     } ; \n \n While running in standalone mode the boilerplate does not offer a way\nfor the user pick a locale, but both will be loaded inside app-builder\nand will be consumed as intended by it, using the correct one based on\nthe user-picked language. \n It is of course possible to change the standalone app to give the user\nthe option to choose the locale in here as well, but this is not\nsomething will be covering in this tutorial. \n Customizing the menu labels \n To customize the existing menu labels, we’ll add the new label ids\ninside both the english and Italian locale files: \n \n Note \n If you named your app something besides  testing  you’ll need to fix\nthese tags to match the name of your app. \n \n      ... \n     messages :   { \n         ... \n         'testing.menu.userList' :   'List of Users' , \n         'testing.menu.pageModelList' :   'Page Models' , \n         ... \n     } , \n     ... \n \n The key in the messages object matches the id of the\n`<FormattedMessage>`component we placed inside the menu, while its\nvalue is the actual string that will be displayed depending on the\ncurrently active language. \n Routes and RoutesDir \n Both of these elements are imported from  src/ui/App.js . The first one\nis a collection of actual  <Route>  components, and the second one is an\nobject containing each route data, i.e.: \n      export   const  routesDir  =   [ \n       { \n         path :   ROUTE_TESTING , \n         component :   < > app component < / > , \n       } , \n     ] ; \n \n The constant  ROUTE_TESTING  is imported from  src/app-init/routes.js \n Customizing the Routes \n Next we will create the two routes for the two links we have created by\ncreating first the two constants needed. \n In your IDE open  src/app-init/routes.js \n      export   const   ROUTE_TESTING   =   '/testing' ; \n     export   const   ROUTE_USER_LIST   =   '/testing/user-list' ; \n     export   const   ROUTE_PAGE_MODELS   =   '/testing/page-models' ; \n \n \n Note \n Change the value of  testing  to what you selected for the name of\nyour App extension. \n \n The value of each constant will be the path of the route. It is\nimportant that each route is a subroute of the id of the app itself,\notherwise this may cause name collision when running inside the\nintegrated environment of app-builder. \n Both routes are next imported inside  App.js : \n Update the imports with your new ROUTE tags. \n      import   { \n       ROUTE_TESTING , \n       ROUTE_USER_LIST , \n       ROUTE_PAGE_MODELS , \n     }   from   'app-init/routes' ; \n \n and then add to the  routesDir  constant: \n      export   const  routesDir  =   [ \n       { \n         path :   ROUTE_TESTING , \n         component :   < > app component < / > , \n       } , \n       { \n         path :   ROUTE_USER_LIST , \n         render :   ( )   =>   < > user list < / > , \n       } , \n       { \n         path :   ROUTE_PAGE_MODELS , \n         render :   ( )   =>   < > page models < / > , \n       } , \n     ] ; \n \n Next, import the routes constants inside  LinkMenu.js  and change\naccordingly the  to  property of the  <LinkMenuItem>  component: \n      ... \n     import   { \n       ROUTE_USER_LIST , \n       ROUTE_PAGE_MODELS , \n     }   from   'app-init/routes' ; \n\n     const   LinkMenu   =   ( )   =>   ( \n       < > \n         < LinkMenuItem\n          id = \"menu-userList\" \n          label = { < FormattedMessage id = \"tatata.menu.userList\"  defaultMessage = \"User List\"   / > } \n          to = { ROUTE_USER_LIST } \n         / > \n         < LinkMenuItem\n          id = \"menu-pageModelList\" \n          label = { < FormattedMessage id = \"tatata.menu.pageModelList\"  defaultMessage = \"Page Model List\"   / > } \n          to = { ROUTE_PAGE_MODELS } \n         / > \n       < / > \n     ) ; \n     ... \n \n Next clicks on the links in the menu will change the routes and display\nthe content defined in the  App.js  file. \n state \n The state in src/babel.js is the combined reducer of the app, the\nrootReducer.js contains the combined reducer of the app and exports it,\nbut also contains the entire reducer of the app when running in\nstandalone mode. \n      export   const  testing  =   combineReducers ( { \n       // implement here your app specific reducers \n     } ) ; \n\n     export   default   combineReducers ( { \n       apps :   combineReducers ( {  testing  } ) , \n      api , \n      currentUser , \n      form , \n      loading , \n      locale , \n      messages , \n      modal , \n      pagination , \n     } ) ; \n \n The app specific reducers are stored inside the  apps  object, this is\ndone to avoid possible name collisions with any reducer stored inside\napp-builder when running the app in integrated mode. \n Customizing the Reducers \n Next we will be creating the two reducers for the user list and page\nmodels. They will be created inside two new directories\n src/state/apps/testing/userList/  and\n src/state/apps/testing/pageModels . The  types.js  files will contain\nthe two action types that we’ll need. \n userList/types.js \n // eslint-disable-next-line import/prefer-default-export\nexport const ADD_USERS = 'apps/testing/add-users';\n \n pageModels/types.js \n // eslint-disable-next-line import/prefer-default-export\nexport const ADD_PAGE_MODELS = 'apps/testing/page-models/add-page-models';\n \n The value of both constants contain the whole namespace\n apps/testing/REDUCER  this is done to avoid any possible name collision\nwhen running the app in integrated mode. \n Next create both actions files: \n userList/actions.js \n      import   { \n       ADD_USERS , \n     }   from   'state/apps/testing/userList/types' ; \n\n     // eslint-disable-next-line import/prefer-default-export \n     export   const   addUsers   =   users   =>   ( { \n       type :   ADD_USERS , \n       payload :  users , \n     } ) ; \n \n pageModels/actions.js \n      import   { \n       ADD_PAGE_MODELS , \n     }   from   'state/apps/testing/pageModels/types' ; \n\n     // eslint-disable-next-line import/prefer-default-export \n     export   const   addPageModels   =   pageModels   =>   ( { \n       type :   ADD_PAGE_MODELS , \n       payload :  pageModels , \n     } ) ; \n \n then the selectors: \n userList/selectors.js \n      import   {  createSelector  }   from   'reselect' ; \n\n     export   const   getUserList   =   state   =>  state . apps . testing . userList ; \n     export   const  getList  =   createSelector ( getUserList ,   userList   =>  userList . list ) ; \n \n pageModels/selectors.js \n      import   {  createSelector  }   from   'reselect' ; \n\n     export   const   getPageModels   =   state   =>  state . apps . testing . pageModels ; \n     export   const  getList  =   createSelector ( getPageModels ,   pageModels   =>  pageModels . list ) ; \n \n And finally the reducers. The default state is going to contain some\nsample data for us to display. \n userList/reducer.js \n      import   {   ADD_USERS   }   from   'state/apps/testing/userList/types' ; \n\n     const  defaultState  =   { \n       list :   [ \n         { \n           username :   'admin' , \n           registration :   '2018-01-08 00:00:00' , \n           lastLogin :   '2018-01-08 00:00:00' , \n           lastPasswordChange :   '2018-01-08 00:00:00' , \n           status :   'active' , \n           passwordChangeRequired :   true , \n           profileAttributes :   { \n             fullName :   'admin' , \n             email :   'admin@entando.com' , \n           } , \n         } , \n         { \n           username :   'user1' , \n           registration :   '2018-01-08 00:00:00' , \n           lastLogin :   '2018-01-08 00:00:00' , \n           lastPasswordChange :   '2018-01-08 00:00:00' , \n           status :   'disabled' , \n           passwordChangeRequired :   true , \n           profileAttributes :   { \n             fullName :   'User Name' , \n             email :   'user1@entando.com' , \n           } , \n         } , \n       ] , \n     } ; \n\n     const   reducer   =   ( state  =  defaultState ,  action  =   { } )   =>   { \n       switch   ( action . type )   { \n         case   ADD_USERS :   { \n           return   {   ... state ,   list :  action . payload  } ; \n         } \n\n         default :   return  state ; \n       } \n     } ; \n\n     export   default  reducer ; \n \n pageModels/reducer.js \n      import   {   ADD_PAGE_MODELS   }   from   'state/apps/testing/pageModels/types' ; \n\n     const  defaultState  =   { \n       list :   [ \n         { \n           code :   'home' , \n           descr :   'Home Page' , \n           configuration :   { \n             frames :   [ \n               { \n                 pos :   0 , \n                 descr :   'Navbar' , \n                 sketch :   { \n                   x1 :   0 , \n                   y1 :   0 , \n                   x2 :   2 , \n                   y2 :   0 , \n                 } , \n               } , \n               { \n                 pos :   1 , \n                 descr :   'Navbar 2' , \n                 sketch :   { \n                   x1 :   3 , \n                   y1 :   0 , \n                   x2 :   5 , \n                   y2 :   0 , \n                 } , \n               } , \n             ] , \n           } , \n           template :   '<html></html>' , \n         } , \n         { \n           code :   'service' , \n           descr :   'Service Page' , \n           configuration :   { \n             frames :   [ \n               { \n                 pos :   0 , \n                 descr :   'Navbar' , \n                 sketch :   { \n                   x1 :   0 , \n                   y1 :   0 , \n                   x2 :   2 , \n                   y2 :   0 , \n                 } , \n               } , \n               { \n                 pos :   1 , \n                 descr :   'Navbar 2' , \n                 sketch :   { \n                   x1 :   3 , \n                   y1 :   0 , \n                   x2 :   5 , \n                   y2 :   0 , \n                 } , \n               } , \n             ] , \n           } , \n           template :   '<html></html>' , \n         } , \n       ] , \n     } ; \n\n     const   reducer   =   ( state  =  defaultState ,  action  =   { } )   =>   { \n       switch   ( action . type )   { \n         case   ADD_PAGE_MODELS :   { \n           return   {   ... state ,   list :  action . payload  } ; \n         } \n\n         default :   return  state ; \n       } \n     } ; \n\n     export   default  reducer ; \n \n Last, we can add the two reducers just created to the\n src/state/rootReducer.js \n      ... \n     import  userList  from   'state/apps/testing/userList/reducer' ; \n     import  pageModels  from   'state/apps/testing/pageModels/reducer' ; \n\n     export   const  testing  =   combineReducers ( { \n      pageModels , \n      userList , \n     } ) ; \n     ... \n \n we will now be able to see with the  reduxDevTools  in our browser. To\nview this state in your reduxDevTools go to: \n State -→ apps -→ testing -→ pageModels  and\n State -→ apps -→ testing -→ userList \n Creating the UI Components \n At this point, both routes created should be rendering a simple string.\nWe will next create the actual component that will be rendered inside\nthe page. \n userList \n Inside  src/ui/userList/  create the  List  component. Create the\n userList  directory and  List.js  file in that directory. \n      import  React  from   'react' ; \n\n     import   { \n      Grid , \n      TablePfProvider , \n     }   from   'patternfly-react' ; \n\n     const   List   =   ( )   =>   { \n       const  data  =   [ \n         { \n           username :   'admin' , \n           registration :   '2018-01-08 00:00:00' , \n         } , \n         { \n           username :   'user1' , \n           registration :   '2018-01-08 00:00:00' , \n         } , \n       ] ; \n\n       const  tr  =  data . map ( row   =>   ( \n         < tr > \n           < td > { row . username } < / td > \n           < td > { row . registration } < / td > \n         < / tr > \n       ) ) ; \n\n       return   ( \n         < Grid fluid > \n           < TablePfProvider\n            striped\n            bordered\n            hover\n           > \n             < thead > \n               < tr > \n                 < td > username < / td > \n                 < td > registration < / td > \n               < / tr > \n             < / thead > \n             < tbody > \n               { tr } \n             < / tbody > \n           < / TablePfProvider > \n         < / Grid > \n       ) ; \n     } ; \n\n     export   default  List ; \n \n Next, change the route inside  src/ui/App.js . Add the import below and\nupdate the component to reference the List component created in the\nprior step. \n      ... \n     import  List  from   'ui/userList/List' ; \n     ... \n       { \n         path :   ROUTE_USER_LIST , \n         component :  List , \n       } , \n     ... \n \n The table will now display correctly when clicking on the menu item. \n connecting to the store \n Next let’s connect the component to the store to get the data from the\nreducer. \n The first step is creating the  ListContainer.js  next to the  List \ncomponent file. \n      import   {  connect  }   from   'react-redux' ; \n     import   {  getList  }   from   'state/apps/testing/userList/selectors' ; \n\n     import  List  from   'ui/userList/List' ; \n\n     export   const   mapStateToProps   =   state   =>   ( { \n       data :   getList ( state ) , \n     } ) ; \n\n     export   default   connect ( \n      mapStateToProps , \n       null , \n     ) ( List ) ; \n \n And then update the List component to receive the property. The List\nfile should now look like this: \n      import  React  from   'react' ; \n     import  PropTypes  from   'prop-types' ; \n\n     import   { \n      Grid , \n      TablePfProvider , \n     }   from   'patternfly-react' ; \n\n     const   List   =   ( {  data  } )   =>   { \n       const  tr  =  data . map ( row   =>   ( \n         < tr > \n           < td > { row . username } < / td > \n           < td > { row . registration } < / td > \n         < / tr > \n       ) ) ; \n\n       return   ( \n         < Grid fluid > \n           < TablePfProvider\n            striped\n            bordered\n            hover\n           > \n             < thead > \n             < tr > \n               < td > username < / td > \n               < td > registration < / td > \n             < / tr > \n             < / thead > \n             < tbody > \n             { tr } \n             < / tbody > \n           < / TablePfProvider > \n         < / Grid > \n       ) ; \n     } ; \n\n     export   default  List ; \n \n Make sure that you remove the predefined  data  const since the data\nwill now be coming from the reducer, on top of defining PropTypes rules\nfor validating and giving a default for the injected property  data . \n Once complete, update the component used in the route inside  App.js .\nUpdate the import to the container and update the component in\n ROUTE_USER_LIST  to the new ListContainer. \n      ... \n     import  ListContainer  from   'ui/userList/ListContainer' ; \n     ... \n       { \n         path :   ROUTE_USER_LIST , \n         component :  ListContainer , \n       } , \n     ... \n \n Go back to your app. We will now see the data inside the table\nreflecting the content of the storage. \n Page Models \n inside  src/ui/pageModels/  we are going to create the  List  component \n      import  React  from   'react' ; \n     import  PropTypes  from   'prop-types' ; \n\n     import   { \n      Grid , \n      TablePfProvider , \n     }   from   'patternfly-react' ; \n\n     const   List   =   ( {  data  } )   =>   { \n       const  tr  =  data . map ( row   =>   ( \n         < tr > \n           < td > { row . username } < / td > \n           < td > { row . registration } < / td > \n         < / tr > \n       ) ) ; \n\n       return   ( \n         < Grid fluid > \n           < TablePfProvider\n            striped\n            bordered\n            hover\n           > \n             < thead > \n             < tr > \n               < td > username < / td > \n               < td > registration < / td > \n             < / tr > \n             < / thead > \n             < tbody > \n             { tr } \n             < / tbody > \n           < / TablePfProvider > \n         < / Grid > \n       ) ; \n     } ; \n\n    List . propTypes  =   { \n       data :  PropTypes . arrayOf ( PropTypes . shape ( { } ) ) , \n     } ; \n\n    List . defaultProps  =   { \n       data :   [ ] , \n     } ; \n\n     export   default  List ; \n \n Next change the route inside  src/ui/App.js \n      ... \n     import  ListPageModels  from   'ui/pageModels/List' ; \n     ... \n       { \n         path :   ROUTE_PAGE_MODELS , \n         component :  ListPageModels , \n       } , \n     ... \n \n The table will now be displayed correctly when clicking on the menu\nitem. \n Connecting to the Store \n Next, connect the component to the store to get the data from the\nreducer. \n The very first thing we’ll do is create the  ListContainer.js  next to\nthe  List  component file. \n      import   {  connect  }   from   'react-redux' ; \n     import   {  getList  }   from   'state/apps/testing/pageModels/selectors' ; \n\n     import  List  from   'ui/pageModels/List' ; \n\n     export   const   mapStateToProps   =   state   =>   ( { \n       data :   getList ( state ) , \n     } ) ; \n\n     export   default   connect ( \n      mapStateToProps , \n       null , \n     ) ( List ) ; \n \n And then update the List component to receive the property. The whole\nList component will have this content: \n      import  React  from   'react' ; \n     import  PropTypes  from   'prop-types' ; \n\n     import   { \n      Grid , \n      TablePfProvider , \n     }   from   'patternfly-react' ; \n\n     const   List   =   ( {  data  } )   =>   { \n       const  tr  =  data . map ( row   =>   ( \n         < tr > \n           < td > { row . code } < / td > \n           < td > { row . descr } < / td > \n         < / tr > \n       ) ) ; \n\n\n       return   ( \n         < Grid fluid > \n           < TablePfProvider\n            striped\n            bordered\n            hover\n           > \n             < thead > \n             < tr > \n               < td > code < / td > \n               < td > descr < / td > \n             < / tr > \n             < / thead > \n             < tbody > \n             { tr } \n             < / tbody > \n           < / TablePfProvider > \n         < / Grid > \n       ) ; \n     } ; \n\n    List . propTypes  =   { \n       data :  PropTypes . arrayOf ( PropTypes . shape ( { } ) ) , \n     } ; \n\n    List . defaultProps  =   { \n       data :   [ ] , \n     } ; \n     export   default  List ; \n \n Next make sure that you remove the predefined  data  const since the\ndata will be coming from the reducer, on top of defining PropTypes rules\nfor validating and giving a default for the injected property  data . \n Once complete, update the component used in the route inside  App.js \n      ... \n     import  PageModelsListContainer  from   'ui/pageModels/ListContainer' ; \n     ... \n       { \n         path :   ROUTE_PAGE_MODELS , \n         component :  PageModelsListContainer , \n       } , \n     ... \n \n You will now see the data inside the table reflecting the content of the\nstorage. \n Connecting the app to an Entando core instance \n By default the app is using mocks and not connecting to any Entando core\ninstance. \n Because the app is making use of  @entando/apimanager  we can easily\nchange this by setting up two  .env  variables inside the  .env  file in\nthe project root: \n     REACT_APP_DOMAIN=http://localhost:8080/entando-app\n    REACT_APP_USE_MOCKS=false\n \n The  REACT_APP_DOMAIN  must pointing towards the domain and container\nwhere the Entando instance is running and  must not  contain trailing\nslashes. \n Once this is done to make the change happen we will have to stop the app\nusing  ctrl + c  and re run it with  npm start . \n Now the toast stating  This application is using mocks  won’t be popping\nup anymore. \n You can make sure that the configuration is correct by looking at the\nnetwork section in the browser dev tools. By default the app\nautomatically makes an admin login against a plain Entando instance to\nauthenticate the user and to be able to consume any protected api. \n This is not an ideal scenario and it is meant to be used only for\ndebugging purposes for many reasons: \n \n \n the username and password should never be hardcoded in your app \n \n \n if authentication is required the user should be the one performing\nthe login action \n \n \n the plain default passwords in use won’t be useful against a proper\nproduction instance of Entando \n Adding the API Calls \n We are now going to add api calls for both users and page models to\nretrieve the data live instead of relying on our store’s default state. \n Inside  src/api  create the  users.js  file: \n      import   {  makeRequest ,   METHODS   }   from   '@entando/apimanager' ; \n\n     // eslint-disable-next-line import/prefer-default-export \n     export   const  getUsers  =   ( page  =   {   page :   1 ,   pageSize :   10   } ,  params  =   '' )   =>   ( \n       makeRequest ( \n         { \n           uri :   ` /api/users ${ params } ` , \n           method :   METHODS . GET , \n           mockResponse :   { } , \n           useAuthentication :   true , \n         } , \n        page , \n       ) \n     ) ; \n \n and then create the  pageModels.js  file: \n      import   {  makeRequest ,   METHODS   }   from   '@entando/apimanager' ; \n\n     // eslint-disable-next-line import/prefer-default-export \n     export   const  getPageModels  =   ( page  =   {   page :   1 ,   pageSize :   10   } ,  params  =   '' )   =>   makeRequest ( { \n       uri :   ` /api/pageModels ${ params } ` , \n       method :   METHODS . GET , \n       mockResponse :   { } , \n       useAuthentication :   true , \n     } ,  page ) ; \n Creating the Thunk \n In order to use the api call we next create a thunk action, which is a\nredux action with side effects, like an API call. \n inside the  src/state/apps/testing/userList/actions.js  file we are\ngoing to add the new action: \n      ... \n     import   {  addErrors  }   from   '@entando/messages' ; \n     import   { \n      getUsers , \n     }   from   'api/users' ; \n     ... \n\n     // thunks \n\n     export   const  fetchUsers  =   ( page  =   {   page :   1 ,   pageSize :   10   } ,  params  =   '' )   =>   dispatch   =>   ( \n       new   Promise ( ( resolve )   =>   { \n         getUsers ( page ,  params ) . then ( ( response )   =>   { \n          response . json ( ) . then ( ( json )   =>   { \n             if   ( response . ok )   { \n               dispatch ( addUsers ( json . payload ) ) ; \n             }   else   { \n               dispatch ( addErrors ( json . errors . map ( err   =>  err . message ) ) ) ; \n             } \n             resolve ( ) ; \n           } ) ; \n         } ) . catch ( ( )   =>   { } ) ; \n       } ) \n     ) ; \n \n Next do the same inside  src/state/apps/testing/pageModels/actions.js : \n      ... \n     import   {  addErrors  }   from   '@entando/messages' ; \n     import   { \n      getPageModels , \n     }   from   'api/pageModels' ; \n     ... \n\n     // thunks \n\n     export   const  fetchPageModels  =   ( page  =   {   page :   1 ,   pageSize :   10   } ,  params  =   '' )   =>   dispatch   =>   ( \n       new   Promise ( ( resolve )   =>   { \n         getPageModels ( page ,  params ) . then ( ( response )   =>   { \n          response . json ( ) . then ( ( data )   =>   { \n             if   ( response . ok )   { \n               dispatch ( addPageModels ( data . payload ) ) ; \n               resolve ( ) ; \n             }   else   { \n               dispatch ( addErrors ( data . errors . map ( err   =>  err . message ) ) ) ; \n               resolve ( ) ; \n             } \n           } ) ; \n         } ) . catch ( ( )   =>   { } ) ; \n       } ) \n     ) ; \n \n Now with two exports, it is safe to remove the\n eslint-disable-next-line  comment on line 5 of both files. \n changing the mapDispatchToProps in the containers \n Next, in order to pass the newly created thunk to both List components,\nwe’ll update the containers accordingly, as: \n src/ui/userList/ListContainer.js \n      ... \n     import   {  fetchUsers  }   from   'state/apps/testing/userList/actions' ; \n     ... \n     export   const   mapDispatchToProps   =   dispatch   =>   ( { \n       fetch :   ( )   =>   dispatch ( fetchUsers ( ) ) , \n     } ) ; \n\n     export   default   connect ( \n      mapStateToProps , \n      mapDispatchToProps , \n     ) ( List ) ; \n \n src/ui/pageModels/ListContainer.js \n      ... \n     import   {  fetchPageModels  }   from   'state/apps/testing/pageModels/actions' ; \n     ... \n     export   const   mapDispatchToProps   =   dispatch   =>   ( { \n       fetch :   ( )   =>   dispatch ( fetchPageModels ( ) ) , \n     } ) ; \n\n     export   default   connect ( \n      mapStateToProps , \n      mapDispatchToProps , \n     ) ( List ) ; \n Updating the List components \n Both List components were simple components with only a  render  method,\ntherefore could be declared as simple constants. \n Next we will fetch data during the  componentDidMount  life cycle event\nwhich will require we turn the constant into a class on top of changing\nthe PropTypes to add the new fetch method passed down to the component. \n src/ui/userList/List.js \n      import  React ,   {  Component  }   from   'react' ; \n     ... \n     class   List   extends   Component   { \n       componentDidMount ( )   { \n         const   {  fetch  }   =   this . props ; \n         fetch ( ) ; \n       } \n\n       render ( )   { \n         const   {  data  }   =   this . props ; \n         const  tr  =  data . map ( row   =>   ( \n           < tr > \n             < td > { row . username } < / td > \n             < td > { row . registration } < / td > \n           < / tr > \n         ) ) ; \n\n         return   ( \n           < Grid fluid > \n             < TablePfProvider\n              striped\n              bordered\n              hover\n             > \n               < thead > \n                 < tr > \n                   < td > username < / td > \n                   < td > registration < / td > \n                 < / tr > \n               < / thead > \n               < tbody > \n                 { tr } \n               < / tbody > \n             < / TablePfProvider > \n           < / Grid > \n         ) ; \n       } \n     } \n\n    List . propTypes  =   { \n       data :  PropTypes . arrayOf ( PropTypes . shape ( { } ) ) , \n       fetch :  PropTypes . func , \n     } ; \n\n    List . defaultProps  =   { \n       data :   [ ] , \n       fetch :   ( )   =>   { } , \n     } ; \n \n src/ui/pageModels/List.js \n      import  React ,   {  Component  }   from   'react' ; \n     ... \n     class   List   extends   Component   { \n       componentDidMount ( )   { \n         const   {  fetch  }   =   this . props ; \n         fetch ( ) ; \n       } \n\n       render ( )   { \n         const   {  data  }   =   this . props ; \n         const  tr  =  data . map ( row   =>   ( \n           < tr > \n             < td > { row . code } < / td > \n             < td > { row . descr } < / td > \n           < / tr > \n         ) ) ; \n\n         return   ( \n           < Grid fluid > \n             < TablePfProvider\n              striped\n              bordered\n              hover\n             > \n               < thead > \n                 < tr > \n                   < td > code < / td > \n                   < td > descr < / td > \n                 < / tr > \n               < / thead > \n               < tbody > \n                 { tr } \n               < / tbody > \n             < / TablePfProvider > \n           < / Grid > \n         ) ; \n       } \n     } \n\n    List . propTypes  =   { \n       data :  PropTypes . arrayOf ( PropTypes . shape ( { } ) ) , \n       fetch :  PropTypes . func , \n     } ; \n\n    List . defaultProps  =   { \n       data :   [ ] , \n       fetch :   ( )   =>   { } , \n     } ; \n clear the default value of the reducer \n Now we should be fetching data from the server, therefore we can safely\nmake the list key in the  defaultState  object an empty array: \n src/state/apps/testing/userList/reducer.js \n      ... \n     const  defaultState  =   { \n       list :   [ ] , \n     } ; \n     ... \n \n src/state/apps/testing/pageModels/reducer.js \n      ... \n     const  defaultState  =   { \n       list :   [ ] , \n     } ; \n     ... \n adding additional dependencies \n It may be necessary to set additional dependencies for your project. If\nthe need arises, it is important to remember a few rules: \n Only actual dependencies that are not already included in  app-builder \ncan be added as pure dependencies. Every other dependency must either be\na  devDependency  or  peerDependency . \n If you are not careful you may end up with duplicated dependencies that\n will  result in errors manifesting themselves when running the app\ninside App Builder. \n running the app in integrated mode within App Builder \n After running  npm install  in the App Builder, the user can run the\n npm run app-install <appId>  command to install the app. \n This command will trigger a download of the app from npm and the\ninstallation of its component within App Builder. After the installation\nprocess is complete, it will be possible to either  npm start  or\n npm build  App Builder. \n To install a dev app, like the one developed in this tutorial which have\nnot been previously published on npm, you will need to use additional\nflags and will have to run a few additional commands. \n Before running the Install command  make sure that you have\nuninstalled all existing peer and dev dependencies to avoid collision\nwith app builder. To do so, from the app builder app directory\n( testing , in this tutorial) just run in the correct order the\nfollowing commands: \n npm run babel \n npm i --only=production \n The first will create the dist directory that will be needed by App\nBuilder while the second one will uninstall anything but production\ndependencies. \n Next, from the App Builder directory, run the install command with these\nadditional flags: \n \n \n -d  specify the relative path where the app is installed. When\nusing this flag the appId should be the normalized app name, without\nthe  @entando/  prefix. \n \n \n -p  specify the package name if it is different from the appId \n \n \n to use flags you will have to use the double dash in the command: \n npm run app-install —  cms -d ../testing -p @entando/testing \n the value in the  -p  flag should always match the actual name of the\napp that is going to be installed inside App Builder . You can check\nyour app name inside the  package.json  file of your app. \n If you experience problems after running the build command delete the\n node_modules  directory before running the second command. \n"},{title:"Building a Docker Image for the Entando Core",frontmatter:{},regularPath:"/v6.1/tutorials/customize-the-platform/app-engine/build-core-image.html",relativePath:"v6.1/tutorials/customize-the-platform/app-engine/build-core-image.md",key:"v-e9938dda",path:"/v6.1/tutorials/customize-the-platform/app-engine/build-core-image.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Introduction",slug:"introduction"},{level:2,title:"Setup",slug:"setup"}],lastUpdated:"12/15/2021, 2:22:26 PM",lastUpdatedTimestamp:1639596146e3,content:" Building a Docker Image for the Entando Core \n Prerequisites \n \n \n Java 8 \n \n \n Docker installed locally\n( https://docs.docker.com/docker-for-windows/install/ ) \n \n \n maven \n \n \n Access to a docker repository (docker.io or other) \n Introduction \n This tutorial will take you through the basic steps to create a docker\nimage from an Entando core application. A more detailed guide with\nadditional commands and configuration can be found here: \n https://github.com/entando/entando-de-app \n Setup \n \n \n Clone the application at:\n https://github.com/entando/entando-de-app  using \n git clone https://github.com/entando/entando-de-app\n \n \n \n On a command line, cd into the entando-de-app you just cloned: \n cd entando-de-app\n \n \n \n Build a docker image from the core app \n mvn clean package -Pwildfly -Pderby docker:build\n \n \n \n View the images installed on your local docker instance \n docker images\n \n Look for \n entando/entando-de-app:latest\n \n \n \n Create a repository on your docker repository to house your new\napplication \n \n \n Re-tag the image you just built with your repo \n  docker tag entando/entando-de-app:latest <YOUR-USER>/<YOUR-REPO-NAME>:latest\n \n \n \n Push the Image to your Repository \n docker push <YOUR-USER>/<YOUR-REPO-NAME>:latest\n \n \n \n"},{title:"Digital Assets",frontmatter:{},regularPath:"/v6.1/tutorials/cms/digital-assets-tutorial.html",relativePath:"v6.1/tutorials/cms/digital-assets-tutorial.md",key:"v-026f84c4",path:"/v6.1/tutorials/cms/digital-assets-tutorial.html",headers:[{level:2,title:"Objective",slug:"objective"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"How to create a Digital Asset",slug:"how-to-create-a-digital-asset"},{level:2,title:"Editing Assets",slug:"editing-assets"},{level:3,title:"Cropping Images",slug:"cropping-images"},{level:2,title:"Embedding an Asset in a Page",slug:"embedding-an-asset-in-a-page"},{level:2,title:"Including an Asset in a Content",slug:"including-an-asset-in-a-content"},{level:2,title:"Configuring Allowed File Extensions for Upload",slug:"configuring-allowed-file-extensions-for-upload"}],lastUpdated:"6/27/2020, 10:35:02 PM",lastUpdatedTimestamp:1593311702e3,content:" Digital Assets \n Objective \n This document provides an overview of the Digital Assets and\nfunctionalities needed to manage images and documents. \n Overview \n The WEB CMS includes capabilities that let you manage contents and\ndigital assets. Digital Assets are images, documents, and other media\nfiles supported in specific format. \n Default Supported Document Formats:  The Entando CMS can be\nconfigured to allow you to load or exclude any type of file extension\nfrom being loaded to your site. For the app builder you should also include the MIME type of the asset you want to allow. The default set of extensions are: \n pdf,xls,doc,ppt,txt,rtf,sxw,sxc,odt,ods,odp,tar,gz,zip,rar,flv,swf,avi,wmv,ogg,mp3,wav,ogm,mov,iso,nrg,docx,docm,xlsx,xlsm,xlsb,pptx,pptm,ppsx,ppsm,sldx,sldm. \n Default Supported Image Formats : jpg, jpeg, png, svg,svg+xml \n How to create a Digital Asset \n To manage the Digital Assets through the Web CMS integrated with App\nBuilder application \n \n Select the CMS section and click on the Digital Assets subsection \n \n \n Add a new image or a new document file \n \n Press the  Drag and Drop or Browse your computer  button and\nchoose, from your file system, images and documents files that you\nwould like to upload \n \n \n \n From the  Add file  modal window, you must choose one the\navailable Groups and then the  Upload  button. If categories have\nbeen defined and displayed , you can join the file with the\ncategories you want. \n \n \n \n \n The image file that you just uploaded is displayed in the list; a\nstatistical overview of the number of the uploaded resources (images\nand documents) is provided. The App Builder’s interface allows the\nusers to choose grid and list view; most of the time, users prefer\nto use list view when they are searching with specific requirements,\nwhile they love grid view for exploring. For every resource, image,\nor document, the list shows the following information: \n \n \n Preview \n \n \n Name \n \n \n Type \n \n \n Uploaded By \n \n \n Uploaded At \n \n \n Group \n \n \n Categories \n \n \n Actions \n \n \n \n \n Furthermore, the interface lets you perform all management actions, as: \n \n \n Edit:  update the information data related to every single\nresource (image and document) \n \n \n Duplicate:  copy identically the resource from the original \n \n \n Download:  transfer the resource in your local machine \n \n \n Delete:  remove the resource \n \n \n \n You can list the contents by filtering with: \n \n \n All : All added files are displayed, images and documents both. \n \n \n Images : All added images are displayed \n \n \n Attachments : All added documents are displayed.\nThe Attachments name will be updated to the Documents name; the same for the Files label. \n Editing Assets \n Once you have a digital asset in place, you have several editing and viewing options. Click the asset's  More Actions  button and select  Edit  to update the asset's name/description, categories, and the file represented. \n Cropping Images \n You can crop images newly uploaded via Digital Assets. You can either crop the image dynamically or by using pre-configured crop ratios. \n To set pre-configured crop ratios: \n \n Select Apps > CMS > Content Settings. \n Under “Settings Image Crop Dimensions,” click  Add . \n Enter a crop ratio, using numeric values separated by a colon. See the screenshot below for an example. \n Click  Save . \n \n To dynamically crop an image: \n \n Edit the asset by opening  Actions  menu > Edit.\n \n Buttons representing your pre-defined crop ratios are below the image. Clicking any of those buttons changes the selected crop area based on the chosen ratio. \n You can create multiple crops of a single image as part of the upload process. The right side of the screen displays the list of crops created during the current session. \n \n \n \n \n \n Use your mouse or the buttons below the image to move or change the crop area, then click  Save  to crop the selected area. Repeat the process as many times as needed.\n \n Click  Close  to return to the Digital Assets screen. \n Embedding an Asset in a Page \n The uploaded asset can be embedded in a page by using  <@wp.resourceUrl path/to/asset . The path can be found in the CMS Configuration > File Browser page. \n \n Example usage:\n <img src=\"<@wp.resourceUrl cms/images/butterfly_d0_d3.jpg\" \n Including an Asset in a Content \n The asset can be included in a content of a type that has an  Attach  or  Image  attribute. \n \n Create a content type with an image attribute.\n \n Create a content based on the created  type.\n \n Under the  Content Attributes  section at the bottom of the page, click the  Add  button beside the image attribute. It will then open a modal that allows you to select an asset by clicking the  Use  action.\n Configuring Allowed File Extensions for Upload \n The types of files that can be uploaded to an Entando applicaiton are controlled by\nconfiguration in the server side of the app builder. If you're using the quickstart this will be the\n entando-de-app . \n There are two properties that control these settings and they are set in  src/main/conf/systemParams.properties  and are a comma delimitted list of values. The property keys are \n \n jacms.imageResource.allowedExtensions= \n jacms.attachResource.allowedExtensions= \n \n If you are configuring the upload for both the App Builder and the legacy Admin Console you should include\nboth the MIME type of the asset and the file extension. The APIs that support resources will check MIME type of the uploaded asset. \n An example configuration for images. \n \n jacms.imageResource.allowedExtensions=jpg,jpeg,png,svg,svg+xml \n \n Where  svg+xml  is the MIME type for an svg image. \n The  systemParams.properties  file is bundled into the WAR and the image for the application so you will need to create and deploy image to reflect changes for these properties in your application. \n"},{title:"Building a Docker Image and Deploying a Pre-Packaged App",frontmatter:{},regularPath:"/v6.1/tutorials/customize-the-platform/app-engine/building-prepackaged-image.html",relativePath:"v6.1/tutorials/customize-the-platform/app-engine/building-prepackaged-image.md",key:"v-1f32e193",path:"/v6.1/tutorials/customize-the-platform/app-engine/building-prepackaged-image.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Introduction",slug:"introduction"},{level:2,title:"Setup",slug:"setup"}],lastUpdated:"12/15/2021, 2:22:26 PM",lastUpdatedTimestamp:1639596146e3,content:' Building a Docker Image and Deploying a Pre-Packaged App \n Prerequisites \n \n \n Java 8 \n \n \n Docker installed locally\n( https://docs.docker.com/docker-for-windows/install/ ) \n \n \n maven \n \n \n Access to a docker repository (docker.io or other) \n Introduction \n This tutorial will show you how you can use an Entando application that\nyou have built as a launching point for creating new applications. \n In this lab you’ll take a demo application previously built, install the\nbackups in a blank application, build an image from the updated app, and\ndeploy it as a new application. \n Setup \n \n \n Clone the application at:\n https://github.com/entando/entando-de-app  using \n git clone https://github.com/entando/entando-de-app\n \n \n \n On a command line, cd into the entando-de-app you just cloned: \n cd entando-de-app\n \n \n \n Take the provide zip file and unzip it in a location of your choice. \n \n \n This zip contains all of the assets, content, and metadata\nneeded to launch an Entando application. We are going to package\nthem the assets and DB an image and \n \n \n Entando will automatically instantiate and populate the app from\nthe most recent backup \n \n \n \n \n Move the resources and protected folders from the zip file into your\n entando-de-app  in  src/main/webapp  replacing any content that is\nalready there \n \n \n Build a docker image from the app \n mvn clean package -Pwildfly -Pderby docker:build\n \n \n Note that the "derby" option here is only for the initialization\nphase of the DB when deploying. It isn’t the final database\nchoice \n \n \n \n View the images installed on your local docker instance \n docker images\n \n Look for \n entando/entando-de-app:latest\n \n \n \n Create a repository on your docker repository to house your new\napplication \n \n \n Re-tag the image you just built with your repo \n  docker tag entando/entando-de-app:latest <YOUR-USER>/<YOUR-REPO_NAME>:latest\n \n \n \n Push the Image to your Repository \n docker push <YOUR-USER>/<YOUR-REPO_NAME>:latest\n \n \n \n Now we need to generate a new application for deployment to\nKubernetes using the helm chart \n \n \n If you have an output from helm from before you can re-use it\nand just apply the changes to the config map. \n \n \n Or you can re-run helm and change the output \n \n \n \n \n Re-run the helm command for your environment (check with your\ninstructor if you don’t know what this is) \n \n \n Open the output yaml file from the helm command in the text editor\nof your choice \n \n For example:  vi training-alpha.yaml \n \n \n \n In that file look for the  ConfigMap \n \n \n The config map defines all of the images that are available as\npart of the deployment. They aren’t all used concurrently. \n \n \n You can also view this config map in kubernetes/OpenShift \n \n \n \n \n Now you need to update the deployment to use your customized Wildfly\nimage. Find  entando-de-app-wildfly  in the config map \n \n Note that we are changing the de-app but you could create a\ncustom version of any of the included images \n \n \n \n Change the version to match the version you used for your image \n \n \n Change the "organization" to the name of your main image repository\norganization and if you aren’t using docker.io (DockerHub) then\nchange the registry as well. \n \n \n Save the file \n \n \n Follow the deployment steps you went through when you originally\ndeployed your Entando application to your Kubernetes instance \n \n \n Once deployed go to the app builder in your app \n \n \n Click Go To Homepage \n \n \n'},{title:"The Entando Core APIs",frontmatter:{},regularPath:"/v6.1/tutorials/customize-the-platform/app-engine/core-swagger.html",relativePath:"v6.1/tutorials/customize-the-platform/app-engine/core-swagger.md",key:"v-a91812da",path:"/v6.1/tutorials/customize-the-platform/app-engine/core-swagger.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Setup",slug:"setup"},{level:2,title:"Overview",slug:"overview"},{level:3,title:"API structure",slug:"api-structure"},{level:3,title:"Models",slug:"models"},{level:2,title:"Tutorial:",slug:"tutorial"}],lastUpdated:"12/15/2021, 2:22:26 PM",lastUpdatedTimestamp:1639596146e3,content:" The Entando Core APIs \n Prerequisites \n \n \n Java 8 \n \n \n maven \n Setup \n \n \n Clone the Entando sample app if you don’t already have it. \n git clone https://github.com/entando/entando-de-app\n \n \n \n Start the app for local execution and enable the swagger profile by\npassing  -Dspring.profiles.active=swagger  to the jetty command. Set\nthe value of  -Djetty.port  to something available on your machine\ne.g. 8081. \n mvn clean package jetty:run-war -Pjetty-local -Pderby -Dspring.profiles.active=swagger -Djetty.port=8085 -Dorg.slf4j.simpleLogger.log.org.eclipse.jetty.annotations.AnnotationParser=error \n \n \n \n Note: If you don't have docker installed or running add  -DskipDocker=true  to the command above \n \n \n \n Wait for the app to start. \n \n \n Once started, navigate to the swagger ui in a browser. \n \n \n \n http://localhost:[your port]/entando-de-app/api/swagger-ui.html\n Overview \n The Entando core exposes REST APIs for every action that can be taken in\nthe App Builder and Admin Console environments. For example, you can use\nthese apis to create pages, create page models or to add widgets to\npages. The APIs can be used to support automation, testing, or\nintegrations with external systems. \n API structure \n All of the APIs share a common top level structure. Each response will\ncontain a top level entry for  errors ,  metadata , and  payload . \n The  errors  will always contain code and a message string indicating an\nerror condition in the request. The  metadata  section is used for\npaging, sorting, filtering and data that is distinct from the body. The\nbody of each response is included in the  payload  section of the\nresponse and varies according to each API. \n Models \n All of the model classes returned by the Entando core are annotated so\nthat the model definition is included in the swagger documentation. At\nthe bottom of the swagger page all of the model classes returned by the\nAPI endpoints can be found. \n Tutorial: \n \n \n Stop the Entando instance if it is running. \n \n \n In the project open  src/main/conf/systemParams.properties . \n \n \n Change the value of this property to reflect the port you are using\nto run the app. \n \n \n applicationBaseURL \n \n \n For example if running on 8085 you would have\n applicationBaseURL=http://localhost:8085/${entando.engine.web.context}/ \n \n \n \n \n Login to the admin console at\n http://localhost:8085/entando-de-app/do/login . \n \n \n Once logged in go to Integration -→ API Management -→ Consumers. \n \n \n Select the kebab button on the row labeled swagger. \n \n \n On that screen enable the button for  client_credentials . \n \n \n On that screen enter  swagger  as the value for the secret. \n \n \n Hit save \n \n \n Return to swagger  your\nport /entando-de-app/api/swagger-ui.html \n \n \n Hit authorize \n \n \n Enter \n \n \n User: admin \n \n \n PW: adminadmin \n \n \n client: swagger \n \n \n client_secret: swagger \n \n \n \n \n Use the  Try it out  button on the APIs \n \n \n Scroll to  widget-controller \n \n \n Select the blue GET row \n \n \n Select  Try it out \n \n \n Look at the results in the window \n \n \n \n \n"},{title:"Add a New Datasource in EAP Server",frontmatter:{},regularPath:"/v6.1/tutorials/customize-the-platform/add_datasource_to_eap_image.html",relativePath:"v6.1/tutorials/customize-the-platform/add_datasource_to_eap_image.md",key:"v-974b2b74",path:"/v6.1/tutorials/customize-the-platform/add_datasource_to_eap_image.html",headers:[{level:2,title:"Other resources",slug:"other-resources"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:' Add a New Datasource in EAP Server \n With EAP should be enough to add a set of parameters the EntandoApp\ncustom resource. \n \n \n Set the standardServerImage to eap \n \n \n Add a  parameters  object \n \n \n \n Parameters environment variables reference \n \n \n \n \n \n \n \n Env variable \n Value \n Example with PortDB \n \n \n \n \n DATASOURCES \n "PORTDB,SERVDB, <YOUR-DS-PREFIX>" \n \n \n \n <YOUR-DS-PREFIX>_NONXA \n Defines the datasource as a non-XA datasource. Defaults to  false \n PORTDB_NONXA="true" \n \n \n <YOUR-DS-PREFIX>_JTA \n Defines Java Transaction API (JTA) option for the non-XA datasource. The XA datasources are already JTA capable by default Defaults to  true \n PORTDB_JTA="false" \n \n \n <YOUR-DS-PREFIX>_URL \n Defines connection URL for the datasource. \n PORTDB_URL="jdbc:derby:/entando-data/databases/entandoPort;create=true" \n \n \n <YOUR-DS-PREFIX>_JNDI \n Defines the JNDI name for the datasource. This setting is useful if you want to override the default generated JNDI name \n PORTDB_JNDI="java:jboss/datasources/entandoPortDataSource" \n \n \n <YOUR-DS-PREFIX>_DRIVER \n Defines Java database driver for the datasource \n PORTDB_DRIVER="derby" \n \n \n <YOUR-DS-PREFIX>_USERNAME \n Defines the username for the datasource \n PORTDB_USERNAME="agile" \n \n \n <YOUR-DS-PREFIX>_PASSWORD \n Defines the password for the datasource \n PORTDB_PASSWORD="agile" \n \n \n <YOUR-DS-PREFIX>_SERVICE_HOST \n Defines the database server’s host name or IP address to be used in the datasource’s connection-url property. \n PORTDB_SERVICE_HOST="dummy" \n \n \n <YOUR-DS-PREFIX>_SERVICE_PORT \n Defines the database server’s port for the datasource. \n PORTDB_SERVICE_PORT="1527" \n \n \n \n \n Note \n For more details on other standard variables check the  EAP\ndocumentation \n \n Here a potential example \n apiVersion: entando.org/v1\nkind: "EntandoApp"\nmetadata:\n  annotations: {}\n  labels: {}\n  name: "quickstart"\nspec:\n  dbms: #tbd\n  replicas: 1\n  standardServerImage: eap\n  ingressPath: /entando-de-app\n  parameters:\n    DATASOURCES: "PORTDB,SERVDB,MYDATASOURCE"\n    MYDATASOURCE_NONXA: "true"\n    MYDATASOURCE_JTA: "false"\n    ...\n Other resources \n \n EAP Official Documentation: Runtime\nArtifacts/Datasources \n \n'},{title:"Tutorial: how to configure custom datasources and connections for Entando Apps on EAP and Wildfly",frontmatter:{},regularPath:"/v6.1/tutorials/customize-the-platform/change-default-datasources-and-connections/tutorials/how-to-configure-custom-datasource.html",relativePath:"v6.1/tutorials/customize-the-platform/change-default-datasources-and-connections/tutorials/how-to-configure-custom-datasource.md",key:"v-be7b3b00",path:"/v6.1/tutorials/customize-the-platform/change-default-datasources-and-connections/tutorials/how-to-configure-custom-datasource.html",headers:[{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Create a Docker project for your own base image to Entando's standard base image(s)",slug:"_1-create-a-docker-project-for-your-own-base-image-to-entando-s-standard-base-image-s"},{level:3,title:"2. Customize the standalone.xml/standalone-openshift.xml file using environment variables.",slug:"_2-customize-the-standalone-xml-standalone-openshift-xml-file-using-environment-variables"},{level:3,title:"3. Build your own Docker base image",slug:"_3-build-your-own-docker-base-image"},{level:3,title:"4. Modify your Entando App project to use the new Docker base image",slug:"_4-modify-your-entando-app-project-to-use-the-new-docker-base-image"},{level:3,title:"5. Build and push your custom Docker image",slug:"_5-build-and-push-your-custom-docker-image"},{level:3,title:"6. Deploy your EntandoApp with the correct environment variables",slug:"_6-deploy-your-entandoapp-with-the-correct-environment-variables"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:' Tutorial: how to configure custom datasources and connections for Entando Apps on EAP and Wildfly \n Purpose \n This tutorial explains how to customize our EAP and Wildfly base Docker images, and then configure the EntandoApp\ncustom resource to use these customizations \n Requirements \n \n \n The Entando Operator is running in the target names \n \n \n Keycloak and the Entando Cluster Infrastructure have been deployed \n \n \n The required external databases and other services are up and running. \n \n \n Your own custom project as described in  the tutorial \n Steps \n 1. Create a Docker project for your own base image to Entando\'s standard base image(s) \n Create a project, ideally in Git repository, and put the following files in the folder \n 1.1. The standalone.xml/standalone-openshift.xml file of choice \n It is essential for your custom Docker image to use a file from one of the official Entando Docker base images. \n If you intend to use provide your own EAP based image, please use this\n standalone-openshift.xml \nfile. \n If you intend to use provide your own Wildfly based image, please use this\n standalone.xml \nfile. \n Please note that if you create your own base image with a different version of EAP or Wildfly, using these files\nmay have unintended consequences. \n 1.2. Any modules that may be required for your datasource or other connection resource \n If the resource you need to connect to requires some custom classes, such as JDBC drivers, please add these as \na module to Wildfly/EAP. As an example, you can look at our\n Derby database module \nthat Entando uses for embedded databases. Please ensure that the path of the folder containing the jar files reflects\nthe fully qualified name of the module in the module.xml file. \n 1.3 Dockerfile \n In your Dockerfile, please be sure to extend the correct base image, and add the correct configuration file to\nthe correct location in the target image. \n For EAP, a most basic Dockerfile would look like this: \n FROM entando/entando-eap71-clustered-base:6.1.2\nCOPY --chown=185:0 ./standalone-openshift.xml /opt/eap/standalone/configuration\n \n For Wildfly, a most basic Dockerfile would look like this: \n FROM entando/entando-eap71-clustered-base:6.1.2\nCOPY --chown=1001:0 ./standalone.xml /wildfly/standalone/configuration\n \n Please take note of the user ownership in these different Dockerfiles. This is quite important as Openshift will\nexpect the user/group ownership to be respected. \n 2. Customize the standalone.xml/standalone-openshift.xml file using environment variables. \n You can now modify your Wildfly/EAP configuration to meet your requirements. Where the configuration could differ\nfrom one environment to a next, we strongly advise using environment variable expressions ( ${env.VAR_NAME} ). The most likely change\nthat would be required in this file is the addition of a datasource. Here is an example of how to add a datasource\nto the datasources subsystem. All the environment variables starting with \'YOURDB\' can be specified from the Docker\ncontainer. \n    ...\n    <subsystem xmlns="urn:jboss:domain:datasources:5.0">\n      <datasources>\n        <datasource jndi-name="${env.YOURDB_JNDI}" enabled="true" use-java-context="true" pool-name="yourDbDataSource" use-ccm="true">\n          <connection-url>${env.YOURDB_URL}</connection-url>\n          <driver>${env.YOURDB_DRIVER}</driver>\n          <security>\n            <user-name>${env.YOURDB_USERNAME}</user-name>\n            <password>${env.YOURDB_PASSWORD}</password>\n          </security>\n        </datasource>\n \n Please take extra care not to remove any lines from these files. This is of particular importance in the case of the\nEAP image as, on startup, scripts in the official EAP look for certain placeholders in this file and populates them\nfrom other environment variables. \n 3. Build your own Docker base image \n You can now build your Docker base image. It is highly recommended that you consider using a dedicated CI/CD build\ntool such as Jenkins X to build the base image and maintain traceability between your source code and the resulting\nDocker image. One possible build command could look like this: \n docker build . -t your-docker-registry.com/your-org/your-base-image:1.0.0 \n 4. Modify your Entando App project to use the new Docker base image \n You can now modify your Entando App project that you have forked as described in the\n relevant tutorial . You would require two changes to the pom.xml file\nof the sample project. \n \n Firstly, you would need to change the variable  server.base.image  to reflect the fully\nqualified URI of your Docker image for EAP and/or Wildfly. For example, if you decided to extend the Wildfly image,\ngo to the Maven profile with the id  wildfly  and change the   server.base.image  to look like this: \n \n <server.base.image>your-docker-registry.com/your-org/your-base-image:1.0.0</server.base.image> \n \n Then you need to change the  <from>  element in the Fabric8 Maven Docker Plugin to reflect this variable.\nNavigate to the first  <image>  element in the pom.xml file. You have found the correct one\nif it contains the following xml: \n \n <from>entando/${server.base.image}:${entando.version}</from> \n Delete the  entando/  prefix and the  :${entando.version}  suffix: \n <from>${server.base.image}</from> \n Please note that, should you still require support for both Wildfly and EAP in your Maven pom, you may need to\nrepeat this exercise for both the  eap  and  wildfly  profiles. \n 5. Build and push your custom Docker image \n Before building your Docker image, it would be a good idea to change the name of the image you want to build. Navigate\nto the previously modified  <image>  element in the Fabric8 Maven Docker Plugin.You can change the  <name>  element\nto reflect your preferred name, e.g. \n <name>your-docker-registry.com/your-org/your-entando-app:1.0.0</name> \n Run: \n mvn clean package -Pwildfly -Pderby \n A new Docker image should now be available named  your-docker-registry.com/your-org/your-entando-app:1.0.0 \n Log into the Docker registry in question and then push the image: \n docker push your-docker-registry.com/your-org/your-entando-app:1.0.0 \n You are now ready to deploy this image. \n 6. Deploy your EntandoApp with the correct environment variables \n The final step is to configure your EntandoApp deployment with the correct environment variables. As is the case with\nall the Entando Custom Resources that result in actual deployments, the property  spec.parameters  will be translated\ninto environment variables on each of the Containers in the Deployment\'s Pod. For an EntandoApp named \'my-app\',\nthe new state of the EntandoApp would could be placed in a file named  my-app.yaml  that would look something like this: \n       kind: "EntandoApp"\n      metadata:\n        name: "my-app"\n      spec:\n        dbms: postgresql\n        replicas: 1\n        customServerImage: your-docker-registry.com/your-org/your-entando-app:1.0.0\n        ingressPath: /your-entando-app\n        parameters:\n          YOURDB_JNDI: java/your-ds\n          YOURDB_URL: jdbc:postgresql://somehost.com:5432/mydb\n          YOURDB_DRIVER: postgresql\n          YOURDB_USERNAME: my_user\n          YOURDB_PASSWORD: mypassword\n      entandoStatus:\n        entandoDeploymentPhase: requested\n\n \n Notice how this Custom Resource specifies a  parameter  for each environment variable that was referenced from the\n standalone.xml  file referenced earlier. \n To apply the changes to your deployment, change the  entandoStatus.entandoDeploymentPhase  property to requested and\napply the file: \n kubectl apply -f my-app.yaml\n \n '},{title:"Tutorial: Connecting to an External Database",frontmatter:{},regularPath:"/v6.1/tutorials/customize-the-platform/connecting-external-db.html",relativePath:"v6.1/tutorials/customize-the-platform/connecting-external-db.md",key:"v-77f92ebc",path:"/v6.1/tutorials/customize-the-platform/connecting-external-db.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:" Tutorial: Connecting to an External Database \n Overview \n This document provides a guide to connecting to an external database. In\nmany (not all) production configurations it is recommended to use a DBMS\noutside of the cluster where your Entando applicaiton is running to\nsimplify maintenance, duplication of resources, and to establish a\nbackup workflow that will scale with your application. \n Prerequisites \n \n \n An environment to install your Entando applicaiton \n \n \n A running PostgreSQL, MySQL, or Oracle environment \n \n \n Administrator access to the database \n \n \n Network access from your Kubernetes cluster to your database \n Tutorial \n \n In the helm quickstart define a db for your deployment that includes\nthe admin credentials for your database \n \n \n db:\n  vendor: postgresql | mysql | oracle\n  host: <yourhost>\n  port: <yourport>\n  adminUser: <youradmin>\n  adminPassword: <youradminpassword>\n  name: <yourdbname>\n \n \n \n Run the helm quickstart or create a deployment for your Entando\nenvironment manually \n \n Note: The quickstart creates a default configuration for the\ndeployment. This isn’t to suggest that it is the only\nconfiguration or that it matches with every use case. It is\nrecommended to think about your desired deployment Architecture\nand to configure for that environment using the CRDs as building\nblocks. This also isn’t to suggest that if it isn’t directly\nsupported by the quickstart template that you can’t change it.\nThe deployment is editable. Treat the helm template as a\nbootstrapping environment and edit your deployments to match\nyour needs and requirements. \n \n \n \n Open the yaml file generated from the deployment and review the\nsettings for the deployment \n \n The Entando Operator will create a secret for the database\nautomatically and use the DB initializers to create the DB for\nthe Entando app and any services that use it \n \n \n \n Deploy your app \n \n \n"},{title:"Manage Entando Databases",frontmatter:{},regularPath:"/v6.1/tutorials/customize-the-platform/databases.html",relativePath:"v6.1/tutorials/customize-the-platform/databases.md",key:"v-61a61646",path:"/v6.1/tutorials/customize-the-platform/databases.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Lightweight, low-config Databases with PostgreSQL and MySQL",slug:"lightweight-low-config-databases-with-postgresql-and-mysql"},{level:2,title:"Existing External Databases",slug:"existing-external-databases"},{level:3,title:"Structure",slug:"structure"},{level:3,title:"How it works",slug:"how-it-works"},{level:3,title:"Keeping track of credentials",slug:"keeping-track-of-credentials"},{level:2,title:"Vendor specific notes",slug:"vendor-specific-notes"},{level:3,title:"Oracle",slug:"oracle"},{level:3,title:"Notes",slug:"notes"},{level:3,title:"MySQL",slug:"mysql"},{level:3,title:"Resulting Connection String",slug:"resulting-connection-string-2"},{level:3,title:"Notes",slug:"notes-2"},{level:3,title:"PostgreSQL",slug:"postgresql"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:' Manage Entando Databases \n Overview \n Entando’s Docker images currently support three different relational\ndatabase management systems: PostgreSQL, MySQL and Oracle. With\nPostgreSQL and MySQL, by default, Entando’s will automatically create a\nKubernetes Deployment hosting the database management systems. However,\nfor Oracle, and also for other scenarios that may require it, Entando\nsupports connectivity to existing external databases. This document\nprovides the user with the necessary information to decide how to manage\nEntando’s databases. \n Lightweight, low-config Databases with PostgreSQL and MySQL \n When deploying Entando Custom Resources that require databases to a new\nNamespace, the default behavior for Entando is to create a Kubernetes\nDeployment. It uses the standard Openshift compliant images: \n \n \n centos/mysql-57-centos7 and \n \n \n centos/postgresql-96-centos7) \n \n \n This is a fairly low-configuration approach, as Entando will create and\ninitialize the databases transparently. Persistent data is stored on any\nPersistent Volume that meets our Persistent Volume Claim requirements.\nWhen an Entando Custom Resource is redeployed, the Persistent Volumes\nremain in tact. Since the subsequent data initialization is idempotent,\nthe supporting Deployments will scale up and behave as expected. \n Generally our services encapsulate the database they use entirely, and\nprovide facilities to import and export the data without needing any\nknowledge of the internal workings of the underlying data store. For\nmost simple Entando Apps the database doesn’t grow too large and is\nfairly easy to manage. This state of affairs allowed us to keep our\ndatabases isolated from each other, thus allowing for isolated\ndeployments without needing complex coordination of database migration\nfor the different deployment pipelines. \n It is worth noting that these database Deployments are not clustered.\nThe customer is therefore strongly advised to provide redundancy and\nclustering in the form of clustered storage. These database deployments\ndo specify a restartPolicy of \'Always\', so in the event of a\nnon-corrupting failure, the database Pod should therefore restart in\nabout 30 seconds. This by no means offers the features of a full\ndatabase cluster, but may suffice for many scenarios. \n However, in more advanced use cases, such as the use of our CMS\nfunctionality, this simplistic approach may not scale. And where there\nis a a centralized database admin team, or where there is a requirement\nto comply to strict organizational governance w.r.t. databases, this\napproach does result in a multitude of databases that may be difficult\nfor the database admin team to manage. \n Existing External Databases \n For this reason, Entando can also be configured to use an existing\ndatabase service provided by the customer. In these scenarios, the\ncustomer is expected to take responbility for the lower level database\noperations such as tablespace creation, permissions and clustering.\nEntando will however still be responsible for creating and populating\nthe tables, indices and foreing keys. Entando will also create all of\nthese in the appropriate table \'container\' for the DBMS in question such\nas a schema (Oracle/PostgreSQL) or a database (MySQL). In order to\nachieve this, Entando installs a dedicated CustomResourceDefinition in\nKubernetes, called an \'EntandoDatabaseService\' \n The idea is for EntandoDatabaseService custom resources to be created in\nthe namespace the EntandoApps and EntandoPlugin that should use them\nwill be created. The EntandoDatabaseService is usually created along\nwith a secret that carries admin credentials to the database in\nquestion. \n Structure \n The EntandoDatabaseService custom resource looks like this: \n  EntandoDatabaseService\nmetadata:\n  name: string, any K8S compliant name\n  namespace: string, the namespace this will be created in\nspec:\n  dbms: string, one of oracle, postgresql or mysql\n  host: string, either an ip address or hostname where the database service is hosted\n  port: integer, the port on which the database service is hosted\n  databaseName: string, the name of the database, only required for PostgreSQL and Oracle\n  secretName: the name of the Secret in the same namespace carrying admin credentials to the database service\n  tablespace: (Oracle only)  the tablespace to use to create the required schemas in\n  jdbcParameters: a map containing name-value pairs for any additional parameters required for the JDBC driver to connect to the database.\n \n The Secret that will provide the admin credentials, identified by the\nabove  secretName  should look like this: \n Secret:\n  name: string, any K8S compliant name\n  namespace: string, the namespace this will be created in\n  stringData:\n    username: string, name of an admin user that can create schemas and other users\n    password: string, password of the above user\n How it works \n In order for the EntandoApp and EntandoPlugin deployer to pick up the\ncorrect database service, the EntandoDatabaseService needs to be created\nBEFORE the EntandoApps and EntandoPlugins are created. There can be\nmultiple EntandoDatabaseServices in the namespace, but they need to\npoint to database services of different vendors, i.e. PostgreSQL, Oracle\nand MySQL. Entando currently cannot enforce any validation but if there\nare two EntandoDatabaseServices that have the same DBMS vendor, it will\nsimply pick the first one and continue. Please ensure that only one\nEntandoDatabaseService exists for each DBMS vendor you need to use. \n Once the appropriate EntandoDatabaseServices have been created, any\nEntandoApp or EntandoPlugin that is created will have to specify the\nappropriate DBMS vendor in their  spec.dbms  property. If the\nEntandoOperator detects an EntandoDatabaseService with a matching DBMS\nvendor, it will continue to create the necessary schemas on the specific\ndatabase. If the EntandoOperator does not detect an\nEntandoDatabaseService with a matching DBMS vendor, it will fall back\nonto its default behaviour which is to create a matching Deployment and\nspin up a database service from the same namespace. If the  spec.dbms \nproperty is not specified on an EntandoApp, the EntandoOperator will\ndefault to PostgreSQL. If the  spec.dbms  property is not specified on\nan EntandoPlugin, the EntandoOperator will assume that the EntandoPlugin\nin question does not require a database and hence bypass any database\nand schema creation. \n When the EntandoOperator processes your Entandoapp or EntandoPlugin with\nan appropriate  spec.dbms  specified, it will create a Schema/User pair\nfor each datasource required. A typical EntandoApp deployment requires 3\ndatasources (portdb,servdb and dedb). Plugins generally only require one\ndatasource (plugindb). \n The database schema and user created will have the same name. The name\nis derived from the name of the EntandoPlugin or EntandoApp by replacing\nall characters that are not ANSI-SQL compliant with an underscore. The\ndatasource name is then suffixed to the schema name. When defining the\nname of your app or plugin, please keep in mind that some DBMS vendors\ndo not support long schema names. Future versions of Entando will allow\nyou to override the schema prefix for an app or plugin, but for now this\nis a limitation one has to keep in mind. \n Keeping track of credentials \n The EntandoOperator generates a Kubernetes Secret for each schema/user\ncombination it creates. The name of this secret is the concatenation of\nthe name of the EntandoApp or EntandoPlugin, the datasource qualifier\nand then the suffix "-secret". For instance, for an EntandoApp called\n"my-app" the "portdb" datasource will have a corresponding Kubernetes\nSecret called "my-app-portdb-secret". The EntandoOperator will never\noverwrite or update an existing database secret. We generate a random\nstring for the password which is generally considered the safest\napproach. If you do however wish to change the password in for the\nresulting user, please remember to update the password on the Kubernetes\nSecret too. Such an operation is however error prone and could result in\nsubsequent deployments failing. \n The EntandoOperator’s schema creation logic is idempotent. If it\ntherefore finds that the generated schema/user combination found in the\nassociated Kuberentes Secret already exists, it won’t do anything.\nHowever, it will attempt to log in, and if it fails to log in, it will\nattempt to create the user. If the user already exists, but with a\ndifferent password than the one in the Kubernetes Secret, all subsequent\ndeployment operations will fail. \n Vendor specific notes \n Oracle \n Example \n   EntandoDatabaseService\n    metadata:\n      name:oracle-service\n    spec:\n      dbms: oracle\n      host: 10.0.0.13\n      port: 1521\n      databaseName: ORCLPDB1.localdomain\n      secretName: oracle-secret\n      tablespace: entando_ts\n      jdbcParameters: {}\n  Secret:\n    metadata:\n      name: oracle-secret\n    stringData:\n      username: admin\n      password: admin123\n Resulting connection string: \n jdbc:oracle:thin:@//10.0.0.13:1521/ORCLPDB1.localdomain \n Notes \n Oracle has some rather complicated rules in building the correct\nconnection string. Please note that for the sake of portability and\nlightweight image we are limited to the thin driver. The  databaseName \ncould also be an Oracle service as opposed to an Oracle  SID . Please\ncoordinate with your Oracle DB Admin to determine exactly what value to\nuse here. We strongly recommend testing your settings with some code or\na tool that constructs JDBC connection. \n When the EntandoOperator prepares the schemas for your EntandoApp or\nEntandoPlugin, it will create a user for every datasource required, and\nas is standard behaviour for Oracle, that user will have its own schema\nwith the same name. Permissions are set up to ensure that one user\ncannot access tables from another user’s schema. Please note that Oracle\nlimits schema names to 30 characters. If you intend to use Oracle,\nplease keep the name of your apps and plugins short enough. The suffixes\nthat we append to the app or plugin name to ensure the resulting schema\nname is unique are usually shorter than 8 characters, so names of about\n20 characters should be safe. \n You can specify which tablespace Entando should use to create the\nschemas in using the  spec.tablespace  property \n ORA-01704: string literal too long \n Entando requires extended datatypes to be activated in Oracle 12c and\nhigher\n( https://oracle-base.com/articles/12c/extended-data-types-12cR1 ) \n MySQL \n Example \n EntandoDatabaseService\n  metadata:\n    name:mysql-service\n  spec:\n    dbms: mysql\n    host: 10.0.0.13\n    port: 3306\n    databaseName:\n    secretName: mysql-secret\n    jdbcParameters:\n       useSSL: "true"\nSecret:\n  metadata:\n    name: mysql-secret\n  stringData:\n    username: admin\n    password: admin123\n Resulting Connection String \n jdbc:mysql://10.0.0.13:3306 \n Notes \n MySQL doesn’t really support schemas, or more accurately, it doesn’t\ndistinguish between schemas and databases. For this reason, no\ndatabaseName is required. The EntandoOperator will therefore create an\nentirely new database for each datasource your EntandoApp or\nEntandoPlugin requires. It will also create a user with the same name as\nthe database with permission set up to ensure one user cannot access the\ndatabase of another user. Please note that MySQL limits database names\nto 63 characters. Keep this in mind when defining the names of your\nEntandoApps and EntandoPlugins \n PostgreSQL \n Example \n   EntandoDatabaseService\n    metadata:\n      name:postgresql-service\n    spec:\n      dbms: postgresql\n      host: 10.0.0.13\n      port: 5432\n      databaseName: my_db\n      secretName: postgresql-secret\n      jdbcParameters: {}\n\n  Secret:\n    metadata:\n      name: postgresql-secret\n    stringData:\n      username: admin\n      password: admin123\n Resulting Connection String \n jdbc:postgresql://10.0.0.13:5432/my_db \n Notes \n PostgreSQL behaves very similar to Oracle when it comes to how it\nassociates a user with its own schema. The current username is used as a\ndefault schema/prefix to resolve tables. As with Oracle, Entando ensures\nthat two users don’t have access to each other’s schemas. \n'},{title:"Tutorial: How to connect Entando 6 to an external Keycloak instance",frontmatter:{},regularPath:"/v6.1/tutorials/customize-the-platform/change-default-datasources-and-connections/tutorials/how-to-connect-to-external-keycloak.html",relativePath:"v6.1/tutorials/customize-the-platform/change-default-datasources-and-connections/tutorials/how-to-connect-to-external-keycloak.md",key:"v-5009a1de",path:"/v6.1/tutorials/customize-the-platform/change-default-datasources-and-connections/tutorials/how-to-connect-to-external-keycloak.html",headers:[{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Get keycloak information",slug:"_1-get-keycloak-information"},{level:3,title:"2. Generate the secret",slug:"_2-generate-the-secret"},{level:3,title:"3. Upload the secret",slug:"_3-upload-the-secret"},{level:3,title:"4. Deploy the Entando6 application",slug:"_4-deploy-the-entando6-application"},{level:2,title:"Conclusion",slug:"conclusion"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:' Tutorial: How to connect Entando 6 to an external Keycloak instance \n Purpose \n This tutorial enables the Entando administrator to leverage an existing\nKeycloak instance. \n Requirements \n \n \n A Keycloak instance \n \n \n A realm named "entando" on that instance \n \n \n An admin user for the "entando" realm \n Steps \n 1. Get keycloak information \n Retrieve the relevant information from the Keycloak instance you want to\nuse. \n Specifically you will need: \n \n \n The username of the Keycloak admin that has admin rights to the\n"entando" realm, e.g entando-keycloak-admin \n \n \n The Keycloak admin password, e.g. password123 \n \n \n The base url for the Keycloak server, including the auth value, e.g.\n https://my-keycloak-instance.com/auth \n 2. Generate the secret \n You now need to generate a secret with name  keycloak-admin-secret \nusing the information retrieved from step 1. The Entando administrator\nwill automatically detect this secret by name, and use it to log onto\nthe provided Keycloak server. \n Here is an example of the secret you will need to construct: \n ---\napiVersion: v1\nstringData:\n    username: <the username of the Keycloak admin user for the "entando" realm>\n    password: <the password of this Keycloak admin user>\n    url: <the base url of the Keycloak service, typically ending with the path /auth>\nkind: Secret\nmetadata\n    name: keycloak-admin-secret\n    namespace: <your-app-namespace>\ntype: Opaque\n \n \n Note \n To encode your values, in bash, you can do\n echo <your-value> | base64 \n 3. Upload the secret \n Next upload the secret to the namespace where you want to deploy your\nEntando 6 instance. \n oc create -f my-secret.yaml -n <my-app-namespace>\n 4. Deploy the Entando6 application \n Now you are ready to deploy your Entando 6 application and the\nadministrator will reuse the  keycloak-admin-secret  secret to populate\nthe environment correctly. \n Conclusion \n You should now have a working Entando 6 instance using an external\nKeycloak server. \n'},{title:"Tutorial: Invoking Entando Core APIs",frontmatter:{},regularPath:"/v6.1/tutorials/customize-the-platform/app-engine/tutorials/invoking-api.html",relativePath:"v6.1/tutorials/customize-the-platform/app-engine/tutorials/invoking-api.md",key:"v-23af9480",path:"/v6.1/tutorials/customize-the-platform/app-engine/tutorials/invoking-api.html",headers:[{level:2,title:"General Overview",slug:"general-overview"},{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Set up a Postman environment",slug:"_1-set-up-a-postman-environment"},{level:3,title:"2. Get an access token",slug:"_2-get-an-access-token"},{level:3,title:"2. Prepare a generic API request",slug:"_2-prepare-a-generic-api-request"},{level:2,title:"QE ready APIs",slug:"qe-ready-apis"},{level:2,title:"Notes on QE requests collections structure",slug:"notes-on-qe-requests-collections-structure"},{level:2,title:"Conclusion",slug:"conclusion"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:' Tutorial: Invoking Entando Core APIs \n General Overview \n Entando supports Swagger and it is accessible, if activated, from its\nweb interface from the base application URL at /api/swagger-ui.html. A\ncomplete list of all available core APIs can be obtained from Swagger. \n Core APIs can be invoked directly from Swagger or from any other\nsuitable tool, i.e., curl or Postman are two common ones. Postman has\nbeen extensively used in API testing and automated API testing because\nof the possibilities it offers and it is the suggested tool. \n All Entando core APIs are accessible from the base URL, for example:\nlocalhost:8080/entando-de-app/api. For example, the Page Controller will\nbe available under /pages from the Base URL (i.e.\nlocalhost:8080/entando-de-app/api/pages), or the Page Model Controller\nwill available under /pageModels (i.e.\nlocalhost:8080/entando-de-app/api/pageModels) and so on. \n Before being able to perform any API request, we will first need to\nobtain an  authorization token , that is achieved with a specific POST\nrequest sent to the oauth/token endpoint, after successful\nauthentication, an access token is returned which grants access to all\nAPI endpoints and actions for which the authenticated user has defined\nprivileges. \n (Refer to User Management Roles for details) \n The best way to proceed in case of extensive testing with APIs with\nPostman, is to set up an environment and define a variable that will\nkeep the access token saved from the POST request to /oauth/token. \n Purpose \n Set up an environment ready to invoke Entando core APIs \n Requirements \n To complete this tutorial you will need: \n \n \n Postman \n \n \n A running Entando 6 instance \n Steps \n 1. Set up a Postman environment \n Create a new Postman environment and define the following variables: \n access_token: (no value)\nrefresh_token: (no value)\nurl: URL of your application (i.e. http://localhost:8080/entando-de-app)\n \n Be careful with the URL variable and make sure you do not have a\ntrailing slash. \n Set Postman to use this environment. \n 2. Get an access token \n Getting an access token is a prerequisite to be able to invoke any API.\nThe following is the required activity. \n \n \n create a Postman collection, name it for example "Access Token" \n \n \n create a new POST request with the following parameters: \n \n \n \n URL field\n{{url}}/api/oauth/token\n \n Note that we are calling the "url" environmental variable for\nconvenience. \n Autorization section\n   Type: Basic Auth\n   Username: (a valid Entando consumer must be defined in Entando) (Refer to appropriate documentation on how to do that) (i.e. appbuilder)\n   Password: (password of the defined consumer) (i.e. appbuilder_secret)\n\nHeaders section\n    Content-Type: application/x-www-form-urlencoded\n\nBody section\nSelect from the radio button the option: x-www-form-urlencoded\n    username: (valid Entando user (i.e. admin))\n    password: (password of the valid user)\n    grant_type: password\n \n The tests section is convenient as we can then set any new API request\nin such a way to make use of that access token. The first line of code\ndefines a variable called "data", which hosts the JSON parsed\nresponseBody from the POST request just sent to /oauth/token; The second\nline sets the environment variable "access_token" to the value returned\nby the POST request. \n Tests section\n    var data = JSON.parse(responseBody);\n    postman.setEnvironmentVariable("access_token", data.access_token);\n \n Launch the POST request to test it, and if successful, you should get a\nresponse like this: \n {\n    "access_token": "b96096493a40b1a7364bd54a6ffb609b",\n    "token_type": "bearer",\n    "refresh_token": "79ff84062b5dc13663961a833b0788f9",\n    "expires_in": 3599\n}\n \n also if you open in edit the Postman environment, you should see that\nthe access_token and the refresh_token variables values have been\nupdated. \n 2. Prepare a generic API request \n Create a new request with the following parameters: \n Authorization section: Inherit auth from parent\n\nHeaders section:\n create the key Authorization with Value: Bearer{{access_token}}\n create the key Content-Type with Value: application/json\n \n Select the appropriate method (GET, DELETE, POST etc.) for your request\nand fill up the URL with appropriate values i.e.\n(localhost:8080/entando-de-app/api/pages) then add to the Body section,\nif needed, the appropriate payload in JSON format, remember to select\nraw and JSON (application/json). \n QE ready APIs \n QE has developed a set of collection requests to automate API testing,\nexamples of that are available on github at\n https://github.com/entando/entando-QE/tree/master/postman_API . \n To use them ,first git clone the project and use the built in Postman\nimporting features. \n Import first the Postman Environment file which can be found under the\nenvironment folder. When imported, from Postman, open in edit that\nenvironment and change the "url" variable to the appropriate value for\nyour specific installation, i.e  http://localhost:8080/entando-de-app/ \nand save it. \n Import from Postman the collections you would like to use and they will\nbecome available in the Postman collections Panel ready to be run. \n Notes on QE requests collections structure \n Each collection is so designed to test a particular use case i.e.\n"Delete an existent page", "Delete a page which has children" etc. \n By design each QE Postman collection is: \n \n \n indipendent (does not require other collections) \n \n \n general (does not make any assumption on the specific Entando\napplication) \n \n \n can be run automatically, with newman, please refer to\n https://github.com/entando/entando-QE  for details \n \n \n Following those requirements, each collection will need to "prepare" the\nenvironment for the actual test. That is achieved by using specific\nrequests, called "helpers", and their only purpose is to create/delete\nall the needed objects. \n Another class of helpers is used to check the persistence of the actions\nperformed by the APIs, i.e. check that after a DELETE, something really\nhas been deleted. \n The request that implements the use case, we can call it main request,\ndoes not contain the word "HELPER" in its name, and it is the only one\ninside a given collection. \n Because collections are designed primarily to run automatically, we have\ndone extensive use of collection variables, so variables like the API\nURL, object names, object codes or payloads are usually defined as a\ncollection variable and can be accessed by all requests inside the\ncollection. \n Conclusion \n This guide let you start invoking Entando 6 APIs \n'},{title:"Backing Up and Restoring an Entando Application",frontmatter:{},regularPath:"/v6.1/tutorials/devops/backing-up-and-restoring-your-environment.html",relativePath:"v6.1/tutorials/devops/backing-up-and-restoring-your-environment.md",key:"v-07300966",path:"/v6.1/tutorials/devops/backing-up-and-restoring-your-environment.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Create a Backup",slug:"create-a-backup"},{level:2,title:"Restore a Backup",slug:"restore-a-backup"}],lastUpdated:"12/15/2021, 2:22:26 PM",lastUpdatedTimestamp:1639596146e3,content:' Backing Up and Restoring an Entando Application \n Prerequisites \n \n \n Java 8 \n \n \n Docker installed locally\n( https://docs.docker.com/docker-for-windows/install/ ) \n \n \n maven \n \n \n Access to a docker repository (docker.io or other) \n \n \n This tutorial will show you how you can use an Entando application that\nyou have built as a launching point for creating new applications. \n Create a Backup \n This step requires using a running Entando environment to take an application backup.\nThe output of this step is a local directory with the files (database and static assets) you can use to restore the application later. \n \n \n Log into  App Builder \n \n \n Go to  Configuration -> Database \n \n \n Click on  Create A Backup  and wait for the process to complete. All of the static assets and database backups are persisted to a PVC in /entando-data on the server pod. \n \n \n Transfer the files from the server-container. The details will vary depending on your kubernetes environment. \n \n \n \n \n \n kubectl \n OpenShift \n \n \n \n \n kubectl cp <pod>:<path> <local-path> \n oc rsync <pod>:<path> <localPath> \n \n \n e.g. kubectl cp quickstart-server-deployment-7b8c699599-f84zq:/entando-data backup \n e.g. oc rsync app-entando-server-deployment-67fd5b9954-s72mb:/entando-data \n \n \n \n \n You should see 3 directories -  databases ,  protected , and  resources .\nThe  protected  directory contains the timestamped backup you triggered from the  App Builder . \n Restore a Backup \n In this lab you’ll take a previously built demo application, install the\nbackup files, build a Docker image from the updated app, and deploy it as a new application. \n \n \n Clone the application at:\n https://github.com/entando/entando-de-app  using \n git clone https://github.com/entando/entando-de-app\n \n \n \n On a command line, cd into the  entando-de-app  you just cloned: \n cd entando-de-app\n \n \n \n Take the backup file and unzip it in a location of your choice. \n \n \n This zip contains all of the assets, content, and metadata\nneeded to launch an Entando application. We are going to package\nthe static assets and database backup into a Docker image. \n \n \n Entando will automatically instantiate and populate the app from\nthe most recent backup \n \n \n \n \n Move the resources and protected folders from your Entando backup into your\n entando-de-app  application under  src/main/webapp  replacing any content that is\nalready there. \n \n \n Build a docker image from the app \n mvn clean package -Pwildfly -Pderby docker:build\n \n \n Note that the "derby" option here is only for the initialization\nphase of the DB when deploying. It isn’t the final database\nchoice \n \n \n \n View the images installed on your local docker instance \n docker images\n \n Look for the following: \n entando/entando-de-app:latest\n \n \n \n Create a repository on your docker account to house your new\napplication \n \n \n Re-tag the image you just built with your repo \n  docker tag entando/entando-de-app:latest <YOUR-USER>/<YOUR-REPO-NAME>:latest\n \n \n \n Push the Image to your Repository \n docker push <YOUR-USER>/<YOUR-REPO-NAME>:latest\n \n \n \n Now we need to generate a new application for deployment to\nKubernetes using the helm chart \n \n \n If you have an output from helm from before you can re-use it\nand just apply the changes to the config map. In this case skip to step 12. \n \n \n Or you can re-run helm and change the output \n \n \n \n \n Re-run the helm command for your environment \n \n \n Open the output yaml file from the helm command in the text editor\nof your choice \n \n For example:  vi training-alpha.yaml \n \n \n \n In that file look for the  ConfigMap \n \n \n The config map defines all of the images that are available as\npart of the deployment. They aren’t all used concurrently. \n \n \n You can also view this config map in  kubernetes/OpenShift \n \n \n \n \n Now you need to update the deployment to use your customized Wildfly\nimage. Find  entando-de-app-wildfly  in the config map \n \n Note that we are changing the de-app but you could create a\ncustom version of any of the included images \n \n \n \n Change the version to match the version you used for your image \n \n \n Change the "organization" to the name of your main image repository\norganization and if you aren’t using docker.io (DockerHub) then\nchange the registry as well. \n \n \n Save the file \n \n \n Follow the deployment steps you went through when you originally\ndeployed your Entando application to your Kubernetes instance \n \n \n Once deployed go to the  App Builder  in your app \n \n \n Click  Go To Homepage  and you should see your restored application. \n \n \n'},{title:"Change Default Datasources and Connections",frontmatter:{},regularPath:"/v6.1/tutorials/customize-the-platform/change-default-datasources-and-connections/",relativePath:"v6.1/tutorials/customize-the-platform/change-default-datasources-and-connections/README.md",key:"v-39cda378",path:"/v6.1/tutorials/customize-the-platform/change-default-datasources-and-connections/",headers:[{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Create a Docker project for your own base image to Entando's standard base image(s)",slug:"_1-create-a-docker-project-for-your-own-base-image-to-entando-s-standard-base-image-s"},{level:3,title:"2. Customize the standalone.xml/standalone-openshift.xml file using environment variables.",slug:"_2-customize-the-standalone-xml-standalone-openshift-xml-file-using-environment-variables"},{level:3,title:"3. Build your own Docker base image",slug:"_3-build-your-own-docker-base-image"},{level:3,title:"4. Modify your Entando App project to use the new Docker base image",slug:"_4-modify-your-entando-app-project-to-use-the-new-docker-base-image"},{level:3,title:"5. Build and push your custom Docker image",slug:"_5-build-and-push-your-custom-docker-image"},{level:3,title:"6. Deploy your EntandoApp with the correct environment variables",slug:"_6-deploy-your-entandoapp-with-the-correct-environment-variables"}],lastUpdated:"6/27/2020, 10:35:02 PM",lastUpdatedTimestamp:1593311702e3,content:' Change Default Datasources and Connections \n Purpose \n This tutorial explains how to customize our EAP and Wildfly base Docker images, and then configure the EntandoApp\ncustom resource to use these customizations \n Requirements \n \n \n The Entando Operator is running in the target names \n \n \n Keycloak and the Entando Cluster Infrastructure have been deployed \n \n \n The required external databases and other services are up and running. \n \n \n Your own custom project as described in  the tutorial \n Steps \n 1. Create a Docker project for your own base image to Entando\'s standard base image(s) \n Create a project, ideally in Git repository, and put the following files in the folder \n 1.1. The standalone.xml/standalone-openshift.xml file of choice \n It is essential for your custom Docker image to use a file from one of the official Entando Docker base images. \n If you intend to use provide your own EAP based image, please use this\n standalone-openshift.xml \nfile. \n If you intend to use provide your own Wildfly based image, please use this\n standalone.xml \nfile. \n Please note that if you create your own base image with a different version of EAP or Wildfly, using these files\nmay have unintended consequences. \n 1.2. Any modules that may be required for your datasource or other connection resource \n If the resource you need to connect to requires some custom classes, such as JDBC drivers, please add these as \na module to Wildfly/EAP. As an example, you can look at our\n Derby database module \nthat Entando uses for embedded databases. Please ensure that the path of the folder containing the jar files reflects\nthe fully qualified name of the module in the module.xml file. \n 1.3 Dockerfile \n In your Dockerfile, please be sure to extend the correct base image, and add the correct configuration file to\nthe correct location in the target image. \n For EAP, a most basic Dockerfile would look like this: \n FROM entando/entando-eap71-clustered-base:6.1.2\nCOPY --chown=185:0 ./standalone-openshift.xml /opt/eap/standalone/configuration\n \n For Wildfly, a most basic Dockerfile would look like this: \n FROM entando/entando-eap71-clustered-base:6.1.2\nCOPY --chown=1001:0 ./standalone.xml /wildfly/standalone/configuration\n \n Please take note of the user ownership in these different Dockerfiles. This is quite important as Openshift will\nexpect the user/group ownership to be respected. \n 2. Customize the standalone.xml/standalone-openshift.xml file using environment variables. \n You can now modify your Wildfly/EAP configuration to meet your requirements. Where the configuration could differ\nfrom one environment to a next, we strongly advise using environment variable expressions ( ${env.VAR_NAME} ). The most likely change\nthat would be required in this file is the addition of a datasource. Here is an example of how to add a datasource\nto the datasources subsystem. All the environment variables starting with \'YOURDB\' can be specified from the Docker\ncontainer. \n    ...\n    <subsystem xmlns="urn:jboss:domain:datasources:5.0">\n      <datasources>\n        <datasource jndi-name="${env.YOURDB_JNDI}" enabled="true" use-java-context="true" pool-name="yourDbDataSource" use-ccm="true">\n          <connection-url>${env.YOURDB_URL}</connection-url>\n          <driver>${env.YOURDB_DRIVER}</driver>\n          <security>\n            <user-name>${env.YOURDB_USERNAME}</user-name>\n            <password>${env.YOURDB_PASSWORD}</password>\n          </security>\n        </datasource>\n \n Please take extra care not to remove any lines from these files. This is of particular importance in the case of the\nEAP image as, on startup, scripts in the official EAP look for certain placeholders in this file and populates them\nfrom other environment variables. \n 3. Build your own Docker base image \n You can now build your Docker base image. It is highly recommended that you consider using a dedicated CI/CD build\ntool such as Jenkins X to build the base image and maintain traceability between your source code and the resulting\nDocker image. One possible build command could look like this: \n docker build . -t your-docker-registry.com/your-org/your-base-image:1.0.0 \n 4. Modify your Entando App project to use the new Docker base image \n You can now modify your Entando App project that you have forked as described in the\n relevant tutorial . You would require two changes to the pom.xml file\nof the sample project. \n \n Firstly, you would need to change the variable  server.base.image  to reflect the fully\nqualified URI of your Docker image for EAP and/or Wildfly. For example, if you decided to extend the Wildfly image,\ngo to the Maven profile with the id  wildfly  and change the   server.base.image  to look like this: \n \n <server.base.image>your-docker-registry.com/your-org/your-base-image:1.0.0</server.base.image> \n \n Then you need to change the  <from>  element in the Fabric8 Maven Docker Plugin to reflect this variable.\nNavigate to the first  <image>  element in the pom.xml file. You have found the correct one\nif it contains the following xml: \n \n <from>entando/${server.base.image}:${entando.version}</from> \n Delete the  entando/  prefix and the  :${entando.version}  suffix: \n <from>${server.base.image}</from> \n Please note that, should you still require support for both Wildfly and EAP in your Maven pom, you may need to\nrepeat this exercise for both the  eap  and  wildfly  profiles. \n 5. Build and push your custom Docker image \n Before building your Docker image, it would be a good idea to change the name of the image you want to build. Navigate\nto the previously modified  <image>  element in the Fabric8 Maven Docker Plugin.You can change the  <name>  element\nto reflect your preferred name, e.g. \n <name>your-docker-registry.com/your-org/your-entando-app:1.0.0</name> \n Run: \n mvn clean package -Pwildfly -Pderby \n A new Docker image should now be available named  your-docker-registry.com/your-org/your-entando-app:1.0.0 \n Log into the Docker registry in question and then push the image: \n docker push your-docker-registry.com/your-org/your-entando-app:1.0.0 \n You are now ready to deploy this image. \n 6. Deploy your EntandoApp with the correct environment variables \n The final step is to configure your EntandoApp deployment with the correct environment variables. As is the case with\nall the Entando Custom Resources that result in actual deployments, the property  spec.parameters  will be translated\ninto environment variables on each of the Containers in the Deployment\'s Pod. For an EntandoApp named \'my-app\',\nthe new state of the EntandoApp would could be placed in a file named  my-app.yaml  that would look something like this: \n       kind: "EntandoApp"\n      metadata:\n        name: "my-app"\n      spec:\n        dbms: postgresql\n        replicas: 1\n        customServerImage: your-docker-registry.com/your-org/your-entando-app:1.0.0\n        ingressPath: /your-entando-app\n        parameters:\n          YOURDB_JNDI: java/your-ds\n          YOURDB_URL: jdbc:postgresql://somehost.com:5432/mydb\n          YOURDB_DRIVER: postgresql\n          YOURDB_USERNAME: my_user\n          YOURDB_PASSWORD: mypassword\n      entandoStatus:\n        entandoDeploymentPhase: requested\n\n \n Notice how this Custom Resource specifies a  parameter  for each environment variable that was referenced from the\n standalone.xml  file referenced earlier. \n To apply the changes to your deployment, change the  entandoStatus.entandoDeploymentPhase  property to requested and\napply the file: \n kubectl apply -f my-app.yaml\n \n '},{title:"Building a Docker Image for the Entando Core",frontmatter:{},regularPath:"/v6.1/tutorials/devops/build-core-image.html",relativePath:"v6.1/tutorials/devops/build-core-image.md",key:"v-beeab77c",path:"/v6.1/tutorials/devops/build-core-image.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Introduction",slug:"introduction"},{level:2,title:"Setup",slug:"setup"}],lastUpdated:"12/15/2021, 2:22:26 PM",lastUpdatedTimestamp:1639596146e3,content:" Building a Docker Image for the Entando Core \n Prerequisites \n \n \n Java 8 \n \n \n Docker installed locally\n( https://docs.docker.com/docker-for-windows/install/ ) \n \n \n maven \n \n \n Access to a docker repository (docker.io or other) \n Introduction \n This tutorial will take you through the basic steps to create a docker\nimage from an Entando core application. A more detailed guide with\nadditional commands and configuration can be found here: \n https://github.com/entando/entando-de-app \n Setup \n \n \n Clone the application at:\n https://github.com/entando/entando-de-app  using \n git clone https://github.com/entando/entando-de-app\n \n \n \n On a command line, cd into the entando-de-app you just cloned: \n cd entando-de-app\n \n \n \n Build a docker image from the core app \n mvn clean package -Pwildfly -Pderby docker:build\n \n \n \n View the images installed on your local docker instance \n docker images\n \n Look for \n entando/entando-de-app:latest\n \n \n \n Create a repository on your docker repository to house your new\napplication \n \n \n Re-tag the image you just built with your repo \n  docker tag entando/entando-de-app:latest <YOUR-USER>/<YOUR-REPO-NAME>:latest\n \n \n \n Push the Image to your Repository \n docker push <YOUR-USER>/<YOUR-REPO-NAME>:latest\n \n \n \n"},{title:"Tutorial: Invoking Entando Core APIs",frontmatter:{},regularPath:"/v6.1/tutorials/customize-the-platform/invoking-api.html",relativePath:"v6.1/tutorials/customize-the-platform/invoking-api.md",key:"v-63176564",path:"/v6.1/tutorials/customize-the-platform/invoking-api.html",headers:[{level:2,title:"General Overview",slug:"general-overview"},{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Set up a Postman environment",slug:"_1-set-up-a-postman-environment"},{level:3,title:"2. Get an access token",slug:"_2-get-an-access-token"},{level:3,title:"2. Prepare a generic API request",slug:"_2-prepare-a-generic-api-request"},{level:2,title:"QE ready APIs",slug:"qe-ready-apis"},{level:2,title:"Notes on QE requests collections structure",slug:"notes-on-qe-requests-collections-structure"},{level:2,title:"Conclusion",slug:"conclusion"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:' Tutorial: Invoking Entando Core APIs \n General Overview \n Entando supports Swagger and it is accessible, if activated, from its\nweb interface from the base application URL at /api/swagger-ui.html. A\ncomplete list of all available core APIs can be obtained from Swagger. \n Core APIs can be invoked directly from Swagger or from any other\nsuitable tool, i.e., curl or Postman are two common ones. Postman has\nbeen extensively used in API testing and automated API testing because\nof the possibilities it offers and it is the suggested tool. \n All Entando core APIs are accessible from the base URL, for example:\nlocalhost:8080/entando-de-app/api. For example, the Page Controller will\nbe available under /pages from the Base URL (i.e.\nlocalhost:8080/entando-de-app/api/pages), or the Page Model Controller\nwill available under /pageModels (i.e.\nlocalhost:8080/entando-de-app/api/pageModels) and so on. \n Before being able to perform any API request, we will first need to\nobtain an  authorization token , that is achieved with a specific POST\nrequest sent to the oauth/token endpoint, after successful\nauthentication, an access token is returned which grants access to all\nAPI endpoints and actions for which the authenticated user has defined\nprivileges. \n (Refer to User Management Roles for details) \n The best way to proceed in case of extensive testing with APIs with\nPostman, is to set up an environment and define a variable that will\nkeep the access token saved from the POST request to /oauth/token. \n Purpose \n Set up an environment ready to invoke Entando core APIs \n Requirements \n To complete this tutorial you will need: \n \n \n Postman \n \n \n A running Entando 6 instance \n Steps \n 1. Set up a Postman environment \n Create a new Postman environment and define the following variables: \n access_token: (no value)\nrefresh_token: (no value)\nurl: URL of your application (i.e. http://localhost:8080/entando-de-app)\n \n Be careful with the URL variable and make sure you do not have a\ntrailing slash. \n Set Postman to use this environment. \n 2. Get an access token \n Getting an access token is a prerequisite to be able to invoke any API.\nThe following is the required activity. \n \n \n create a Postman collection, name it for example "Access Token" \n \n \n create a new POST request with the following parameters: \n \n \n \n URL field\n{{url}}/api/oauth/token\n \n Note that we are calling the "url" environmental variable for\nconvenience. \n Autorization section\n   Type: Basic Auth\n   Username: (a valid Entando consumer must be defined in Entando) (Refer to appropriate documentation on how to do that) (i.e. appbuilder)\n   Password: (password of the defined consumer) (i.e. appbuilder_secret)\n\nHeaders section\n    Content-Type: application/x-www-form-urlencoded\n\nBody section\nSelect from the radio button the option: x-www-form-urlencoded\n    username: (valid Entando user (i.e. admin))\n    password: (password of the valid user)\n    grant_type: password\n \n The tests section is convenient as we can then set any new API request\nin such a way to make use of that access token. The first line of code\ndefines a variable called "data", which hosts the JSON parsed\nresponseBody from the POST request just sent to /oauth/token; The second\nline sets the environment variable "access_token" to the value returned\nby the POST request. \n Tests section\n    var data = JSON.parse(responseBody);\n    postman.setEnvironmentVariable("access_token", data.access_token);\n \n Launch the POST request to test it, and if successful, you should get a\nresponse like this: \n {\n    "access_token": "b96096493a40b1a7364bd54a6ffb609b",\n    "token_type": "bearer",\n    "refresh_token": "79ff84062b5dc13663961a833b0788f9",\n    "expires_in": 3599\n}\n \n also if you open in edit the Postman environment, you should see that\nthe access_token and the refresh_token variables values have been\nupdated. \n 2. Prepare a generic API request \n Create a new request with the following parameters: \n Authorization section: Inherit auth from parent\n\nHeaders section:\n create the key Authorization with Value: Bearer{{access_token}}\n create the key Content-Type with Value: application/json\n \n Select the appropriate method (GET, DELETE, POST etc.) for your request\nand fill up the URL with appropriate values i.e.\n(localhost:8080/entando-de-app/api/pages) then add to the Body section,\nif needed, the appropriate payload in JSON format, remember to select\nraw and JSON (application/json). \n QE ready APIs \n QE has developed a set of collection requests to automate API testing,\nexamples of that are available on github at\n https://github.com/entando/entando-QE/tree/master/postman_API . \n To use them ,first git clone the project and use the built in Postman\nimporting features. \n Import first the Postman Environment file which can be found under the\nenvironment folder. When imported, from Postman, open in edit that\nenvironment and change the "url" variable to the appropriate value for\nyour specific installation, i.e  http://localhost:8080/entando-de-app/ \nand save it. \n Import from Postman the collections you would like to use and they will\nbecome available in the Postman collections Panel ready to be run. \n Notes on QE requests collections structure \n Each collection is so designed to test a particular use case i.e.\n"Delete an existent page", "Delete a page which has children" etc. \n By design each QE Postman collection is: \n \n \n indipendent (does not require other collections) \n \n \n general (does not make any assumption on the specific Entando\napplication) \n \n \n can be run automatically, with newman, please refer to\n https://github.com/entando/entando-QE  for details \n \n \n Following those requirements, each collection will need to "prepare" the\nenvironment for the actual test. That is achieved by using specific\nrequests, called "helpers", and their only purpose is to create/delete\nall the needed objects. \n Another class of helpers is used to check the persistence of the actions\nperformed by the APIs, i.e. check that after a DELETE, something really\nhas been deleted. \n The request that implements the use case, we can call it main request,\ndoes not contain the word "HELPER" in its name, and it is the only one\ninside a given collection. \n Because collections are designed primarily to run automatically, we have\ndone extensive use of collection variables, so variables like the API\nURL, object names, object codes or payloads are usually defined as a\ncollection variable and can be accessed by all requests inside the\ncollection. \n Conclusion \n This guide let you start invoking Entando 6 APIs \n'},{title:"Tutorial: Extending the App Builder",frontmatter:{},regularPath:"/v6.1/tutorials/customize-the-platform/extend-app-builder.html",relativePath:"v6.1/tutorials/customize-the-platform/extend-app-builder.md",key:"v-069d34da",path:"/v6.1/tutorials/customize-the-platform/extend-app-builder.html",headers:[{level:2,title:"Creating a Basic Application",slug:"creating-a-basic-application"},{level:2,title:"Understanding the Stand Alone Environment",slug:"understanding-the-stand-alone-environment"},{level:2,title:"Customizing the Menu",slug:"customizing-the-menu"},{level:2,title:"Customizing the menu labels",slug:"customizing-the-menu-labels"},{level:2,title:"Customizing the Routes",slug:"customizing-the-routes"},{level:2,title:"state",slug:"state"},{level:2,title:"Customizing the Reducers",slug:"customizing-the-reducers"},{level:2,title:"userList",slug:"userlist"},{level:3,title:"connecting to the store",slug:"connecting-to-the-store"},{level:2,title:"Page Models",slug:"page-models"},{level:3,title:"Connecting to the Store",slug:"connecting-to-the-store-2"},{level:2,title:"Adding the API Calls",slug:"adding-the-api-calls"},{level:2,title:"Creating the Thunk",slug:"creating-the-thunk"},{level:2,title:"changing the mapDispatchToProps in the containers",slug:"changing-the-mapdispatchtoprops-in-the-containers"},{level:2,title:"Updating the List components",slug:"updating-the-list-components"},{level:2,title:"clear the default value of the reducer",slug:"clear-the-default-value-of-the-reducer"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:" Tutorial: Extending the App Builder \n Apps for the Entando App Builder are developed as standalone\napplications which can be run using  npm start  in standalone mode. \n Each application should be deployed in npm using the  @entando \nnamespace and will export into their dist folder several items used by\nthe App Builder when integrating it into the full application. \n Creating a Basic Application \n To create a basic application, use the  entando\nfpg  running the\n npx @entando/fpg ab-app <appName>  command. \n the  appName  should only contain alphanumeric characters and\nunderscores, and should begin with a letter. \n This will create inside the working directory, a boilerplate app-builder\napp in a directory named  <appName>  argument. \n i.e. \n using the command  npm @entando/fpg ab-app testing  inside your home\ndirectory, a directory named  testing  will be created containing the\napp. \n All dependencies will already be installed allowing you to  cd  inside\nthe project directory and run  npm start  to start the app running. \n Understanding the Stand Alone Environment \n Each app for the App Builder, can run in both a stand alone mode and an\nintegrated mode. Using  npm start  will use standalone mode. \n In this environment you’ll be looking at the user interface of the app\ninside a default page. This page, which includes a default menu, will\nnot be exported and therefore can be customized. \n To better understand which elements and components are being exported to\nApp Builder, it is best to understand the anatomy of the app. \n Exports \n Each app will have a  babel.js  export file similar to: \n      import  menu  from   'ui/common/LinkMenu' ; \n     import   {  cms  as  state  }   from   'state/rootReducer' ; \n     import   {  routes ,  routesDir  }   from   'ui/App' ; \n     import  en  from   'locales/en' ; \n     import  it  from   'locales/it' ; \n\n     const  testing  =   { \n       id :   'testing' , \n      menu , \n      state , \n      routes , \n      routesDir , \n       locales :   { \n        en , \n        it , \n       } , \n     } ; \n\n     export   default  testing ; \n id: is the app id. \n This parameter is used by App Builder to differentiate all integrated\napps. \n menu: is a React component containing all the menu elements. \n These elements are used inside the standalone environment and inside the\nintegrated environment as a second level menu. The boilerplate app\ncontains a basic menu. \n      import  React  from   'react' ; \n     import   {  LinkMenuItem  }   from   '@entando/menu' ; \n     import   {  FormattedMessage  }   from   'react-intl' ; \n\n     const   LinkMenu   =   ( )   =>   ( \n       < > \n         < LinkMenuItem\n          id = \"menu-SECTION_ID\" \n          label = { < FormattedMessage id = \"testing.menu.SECTION_NAME\"  defaultMessage = \"SECTION_NAME\"   / > } \n          to = '/use/const/here/imported/from/routes' \n         / > \n       < / > \n     ) ; \n\n     export   default  LinkMenu ; \n Customizing the Menu \n For this exercise, we will create two links inside the menu. The first\nwill link to a page listing all the users inside the entando instance.\nThe second will list all the existing page models inside the Entando\ninstance. \n For this example we’re using existing APIs from the Entando core just\nfor simplicity, you can instead call any API or data source. \n In your app project, open  src/ui/common/LinkMenu.js  and update the\nconst to the code below. \n      const   LinkMenu   =   ( )   =>   ( \n       < > \n         < LinkMenuItem\n          id = \"menu-userList\" \n          label = { < FormattedMessage id = \"testing.menu.userList\"  defaultMessage = \"User List\"   / > } \n          to = '/use/const/here/imported/from/routes' \n         / > \n         < LinkMenuItem\n          id = \"menu-pageModelList\" \n          label = { < FormattedMessage id = \"testing.menu.pageModelList\"  defaultMessage = \"Page Model List\"   / > } \n          to = '/use/const/here/imported/from/routes' \n         / > \n       < / > \n     ) ; \n \n it is important that both the  <LinkMenuItem>  id property and the\n`<FormattedMessage>`properties inside label have the correct values\nassigned, i.e.: \n the LinkMenuItem id will be  menu-userList  while the FormattedMessage\nid will be  testing.menu.userList  and the defaultMessage will be\n User List . \n locales \n The locales files are objects that contain all of the i18n locales of\nthe app. \n By default the boilerplate contains both the english and italian i18n\nfiles. \n In your app project in  src/locales/en.js  and  src/locales/it.js  you\ncan see your labels. \n      export   default   { \n       locale :   'en' , \n       messages :   { \n         'testing.title' :   '' , \n         'testing.label.errors' :   '' , \n         'testing.label.cancel' :   '' , \n         'testing.chooseAnOption' :   '' , \n         'testing.tip' :   '' , \n         'testing.new' :   '' , \n         'testing.save' :   '' , \n         'testing.saveAndApprove' :   '' , \n         'testing.unpublish' :   '' , \n         'testing.setContentAs' :   '' , \n         'testing.cancel' :   '' , \n         'testing.saveAndContinue' :   '' , \n         'testing.stickySave.status' :   '' , \n         'testing.stickySave.lastAutoSave' :   '' , \n       } , \n     } ; \n \n While running in standalone mode the boilerplate does not offer a way\nfor the user pick a locale, but both will be loaded inside app-builder\nand will be consumed as intended by it, using the correct one based on\nthe user-picked language. \n It is of course possible to change the standalone app to give the user\nthe option to choose the locale in here as well, but this is not\nsomething will be covering in this tutorial. \n Customizing the menu labels \n To customize the existing menu labels, we’ll add the new label ids\ninside both the english and Italian locale files: \n \n Note \n If you named your app something besides  testing  you’ll need to fix\nthese tags to match the name of your app. \n \n      ... \n     messages :   { \n         ... \n         'testing.menu.userList' :   'List of Users' , \n         'testing.menu.pageModelList' :   'Page Models' , \n         ... \n     } , \n     ... \n \n The key in the messages object matches the id of the\n`<FormattedMessage>`component we placed inside the menu, while its\nvalue is the actual string that will be displayed depending on the\ncurrently active language. \n Routes and RoutesDir \n Both of these elements are imported from  src/ui/App.js . The first one\nis a collection of actual  <Route>  components, and the second one is an\nobject containing each route data, i.e.: \n      export   const  routesDir  =   [ \n       { \n         path :   ROUTE_TESTING , \n         component :   < > app component < / > , \n       } , \n     ] ; \n \n The constant  ROUTE_TESTING  is imported from  src/app-init/routes.js \n Customizing the Routes \n Next we will create the two routes for the two links we have created by\ncreating first the two constants needed. \n In your IDE open  src/app-init/routes.js \n      export   const   ROUTE_TESTING   =   '/testing' ; \n     export   const   ROUTE_USER_LIST   =   '/testing/user-list' ; \n     export   const   ROUTE_PAGE_MODELS   =   '/testing/page-models' ; \n \n \n Note \n Change the value of  testing  to what you selected for the name of\nyour App extension. \n \n The value of each constant will be the path of the route. It is\nimportant that each route is a subroute of the id of the app itself,\notherwise this may cause name collision when running inside the\nintegrated environment of app-builder. \n Both routes are next imported inside  App.js : \n Update the imports with your new ROUTE tags. \n      import   { \n       ROUTE_TESTING , \n       ROUTE_USER_LIST , \n       ROUTE_PAGE_MODELS , \n     }   from   'app-init/routes' ; \n \n and then add to the  routesDir  constant: \n      export   const  routesDir  =   [ \n       { \n         path :   ROUTE_TESTING , \n         component :   < > app component < / > , \n       } , \n       { \n         path :   ROUTE_USER_LIST , \n         render :   ( )   =>   < > user list < / > , \n       } , \n       { \n         path :   ROUTE_PAGE_MODELS , \n         render :   ( )   =>   < > page models < / > , \n       } , \n     ] ; \n \n Next, import the routes constants inside  LinkMenu.js  and change\naccordingly the  to  property of the  <LinkMenuItem>  component: \n      ... \n     import   { \n       ROUTE_USER_LIST , \n       ROUTE_PAGE_MODELS , \n     }   from   'app-init/routes' ; \n\n     const   LinkMenu   =   ( )   =>   ( \n       < > \n         < LinkMenuItem\n          id = \"menu-userList\" \n          label = { < FormattedMessage id = \"tatata.menu.userList\"  defaultMessage = \"User List\"   / > } \n          to = { ROUTE_USER_LIST } \n         / > \n         < LinkMenuItem\n          id = \"menu-pageModelList\" \n          label = { < FormattedMessage id = \"tatata.menu.pageModelList\"  defaultMessage = \"Page Model List\"   / > } \n          to = { ROUTE_PAGE_MODELS } \n         / > \n       < / > \n     ) ; \n     ... \n \n Next clicks on the links in the menu will change the routes and display\nthe content defined in the  App.js  file. \n state \n The state in src/babel.js is the combined reducer of the app, the\nrootReducer.js contains the combined reducer of the app and exports it,\nbut also contains the entire reducer of the app when running in\nstandalone mode. \n      export   const  testing  =   combineReducers ( { \n       // implement here your app specific reducers \n     } ) ; \n\n     export   default   combineReducers ( { \n       apps :   combineReducers ( {  testing  } ) , \n      api , \n      currentUser , \n      form , \n      loading , \n      locale , \n      messages , \n      modal , \n      pagination , \n     } ) ; \n \n The app specific reducers are stored inside the  apps  object, this is\ndone to avoid possible name collisions with any reducer stored inside\napp-builder when running the app in integrated mode. \n Customizing the Reducers \n Next we will be creating the two reducers for the user list and page\nmodels. They will be created inside two new directories\n src/state/apps/testing/userList/  and\n src/state/apps/testing/pageModels . The  types.js  files will contain\nthe two action types that we’ll need. \n userList/types.js \n // eslint-disable-next-line import/prefer-default-export\nexport const ADD_USERS = 'apps/testing/add-users';\n \n pageModels/types.js \n // eslint-disable-next-line import/prefer-default-export\nexport const ADD_PAGE_MODELS = 'apps/testing/page-models/add-page-models';\n \n The value of both constants contain the whole namespace\n apps/testing/REDUCER  this is done to avoid any possible name collision\nwhen running the app in integrated mode. \n Next create both actions files: \n userList/actions.js \n      import   { \n       ADD_USERS , \n     }   from   'state/apps/testing/userList/types' ; \n\n     // eslint-disable-next-line import/prefer-default-export \n     export   const   addUsers   =   users   =>   ( { \n       type :   ADD_USERS , \n       payload :  users , \n     } ) ; \n \n pageModels/actions.js \n      import   { \n       ADD_PAGE_MODELS , \n     }   from   'state/apps/testing/pageModels/types' ; \n\n     // eslint-disable-next-line import/prefer-default-export \n     export   const   addPageModels   =   pageModels   =>   ( { \n       type :   ADD_PAGE_MODELS , \n       payload :  pageModels , \n     } ) ; \n \n then the selectors: \n userList/selectors.js \n      import   {  createSelector  }   from   'reselect' ; \n\n     export   const   getUserList   =   state   =>  state . apps . testing . userList ; \n     export   const  getList  =   createSelector ( getUserList ,   userList   =>  userList . list ) ; \n \n pageModels/selectors.js \n      import   {  createSelector  }   from   'reselect' ; \n\n     export   const   getPageModels   =   state   =>  state . apps . testing . pageModels ; \n     export   const  getList  =   createSelector ( getPageModels ,   pageModels   =>  pageModels . list ) ; \n \n And finally the reducers. The default state is going to contain some\nsample data for us to display. \n userList/reducer.js \n      import   {   ADD_USERS   }   from   'state/apps/testing/userList/types' ; \n\n     const  defaultState  =   { \n       list :   [ \n         { \n           username :   'admin' , \n           registration :   '2018-01-08 00:00:00' , \n           lastLogin :   '2018-01-08 00:00:00' , \n           lastPasswordChange :   '2018-01-08 00:00:00' , \n           status :   'active' , \n           passwordChangeRequired :   true , \n           profileAttributes :   { \n             fullName :   'admin' , \n             email :   'admin@entando.com' , \n           } , \n         } , \n         { \n           username :   'user1' , \n           registration :   '2018-01-08 00:00:00' , \n           lastLogin :   '2018-01-08 00:00:00' , \n           lastPasswordChange :   '2018-01-08 00:00:00' , \n           status :   'disabled' , \n           passwordChangeRequired :   true , \n           profileAttributes :   { \n             fullName :   'User Name' , \n             email :   'user1@entando.com' , \n           } , \n         } , \n       ] , \n     } ; \n\n     const   reducer   =   ( state  =  defaultState ,  action  =   { } )   =>   { \n       switch   ( action . type )   { \n         case   ADD_USERS :   { \n           return   {   ... state ,   list :  action . payload  } ; \n         } \n\n         default :   return  state ; \n       } \n     } ; \n\n     export   default  reducer ; \n \n pageModels/reducer.js \n      import   {   ADD_PAGE_MODELS   }   from   'state/apps/testing/pageModels/types' ; \n\n     const  defaultState  =   { \n       list :   [ \n         { \n           code :   'home' , \n           descr :   'Home Page' , \n           configuration :   { \n             frames :   [ \n               { \n                 pos :   0 , \n                 descr :   'Navbar' , \n                 sketch :   { \n                   x1 :   0 , \n                   y1 :   0 , \n                   x2 :   2 , \n                   y2 :   0 , \n                 } , \n               } , \n               { \n                 pos :   1 , \n                 descr :   'Navbar 2' , \n                 sketch :   { \n                   x1 :   3 , \n                   y1 :   0 , \n                   x2 :   5 , \n                   y2 :   0 , \n                 } , \n               } , \n             ] , \n           } , \n           template :   '<html></html>' , \n         } , \n         { \n           code :   'service' , \n           descr :   'Service Page' , \n           configuration :   { \n             frames :   [ \n               { \n                 pos :   0 , \n                 descr :   'Navbar' , \n                 sketch :   { \n                   x1 :   0 , \n                   y1 :   0 , \n                   x2 :   2 , \n                   y2 :   0 , \n                 } , \n               } , \n               { \n                 pos :   1 , \n                 descr :   'Navbar 2' , \n                 sketch :   { \n                   x1 :   3 , \n                   y1 :   0 , \n                   x2 :   5 , \n                   y2 :   0 , \n                 } , \n               } , \n             ] , \n           } , \n           template :   '<html></html>' , \n         } , \n       ] , \n     } ; \n\n     const   reducer   =   ( state  =  defaultState ,  action  =   { } )   =>   { \n       switch   ( action . type )   { \n         case   ADD_PAGE_MODELS :   { \n           return   {   ... state ,   list :  action . payload  } ; \n         } \n\n         default :   return  state ; \n       } \n     } ; \n\n     export   default  reducer ; \n \n Last, we can add the two reducers just created to the\n src/state/rootReducer.js \n      ... \n     import  userList  from   'state/apps/testing/userList/reducer' ; \n     import  pageModels  from   'state/apps/testing/pageModels/reducer' ; \n\n     export   const  testing  =   combineReducers ( { \n      pageModels , \n      userList , \n     } ) ; \n     ... \n \n we will now be able to see with the  reduxDevTools  in our browser. To\nview this state in your reduxDevTools go to: \n State -→ apps -→ testing -→ pageModels  and\n State -→ apps -→ testing -→ userList \n Creating the UI Components \n At this point, both routes created should be rendering a simple string.\nWe will next create the actual component that will be rendered inside\nthe page. \n userList \n Inside  src/ui/userList/  create the  List  component. Create the\n userList  directory and  List.js  file in that directory. \n      import  React  from   'react' ; \n\n     import   { \n      Grid , \n      TablePfProvider , \n     }   from   'patternfly-react' ; \n\n     const   List   =   ( )   =>   { \n       const  data  =   [ \n         { \n           username :   'admin' , \n           registration :   '2018-01-08 00:00:00' , \n         } , \n         { \n           username :   'user1' , \n           registration :   '2018-01-08 00:00:00' , \n         } , \n       ] ; \n\n       const  tr  =  data . map ( row   =>   ( \n         < tr > \n           < td > { row . username } < / td > \n           < td > { row . registration } < / td > \n         < / tr > \n       ) ) ; \n\n       return   ( \n         < Grid fluid > \n           < TablePfProvider\n            striped\n            bordered\n            hover\n           > \n             < thead > \n               < tr > \n                 < td > username < / td > \n                 < td > registration < / td > \n               < / tr > \n             < / thead > \n             < tbody > \n               { tr } \n             < / tbody > \n           < / TablePfProvider > \n         < / Grid > \n       ) ; \n     } ; \n\n     export   default  List ; \n \n Next, change the route inside  src/ui/App.js . Add the import below and\nupdate the component to reference the List component created in the\nprior step. \n      ... \n     import  List  from   'ui/userList/List' ; \n     ... \n       { \n         path :   ROUTE_USER_LIST , \n         component :  List , \n       } , \n     ... \n \n The table will now display correctly when clicking on the menu item. \n connecting to the store \n Next let’s connect the component to the store to get the data from the\nreducer. \n The first step is creating the  ListContainer.js  next to the  List \ncomponent file. \n      import   {  connect  }   from   'react-redux' ; \n     import   {  getList  }   from   'state/apps/testing/userList/selectors' ; \n\n     import  List  from   'ui/userList/List' ; \n\n     export   const   mapStateToProps   =   state   =>   ( { \n       data :   getList ( state ) , \n     } ) ; \n\n     export   default   connect ( \n      mapStateToProps , \n       null , \n     ) ( List ) ; \n \n And then update the List component to receive the property. The List\nfile should now look like this: \n      import  React  from   'react' ; \n     import  PropTypes  from   'prop-types' ; \n\n     import   { \n      Grid , \n      TablePfProvider , \n     }   from   'patternfly-react' ; \n\n     const   List   =   ( {  data  } )   =>   { \n       const  tr  =  data . map ( row   =>   ( \n         < tr > \n           < td > { row . username } < / td > \n           < td > { row . registration } < / td > \n         < / tr > \n       ) ) ; \n\n       return   ( \n         < Grid fluid > \n           < TablePfProvider\n            striped\n            bordered\n            hover\n           > \n             < thead > \n             < tr > \n               < td > username < / td > \n               < td > registration < / td > \n             < / tr > \n             < / thead > \n             < tbody > \n             { tr } \n             < / tbody > \n           < / TablePfProvider > \n         < / Grid > \n       ) ; \n     } ; \n\n     export   default  List ; \n \n Make sure that you remove the predefined  data  const since the data\nwill now be coming from the reducer, on top of defining PropTypes rules\nfor validating and giving a default for the injected property  data . \n Once complete, update the component used in the route inside  App.js .\nUpdate the import to the container and update the component in\n ROUTE_USER_LIST  to the new ListContainer. \n      ... \n     import  ListContainer  from   'ui/userList/ListContainer' ; \n     ... \n       { \n         path :   ROUTE_USER_LIST , \n         component :  ListContainer , \n       } , \n     ... \n \n Go back to your app. We will now see the data inside the table\nreflecting the content of the storage. \n Page Models \n inside  src/ui/pageModels/  we are going to create the  List  component \n      import  React  from   'react' ; \n     import  PropTypes  from   'prop-types' ; \n\n     import   { \n      Grid , \n      TablePfProvider , \n     }   from   'patternfly-react' ; \n\n     const   List   =   ( {  data  } )   =>   { \n       const  tr  =  data . map ( row   =>   ( \n         < tr > \n           < td > { row . username } < / td > \n           < td > { row . registration } < / td > \n         < / tr > \n       ) ) ; \n\n       return   ( \n         < Grid fluid > \n           < TablePfProvider\n            striped\n            bordered\n            hover\n           > \n             < thead > \n             < tr > \n               < td > username < / td > \n               < td > registration < / td > \n             < / tr > \n             < / thead > \n             < tbody > \n             { tr } \n             < / tbody > \n           < / TablePfProvider > \n         < / Grid > \n       ) ; \n     } ; \n\n    List . propTypes  =   { \n       data :  PropTypes . arrayOf ( PropTypes . shape ( { } ) ) , \n     } ; \n\n    List . defaultProps  =   { \n       data :   [ ] , \n     } ; \n\n     export   default  List ; \n \n Next change the route inside  src/ui/App.js \n      ... \n     import  ListPageModels  from   'ui/pageModels/List' ; \n     ... \n       { \n         path :   ROUTE_PAGE_MODELS , \n         component :  ListPageModels , \n       } , \n     ... \n \n The table will now be displayed correctly when clicking on the menu\nitem. \n Connecting to the Store \n Next, connect the component to the store to get the data from the\nreducer. \n The very first thing we’ll do is create the  ListContainer.js  next to\nthe  List  component file. \n      import   {  connect  }   from   'react-redux' ; \n     import   {  getList  }   from   'state/apps/testing/pageModels/selectors' ; \n\n     import  List  from   'ui/pageModels/List' ; \n\n     export   const   mapStateToProps   =   state   =>   ( { \n       data :   getList ( state ) , \n     } ) ; \n\n     export   default   connect ( \n      mapStateToProps , \n       null , \n     ) ( List ) ; \n \n And then update the List component to receive the property. The whole\nList component will have this content: \n      import  React  from   'react' ; \n     import  PropTypes  from   'prop-types' ; \n\n     import   { \n      Grid , \n      TablePfProvider , \n     }   from   'patternfly-react' ; \n\n     const   List   =   ( {  data  } )   =>   { \n       const  tr  =  data . map ( row   =>   ( \n         < tr > \n           < td > { row . code } < / td > \n           < td > { row . descr } < / td > \n         < / tr > \n       ) ) ; \n\n\n       return   ( \n         < Grid fluid > \n           < TablePfProvider\n            striped\n            bordered\n            hover\n           > \n             < thead > \n             < tr > \n               < td > code < / td > \n               < td > descr < / td > \n             < / tr > \n             < / thead > \n             < tbody > \n             { tr } \n             < / tbody > \n           < / TablePfProvider > \n         < / Grid > \n       ) ; \n     } ; \n\n    List . propTypes  =   { \n       data :  PropTypes . arrayOf ( PropTypes . shape ( { } ) ) , \n     } ; \n\n    List . defaultProps  =   { \n       data :   [ ] , \n     } ; \n     export   default  List ; \n \n Next make sure that you remove the predefined  data  const since the\ndata will be coming from the reducer, on top of defining PropTypes rules\nfor validating and giving a default for the injected property  data . \n Once complete, update the component used in the route inside  App.js \n      ... \n     import  PageModelsListContainer  from   'ui/pageModels/ListContainer' ; \n     ... \n       { \n         path :   ROUTE_PAGE_MODELS , \n         component :  PageModelsListContainer , \n       } , \n     ... \n \n You will now see the data inside the table reflecting the content of the\nstorage. \n Connecting the app to an Entando core instance \n By default the app is using mocks and not connecting to any Entando core\ninstance. \n Because the app is making use of  @entando/apimanager  we can easily\nchange this by setting up two  .env  variables inside the  .env  file in\nthe project root: \n     REACT_APP_DOMAIN=http://localhost:8080/entando-app\n    REACT_APP_USE_MOCKS=false\n \n The  REACT_APP_DOMAIN  must pointing towards the domain and container\nwhere the Entando instance is running and  must not  contain trailing\nslashes. \n Once this is done to make the change happen we will have to stop the app\nusing  ctrl + c  and re run it with  npm start . \n Now the toast stating  This application is using mocks  won’t be popping\nup anymore. \n You can make sure that the configuration is correct by looking at the\nnetwork section in the browser dev tools. By default the app\nautomatically makes an admin login against a plain Entando instance to\nauthenticate the user and to be able to consume any protected api. \n This is not an ideal scenario and it is meant to be used only for\ndebugging purposes for many reasons: \n \n \n the username and password should never be hardcoded in your app \n \n \n if authentication is required the user should be the one performing\nthe login action \n \n \n the plain default passwords in use won’t be useful against a proper\nproduction instance of Entando \n Adding the API Calls \n We are now going to add api calls for both users and page models to\nretrieve the data live instead of relying on our store’s default state. \n Inside  src/api  create the  users.js  file: \n      import   {  makeRequest ,   METHODS   }   from   '@entando/apimanager' ; \n\n     // eslint-disable-next-line import/prefer-default-export \n     export   const  getUsers  =   ( page  =   {   page :   1 ,   pageSize :   10   } ,  params  =   '' )   =>   ( \n       makeRequest ( \n         { \n           uri :   ` /api/users ${ params } ` , \n           method :   METHODS . GET , \n           mockResponse :   { } , \n           useAuthentication :   true , \n         } , \n        page , \n       ) \n     ) ; \n \n and then create the  pageModels.js  file: \n      import   {  makeRequest ,   METHODS   }   from   '@entando/apimanager' ; \n\n     // eslint-disable-next-line import/prefer-default-export \n     export   const  getPageModels  =   ( page  =   {   page :   1 ,   pageSize :   10   } ,  params  =   '' )   =>   makeRequest ( { \n       uri :   ` /api/pageModels ${ params } ` , \n       method :   METHODS . GET , \n       mockResponse :   { } , \n       useAuthentication :   true , \n     } ,  page ) ; \n Creating the Thunk \n In order to use the api call we next create a thunk action, which is a\nredux action with side effects, like an API call. \n inside the  src/state/apps/testing/userList/actions.js  file we are\ngoing to add the new action: \n      ... \n     import   {  addErrors  }   from   '@entando/messages' ; \n     import   { \n      getUsers , \n     }   from   'api/users' ; \n     ... \n\n     // thunks \n\n     export   const  fetchUsers  =   ( page  =   {   page :   1 ,   pageSize :   10   } ,  params  =   '' )   =>   dispatch   =>   ( \n       new   Promise ( ( resolve )   =>   { \n         getUsers ( page ,  params ) . then ( ( response )   =>   { \n          response . json ( ) . then ( ( json )   =>   { \n             if   ( response . ok )   { \n               dispatch ( addUsers ( json . payload ) ) ; \n             }   else   { \n               dispatch ( addErrors ( json . errors . map ( err   =>  err . message ) ) ) ; \n             } \n             resolve ( ) ; \n           } ) ; \n         } ) . catch ( ( )   =>   { } ) ; \n       } ) \n     ) ; \n \n Next do the same inside  src/state/apps/testing/pageModels/actions.js : \n      ... \n     import   {  addErrors  }   from   '@entando/messages' ; \n     import   { \n      getPageModels , \n     }   from   'api/pageModels' ; \n     ... \n\n     // thunks \n\n     export   const  fetchPageModels  =   ( page  =   {   page :   1 ,   pageSize :   10   } ,  params  =   '' )   =>   dispatch   =>   ( \n       new   Promise ( ( resolve )   =>   { \n         getPageModels ( page ,  params ) . then ( ( response )   =>   { \n          response . json ( ) . then ( ( data )   =>   { \n             if   ( response . ok )   { \n               dispatch ( addPageModels ( data . payload ) ) ; \n               resolve ( ) ; \n             }   else   { \n               dispatch ( addErrors ( data . errors . map ( err   =>  err . message ) ) ) ; \n               resolve ( ) ; \n             } \n           } ) ; \n         } ) . catch ( ( )   =>   { } ) ; \n       } ) \n     ) ; \n \n Now with two exports, it is safe to remove the\n eslint-disable-next-line  comment on line 5 of both files. \n changing the mapDispatchToProps in the containers \n Next, in order to pass the newly created thunk to both List components,\nwe’ll update the containers accordingly, as: \n src/ui/userList/ListContainer.js \n      ... \n     import   {  fetchUsers  }   from   'state/apps/testing/userList/actions' ; \n     ... \n     export   const   mapDispatchToProps   =   dispatch   =>   ( { \n       fetch :   ( )   =>   dispatch ( fetchUsers ( ) ) , \n     } ) ; \n\n     export   default   connect ( \n      mapStateToProps , \n      mapDispatchToProps , \n     ) ( List ) ; \n \n src/ui/pageModels/ListContainer.js \n      ... \n     import   {  fetchPageModels  }   from   'state/apps/testing/pageModels/actions' ; \n     ... \n     export   const   mapDispatchToProps   =   dispatch   =>   ( { \n       fetch :   ( )   =>   dispatch ( fetchPageModels ( ) ) , \n     } ) ; \n\n     export   default   connect ( \n      mapStateToProps , \n      mapDispatchToProps , \n     ) ( List ) ; \n Updating the List components \n Both List components were simple components with only a  render  method,\ntherefore could be declared as simple constants. \n Next we will fetch data during the  componentDidMount  life cycle event\nwhich will require we turn the constant into a class on top of changing\nthe PropTypes to add the new fetch method passed down to the component. \n src/ui/userList/List.js \n      import  React ,   {  Component  }   from   'react' ; \n     ... \n     class   List   extends   Component   { \n       componentDidMount ( )   { \n         const   {  fetch  }   =   this . props ; \n         fetch ( ) ; \n       } \n\n       render ( )   { \n         const   {  data  }   =   this . props ; \n         const  tr  =  data . map ( row   =>   ( \n           < tr > \n             < td > { row . username } < / td > \n             < td > { row . registration } < / td > \n           < / tr > \n         ) ) ; \n\n         return   ( \n           < Grid fluid > \n             < TablePfProvider\n              striped\n              bordered\n              hover\n             > \n               < thead > \n                 < tr > \n                   < td > username < / td > \n                   < td > registration < / td > \n                 < / tr > \n               < / thead > \n               < tbody > \n                 { tr } \n               < / tbody > \n             < / TablePfProvider > \n           < / Grid > \n         ) ; \n       } \n     } \n\n    List . propTypes  =   { \n       data :  PropTypes . arrayOf ( PropTypes . shape ( { } ) ) , \n       fetch :  PropTypes . func , \n     } ; \n\n    List . defaultProps  =   { \n       data :   [ ] , \n       fetch :   ( )   =>   { } , \n     } ; \n \n src/ui/pageModels/List.js \n      import  React ,   {  Component  }   from   'react' ; \n     ... \n     class   List   extends   Component   { \n       componentDidMount ( )   { \n         const   {  fetch  }   =   this . props ; \n         fetch ( ) ; \n       } \n\n       render ( )   { \n         const   {  data  }   =   this . props ; \n         const  tr  =  data . map ( row   =>   ( \n           < tr > \n             < td > { row . code } < / td > \n             < td > { row . descr } < / td > \n           < / tr > \n         ) ) ; \n\n         return   ( \n           < Grid fluid > \n             < TablePfProvider\n              striped\n              bordered\n              hover\n             > \n               < thead > \n                 < tr > \n                   < td > code < / td > \n                   < td > descr < / td > \n                 < / tr > \n               < / thead > \n               < tbody > \n                 { tr } \n               < / tbody > \n             < / TablePfProvider > \n           < / Grid > \n         ) ; \n       } \n     } \n\n    List . propTypes  =   { \n       data :  PropTypes . arrayOf ( PropTypes . shape ( { } ) ) , \n       fetch :  PropTypes . func , \n     } ; \n\n    List . defaultProps  =   { \n       data :   [ ] , \n       fetch :   ( )   =>   { } , \n     } ; \n clear the default value of the reducer \n Now we should be fetching data from the server, therefore we can safely\nmake the list key in the  defaultState  object an empty array: \n src/state/apps/testing/userList/reducer.js \n      ... \n     const  defaultState  =   { \n       list :   [ ] , \n     } ; \n     ... \n \n src/state/apps/testing/pageModels/reducer.js \n      ... \n     const  defaultState  =   { \n       list :   [ ] , \n     } ; \n     ... \n adding additional dependencies \n It may be necessary to set additional dependencies for your project. If\nthe need arises, it is important to remember a few rules: \n Only actual dependencies that are not already included in  app-builder \ncan be added as pure dependencies. Every other dependency must either be\na  devDependency  or  peerDependency . \n If you are not careful you may end up with duplicated dependencies that\n will  result in errors manifesting themselves when running the app\ninside App Builder. \n running the app in integrated mode within App Builder \n After running  npm install  in the App Builder, the user can run the\n npm run app-install <appId>  command to install the app. \n This command will trigger a download of the app from npm and the\ninstallation of its component within App Builder. After the installation\nprocess is complete, it will be possible to either  npm start  or\n npm build  App Builder. \n To install a dev app, like the one developed in this tutorial which have\nnot been previously published on npm, you will need to use additional\nflags and will have to run a few additional commands. \n Before running the Install command  make sure that you have\nuninstalled all existing peer and dev dependencies to avoid collision\nwith app builder. To do so, from the app builder app directory\n( testing , in this tutorial) just run in the correct order the\nfollowing commands: \n npm run babel \n npm i --only=production \n The first will create the dist directory that will be needed by App\nBuilder while the second one will uninstall anything but production\ndependencies. \n Next, from the App Builder directory, run the install command with these\nadditional flags: \n \n \n -d  specify the relative path where the app is installed. When\nusing this flag the appId should be the normalized app name, without\nthe  @entando/  prefix. \n \n \n -p  specify the package name if it is different from the appId \n \n \n to use flags you will have to use the double dash in the command: \n npm run app-install —  cms -d ../testing -p @entando/testing \n the value in the  -p  flag should always match the actual name of the\napp that is going to be installed inside App Builder . You can check\nyour app name inside the  package.json  file of your app. \n If you experience problems after running the build command delete the\n node_modules  directory before running the second command. \n"},{title:"Business Objective",frontmatter:{},regularPath:"/v6.1/tutorials/customize-the-platform/pda-tutorial.html",relativePath:"v6.1/tutorials/customize-the-platform/pda-tutorial.md",key:"v-5ca42bd6",path:"/v6.1/tutorials/customize-the-platform/pda-tutorial.html",headers:[{level:2,title:"Micro Frontend",slug:"micro-frontend"},{level:2,title:"Process Automation Manager (PAM)",slug:"process-automation-manager-pam"},{level:2,title:"Business Process Modeling Notation (bpmn)",slug:"business-process-modeling-notation-bpmn"},{level:2,title:"Decision Model and Notation (dmn)",slug:"decision-model-and-notation-dmn"},{level:2,title:"Back End for Front End (BFF)",slug:"back-end-for-front-end-bff"},{level:2,title:"Task List",slug:"task-list"},{level:3,title:"PAM Implementation",slug:"pam-implementation"},{level:2,title:"Task Details",slug:"task-details"},{level:3,title:"PAM Implementation",slug:"pam-implementation-2"},{level:2,title:"Task Comments",slug:"task-comments"},{level:3,title:"PAM Implementation",slug:"pam-implementation-3"},{level:2,title:"Task Forms",slug:"task-forms"},{level:3,title:"PAM Implementation",slug:"pam-implementation-4"},{level:2,title:"Attachments",slug:"attachments"},{level:3,title:"PAM Implementation",slug:"pam-implementation-5"},{level:2,title:"New Process Form",slug:"new-process-form"},{level:2,title:"Summary Card",slug:"summary-card"},{level:3,title:"PAM Implementation",slug:"pam-implementation-6"},{level:2,title:"Totals Over Time",slug:"totals-over-time"},{level:3,title:"PAM Implementation",slug:"pam-implementation-7"},{level:2,title:"Styling",slug:"styling"},{level:2,title:"Implementing a New Engine or Integrating a New Task Source",slug:"implementing-a-new-engine-or-integrating-a-new-task-source"},{level:2,title:"Page Templates and Layout",slug:"page-templates-and-layout"},{level:2,title:"Creating a new PDA MFE",slug:"creating-a-new-pda-mfe"},{level:2,title:"Communication between MFEs",slug:"communication-between-mfes"},{level:2,title:"Micro Frontend Overview",slug:"micro-frontend-overview"},{level:3,title:"Task forms",slug:"task-forms-2"},{level:2,title:"Widgets",slug:"widgets"},{level:2,title:"Building From source",slug:"building-from-source"},{level:2,title:"Code Style",slug:"code-style"},{level:2,title:"Sonar",slug:"sonar"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:' Business Objective \n The Entando Process Driven Applications plugin is built to provide a\nrich and full featured user experience to allow for the management and\ncompletion of business processes and automation. The UX is delivered a\ngeneral purpose UX layer built using micro frontends that can be\nutilized for any business process or task engine. Customers drive the UX\nlayer by utilizing a pre-developed Entando integration or by\nimplementing a set of interfaces on the server side. The backend is a\nSpring Boot microservice that provides a pluggable interface allowing\nfor the injection of any underlying process or automation toolkit. The\ninterfaces and steps for creating a new PDA backend implementation are\nprovided below. This document provides an overview of the Entando\nProcess Driven Apps (PDA) plugin. The initial section covers the\nbusiness functionality and user facing micro frontends. The second\nsection covers the architecture and the points of extension for the PDA\nplugin. The third provides a detailed technical overview for developers\nto add new functionality to a PDA implementation. \n Terminology \n Micro Frontend \n A Micro frontend architecture is an approach to developing web\napplication as a composition of small frontend apps. Instead of writing\na large monolith frontend application, the application is broken down\ninto domain specific micro frontends, which are self-contained and can\nbe developed and deployed independently. \n Process Automation Manager (PAM) \n A business process automation engine built and maintained by Red Hat \n Business Process Modeling Notation (bpmn) \n Business Process Model and Notation (BPMN) is a graphical representation\nfor specifying business processes in a business process model. \n Decision Model and Notation (dmn) \n Decision Model and Notation is a standard published by the Object\nManagement Group. It is a standard approach for describing and modeling\nrepeatable decisions within organizations to ensure that decision models\nare interchangeable across organizations. \n Back End for Front End (BFF) \n A microservice architecture allows teams to iterate quickly and to\ndevelop technology to scale rapidly. The Backend for Frontend (BFF)\narchitecture is a type of pattern built with microservices. The key\ncomponent of this pattern is an application that connects the front-end\nof your application with the backend. This BFF Code Pattern will help\nyou build that component according to IBM’s best practices. \n PDA Micro Frontends \n This section provides an overview of each of the micro frontends (MFE)\nthat are available as part of the Entando PDA plugin. In cases below\nwhere there are details specific to the PAM implementation they are\nprovided for that MFE. When extending the integration layer to other\nengines or custom implementations it will be up to the integrating team\nto define behavior and datasource for each MFE. \n Task List \n The task list MFE provides a user with a list of visible tasks that are\neither assigned to that user or that are potentially ownable by that\nuser. In the default implementation the visible tasks are limited to a\nsingle process instance. At configuration time the application designer\nis given the option to select a set of columns that will be visible in\nthe task list for that page. \n PAM Implementation \n The default PAM implementation makes the top level task fields available\nin the task list for selection. It is possible to fetch task and process\nvariables for rendering in the task list but these values are excluded\nby default due to the additional API call overhead required. \n Task Details \n The task details MFE renders detailed information about a given task.\nThe task details widget is intended to give the final user processing a\ntask the information necessary to complete the task at hand. The task\ndetails are rendered in a read only grid. See the styling section below\nfor changing and customizing the layout. \n PAM Implementation \n The PAM integration renders task variables in the task details widget. \n Task Comments \n The task comments MFE gives the user the ability to view notes attached\nto a given task and to add new notes to a task. \n PAM Implementation \n The PAM implementation reads and publishes notes to the comments\nendpoint \n Task Forms \n The task form implementation renders a form specific to a task and gives\nthe user the ability to complete that form. The form implementation is a\nwrapper around a JSON schema that describes the layout, style and\ncontent of the form. It is up to the backend implementation to transform\nto the schema and default ux layout needed to render the form. See the\ntechnical documentation below for more on the JSON schema based\nimplementation. \n PAM Implementation \n The PAM implementation of forms depends on the presence of a form\ndefinition being present on the PAM task. The Entando PAM engine\nimplementation transforms from the PAM format to the JSON schema to\nrender the form. And it transforms the API format back to the PAM format\nbased on the form definition in PAM. There are some limitations on form\ncustomization due to the format required to return data to PAM. See the\nforms section in the technical documentation for more information. \n Attachments \n The attachments MFE gives the user to view documents attached to a\ntask/case/process and to add new documents to a task/case/process. \n PAM Implementation \n The PAM implementation posts the documents to the PAM endpoints for\nstorage. Future features will include using Entando document storage for\nstoring documents and a pluggable document management interface. \n New Process Form \n The new process form renders a form that allows the final user to\nprovide the information necessary to instantiate a new business process\ninstance. The technology for generating the process form is the same as\nthe JSON schema definition used for task forms. === PAM Implementation\nThe PAM implementation depends on a form definition being attached to\nthe process definition. Entando transforms the PAM representation into a\nJSON schema form that can be rendered to the final user. \n Summary Card \n The summary card MFE provides a view into aggregate data for the process\nimplementation. The rendered information includes a total value, a trend\nvalue, and a selector for timeframe. The summary card allows the\napplication developer to select a request for rendering the requested\ninformation which maps to a call in the underlying engine to provide the\nsummarized data. \n PAM Implementation \n The PAM implementation of the summary card widget relies on the PAM\ncustom query functionality. The PAM PDA engine exposes configuration\nthat allows users/developers to define a custom query in a config file\nthat will be executed to render the summary card. This implementation\nallows the data rendered on the summary cards to be changed via\nconfiguration. In the application there is a properties file that allows\nthe implementer to provide a custom query for each of the cards. \n Totals Over Time \n The totals over time MFE provides a dual axis line/bar graph providing\ntrend information about the process environment. The MFE also provides\nthree summary values for comparison over the same time period. \n PAM Implementation \n The PAM implementation of the totals over time MFE utilizes custom\nqueries to fetch the summary data rendered in the chart. The queries\nused in the implementation are defined in configuration files in the MFE\nand can be updated to render data specific to a given implementation. \n Customizing the Process Driven Application \n Styling \n The Entando PDA MFEs are styled via a material UI theme. That theme can\nbe downloaded and updated here:\n https://github.com/entando/frontend-libraries/tree/master/packages/entando-ui \n Implementing a New Engine or Integrating a New Task Source \n Implementing a new Engine for Process Driven Applications means to\ncreate a new Java Project and implement the interfaces defined in the\npda-core-engine project. So, the new project should include the\npda-core-engine as a dependency. To see an implementation in action,\ntake a look at the pda-redhatpam-engine project, which implements the\nRed Hat PAM engine integration. After the engine is implemented, the JAR\nfile resulting from the implementation should be available in the\nclasspath for entando-process-driven-plugin, which is the project that\nis ultimately executed and exposes the Rest APIs for the frontend\napplication. One way to do that is by publishing the engine\nimplementation to a Maven repository and adding it as a dependency to\nthe entando-process-driven-plugin project. Below are the descriptions of\nthe key classes and interfaces in the pda-core-engine project that need\nto be inherited or implemented when creating a new engine\nimplementation: \n \n \n Engine: This class represents a BPM engine and exposes the services\nthat are available for that specific implementation. It is intended\nto be inherited and the subclass should provide the real\nimplementation for each service by calling the superclass\nconstructor with the service implementations as arguments. If any\nservice is not supported, a null value should be passed to the\ncorresponding constructor argument. The engine can provide\nimplementations for the the following service interfaces: \n \n \n TaskService: defines service methods for task retrieval from the\nBPM engine. \n \n \n TaskDefinitionService: defines service methods related to task\ndefinition. A task definition specifies which fields or columns\nare available for all task instances. \n \n \n TaskCommentService: defines service methods related to task\ncomment manipulation. It should be implemented if the task\ncomment is supported by the engine. \n \n \n TaskAttachmentService: defines service methods to operate on\ntask attachments. It should be implemented if the engine\nsupports file attachment on the task. \n \n \n TaskFormService: defines service methods for task form\noperations, like retrieving the form definition and submitting a\nform. The Form object can be used to render a form dynamically. \n \n \n TaskLifecycleService: defines service methods related to the\ntask lifecycle. The lifecycle operations move the task from one\nstate to another. \n \n \n TaskLifecycleBulkService: defines methods for bulk lifecycle\noperations. Like the TaskLifecycleService, methods here move the\ntask from one state to another, but this interface works with\nmultiple tasks at a time. \n \n \n ProcessService: defines service methods for process definitions\noperations. \n \n \n ProcessFormService: defines service methods for process form\noperations, like retrieving the form definition and submitting a\nform. The Form object can be used to render a form dynamically. \n \n \n GroupService: define service methods related to groups from the\nBPM engine. \n Page Templates and Layout \n Page templates are page templates that facilitate rapid development of\npages and allow adding pre-made components - widgets - just by drag &\ndropping. Templating language used in page models is parsed by Apache\nFreeMarker template engine. To create a new page model, go to the Admin\npanel and select UX Pattern > Page Models. Press “Add” and you will be\nredirected to the page model creation screen. Add the page model code\nand page model name. Depending on the version you are using you will\nneed to provide a XML or JSON schema. This schema is used to generate\nthe page layout in page configuration screen - it’s used to drag & drop\nwidgets on the page and helps users visualize where each widget will be\nplaced on the page. Basic schema could look like this \n {\n  "frames": [\n    {\n      "pos": 0,\n      "descr": "Widget description",\n      "mainFrame": false,\n      "defaultWidget": null,\n      "sketch": {\n        "x2": 1,\n        "y2": 0,\n        "x1": 0,\n        "y1": 0\n      }\n    }\n  ]\n}\n \n Each item in the frames array represents a widget frame (slot). \n \n \n pos - a position index (starts from zero); this value is used in\nAPIs to address specific widget on the page \n \n \n descr - widget frame description that is displayed in page\nconfiguration screen \n \n \n mainFrame - The primary frame on the page model \n \n \n defaultWidget - widget code for a default widget to use in this\nframe; page model developer can help out users and suggest the\ndefault widgets to use (e.g., header and footer widgets) \n \n \n sketch - an object with 4 coordinates on x and y axises; this allows\nthe developer to place the widgets on the visual representation of\nthe page model’s frames. \n \n \n Sketch’s x and y values go from 0 to 11 (similar to columns in\nBootstrap), so if you want to place a 2x2 frame at the top left corner\nof the page, the values would be x1: 0, x2: 1 y1: 0 y2: 1. \n After you create the JSON/XML schema for the widgets, you can start\nworking on the page template itself. It’s a HTML template that contains\nreferences to the frames you have added in schema. To add a frame in a\nspecific place of the page, just add  <@wp.show frame=0 /> , where frame\nis the pos variable from the schema. Do not forget to add\n <#assign wp=JspTaglibs["/aps-core"]>  at the top of your template, it\nwill provide access to wp variable. \n After you are done with your page model, go to Page designer > Page\ntree and create a new page by pressing “Add”. Fill the needed\ninformation and under Settings > Page Model select your newly created\npage model. Press “Save and Configure” and you will be redirected to the\npage configuration screen where you will be able to drag & drop the\navailable widgets onto the free frames. Set up your widgets (not all\nframes need to be filled) and publish the page. To see your page you can\npress “Preview” or go to\n `<YOUR_ENVIRONMENT_URL>/<LOCALE>/<PAGE_CODE>.page . If your pages\nshare common parts such as GTM scripts, consider using fragments.\nFragments are like shared code snippets - just add <@wp.fragment\ncode="<FRAGMENT_CODE>" escapeXml=false /> to your page template and\nthe code inside the fragment will be added to your page. \n Creating a new PDA MFE \n There are no limitations on the stack that could be used to create PDA\nMFEs. Custom Elements are a great way to hide implementation details\nwhile providing a neutral interface to others. To create a simple PDA\nMFE, implement your solution using technologies you are familiar with\nand wrap it in a custom element. Build your solution with a custom\nelement and upload the built files (Settings > File Browser) in\n/public/ folder. Go to  UX Pattern > Widget  section of the admin panel\nand press “Add” to add a new widget. Enter widget code, titles, select\ngroup (for free access to everybody, select “Free Access”), and fill the\nCustom UI: \n <#assign wp=JspTaglibs["/aps-core"]>\n<script src="<@wp.resourceURL />path/from/static/bundle.js"><\/script>\n<your-custom-element parameter=”value” />\n \n <#assign wp=JspTaglibs["/aps-core"]>  - provides access to wp variable\nthat is used to get resource URL. After you add the widget, go to the\npage tree, select a page where you would like to use the widget and\nconfigure it. Drag and drop the widget into a frame and publish the\npage. \n Communication between MFEs \n Communication between MFEs can be achieved using Custom Events. Each\nwidget can define events that it will emit and register to events that\nare important to it. \n const createWidgetEvent = eventType => {\n  return payload => {\n    const widgetEvent = new CustomEvent(eventType, { payload });\n    window.dispatchEvent(widgetEvent);\n  };\n};\n\n\nconst subscribeToWidgetEvent = (eventType, eventHandler) => {\n  window.addEventListener(eventType, eventHandler);\n  return () => {\n    window.removeEventListener(eventType, eventHandler);\n  };\n};\n \n Custom element then creates the events it emits and registers to the\nevents that it wants to react to \n constructor(props) {\n  super(props);\n\n  // other code\n\n  this.onClickSubmit = createWidgetEvent(‘myWidget.onSubmit’);\n}\n\nconnectedCallback() {\n\n  // other code\n\n  this.unsubscribeFromWidgetEvents = subscribeToWidgetEvent(\n    ‘otherWidget.onClickClear’,\n    () => {\n      // callback function when otherWidget fires the onClickClear custom event\n    }\n  }\n}\n Technical Documentation \n Micro Frontend Overview \n Task forms \n Widgets containing form (e.g., task completion form widget) use JSON\nschema to dynamically create forms. Widget implementation uses\nreact-jsonshema-form library that converts forms’ JSON schemas into\nReact components. Our initial implementation uses Material UI components\nvia Material UI theme library rjsf-material-ui as baseline and has\nEntando specific templates, widgets and fields (which are\nreact-jsonshema-form terms for parts of forms). In this section you will\nlearn about basic setup of the form, but if you would like to learn\nmore, please refer to react-jsonshema-form documentation. Themed JSON\nform is created using the withTheme() method from the\nreact-jsonschema-form package \n import { withTheme } from \'react-jsonschema-form\';\nimport { Theme as MuiRJSForm } from \'rjsf-material-ui\';\n\nconst JSONForm = props => {\n\n  const ThemedForm = withTheme(MuiRJSForm);\n\n  // ...\n\n  return (\n    <ThemedForm\n    schema={formSchema}\n    uiSchema={uiSchema}\n    {...customTemplates}\n    widgets={customWidgets}\n    formData={formData}\n    onSubmit={e => onSubmitForm(e)}\n    >\n  );\n};\n\nexport default JSONForm;\n \n For JSON Form to work, the form schema is mandatory. It’s a JSON\ndefinition of the form’s structure. Users can also provide form data via\nformData variable, which should follow the structure of JSON schema; and\nUI schema using uiSchema variable, which allows users to customise the\nform’s UI (components, rules, types, etc.) To test JSON schema, UI\nschema and form data, you can use react-jsonschema-form sandbox\nenvironment. Custom Entando templates, widgets, and fields provide a\npossibility to customise the layout of the form using Grid components.\nTo specify what area a field or subform should fill, users can provide\nsize parameter in UI schema’s ui:options object. Size refers to Material\nUI’s grid column widths (Material UI documentation) where the area the\nfrom can take up is divided into 12 columns and value 12 (a default\nvalue if size is not provided) means the field or subform should take up\nall 12 columns. That means that size should be a value from 1 to 12. If\ntwo fields that are next to each other have size values 8 and 4\nrespectively - they will fit into one row, first field being 2 times\nwider than the second field. User can also provide innerSize parameter\nto size the input inside the field. This helps with formatting - if user\nwants a two column layout and have smaller input fields inside these\ncolumns. Multicolumn layout can also be achieved using\ngenerateColumnedOFT(columnSize) functionality, basically providing the\ndefault columnSize to the created form. generateColumnedOFT returns an\nObjectFieldTemplate that is used as a template for all object fields\n(fields that contain properties inside of them). To help us understand\nthe mapping between JSON schema and UI schema lets define an example\nschema: \n {\n  "$schema": "http://json-schema.org/draft-07/schema#",\n  "$id": "http://entando.org/schemas/pda-form.json",\n  "title": "Mortgage Application Form",\n  "type": "object",\n  "properties": {\n    "Application": {\n      "title": "Application",\n    "type": "object",\n    "required": [],\n    "properties": {\n        "mortgageamount": {\n          "type": "integer",\n          "title": "Mortgage amount",\n          "description": "Mortgage amount"\n        },\n        "downpayment": {\n          "type": "integer",\n          "title": "Down Payment",\n          "description": "Down Payment"\n        },\n        "applicant": {\n          "title": "Applicant",\n          "type": "object",\n          "required": [],\n          "properties": {\n            "name": {\n              "type": "string",\n              "title": "Name",\n              "description": "Name",\n              "maxLength": 100\n            },\n            "annualincome": {\n              "type": "integer",\n              "title": "Annual Income",\n              "description": "Annual Income"\n            }\n          }\n        },\n        "property": {\n          "title": "Property",\n          "type": "object",\n          "required": [],\n          "properties": {\n            "age": {\n              "type": "integer",\n              "title": "Age of property",\n              "description": "Age of property"\n            },\n            "address": {\n              "type": "string",\n              "title": "Address of property",\n              "description": "Address of property",\n              "maxLength": 100\n               }\n          }\n        }\n      }\n    },\n    "inlimit": {\n      "type": "boolean",\n    "title": "Is mortgage application in limit?"\n    }\n  }\n}\n \n From this JSON (you can copy & paste it into the react-jsonschema-form\nsandbox) we can see that there is a main form with a title “Mortgage\nApplication Form”. Root “Mortgage Application Form” form has two\nproperties - one is a subform  Application  and the second one is just a\ncheckbox field (field ID is inlimit). Application subform contains 2\nfields: Mortgage amount (field ID is mortgageamount) and Down Payment\n(field ID is downpayment); and two subforms - Applicant (field ID is\napplicant) and Property (field ID is property). Applicant subform\ncontains 2 fields - Name (field ID is name) and Annual Income (field ID\nis annualincome). Property subform contains 2 fields - Age of property\n(field ID is age) and Address of property (field ID is address) By\ndefault (without providing UI schema) they are all listed one field per\nrow. To use Entando’s implementation of Grid layout, users have to\nprovide UI schema with details about each field. For example, if we\nwould like to have a layout that looks like this (fields are marked\n [ field name ] ): \n +----------------------------------------------------------------------------+\n| Mortgage Application Form                                                  |\n+----------------------------------------------------------------------------+\n| Application                                                                |\n+----------------------------------+-----------------------------------------+\n| [Mortgage amount]                | [Down Payment]                          |\n+----------------------------------+-----------------+-----------------------+\n| Applicant                                          | Property              |\n+----------------------------------+-----------------+-----------------------+\n| [Name]                           | [Annual Income] | [Age of property]     |\n+----------------------------------+-----------------+-----------------------+\n|                                                    | [Address of property] |\n+----------------------------------------------------+-----------------------+\n \n To set up the UI schema you have to define each field you want to\ncustomise by addressing using the field IDs - to add options to\nApplicant’s Name field, you will have to create an object tree going\nfrom root object through Application —> Applicant —> Name (using IDs\nit’s Application.applicant.name). UI schema for the table layout defined\nabove would look like this: \n {\n  Application: {\n    \'ui:options\': {\n      size: 12, // <-- this value is not mandatory as size is 12 columns-wide by default\n    },\n    mortgageamount: {\n      \'ui:disabled\': true, // <-- user can define fields disabled at UI schema level\n      \'ui:options\': {\n        size: 6, // <-- Mortgage amount field should take up half of the row\n      },\n    },\n    downpayment: {\n      \'ui:options\': {\n        size: 4, // <-- Down payment field should take up the other half of the row\n      },\n    },\n    applicant: {\n      \'ui:options\': {\n        size: 8, // <-- Applicant subform should take up 8 out of 12 columns\n      },\n      name: {\n        \'ui:options\': {\n          size: 8, // <-- Applicant name field should take up 8 columns in the 8 columns that Applicant subform occupies\n        },\n      },\n      annualincome: {\n        \'ui:options\': {\n          size: 4, // <-- Annual Income field taking up the remaining 4 columns\n        },\n      },\n    },\n    property: {\n      \'ui:options\': {\n        size: 4, // <-- Property subform should take up the remaining 4 out of 12 columns\n      },\n      // note that property\'s fields are not mentioned - defaulting them to 12 columns in are that is available to them\n    },\n  },\n};\n\nAs Material UI components are used for field templates, there might be a need to pass some Material UI options into the field. You can do that by adding muiProps object to the ui:options.\nFor example, if you would like to make the Down payment field resizable, you can add multiline: true to muiProps option. If you want to make the field take up multiple rows by default, add rows and rowsMax fields. The latter limits how many rows should be added until the scroll bar is shown.\ndownpayment: {\n  \'ui:options\': {\n    size: 4,\n    muiProps: {\n      multiline: true,\n      rows: 2,\n      rowsMax: 4\n    }\n  }\n}\n Widgets \n Different types of widgets can be applied by passing the type via\n"ui:widget". Property tells the form which UI widget should be used to\nrender a field. You can read about react-jsonschema-form supported\nwidgets here. \n Building From source \n Reference the component projects for instructions to build from source.\n https://github.com/entando/entando-process-driven-plugin \n https://github.com/entando/entando-process-driven-plugin/tree/master/widgets \n https://github.com/entando/pda-redhatpam-engine \n https://github.com/entando/pda-core-engine \n Code Style \n See:  https://github.com/entando/entando-code-style \n Sonar \n https://sonarcloud.io/organizations/entando/projects \n'},{title:"Tutorial: Connecting to an External Database",frontmatter:{},regularPath:"/v6.1/tutorials/devops/external-database/",relativePath:"v6.1/tutorials/devops/external-database/README.md",key:"v-197d46c4",path:"/v6.1/tutorials/devops/external-database/",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:" Tutorial: Connecting to an External Database \n Overview \n This document provides a guide to connecting to an external database. In\nmany (not all) production configurations it is recommended to use a DBMS\noutside of the cluster where your Entando applicaiton is running to\nsimplify maintenance, duplication of resources, and to establish a\nbackup workflow that will scale with your application. \n Prerequisites \n \n \n An environment to install your Entando applicaiton \n \n \n A running PostgreSQL, MySQL, or Oracle environment \n \n \n Administrator access to the database \n \n \n Network access from your Kubernetes cluster to your database \n Tutorial \n \n In the helm quickstart define a db for your deployment that includes\nthe admin credentials for your database \n \n \n db:\n  vendor: postgresql | mysql | oracle\n  host: <yourhost>\n  port: <yourport>\n  adminUser: <youradmin>\n  adminPassword: <youradminpassword>\n  name: <yourdbname>\n \n \n \n Run the helm quickstart or create a deployment for your Entando\nenvironment manually \n \n Note: The quickstart creates a default configuration for the\ndeployment. This isn’t to suggest that it is the only\nconfiguration or that it matches with every use case. It is\nrecommended to think about your desired deployment Architecture\nand to configure for that environment using the CRDs as building\nblocks. This also isn’t to suggest that if it isn’t directly\nsupported by the quickstart template that you can’t change it.\nThe deployment is editable. Treat the helm template as a\nbootstrapping environment and edit your deployments to match\nyour needs and requirements. \n \n \n \n Open the yaml file generated from the deployment and review the\nsettings for the deployment \n \n The Entando Operator will create a secret for the database\nautomatically and use the DB initializers to create the DB for\nthe Entando app and any services that use it \n \n \n \n Deploy your app \n \n \n"},{title:"Connect to an External Keycloak Instance",frontmatter:{},regularPath:"/v6.1/tutorials/devops/external-keycloak/",relativePath:"v6.1/tutorials/devops/external-keycloak/README.md",key:"v-43de24f2",path:"/v6.1/tutorials/devops/external-keycloak/",headers:[{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Get keycloak information",slug:"_1-get-keycloak-information"},{level:3,title:"2. Generate the secret",slug:"_2-generate-the-secret"},{level:3,title:"3. Upload the secret",slug:"_3-upload-the-secret"},{level:3,title:"4. Deploy the Entando6 application",slug:"_4-deploy-the-entando6-application"},{level:2,title:"Conclusion",slug:"conclusion"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:' Connect to an External Keycloak Instance \n Purpose \n This tutorial enables the Entando administrator to leverage an existing\nKeycloak instance. \n Requirements \n \n \n A Keycloak instance \n \n \n A realm named "entando" on that instance \n \n \n An admin user for the "entando" realm \n Steps \n 1. Get keycloak information \n Retrieve the relevant information from the Keycloak instance you want to\nuse. \n Specifically you will need: \n \n \n The username of the Keycloak admin that has admin rights to the\n"entando" realm, e.g entando-keycloak-admin \n \n \n The Keycloak admin password, e.g. password123 \n \n \n The base url for the Keycloak server, including the auth value, e.g.\n https://my-keycloak-instance.com/auth \n 2. Generate the secret \n You now need to generate a secret with name  keycloak-admin-secret \nusing the information retrieved from step 1. The Entando administrator\nwill automatically detect this secret by name, and use it to log onto\nthe provided Keycloak server. \n Here is an example of the secret you will need to construct: \n ---\napiVersion: v1\nstringData:\n    username: <the username of the Keycloak admin user for the "entando" realm>\n    password: <the password of this Keycloak admin user>\n    url: <the base url of the Keycloak service, typically ending with the path /auth>\nkind: Secret\nmetadata\n    name: keycloak-admin-secret\n    namespace: <your-app-namespace>\ntype: Opaque\n \n \n Note \n To encode your values, in bash, you can do\n echo <your-value> | base64 \n 3. Upload the secret \n Next upload the secret to the namespace where you want to deploy your\nEntando 6 instance. \n oc create -f my-secret.yaml -n <my-app-namespace>\n 4. Deploy the Entando6 application \n Now you are ready to deploy your Entando 6 application and the\nadministrator will reuse the  keycloak-admin-secret  secret to populate\nthe environment correctly. \n Conclusion \n You should now have a working Entando 6 instance using an external\nKeycloak server. \n'},{title:"Bundle and components details",frontmatter:{},regularPath:"/v6.1/tutorials/ecr/ecr-bundle-details.html",relativePath:"v6.1/tutorials/ecr/ecr-bundle-details.md",key:"v-5ba28d60",path:"/v6.1/tutorials/ecr/ecr-bundle-details.html",headers:[{level:2,title:"Bundle convensions",slug:"bundle-convensions"},{level:2,title:"Descriptor File",slug:"descriptor-file"},{level:2,title:"Plugin Descriptor",slug:"plugin-descriptor"},{level:2,title:"Widget Descriptor",slug:"widget-descriptor"},{level:2,title:"Fragment Descriptor",slug:"fragment-descriptor"},{level:2,title:"Page Model Descriptor",slug:"page-model-descriptor"},{level:2,title:"Content Type Descriptor",slug:"content-type-descriptor"},{level:2,title:"Content Model Descriptor",slug:"content-model-descriptor"},{level:2,title:"Static Files",slug:"static-files"}],lastUpdated:"6/1/2021, 10:21:20 AM",lastUpdatedTimestamp:162255728e4,content:' Bundle and components details \n In order for the entando-component-manager to read the content of a\nbundle and install components, a  descriptor.yaml  file is required at\nthe root of the bundle package. \n Here is a generic bundle structure \n .\n├ descriptor.yaml\n├ resources/\n│ └ ...\n└ ... (folders reported in descriptor.yaml file)\n Bundle convensions \n \n \n The bundle descriptor file needs to be named  descriptor.yaml \notherwise the bundle will not be recognized. \n \n \n Static resources are not defined in the  descriptor.yaml  file as\nthey are by default read from a  resources  folder. If you need to\ninstall static resources, please follow the following convention. \n Descriptor File \n The descriptor file will aggregate all components inside and has the\nfollowing structure. \n \n Warning \n Remember the file needs to be named  descriptor.yaml . \n \n Descriptor.yaml. \n code: survey_bundle # The bundle ID\ndescription: This is the survey bundle # The description of the bundle\n\ncomponents: # All components will be here\nOptional. Use if the component requires a deployment\n  plugins:\n    - folder/you/want/my_plugin_descriptor.yaml\n    - folder/you/want/another_plugin_descriptor.yaml\nTo create widgets you will need to add references to the descriptor file\'s\n  widgets:\n    - widgets/my_widget_descriptor.yaml\n    - widgets/another_widget_descriptor.yaml\nTo create fragments, you will need to add references to the descriptor file\'s\n  fragments:\n    - fragments/my_fragment.yaml\nTo create Page Models you will need to add references to the descriptor file\'s\n  pageModels:\n    - pagemodels/my_page_model_descriptor.yaml\n    - pagemodels/another_page_model_descriptor.yaml\nTo create Content Types you will need to add references to the descriptor file\'s\n  contentTypes:\n    - contenttypes/my_content_type_descriptor.yaml\nTo create Content Models you will need to add references to the descriptor file\'s\n  contentModels:\n    - contentmodels/my_content_model_descriptor.yaml\n    - contentmodels/another_content_model_descriptor.yaml\nLabels on the system\n  labels:\n    - key: HELLO # This is the label identifier\n      titles: # The titles on the label\n        it: Mio Titolo # The title in Italian\n        en: My Title # The title in English\n Plugin Descriptor \n A plugin should be described using the  EntandoPlugin CustomResource\nformat . \n Here is an example, but check the CRD for details on the available\nfields. \n Plugin descriptor.yaml. \n kind: "EntandoPlugin"\napiVersion: "entando.org/v1alpha1"\nmetadata:\n  name: "my-plugin"\nspec:\n  image: "my-image"\n  replicas: 1\n  dbms: "postgresql"\n  roles:\n    - name: "task-list"\n      code: "task-list"\n    - name: "task-get"\n      code: "task-get"\n    - name: "connection-list"\n      code: "connection-list"\n    - name: "connection-get"\n      code: "connection-get"\n    - name: "connection-create"\n      code: "connection-create"\n    - name: "connection-delete"\n      code: "connection-delete"\n    - name: "connection-edit"\n      code: "connection-edit"\n  permissions: []\n  parameters: {}\n  ingressPath: "/myPath"\n  healthCheckPath: "/actuator/health"\n  securityLevel: "strict"\n  connectionConfigNames: []\n Widget Descriptor \n Here is an example of a widget descriptor \n Widget descriptor.yaml. \n code: another_todomvc_widget # The Widget identification\n\ntitles: # Widget\'s Titles\n  en: TODO MVC Widget # Title in English\n  it: TODO MVC Widget # Title in Italian\n\ngroup: free # The owner group of the widget\nOptional. The UI Path, the widget.ftl file will have the customUi content\ncustomUiPath: widget.ftl\nOptional. The Custom UI\ncustomUi: >-\n    <h1>My custom widget UI</h1>\nOptional. ConfigUI\nconfigUi:\n  customElement: todomvc-config # The name of the custom-element used to render the configUI\n  resources:\n    - <bundleid>/static/js/main.js # The resources necessary to the custom element to render the configUI, like the code\n Fragment Descriptor \n Fragment descriptor.yaml. \n code: my-fragment # The fragment identification\nOptional. The fragment content\nguiCode: >-\n  "<div>Here the content</div>"\nOptional. The GuiCode Path, the fragment.ftl file will have the guiCde conent in it\nguiCodePath: fragment.ftl\n Page Model Descriptor \n Page model descriptor.yaml. \n code: todomvc_page_model # The Page Model identification\ndescription: TODO MVC basic page model # The Page Model description\n\ntitles: # Page Model\'s Titles\n  en: TODO MVC PageModel # Title in English\n  it: TODO MVC PageModel # Title in Italian\nThe Page Model configuration\nconfiguration:\n  frames: # All frames\n    - pos: 0 # Frame position\n      description: Header # Frame description\n      sketch: # Frame sketch configuration\n        x1: 0\n        y1: 0\n        x2: 11\n        y2: 0\nA simplified way to define a Frame\n    - pos: 1\n      description: Breadcrumb\n      sketch: { x1: 0, y1: 1, x2: 11, y2: 1 }\nOptional. Define the Page Model Template in a separate file or inside the descriptor file with `template`\ntemplatePath: page.ftl\nOptional. Define the Page Model Template this way or in a separate file with `templatePath`\ntemplate: >-\n  <#assign wp=JspTaglibs[\\"/aps-core\\"]>\n  <!DOCTYPE HTML PUBLIC \\"-//W3C//DTD HTML 4.0 Transitional//EN\\">\n  <html>\n      <head>\n          <title><@wp.currentPage param=\\"title\\" /></title>\n      </head>\n      <body>\n          <h1><@wp.currentPage param=\\"title\\" /></h1>\n          <a href=\\"<@wp.url page=\\"homepage\\"/>\\">Home</a><br>\n          <div>\n              <h1>Bundle 1 Page Model</h1>\n              <@wp.show frame=0 />\n          </div>\n      </body>\n  </html>\n Content Type Descriptor \n For more details on the properties, refer to the Content Type\ndocumentation. \n Content-type descriptor.yaml. \n code: CNG\nname: Demo\nstatus: 0\n\nattributes:\n  - code: title\n    type: Text\n    name: Title\n    roles:\n      - code: jacms:title\n        descr: The main title of a Content\n    disablingCodes: []\n    mandatory: true\n    listFilter: false\n    indexable: false\n\n    enumeratorStaticItems: string\n    enumeratorStaticItemsSeparator: string\n    enumeratorExtractorBean: string\n\n    validationRules:\n      minLength: 0\n      maxLength: 100\n      regex: string\n      rangeStartString: string\n      rangeEndString: string\n      rangeStartStringAttribute: string\n      rangeEndStringAttribute: string\n      equalString: string\n      equalStringAttribute: string\n      rangeStartDate: string\n      rangeEndDate: string\n      rangeStartDateAttribute: string\n      rangeEndDateAttribute: string\n      equalDate: string\n      equalDateAttribute: string\n      rangeStartNumber: 0\n      rangeStartNumberAttribute: string\n      rangeEndNumber: 0\n      rangeEndNumberAttribute: string\n      equalNumber: 0\n      equalNumberAttribute:\n      ognlValidation:\n        applyOnlyToFilledAttr: false\n        errorMessage: Something\n        keyForErrorMessage: some\n        keyForHelpMessage: thing\n        ognlExpression: string\n Content Model Descriptor \n Content-model descriptor.yaml. \n id: 8880003\ncontentType: CNG\ndescription: Demo Content Model\nOptional. Define the Content Model Shape in a separate file or inside descriptor file with `contentShape`\ncontentShapePath:\nOptional. Define the Content Model Shape this way or in a separate file with `contentShapePath`\ncontentShape: >-\n  <article>\n    <h1>$content.Title.text</h1>\n    <h2>Demo content model</h2>\n    #if ( $content.MainBody.text != "" )\n    $content.MainBody.text\n    #end\n  </article>\n Static Files \n In order to upload static files, you will need to create a folder called\n resources/ , all files inside this folder will be uploaded in the same\nfolder structure that is inside. \n resources/\n├ css/\n│ └ styles.css\n├ js/\n│ └ script.js\n├ images/\n│ ├ favicon.ico\n│ └ logo.png\n└ page.html\n \n On the structure mentioned above, the resulting files in the Entando\narchitecture will be: \n yourbundleid/\n├ css/\n│ └ styles.css\n├ js/\n│ └ script.js\n├ images/\n│ ├ favicon.ico\n│ └ logo.png\n└ page.html\n \n \n Important \n yourbundleid  is the  code  property inside  descriptor.yaml \n \n So if you need to use the file in a widget or page model, use this FTL\ntag  <@wp.resourceURL /> : \n <img src="<@wp.resourceURL />yourbundleid/images/logo.png">\n<link rel="stylesheet" href="<@wp.resourceURL />yourbundleid/css/styles.css">\n<link rel="shortcut icon" href="<@wp.resourceURL />yourbundleid/images/favicon.ico" type="image/x-icon"/>\n<script type="application/javascript" src="<@wp.resourceURL />yourbundleid/js/script.js"><\/script>\n \n '},{title:"Overview",frontmatter:{},regularPath:"/v6.1/tutorials/ecr/ecr-overview.html",relativePath:"v6.1/tutorials/ecr/ecr-overview.md",key:"v-7ab73f40",path:"/v6.1/tutorials/ecr/ecr-overview.html",headers:[{level:2,title:"Introduction",slug:"introduction"},{level:2,title:"Glossary",slug:"glossary"},{level:3,title:"Component",slug:"component"},{level:3,title:"ECR Bundle",slug:"ecr-bundle"},{level:3,title:"EntandoDeBundle custom resource",slug:"entandodebundle-custom-resource"},{level:3,title:"Entando-component-manager",slug:"entando-component-manager"},{level:3,title:"Entando-K8S-service",slug:"entando-k8s-service"},{level:2,title:"Architecture",slug:"architecture"},{level:2,title:"Example flow",slug:"example-flow"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:" Overview \n Introduction \n The Entando Component Repository (ECR) is meant to be a repository to\nshare reusable components among different Entando instances. \n The following glossary relates to the ECR and related concepts: \n Glossary \n Component \n An Entando component - simply referred to as component - is a piece of\nreusable code/resource to be used in an Entando widget, page or\napplication. Examples of components are widgets, microfrontends,\ncontent-types, labels, plugins, and static resources \n ECR Bundle \n An ECR bundle - is a package containing one or more components and a\n'descriptor.yaml' file providing information about the bundle. The\nbundle is published on an NPM registry and is shared with an Entando\napplication using the EntandoDeBundle custom resource. \n EntandoDeBundle custom resource \n The EntandoDeBundle custom resource is a Kubernetes custom resource\nreadable by the Entando6 operator. It’s used to provide information\nabout an ECR bundle and make the bundle available in kubernetes for the\nentando-component-manager. \n Entando-component-manager \n The entando-component-manager - a.k.a component-manager is part of the\nEntando6 app and dialogs both with the Kubernetes cluster via the\nentando-k8s-service and with the entando-core. The\nentando-component-manager reads the bundles from the cluster and exposes\nthem via an API accessible from AppBuilder. The component-manager is\nalso responsible of the installation/removal of components from\nentando-core \n Entando-K8S-service \n The Entando-K8S-Service is part of the Entando infrastructure and is\nresponsible for the low-level communication with the K8S cluster API. \n Architecture \n \n From an architectural point of view, the ECR is composed of 1. The\nEntandoDeBundles which contain the metadata associated with a bundle 2.\nThe Entando-k8s-service which reads the bundles from the\ncluster/namspace(s) and serves them via a consumable API 3. The\nComponent-manager which creates the connection between the EntandoApp\nand the K8S-service. \n Example flow \n \n \n The user lands on the ECR page in app-builder and wants to see the\nlist of bundles shared with that EntandoApp \n \n \n AppBuilder asks the component-manager for the list of available\nbundles \n \n \n Component-manager queries the k8s-service to get the available\nbundles \n \n \n The k8s-service queries the cluster/namespace(s) it is able to read\nfrom for available bundles and returns the list to the\ncomponent-manager \n \n \n Component-manager returns a list to App-Builder \n \n \n The user is able to see the available bundles and is able to install\none or more of them \n \n \n"},{title:"How to customize bundle info shown in Entando App Builder",frontmatter:{},regularPath:"/v6.1/tutorials/ecr/ecr-bundle-presentation-config.html",relativePath:"v6.1/tutorials/ecr/ecr-bundle-presentation-config.md",key:"v-5ccc0800",path:"/v6.1/tutorials/ecr/ecr-bundle-presentation-config.html",lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:" How to customize bundle info shown in Entando App Builder \n \n In the image above you can see an example of a bundle as is displayed in the ECR user interface inside the Entando App Builder. \n The corresponding custom-resource file on Kubernetes is similar to this: \n apiVersion: entando.org/v1\nkind: EntandoDeBundle\nmetadata:\n  name: simple-entando-bundle\nspec:\n  details:\n    name: \"Entando Bundle\"\n    description: An example of an Entando bundle\n    dist-tags:\n      latest: v0.0.1\n    time:\n      created: '2020-05-20T15:59:21.946Z'\n      modified: '2020-05-20T15:59:21.946Z'\n      v0.0.1: '2020-05-20T15:59:21.946Z'\n    versions:\n      - v0.0.1\n    keywords:\n      - entando6\n    author: Entando\n    thumbnail: >-\n      data:image/jpeg;base64,....\n  tags:\n....\n \n In order to change the UI elements, you need to update the custom-resource in accordance with this table \n \n \n \n Field \n UI Element \n \n \n \n \n spec.details.name \n Set the bundle title \n \n \n spec.details.description \n Set the bundle description (only visible in the list presentation format) \n \n \n spec.details.thumbnail \n Set the bundle thumbnail, expressed as a base64 encoded string \n \n \n spec.details.dist-tags.latest \n Set what's the latest version of the bundle \n \n \n \n"},{title:"Filtering bundles",frontmatter:{},regularPath:"/v6.1/tutorials/ecr/ecr-bundle-filters.html",relativePath:"v6.1/tutorials/ecr/ecr-bundle-filters.md",key:"v-861cc580",path:"/v6.1/tutorials/ecr/ecr-bundle-filters.html",headers:[{level:3,title:"Supported labels keys are:",slug:"supported-labels-keys-are"},{level:3,title:"Example",slug:"example"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:' Filtering bundles \n ECR bundles are filterable by component from App Builder user interface. \n \n Behind the scenes, filtering is done using the label-based filtering provided out of the box from Kubernetes. \n To enable filtering of a bundle, the custom-resource representing the bundle on the Entando Cluster needs to contain the correct labels. An important note on the values to add the the  labels  field, even if to correctly define a label in a k8s resource both the key and the value are required, from an Entando point of view only the key part of the label is used for filtering. The value could be set to anything, but our reccomendation is to use  "true"  for clarity and simplicity. \n Supported labels keys are: \n \n \n \n \n \n \n \n Label entry \n Description \n \n \n \n \n widget: "true" \n The bundle contains one or more microfrontends (widgets)  \n \n \n plugin: "true" \n The bundle contains one or more microservices (plugins) \n \n \n fragment: "true" \n The bundle contains one or more fragments \n \n \n page: "true" \n The bundle contains one or more pages \n \n \n pageTemplate: "true" \n The bundle contains one or more page templates \n \n \n contentType: "true" \n The bundle contains one or more content types \n \n \n contentTemplate: "true" \n The bundle contains one or more content templates \n Example \n Here an example of the metadata for a ecr bundle containg micro-frontends, some microservices, pages and page templates \n apiVersion: entando.org/v1\nkind: EntandoDeBundle\nmetadata:\n  name: demo-bundle\n  labels:\n    widget: "true"\n    plugin: "true"\n    page: "true"\n    pageTemplate: "true"\nspec:\n  details:\n  ...\n \n '},{title:"Troubleshooting ECR",frontmatter:{},regularPath:"/v6.1/tutorials/ecr/ecr-troubleshooting-guide.html",relativePath:"v6.1/tutorials/ecr/ecr-troubleshooting-guide.md",key:"v-176c11e4",path:"/v6.1/tutorials/ecr/ecr-troubleshooting-guide.html",headers:[{level:2,title:"A bundle installation/removal has failed, how to access the logs?",slug:"a-bundle-installation-removal-has-failed-how-to-access-the-logs"},{level:3,title:"Overview",slug:"overview"},{level:3,title:"Solution",slug:"solution"},{level:2,title:"My bundle has an issue, how should I publish a new version of the bundle?",slug:"my-bundle-has-an-issue-how-should-i-publish-a-new-version-of-the-bundle"},{level:3,title:"Overview",slug:"overview-2"},{level:3,title:"Solution",slug:"solution-2"},{level:2,title:"Bundle installation fails because a file has not been found in the bundle",slug:"bundle-installation-fails-because-a-file-has-not-been-found-in-the-bundle"},{level:3,title:"Overview",slug:"overview-3"},{level:3,title:"Solution",slug:"solution-3"},{level:2,title:"Bundle installation failed due to plugin(s) images not reachable",slug:"bundle-installation-failed-due-to-plugin-s-images-not-reachable"},{level:3,title:"Overview",slug:"overview-4"},{level:3,title:"Solution",slug:"solution-4"},{level:2,title:"I can't uninstall a bundle because some components are in use",slug:"i-can-t-uninstall-a-bundle-because-some-components-are-in-use"},{level:3,title:"Overview",slug:"overview-5"},{level:3,title:"Solution",slug:"solution-5"}],lastUpdated:"6/27/2020, 10:35:02 PM",lastUpdatedTimestamp:1593311702e3,content:" Troubleshooting ECR \n A bundle installation/removal has failed, how to access the logs? \n Overview \n Currently the Entando component manager logs are available in kubernetes via dashboard (openshift) or cli tools (k9s or kubectl).\nIf in you Entando cluster you have more than one Entando App custom resource, you will need to know what's the correct component-manager to check using the corresponding Entando App name and namespace where the app has been deployed. \n Solution \n Using  kubectl  and assuming for simplicity that you have only one Entando App named  quickstart  and your Entando cluster is only composed of one namespace, also named  quickstart ,\nyou can get the component-manager logs using the command \n kubectl logs -f deployment/quickstart-server-deployment --namespace quickstart -c de-container\n \n Note : the  -f  flag is optional and could be used to follow the logs for debugging purposes \n My bundle has an issue, how should I publish a new version of the bundle? \n Overview \n Sometimes a bundle could have some issues: typos in the  descriptor.yaml  file, wrong references of components or to not available docker images are just a few of the possible errors. \n Solution \n \n If the bundle is shared using a git repository, you can make the required changes to your project and publish the new version to git and generate a new tag for it. \n Once the new tag is published, update the bundle costum-resource avaialble in you Entando Cluster by adding the new tag to the  tags  objects  and replacing the latest  dist-tags  to point to this new version. \n Proceed with the new installation \n \n If you're actively working on your bundle and you simply want to verify things are working correctly, instead of generating a new tag for each release of the bundle you can try to keep overriding a specific tag using the git command  git tag -f . We suggest you to follow this practice only during development and not in production. \n Bundle installation fails because a file has not been found in the bundle \n Overview \n When a component that is referenced in the  descriptor.yaml  is missing in the bundle or not correctly referenced, the bundle installation fails and in the logs is reported which file has not been found. \n ERROR - File with name {filename} not found in the bundle\n Solution \n When such a problem happens, verify that the component referenced in the descriptor file are actually present in the bundle and that the reference is properly typed. \n Publish a new version of your bundle as described in the\n \"My bundle has an issue\"  section \n Bundle installation failed due to plugin(s) images not reachable \n Overview \n Plugin included in a bundle are referenced using their docker image. Sometime the image is not available - maybe has not yet be published or is in a private docker registry - and plugin installation can't happen and the entire bundle installation process can't finish successfully \n Solution \n Verify that the docker image you are referencing is correct and publicly available. \n \"My bundle has an issue\"  section \n I can't uninstall a bundle because some components are in use \n Overview \n When removing an installed bundle, the Entando component manager verfies that the bundle components\nare not in use by any other component. Removing such components would cause an error during removal\nas in certain case the deleting a component in use is not permitted. \n Solution \n In order to prevent such errors, the user is alerted and required to manually decouple the bundle\ncomponents before beign able to completely remove the bundle from the system. \n"},{title:"Create a local NPM registry for testing",frontmatter:{},regularPath:"/v6.1/tutorials/ecr/how-to-create-local-npm-registry.html",relativePath:"v6.1/tutorials/ecr/how-to-create-local-npm-registry.md",key:"v-580c2f40",path:"/v6.1/tutorials/ecr/how-to-create-local-npm-registry.html",headers:[{level:2,title:"Start local nexus as a docker container",slug:"start-local-nexus-as-a-docker-container"},{level:2,title:"Setup a private npm registry",slug:"setup-a-private-npm-registry"},{level:2,title:"Setup npm-realm and user for publishing",slug:"setup-npm-realm-and-user-for-publishing"},{level:2,title:"Create the role",slug:"create-the-role"},{level:2,title:"Create the user",slug:"create-the-user"},{level:2,title:"Enable npm realm to support npm adduser or npm login",slug:"enable-npm-realm-to-support-npm-adduser-or-npm-login"},{level:2,title:"Configure NPM",slug:"configure-npm"},{level:2,title:"Config npm to use the local repository",slug:"config-npm-to-use-the-local-repository"},{level:2,title:"Login to the registry",slug:"login-to-the-registry"},{level:2,title:"Good to go",slug:"good-to-go"},{level:2,title:"Set the publish repository at package.json level",slug:"set-the-publish-repository-at-package-json-level"}],lastUpdated:"2/14/2022, 9:18:26 AM",lastUpdatedTimestamp:1644848306e3,content:' Create a local NPM registry for testing \n As a registry you can use whatever technology you prefer. Some examples\nare the  NPM official registry ,\n Verdaccio  or\n Nexus \n For development purposes, let’s start a local Nexus repository and set\nit up as NPM registry \n Start local nexus as a docker container \n Start by creating a volume to host all the data you will build in nexus.\nThis is useful to save the content even if you will remove the docker\ncontainer. You can follow two different approaches here: 1. You create a\ndocker volume and mount it (that’s the sonatype recommanded approach) 2.\nYou create a folder, change the modification to 777 and use that as a\nvolume \n By following the first approach, here are the commands you will need to\nissue in order to run Nexus as a docker container using the docker\ncommand \n docker volume create --name nexus-data\ndocker run -d -p 8081:8081 --name nexus -v nexus-data:/nexus-data sonatype/nexus3\n \n With the second approach, create a directory (e.g.  nexus-data ) and set\nthe own to UID 200 \n mkdir nexus-data && chown -R 200:200 nexus-data\ndocker run -d -p 8081:8081 --name nexus -v "$(pwd)/nexus-data":/nexus-data sonatype/nexus3\n \n Nexus should be available at your localhost at port 8081 \n Now you need to sign-in as an admin to configure Nexus and make it\nusable as a private npm repository. To do so, you need to get the admin\ncredential from inside the container. \n docker exec -it nexus cat /nexus-data/admin.password\n \n Now you can use the password to access your private nexus instance as an\nadmin and change the admin password to something easier for you to work\nwith. \n Setup a private npm registry \n \n NOTE : Nexus allows you to setup both a private registry and a\nproxy to an external registry. For development purposes, having only a\nprivate registry could make sense in order to retrieve only local\nmodules and not modules available on remote registries, though feel\nfree to setup also a proxy if you want to get access to npm modules\noutside of the private registry. Check out the\n documentation \non nexus website for further details. \n \n To setup a local repository: 1. Go to the\n Server administration and configuration  page 2. Go to repositories 3.\nCreate a new repository 4. Choose the  npm (hosted)  5. Provide a name\nand save \n \n NOTE : If you want you can also create a group repository to\nsupport search from multiple sources (local/proxies) at the same time. \n Setup npm-realm and user for publishing \n In order to be able to login and publish into a repository you need to \n \n Create a role to enable user publishing 2. Create a user and assign\nroles to them 3. Enable the NPM realm to support  npm adduser  or\n npm login  commands \n Create the role \n \n \n Go to  Security > Roles > Create role > Nexus Role \n \n \n Choose a role ID and name \n \n \n In the privileges, add the one required for publishing, e.g.\n nx-repository-view-npm-<your-repo>-* \n \n \n Save \n Create the user \n \n \n Go to  Security > Users > Create local user \n \n \n Add the relevant informations for your user, set the user  Active \nand add the role you created in the previous step \n Enable npm realm to support  npm adduser  or  npm login \n \n \n Go to  Security > Realms \n \n \n Add  the npm Bearer Token Realm  to the active column \n Configure NPM \n Config npm to use the local repository \n In order to use the private repository as default repository you need to\nconfigure npm accordingly (or use the  --registry=  option with all your\ncommands) \n npm config set registry http://localhost:8081/repository/<repo-name>/\n \n \n Note A : The trailing slash at the end of the repository is\nrequired for the repository to work \n \n \n Note B : This repository will be used for all the npm methods, so\nbare in mind that changing the global repository will potentially\nbreak other projects. If you want to avoid this, continue to use the\n --registry  option. \n Login to the registry \n You should be able to login to the registry using the login command \n npm login --registry=http://localhost:8081/repository/<repo-name>/\n Good to go \n You can now publish your own npm modules to the private registry using\nthe publish command \n npm publish --registry=http://localhost:8081/repository/<repo-name>/\n Set the publish repository at package.json level \n In your npm module you can also add to the  package.json  an entry to\nmake the private repository the default for publishing. Add this to your\npackage.json file \n   "publishConfig": {\n    "registry": "http://localhost:8081/repository/<repo-name>/"\n  }\n \n '},{title:"Bundle uninstall",frontmatter:{},regularPath:"/v6.1/tutorials/ecr/ecr-uninstall-flow.html",relativePath:"v6.1/tutorials/ecr/ecr-uninstall-flow.md",key:"v-ddda39c0",path:"/v6.1/tutorials/ecr/ecr-uninstall-flow.html",headers:[{level:2,title:"Uninstall process",slug:"uninstall-process"},{level:2,title:"Troubleshooting",slug:"troubleshooting"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:" Bundle uninstall \n Uninstall process \n To uninstall a bundle that was previously installed on an Entando App Engine, from Entando App builder UI go to\nthe  Component Repository  tab and select the bundle you want to uninstall \n \n An initial check is made to verify none of the bundle components are in use.\nIf any of the components are in use, a popup will alert you.\nNote that you can't force the removal of a bundle if its components are in use. \n Once the removal process starts: \n \n Bundle resources are deleted from the Entando App Engine \n Components included in the bundle are removed from the Entando App Engine \n Plugins are unlinked \n Troubleshooting \n If any error happens during the uninstall process and you don't know what to do,\ncheck out the  Troubleshooting guide  or the  Entando Forum \n"},{title:"How to setup a Nexus instance on a Kubernetes cluster",frontmatter:{},regularPath:"/v6.1/tutorials/ecr/how-to-setup-nexus-on-kubernetes-cluster.html",relativePath:"v6.1/tutorials/ecr/how-to-setup-nexus-on-kubernetes-cluster.md",key:"v-cd20d140",path:"/v6.1/tutorials/ecr/how-to-setup-nexus-on-kubernetes-cluster.html",headers:[{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Create a namespace for nexus",slug:"_1-create-a-namespace-for-nexus"},{level:3,title:"2. Create the deployment file.",slug:"_2-create-the-deployment-file"},{level:3,title:"3. Create the deployment",slug:"_3-create-the-deployment"},{level:3,title:"4. Create a service for nexus",slug:"_4-create-a-service-for-nexus"},{level:3,title:"5. Access nexus",slug:"_5-access-nexus"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:' How to setup a Nexus instance on a Kubernetes cluster \n Requirements \n \n \n A kubernetes cluster (that could be minikube, minishift, microk8s,\netc.) \n \n \n A dedicated namespace for nexus (we are going to use  nexus  as\ntarget namespace) \n Steps \n 1. Create a namespace for nexus \n We are going to deploy our nexus instance on a namespace called  nexus \n kubectl create namespace nexus\n 2. Create the deployment file. \n Let’s create a  Deployment.yaml  file to describe our nexus\ndeployment. \n Here things get a little bit different between nexus 2.x and nexus 3.x.\nIn both cases though we are going to use a volume mount for nexus-data,\nremember that this is going to be removed when the pod is removed. In\nproduction you should probably use some kind of persistent data. \n Nexus 2.x \n Here we are passing a few customizable ENV variable and adding a volume\nmount for nexus data. \n Deployment.yaml. \n     apiVersion: apps/v1\n    kind: Deployment\n    metadata:\n      name: nexus\n      namespace: nexus\n    spec:\n      replicas: 1\n      template:\n        metadata:\n          labels:\n            app: nexus-server\n        spec:\n          containers:\n            - name: nexus\n              image: sonatype/nexus:latest\n              env:\n              - name: MAX_HEAP\n                value: "800m"\n              - name: MIN_HEAP\n                value: "300m"\n              resources:\n                limits:\n                  memory: "4Gi"\n                  cpu: "1000m"\n                requests:\n                  memory: "2Gi"\n                  cpu: "500m"\n              ports:\n                - containerPort: 8081\n              volumeMounts:\n                - name: nexus-data\n                  mountPath: /sonatype-work\n          volumes:\n            - name: nexus-data\n              emptyDir: {}\n Nexus 3.x \n For Nexus 3.x we dont use any custom env variables. You can check the\nofficial docker repo for the supported env variables. \n Deployment.yaml. \n     apiVersion: extensions/v1beta1\n    kind: Deployment\n    metadata:\n      name: nexus\n      namespace: nexus\n    spec:\n      replicas: 1\n      selector:\n        matchLabels:\n            app: nexus-server\n      template:\n        metadata:\n          labels:\n            app: nexus-server\n        spec:\n          containers:\n            - name: nexus\n              image: sonatype/nexus3:latest\n              resources:\n                limits:\n                  memory: "4Gi"\n                  cpu: "1000m"\n                requests:\n                  memory: "2Gi"\n                  cpu: "500m"\n              ports:\n                - containerPort: 8081\n              volumeMounts:\n                - name: nexus-data\n                  mountPath: /nexus-data\n          volumes:\n            - name: nexus-data\n              emptyDir: {}\n 3. Create the deployment \n Now let’s create the deployment \n kubectl create -f Deployment.yaml\n \n You can check the deployment pod status with \n kubectl get pod -n nexus\n 4. Create a service for nexus \n Now you need to create a  Service.yaml  file that will to expose the\nnexus endpoint using NodePort. \n \n Note \n If you are on a cloud, you can expose the service using a load\nbalancer using the service type Loadbalancer. Also, the Prometheus\nannotations will help in service endpoint monitoring by Prometheus. \n \n Service.yaml. \n apiVersion: v1\nkind: Service\nmetadata:\n  name: nexus-service\n  namespace: devops-tools\n  annotations:\n      prometheus.io/scrape: \'true\'\n      prometheus.io/path:   /\n      prometheus.io/port:   \'8081\'\nspec:\n  selector:\n    app: nexus-server\n  type: NodePort\n  ports:\n    - port: 8081\n      targetPort: 8081\n      nodePort: 32000\n \n Now you can create the service \n kubectl create -f Service.yaml\n \n Check the service configuration using kubectl. \n kubectl describe service nexus-service -n devops-tools\n 5. Access nexus \n Now you will be able to access nexus on any of the Kubernetes node IP on\nport 32000/nexus as we have exposed the node port. For example, \n \n \n \n \n \n \n \n Service \n Url \n \n \n Nexus 2 \n http://35.144.130.153:32000/nexus \n \n \n Nexus 3 \n http://35.144.130.153:32000 \n \n \n \n \n Note \n For Nexus 2.x and Nexus 3 < 3.17 the default username and password\nwill be admin & admin123, while for Nexus 3 >= 3.17 you need to get\nthe password from within the container with\n cat /nexus-data/admin.password \n \n'},{title:"Creating an Entando Component Repository (ECR) bundle using npm registry",frontmatter:{},regularPath:"/v6.1/tutorials/ecr/tutorials/create-ecr-bundle-from-npm.html",relativePath:"v6.1/tutorials/ecr/tutorials/create-ecr-bundle-from-npm.md",key:"v-af750026",path:"/v6.1/tutorials/ecr/tutorials/create-ecr-bundle-from-npm.html",headers:[{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Create a bundle folder",slug:"_1-create-a-bundle-folder"},{level:3,title:"2. Add a descriptor.yaml file",slug:"_2-add-a-descriptor-yaml-file"},{level:3,title:"3. Add a simple component to the bundle",slug:"_3-add-a-simple-component-to-the-bundle"},{level:3,title:"4. Make the bundle an NPM module to be hostable on an NPM registry.",slug:"_4-make-the-bundle-an-npm-module-to-be-hostable-on-an-npm-registry"},{level:3,title:"5. Publish the bundle on an NPM registry",slug:"_5-publish-the-bundle-on-an-npm-registry"},{level:3,title:"6. Create the EntandoDeBundle custom resource for Kubernetes",slug:"_6-create-the-entandodebundle-custom-resource-for-kubernetes"},{level:3,title:"7. Upload the bundle to Kubernetes",slug:"_7-upload-the-bundle-to-kubernetes"},{level:2,title:"Conclusion",slug:"conclusion"},{level:2,title:"Resources",slug:"resources"}],lastUpdated:"12/15/2020, 3:24:13 PM",lastUpdatedTimestamp:1608063853e3,content:' Creating an Entando Component Repository (ECR) bundle using npm registry \n Purpose \n Generate a simple Entando Component Repository (ECR) bundle shareable in an Entando 6 environment using npm registry \n Requirements \n You can create the bundle using you favorite text/code editor. To share the bundle you will need: \n \n Node / NPM \n An NPM registry where to upload the bundle \n A K8S cluster where to upload the bundle (e.g. minikube, microk8s, minishift) configured correctly for Entando 6 \n A namespace in the cluster reachable from the operator and entando-k8s-service \n The  entando-bundle-cli  command-line tool to generate the necessary metadata to share the bundle in a Kubernetes cluster \n Steps \n 1. Create a bundle folder \n To start, let’s create a new folder to host your bundle. \n mkdir example-bundle && cd example-bundle\n 2. Add a descriptor.yaml file \n For a bundle to be readable by the ECR it will need at least a  descriptor.yaml  file in the folder. Let’s create it with some minimal information. \n vim descriptor.yaml\n \n Here is some content for your base descriptor. \n code: example-bundle\ndescription: This is an example of an Entando 6 bundle\n\ncomponents:\n 3. Add a simple component to the bundle \n This bundle will contains only a simple widget. \n Let’s first create the widget metadata in a dedicated folder. \n mkdir widgets\n\nvim widgets/example-widget.yaml\n \n Now let’s populate the  example-widget.yaml  metadata with some content: \n code: example-widget\ntitles:\n  en: Example Widget\n  it: Widget d\'esempio\ngroup: free\ncustomUi: <h2>Hi from Example Widget</h2>\n \n Finally, add a reference to this widget in the bundle  descriptor.yaml  file. \n code: example-bundle\ndescription: This is an example of a Entando 6 bundle\n\ncomponents:\n    widgets:\n        - widgets/example-widget.yaml\n 4. Make the bundle an NPM module to be hostable on an NPM registry. \n From the bundle root, initialize a  package.json  file \n npm init\n \n Follow the instructions on screen. Here is an example of a possible  package.json  file: \n {\n  "name": "example-bundle",\n  "version": "1.0.0",\n  "description": "An example of an Entando6 bundle",\n  "license": "LGPL-2.1",\n  "main": "descriptor.yaml",\n  "keywords": [\n    "entando6",\n    "digital-exchange",\n    "entando-de-bundle"\n  ]\n}\n \n \n Note \n Try to keep the name of the published bundle the same as the bundle code in the descriptor.yaml file to avoid confusion. \n 5. Publish the bundle on an NPM registry \n Now your bundle is ready to be published on an NPM registry. \n From the root of the bundle (where the package.json and descriptor.yaml files are) you can issue an  npm publish  command. \n \n Important \n It would be ideal to have a private npm registry to upload this into.\nCheck the  resources section  for more details; \n \n npm publish --registry=<your-registry>\n 6. Create the EntandoDeBundle custom resource for Kubernetes \n Assuming the "entando-bundle-cli" command-line utility is already installed and available globally on your system, you can now convert the module into an EntandoDeBundle K8S custom resource. We assume you have a namespace in a Kubernetes cluster which is readable from the Entando Operator and you have the permissions to create resources there. Let’s call this namespace  accessible-ns \n You can also provide a thumbnail for your bundle using  --thumbnail-url=<your-thumbnail-url . \n entando-bundle from-npm @entando/example-bundle --name=example-bundle --namespace=accessible-ns --dry-run > example-bundle.yaml\n 7. Upload the bundle to Kubernetes \n Now you simply need to upload the bundle into Kubernetes. \n kubectl create -f example-bundle.yaml\n Conclusion \n You should now have the bundle available in your cluster and accessible from the App Builder. \n Resources \n \n \n Setup a local npm registry for testing\npurposes \n \n \n Entando Bundle CLI\nproject \n \n \n'},{title:"Creating an Entando Component Repository (ECR) bundle from Blueprint",frontmatter:{},regularPath:"/v6.1/tutorials/ecr/tutorials/from-blueprint-to-de.html",relativePath:"v6.1/tutorials/ecr/tutorials/from-blueprint-to-de.md",key:"v-be5aa166",path:"/v6.1/tutorials/ecr/tutorials/from-blueprint-to-de.html",headers:[{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Generate an entity",slug:"_1-generate-an-entity"},{level:3,title:"2. Populate the bundle with the micro frontends",slug:"_2-populate-the-bundle-with-the-micro-frontends"},{level:3,title:"3. Generate a docker image for your microservice",slug:"_3-generate-a-docker-image-for-your-microservice"},{level:3,title:"4. Publish the Docker image to Docker registry (DockerHub or equivalent)",slug:"_4-publish-the-docker-image-to-docker-registry-dockerhub-or-equivalent"},{level:3,title:"5. Publish the bundle to an Npm registry",slug:"_5-publish-the-bundle-to-an-npm-registry"},{level:3,title:"6. Generate the EntandoDeBundle Kubernetes custom resource",slug:"_6-generate-the-entandodebundle-kubernetes-custom-resource"},{level:3,title:"7. Deploy the EntandoDeBundle custom resource on the cluster",slug:"_7-deploy-the-entandodebundle-custom-resource-on-the-cluster"},{level:2,title:"Conclusion",slug:"conclusion"},{level:2,title:"Resources",slug:"resources"}],lastUpdated:"7/10/2020, 10:24:52 AM",lastUpdatedTimestamp:1594391092e3,content:" Creating an Entando Component Repository (ECR) bundle from Blueprint \n Purpose \n In this tutorial you will learn how to generate an ECR bundle from a microservice generated using the JHipster’s Entando Blueprint. \n Requirements \n \n \n A microservice built with the Entando Blueprint \n \n \n Node and NPM are installed on your machine \n \n \n An NPM registry where to upload the bundle (must be logged in) \n \n \n Docker installed on your machine and you are able to upload images\nto docker-hub \n Steps \n \n Note \n In this tutorial we will assume you have generated at least an entity for your microservice. \n 1. Generate an entity \n In order to include auto-generated micro frontends to your bundle you will need to use the  jhispter entity  generator. Let’s assume we want to generate a simple  Conference  entity. \n jhipster entity Conference\n \n Let’s use these options: \n \n \n One field of type  String  called  name  with no validation \n \n \n No relationships with other entities \n \n \n REST controller should use the repository directly \n \n \n No pagination for the entity \n 2. Populate the bundle with the micro frontends \n To populate the bundle with the generated micro frontends, run the  ./buildBundle.sh  script or use the npm. \n npm run populate-bundle\n \n \n Important \nThe bundle population with the micro frontends requires some time to be processed. You should be able to follow the progress of the operation on screen. \n 3. Generate a docker image for your microservice \n JHipster uses the JIB Maven plugin to generate a docker image for your microservice. \n By default the output image will use the name of your application and the  0.0.1-SNAPSHOT  tag, eg.  entando/jhipster@0.0.1-SNAPSHOT . \n ./mvnw -Pprod clean package jib:dockerBuild [-Djib.to.image=<your-image-name]\n \n \n Note \n By default the organization used to generate the docker image is  entando , but you can provide a custom value during project initialization, as well as by changing the  pom.xml  file or by providing the  -Djib.to.image=<org>/<name>:<version>  to the  jib:dockerBuild  command. \n \n \n Note \n Output image name is generated using the organization value defined during project initialization. You can override the provided values by altering the  pom.xml  file or by customizing the  -Djib.to.image  parameter used in the  ./mvnw  command \n \n \n Warning \n If you manually override the target image of the docker build, remember to update the plugin metadata in the bundle accordingly. \n 4. Publish the Docker image to Docker registry (DockerHub or equivalent) \n Let’s now publish the docker image for the microservice to make it available later during bundle installation in the cluster. \n docker push <name-of-the-image:tag>\n 5. Publish the bundle to an Npm registry \n Now let’s publish the bundle to your private NPM registry. \n cd bundle/\n\nnpm publish . --registry=<your-private-registry-url>\n 6. Generate the EntandoDeBundle Kubernetes custom resource \n You should now be able to generate an EntandoDeBundle custom resource using the  entando-bundle  command-line tool. \n \n Warning \n Make sure both the NPM registry where you published the bundle and the Docker registry where you published the docker image are accessible in read mode without restrictions. \n \n entando-bundle from-npm <your-bundle-name> --dry-run --registry=<your-private-registry> [--name=<custom-name>] [--namespace=<namespace-to-deploy>] > jhipster-bundle.yaml\n 7. Deploy the EntandoDeBundle custom resource on the cluster \n Finally, let’s deploy the previously generated custom resource on the Kubernetes/OpenShift cluster \n kubectl create -f jhipster-bundle.yaml\n Conclusion \n You should now have the bundle available in your cluster and accessible from App Builder. \n Resources \n \n \n Setup a local npm registry for testing\npurposes \n \n \n Entando Bundle CLI\nproject \n \n \n Entando blueprint \n \n \n"},{title:"Use Blueprint generated plugin and microfrontend without a bundle",frontmatter:{},regularPath:"/v6.1/tutorials/ecr/tutorials/ecr-deploy-use-plugin-and-mfe-without-bundle.html",relativePath:"v6.1/tutorials/ecr/tutorials/ecr-deploy-use-plugin-and-mfe-without-bundle.md",key:"v-1df409ed",path:"/v6.1/tutorials/ecr/tutorials/ecr-deploy-use-plugin-and-mfe-without-bundle.html",headers:[{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:2,title:"1. Generate an entity using the Blueprint",slug:"_1-generate-an-entity-using-the-blueprint"},{level:2,title:"2. Populate the bundle with the micro frontends",slug:"_2-populate-the-bundle-with-the-micro-frontends"},{level:2,title:"3. Generate a docker image for your microservice",slug:"_3-generate-a-docker-image-for-your-microservice"},{level:2,title:"4. Publish the Docker image to Docker registry (DockerHub or equivalent)",slug:"_4-publish-the-docker-image-to-docker-registry-dockerhub-or-equivalent"},{level:2,title:"5. Deploy the plugin in your Entando Cluster",slug:"_5-deploy-the-plugin-in-your-entando-cluster"},{level:2,title:"6. Wait for your plugin to be in Running state and link the plugin with the app using an EntandoAppPluginLink custom resource",slug:"_6-wait-for-your-plugin-to-be-in-running-state-and-link-the-plugin-with-the-app-using-an-entandoapppluginlink-custom-resource"},{level:2,title:"7. Upload the Microfrontend to your EntandoApp",slug:"_7-upload-the-microfrontend-to-your-entandoapp"},{level:2,title:"8. Create a fragment for keycloak",slug:"_8-create-a-fragment-for-keycloak"},{level:2,title:"9. Import the fragment into the head section of the used page template",slug:"_9-import-the-fragment-into-the-head-section-of-the-used-page-template"},{level:2,title:"10. Use the microfrontend and microservice",slug:"_10-use-the-microfrontend-and-microservice"}],lastUpdated:"12/8/2021, 3:22:31 PM",lastUpdatedTimestamp:1638994951e3,content:' Use Blueprint generated plugin and microfrontend without a bundle \n Purpose \n In this tutorial you will learn how to use the plugin and microfrontend generated using the Entando Blueprint\nin a running cluster without the need to include the components in a bundle \n Requirements \n \n \n A microservice built with the Entando Component Generator \n \n \n Node and NPM are installed on your machine (use LTS version) \n \n \n Docker is installed on your machine and you are able to upload images to docker-hub or an image repository of your\nchoice \n \n \n An Entando Cluster where to deploy the Entando Plugin with a working instance of Entando App Builder\nand Entando App Engine \n Steps \n 1. Generate an entity using the Blueprint \n In order to include auto-generated micro frontends to your bundle you\nwill need to use the  jhispter entity  generator. Let’s assume we want\nto generate a simple  Conference  entity. \n jhipster entity Conference\n \n Let’s use these options: \n \n \n One field of type  String  called  name  with no validation \n \n \n No relationships with other entities \n \n \n REST controller should use the repository directly \n \n \n No pagination for the entity \n 2. Populate the bundle with the micro frontends \n \n To populate the bundle with the generated micro frontends, run the\n ./buildBundle.sh  script or use the npm. \n npm run populate-bundle\n \n \n Important \n The bundle population with the micro frontends requires some time to\nbe processed. You should be able to follow the progress of the\noperation on screen. \n 3. Generate a docker image for your microservice \n JHipster uses the JIB Maven plugin to generate a docker image for your\nmicroservice. \n The name of the output image generated with JIB will be composed by: \n \n The organization you chose during the setup wizard (by default that\'s set to  entando ) \n The name of the application \n Version  0.0.1-SNAPSHOT \n \n You can build the docker image with this command \n ./mvnw -Pprod clean package jib:dockerBuild\n \n If for example during setup wizard you chose a custom organization  myorg  and the set the application name to  jhipster  the resulting docker image is going to be  myorg/jhipster:0.0.1-SNAPSHOT \n \n Note \n Output image name can be changed in the  pom.xml  file by providing the\nby providing a different value in the  plugins.plugin.jib-maven-plugin.configuration.to.image  tag \n \n  <plugin>\n   <groupId>com.google.cloud.tools</groupId>\n   <artifactId>jib-maven-plugin</artifactId>\n   <configuration>\n     \x3c!-- ... --\x3e\n     <to>\n       <image>\x3c!-- use a custom value here --\x3e</image>\n     </to>\n     \x3c!-- ... --\x3e\n   </configuration>\n </plugin>\n \n \n Note \n Output image name can also be changed temporarely\nby customizing in the  ./mvnw  command using the  -Djib.to.image \nparameter. For example, if you want to build an image with organization  myneworg , name  myapp  and version  latest  you can do \n ./mvnw -Pprod clean package jib:dockerBuild -Djib.to.image=myneworg/myapp:latest\n \n \n \n Warning \n If you change the target image of the docker build, remember to update\nthe plugin metadata in the bundle accordingly. \n 4. Publish the Docker image to Docker registry (DockerHub or equivalent) \n Let’s now publish the docker image for the microservice to make it\navailable later during bundle installation in the cluster. \n docker push <name-of-the-image:tag>\n 5. Deploy the plugin in your Entando Cluster \n Assuming you have an Entando Cluster available in an  entando  namespace, you can now take\nthe plugin custom resource generated by the Entando Blueprint in the  bundle/plugins  folder and deploy it\nin your  entando  namespace. \n \n Warning \n As stated at step 4, if you changed the target image of your docker build, the plugin custom resource\nin the  bundle/plugins  folder needs to be updated to point to the correct image \n \n From the jhipster project root \n cd  bundle/plugins\n\nkubectl create -f  < plugin-file.yaml >  -n entando\n 6. Wait for your plugin to be in  Running  state and link the plugin with the app using an  EntandoAppPluginLink  custom resource \n Once the plugin server deployment will be up and running, you can create an  EntandoAppPluginLink custom resource \nto make the plugin API available from the EntandoApp domain.\nHere an example of a EntandoAppPluginLink custom resource. Some assumptions with this custom resource: \n \n The EntandoPlugin generated with the blueprint has name  my-demo-plugin \n The EntandoApp where I want to expose the  my-demo-plugin  apis is named  my-entando-app \n Both are deployed on the  entando  namespace. \n As a name for the link, I\'ll use  my-entando-app-to-my-demo-plugin-link \n \n \n Warning \nRemember to change the fields to match your setup. \n \n > cat <<EOF > /tmp/mylink.yaml\napiVersion: entando.org/v1\nkind: EntandoAppPluginLink\nmetadata:\n  name: my-entando-app-to-my-demo-plugin-link\n  namespace: entando\nspec:\n  entandoAppName: my-entando-app\n  entandoAppNamespace: entando\n  entandoPluginName: my-demo-plugin\n  entandoPluginNamespace: entando\nEOF\n \n Now add this link to your environment \n kubectl create -f /tmp/my-link.yaml -n entando\n \n A new link deployer will start and will work behind the scenes to add your plugin  ingressPath  (this is part of the\nplugin  spec ) to the EntandoApp ingress \n 7. Upload the Microfrontend to your EntandoApp \n Now that the the plugin and the app are linked together, you can proceed to generate the Micro Frontend from the App Builder\nand upload the static resources like  js  and  css  files. \n \n From AppBuilder access the File browser and create a new folder in the  public  folder and name like the name of the bundle (is the  code  field available\nin the  /bundle/descriptor.yaml  file of the blueprint project) or using a custom name, e.g.  demo-widget \n \n \n Warning \nIf you choose to use a custom folder, remember to update the references in the customUI of the widget later \n \n \n Upload all the resources generated in  step 2 of this guide  and available in the  /bundle/resources  folder\nof the blueprint project into the  demo-widget  folder of Entando App Builder file browser. \n \n \n Warning \nYou can decide to recreate the folder structure as the one in  /bundle/resources  or not, but you need to update the\nreferences in the customUi / configUI of the widget later \n \n \n Create the widget component from the  UX Patterns > Widgets  page. You can use whatever title you want, but for\nthe customUI copy the one generated in  step 2 of this guide  for one of the widgets you generated.\nAs an example, the customUI for the  detailWidget  of the conference entity is available in\n /bundle/ui/widgets/conference/detailsWidget/conference-details-widget.ftl \n \n \n Warning \nRemember to update all the references in the customUI to use the custom folder structure you defined in steps 7.1 and 7.2 \n \n \n You will need to update the service-url of your widgets to reflect the ingress path to your microservice created above. This path can be set on your customer element if you set it up during blueprint generation. For example, \n \n Create the widget on app-builder, you can see the right custom element to use into public/index.html\n\n\tUpdate the service-url value with the relative path of your service if you\'re deploying a bundle\n\t\tEx. <car-table service-url="/newBp/api"  />\n\tOr use the full path if you\'re deploying the BE and FE individually\n\t\tEx. <car-table service-url="http://newbp-plugin-entando.192.168.64.7.nip.io/newBp/api"/>\n 8. Create a fragment for keycloak \n \n In the App Builder go to  UX Patterns --\x3e Fragments . \n Select Add \n For the code enter  keycloak. \n Place the freemarker template below into the Gui Code field. \n \n <script src="http://ROUTE_TO_KEYCLOAK/auth/js/keycloak.js"><\/script>\n\t<script>\n\t  const keycloak = Keycloak(\'/entando-de-app/keycloak.json\');\n\t  function createKcDispatcher(payload) {\n\t    return () =>\n\t      window.dispatchEvent(\n\t        new CustomEvent("keycloak", { detail: payload })\n\t      );\n\t  }\n\t  keycloak.onReady = createKcDispatcher({ eventType: "onReady" });\n\t  keycloak.onAuthSuccess = createKcDispatcher({\n\t    eventType: "onAuthSuccess"\n\t  });\n\t  keycloak.onAuthError = createKcDispatcher({\n\t    eventType: "onAuthError"\n\t  });\n\t  keycloak.onAuthRefreshSuccess = createKcDispatcher({\n\t    eventType: "onAuthRefreshSuccess"\n\t  });\n\t  keycloak.onAuthRefreshError = createKcDispatcher({\n\t    eventType: "onAuthRefreshError"\n\t  });\n\t  keycloak.onAuthLogout = createKcDispatcher({\n\t    eventType: "onAuthLogout"\n\t  });\n\t  keycloak.onTokenExpired = createKcDispatcher({\n\t    eventType: "onTokenExpired"\n\t  });\n\t  const onInit = createKcDispatcher({ eventType: "onInit" });\n\t  window.entando = {\n\t    ...(window.entando || {}),\n\t    keycloak\n\t  };\n\t  window.entando.keycloak.init({ onLoad: "check-sso" }).success(onInit);\n\t<\/script>\n 9. Import the fragment into the head section of the used page template \n Add the following freemarker snippet to the page template you are using for your pages. \n <@wp.fragment code="keycloak" escapeXml=false />\n 10. Use the microfrontend and microservice \n You can now use your micro frontend and your microservice in your Entando App. \n'},{title:"Microfrontends",frontmatter:{sidebarDepth:2},regularPath:"/v6.1/tutorials/micro-frontends/",relativePath:"v6.1/tutorials/micro-frontends/README.md",key:"v-09fe236b",path:"/v6.1/tutorials/micro-frontends/",headers:[{level:2,title:"Introduction",slug:"introduction"},{level:2,title:"Tutorials",slug:"tutorials"}],lastUpdated:"12/15/2020, 3:24:13 PM",lastUpdatedTimestamp:1608063853e3,content:" Microfrontends \n Introduction \n \n The idea behind Micro Frontends is to think about a website or web app as  a composition of features  which are owned by  independent teams . Each team has a  distinct area of business  or  mission  it cares about and specialises in. A team is  cross functional  and develops its features  end-to-end , from database to user interface. \n —  Michael Geers,  micro-frontends.org \n \n Think of micro frontends as the implementation of a microservices architecture applied to the full web application that extends all the way to the frontend. \n Entando implements micro frontends based on  Web Components , a set of technologies that allow developers to create reusable custom elements supported by all major internet browsers. \n Web Components can work with vanilla JavaScript as well as with the most popular web frameworks (e.g., React, Angular, and Vue). \n Entando's microservice and micro frontend architecture allows developers to work with their favorite technology stack, and makes it easier for companies to integrate disparate applications. \n Tutorials \n \n \n Create a React Micro Frontend \n \n \n Create an Angular Micro Frontend \n \n \n Add an App Builder configuration screen to a\nwidget \n \n \n Display widget configuration \n \n \n The Entando Blueprint generated widgets \n \n \n Communicate Between Micro Frontends \n \n \n Widget authentication with Keycloak \n \n \n"},{title:"Tutorial: Blueprint generated widgets' overview",frontmatter:{},regularPath:"/v6.1/tutorials/micro-frontends/generate-micro-frontends-from-a-database-entity/",relativePath:"v6.1/tutorials/micro-frontends/generate-micro-frontends-from-a-database-entity/README.md",key:"v-7329955e",path:"/v6.1/tutorials/micro-frontends/generate-micro-frontends-from-a-database-entity/",headers:[{level:2,title:"Common parts",slug:"common-parts"},{level:3,title:"Authentication",slug:"authentication"},{level:3,title:"Custom events",slug:"custom-events"},{level:3,title:"Tests and mocks",slug:"tests-and-mocks"},{level:3,title:"PropTypes",slug:"proptypes"},{level:3,title:"Fetching data",slug:"fetching-data"},{level:2,title:"Form widget",slug:"form-widget"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:' Tutorial: Blueprint generated widgets\' overview \n When you create an entity using Entando blueprint, it generates a few\npremade widgets. In this section we will review them. \n We will be using  Conference  as an entity name for the examples below. \n Common parts \n Each widget contains a README file that should help you with the setup. \n All generated widgets are web components created using Custom Elements\nAPI. \n Each widget is displayed using the custom element tag - e.g., inside the\nDetails widget folder  conference/detailsWidget/public/index.html  you\ncan find\n conference-details id="1" override-edit-handler hide-edit-button /> .\nThis element  <conference-details />  is defined in the component entry\npoint at\n conference/detailsWidget/src/custom-elements/ConferenceDetailsElement.js . \n \n Note \n custom element names ( conference-details ) require a dash in them to\nbe used, e.g., (kebab-case) - they can not be single words. \n \n For more information about web components, custom elements and micro\nfrontends, please refer to "Create a react micro frontend widget"\nsection. \n Authentication \n If widget requires authentication, component is wrapped in\n KeycloakContext.Provider  and Keycloak object is fetched from\n window.entando.keycloak  variable. Entando is using Keycloak as our\nauthentication provider, but you can add any providers you like. \n ReactDOM.render(\n  <KeycloakContext.Provider value={this.keycloak}>\n    <StylesProvider jss={this.jss}>\n      <ThemeProvider theme={this.muiTheme}>{FormContainer}</ThemeProvider>\n    </StylesProvider>\n  </KeycloakContext.Provider>,\n  this.mountPoint\n);\n \n For more information about authentication implementation, please refer\nto the "Authentication" section. \n Custom events \n All widgets rely on custom events for communication which is why custom\nevent creation and removal is in each widget, as well as event listener\ncreation. Note that when an event listener is created, it should be when\nthe element is no longer needed. It should be created in the custom\nelement’s  disconnectedCallback()  function. \n To add more events to listen to the widgets, add the event types to\n INPUT_EVENT_TYPES  object at\n detailsWidget/src/custom-elements/widgetEventTypes.js  which will add\nit to the listener list (or remove the event by removing the element). \n For more information about custom events and widget communication,\nplease refer to the section on "Widget communication". \n Tests and mocks \n Each widget has tests written for it. Entando uses\n react-testing-library , but developers are free to upgrade and use any\ntool. Tests are kept at  detailsWidget/src/components/  and mocks for\nthem are at  detailsWidget/src/components/ . \n PropTypes \n PropTypes for data used across several components are shared - you can\nsee and modify them at  detailsWidget/src/components/ . This way you can\navoid repeating same propTypes in each component and just import shared\nones \n import React from \'react\';\nimport conferenceType from \'components/__types__/conference\';\n\nconst ConferenceDetails = props => {\n  // ...\n};\n\nConferenceDetails.propTypes = {\n  conference: conferenceType,\n  t: PropTypes.func.isRequired,\n};\n\nexport default ConferenceDetails;\n Fetching data \n For data fetching from widgets use Fetch API. You can find functions for\nfetching data at  detailsWidget/src/api  in different files for\ndifferent contexts. \n Form widget \n For displaying forms within a widget use\n Formik  which helps with form state\nmanagement. For data validation use\n Yup . \n'},{title:"Authentication",frontmatter:{},regularPath:"/v6.1/tutorials/micro-frontends/authentication/",relativePath:"v6.1/tutorials/micro-frontends/authentication/README.md",key:"v-2bb0591c",path:"/v6.1/tutorials/micro-frontends/authentication/",lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:" Authentication \n Keycloak is used for authentication. \n To set up keycloak server, please refer to Keycloak\n documentation . \n As all MFE widgets use the same Keycloak instance, it should be\ninitialized on a container of all widgets. \n Using Details widget generated using Entando JHipster blueprint as an\nexample, let’s get familiar with authentication implementation. \n As mentioned before, widget auth implementation assumes that Keycloak is\ninitialized outside of the widget. In Details example, it is done in\nindex.html where Keycloak server’s keycloak.js is used. \n <head>\n    <script src=\"keycloak.js\"><\/script>\n    <script>\n        var keycloak = new Keycloak();\n        keycloak\n          .init({ onLoad: 'check-sso' })\n          .success(onInit);\n    <\/script>\n</head>\n \n \n Note \n keycloak.js is provided by your Keycloak server at\n <SERVER_URL:PORT>/auth/js/keycloak.js \n \n Keycloak is initialized by passing Keycloak server path, realm and\nclient ID and calling  init({/* options */})  function. \n const keycloak = Keycloak({\n  url: 'http://localhost:9080/auth',\n  realm: 'jhipster',\n  clientId: 'jhipster-entando-react-client',\n});\n\nkeycloak\n  .init({ onLoad: 'check-sso' })\n  .success(onInit);\n \n Depending on Keycloak version you are using,  init()  function can\nreturn a Promise (newer versions support  promiseType: 'native' \noption). \n keycloak\n  .init({ onLoad: 'check-sso', promiseType: 'native' })\n  .then(authenticated => {\n    alert(authenticated ? 'Authenticated' : 'Not authenticated');\n  })\n  .catch(() => {\n    alert('Failed to initialize');\n  });\n \n All the Keycloak events are made custom events - this way widgets could\nreact to them if a need arises. \n function createKcDispatcher(payload) {\n  return () => window.dispatchEvent(new CustomEvent('keycloak', { detail: payload }));\n}\n\nkeycloak.onReady = createKcDispatcher({ eventType: 'onReady' });\nkeycloak.onAuthSuccess = createKcDispatcher({ eventType: 'onAuthSuccess' });\nkeycloak.onAuthError = createKcDispatcher({ eventType: 'onAuthError' });\nkeycloak.onAuthRefreshSuccess = createKcDispatcher({ eventType: 'onAuthRefreshSuccess' });\nkeycloak.onAuthRefreshError = createKcDispatcher({ eventType: 'onAuthRefreshError' });\nkeycloak.onAuthLogout = createKcDispatcher({ eventType: 'onAuthLogout' });\nkeycloak.onTokenExpired = createKcDispatcher({ eventType: 'onTokenExpired' });\nconst onInit = createKcDispatcher({ eventType: 'onInit' });\n \n Keycloak object is then stored into  window.entando  object for widgets\nto have access to. \n window.entando = {\n  ...(window.entando || {}),\n  keycloak,\n};\n \n On the widget side inside the custom element creation logic Keycloak\nobject is accessed and passed into the component via Keycloak context \n const getKeycloakInstance = () =>\n  (window &&\n    window.entando &&\n    window.entando.keycloak &&\n    { ...window.entando.keycloak, initialized: true }\n  ) || { initialized: false };\n\n\n// ...\n\nconstructor(...args) {\n  // ...\n  this.keycloak = getKeycloakInstance();\n}\n\nconnectedCallback() {\n  // ...\n  ReactDOM.render(\n    <KeycloakContext.Provider value={this.keycloak}>\n      <ConferenceDetailsContainer />\n    </KeycloakContext.Provider>,\n    this.mountPoint\n  );\n}\n \n And on the component side you can show different content depending on\nthe authentication status \n At  auth/KeycloakViews.js \n export const AuthenticatedView = ({ children, keycloak }) => {\n  const authenticated = keycloak.initialized && keycloak.authenticated;\n  return authenticated ? children : null;\n};\n\nexport const UnauthenticatedView = ({ children, keycloak }) => {\n  const authenticated = keycloak.initialized && keycloak.authenticated;\n  return !authenticated ? children : null;\n};\n \n At  components/ConferenceDetailsContainer.js \n render() {\n  const { conference, loading } = this.state;\n  const { t, keycloak } = this.props;\n\n  return (\n    <ThemeProvider theme={this.theme}>\n      <UnauthenticatedView keycloak={keycloak}>\n        {t('common.notAuthenticated')}\n      </UnauthenticatedView>\n      <AuthenticatedView keycloak={keycloak}>\n        {loading && t('common.loading')}\n        {!loading && <ConferenceDetails conference={conference} />}\n      </AuthenticatedView>\n    </ThemeProvider>\n  );\n}\n \n \n Note \n Keycloak object is accessible via props because of  withKeycloak  HOC:\n export default withKeycloak(ConferenceDetailsContainer); \n \n"},{title:"Create an Angular Micro Frontend",frontmatter:{sidebarDepth:2},regularPath:"/v6.1/tutorials/micro-frontends/angular.html",relativePath:"v6.1/tutorials/micro-frontends/angular.md",key:"v-3b0f49bc",path:"/v6.1/tutorials/micro-frontends/angular.html",headers:[{level:2,title:"Create Angular App",slug:"create-angular-app"},{level:3,title:"Convert to Custom Element",slug:"convert-to-custom-element"},{level:3,title:"Test Micro Frontend",slug:"test-micro-frontend"},{level:2,title:"Build It",slug:"build-it"},{level:2,title:"Host Micro Frontend",slug:"host-micro-frontend"},{level:3,title:"Create Public Folder",slug:"create-public-folder"},{level:3,title:"Add Widget",slug:"add-widget"},{level:3,title:"See It in Action",slug:"see-it-in-action"}],lastUpdated:"7/10/2020, 12:19:38 PM",lastUpdatedTimestamp:1594397978e3,content:" Create an Angular Micro Frontend \n Prerequisites \n \n A working instance of Entando. \n \n \n Tested Versions \n node v13.8.0 → We suggest using  nvm  to handle node installations. \n Create Angular App \n Install Angular CLI. \n npm   install  -g @angular/cli\n \n Generate a new angular application. \n ng new angular-widget\n \n Choose the following options: \n ? Would you like to  add  Angular routing? No\n? Which stylesheet  format  would you like to use? CSS\n \n Serve the application. \n cd  angular-widget\n \n ng serve\n \n This is the expected output: \n angular-widget\n├── e2e\n│   └── src\n│       ├── app.e2e-spec.ts\n│       └── app.po.ts\n│\n├── node_modules\n├── src\n│   ├── app\n│   │   ├── app.component.css\n│   │   ├── app.component.html\n│   │   ├── app.component.spec.ts\n│   │   ├── app.component.ts\n│   │   └── app.module.ts\n│   │\n│   ├── assets\n│   │   └── .gitkeep\n│   │\n│   ├── environment\n│   │   ├── environment.prod.ts\n│   │   └── environment.ts\n│   │\n│   ├── favicon.ico\n│   ├── index.html\n│   ├── main.ts\n│   ├── polyfills.ts\n│   ├── styles.css\n│   └── test.ts\n│\n├── .editorconfig\n├── .gitignore\n├── angular.json\n├── browserlist\n├── karma.conf.js\n├── package.json\n├── README.md\n├── tsconfig.app.json\n├── tsconfig.json\n├── tsconfig.spec.json\n└── tslint.json\n Convert to Custom Element \n Next, let's convert our Angular app into a custom element. We'll use  Angular elements  to transform components into custom elements. \n ng  add  @angular/elements\n \n WARNING \n Install the Angular elements package using  ng add , not with  npm install  as it runs additional steps behind the scenes like adding the  document-register-element  polyfill. \n \n TIP \n Angular elements are Angular components packaged as custom elements (also called Web Components), a web standard for defining new HTML elements in a framework-agnostic way. \n \n Open  angular-widget/src/app/app.component.ts . \n \n Here's what the initial file looks like: \n \n import   {  BrowserModule  }   from   '@angular/platform-browser' ; \n import   {  NgModule  }   from   '@angular/core' ; \n\n import   {  AppComponent  }   from   './app.component' ; \n\n@ NgModule ( { \n   declarations :   [ \n    AppComponent\n   ] , \n   imports :   [ \n    BrowserModule\n   ] , \n   providers :   [ ] , \n   bootstrap :   [ AppComponent ] \n } ) \n export   class   AppModule   {   } \n \n Replace the entire file with: \n import   {  BrowserModule  }   from   '@angular/platform-browser' ; \n import   {  NgModule ,  Injector  }   from   '@angular/core' ; \n import   {  createCustomElement  }   from   '@angular/elements' ; \n import   {  AppComponent  }   from   './app.component' ; \n\n@ NgModule ( { \n   declarations :   [ \n    AppComponent\n   ] , \n   imports :   [ \n    BrowserModule\n   ] , \n   providers :   [ ] , \n   entryComponents :   [ AppComponent ] \n } ) \n export   class   AppModule   { \n   constructor ( private   injector :  Injector )   { } \n\n   ngDoBootstrap ( )   { \n     const  el  =   createCustomElement ( AppComponent ,   {   injector :   this . injector  } ) ; \n    customElements . define ( 'angular-widget' ,  el ) ; \n   } \n } \n \n \n In the initial file,  AppComponent  is bootstrapped directly during application launch. \n In the updated file, we booststrap our custom element using the  ngDoBootstrap()  method . \n \n Custom Elements \n \n Must contain a hyphen  -  in the name. : \n Cannot be a single word. \n Should follow  kebab-case  for naming convention. \n Test Micro Frontend \n Now, let's check our custom element to see if it's working. \n Open  angular-widget/src/index.html . \n In the  <body> , replace  <app-root></app-root>  with your custom element  <angular-widget /> . \n <! doctype   html > \n < html   lang = \" en \" > \n < head > \n   < meta   charset = \" utf-8 \" > \n   < title > AngularWidget </ title > \n   < base   href = \" / \" > \n   < meta   name = \" viewport \"   content = \" width=device-width, initial-scale=1 \" > \n   < link   rel = \" icon \"   type = \" image/x-icon \"   href = \" favicon.ico \" > \n </ head > \n < body > \n   < angular-widget   /> \n </ body > \n </ html > \n \n Congratulations! \n You’re now running  Angular  in a containerized micro frontend. \n Build It \n From the project root, type: \n ng build --prod --outputHashing = none\n \n This will generate an  angular-widget/dist  directory. \n If we assume browser support for  ES6 (ECMAScript 2015) , we can focus on the following JavaScript files to publish our app: \n \n main-es2015.js \n polyfills-es2015.js \n runtime-es2015.js \n \n Generated Build Files \n --outputHashing=none  generates files without hashes so we can deploy new versions of the micro frontend without having to reconfigure our widget in Entando to point to the newly built files. \n \n If you want to use file names with content hashes to avoid potential caching issues in your browser, you can update the  Custom UI  field of your widget after building new versions of your micro frontend. Widget configuration is covered in the next section. \n Host Micro Frontend \n Now we're ready to host our micro frontend in Entando. \n Create Public Folder \n \n \n Navigate to  Entando App Builder  in your browser. \n \n \n Click  Configuration  at the upper right hand side of the screen. \n \n \n Click the  File Browser  tab. \n \n \n Click the  public  folder. \n \n \n Click  Create Folder . \n \n \n Enter  angular-widget \n \n \n Click  Save . \n \n \n Click  angular-widget . \n \n \n Click 'Upload Files`. \n \n \n Upload the following files from  angular-widget/dist/angular-widget : \n \n \n \n main-es2015.js \n polyfills-es2015.js \n runtime-es2015.js \n \n Additional Deployment Options \n \n Install the micro frontend from a bundle in the  Entando Component Repository . \n Add the micro frontend to  Entando App Builder . \n Load the micro frontend from an API. \n Add Widget \n \n \n Go to  Entando App Builder  in your browser. \n \n \n Click  UX Patterns  →  Widgets  at the top nav. \n \n \n Click  Add  at the upper right. \n \n \n Enter the following: \n \n \n \n \n Title: Angular Widget  → for both English and Italian languages \n Code: angular_widget  → note: dashes are not allowed \n Group: Free Access \n Custom UI: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < script   async   src = \" < @wp . resourceURL  /> angular-widget/main-es2015.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> angular-widget/polyfills-es2015.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> angular-widget/runtime-es2015.js \" > </ script > \n\n < angular-widget   /> \n \n \n Click  Save . \n \n TIP \n <#assign wp=JspTaglibs[ \"/aps-core\"]>  gives you access to the  @wp  object where you can use environment variables like  resourceURL . \n See It in Action \n Let's see the Angular micro frontend in action on our page. \n Add Page \n Note \n If you've already configured your home page: \n \n   Next to the  Home  folder, under  Actions , click  Configure . \n   Skip to the  Add Widget  section. \n \n \n Let's add our widget to the  Home  page. \n \n \n Click  Page Designer  →  Page Tree  at the top nav. \n \n \n Next to the  Home  folder, under  Actions , click  Edit . \n \n \n Next to  Page Template  select  Service Page . \n \n \n Click  Save and Configure . \n Add Widget \n \n \n In the Search field in right-hand sidebar, enter  Angular Widget . \n \n \n Drag and drop  Angular Widget  into the  Sample Frame  in the main body of the page. \n \n \n Click  Publish . \n \n \n At the upper right, click  Go to Homepage . \n \n \n \n Congratulations! \n You now have an Angular micro frontend running in Entando. \n \n"},{title:"Microfrontends",frontmatter:{},regularPath:"/v6.1/tutorials/micro-frontends/micro-frontends/",relativePath:"v6.1/tutorials/micro-frontends/micro-frontends/README.md",key:"v-2c5a4dbe",path:"/v6.1/tutorials/micro-frontends/micro-frontends/",headers:[{level:2,title:"Introduction",slug:"introduction"},{level:2,title:"Tutorials",slug:"tutorials"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:" Microfrontends \n Introduction \n \n The idea behind Micro Frontends is to think about a website or web app\nas  a composition of features  which are owned by  independent\nteams . Each team has a  distinct area of business  or  mission \nit cares about and specialises in. A team is  cross functional  and\ndevelops its features  end-to-end , from database to user interface. \n —  Michael Geers,  micro-frontends.org \n \n \n So, think of microfrontends as the implementation of microservices\nconcept to a full web app, UI included. \n The Entando way to microfrontends is based on  Web\nComponents ,\na set of technologies that allow developers to create reusable custom\nelements supported by all major internet browsers. \n Web Components can work with vanilla JS as well as with the most popular\nweb frameworks (React, Angular, Vue, etc.). \n That means the Entando platform enables developers work with their\nfavourite tech stack, and allows companies to quickly evolve their\ntechnology and to always look for best tech talents no matter the\nframework they use. \n The following tutorials will help you creating Entando Widgets using a\nmicrofrontend-based approach. \n Tutorials \n \n \n Create a React widget \n \n \n Create an Angular widget \n \n \n Add an App Builder configuration screen to a\nwidget \n \n \n Display widget configuration \n \n \n The Entando Blueprint generated widgets \n \n \n Communication between two React widgets \n \n \n Communication between an Angular widget and a React\nwidget \n \n \n Widget authentication with Keycloak \n \n \n"},{title:"Communicate Between Micro Frontends",frontmatter:{sidebarDepth:2},regularPath:"/v6.1/tutorials/micro-frontends/communication.html",relativePath:"v6.1/tutorials/micro-frontends/communication.md",key:"v-ca77df0c",path:"/v6.1/tutorials/micro-frontends/communication.html",headers:[{level:2,title:"Publisher",slug:"publisher"},{level:3,title:"Create Custom Event",slug:"create-custom-event"},{level:3,title:"Update React App to Dispatch Event",slug:"update-react-app-to-dispatch-event"},{level:3,title:"Test Event Dispatcher",slug:"test-event-dispatcher"},{level:2,title:"Subscriber",slug:"subscriber"},{level:3,title:"Add Event Listener",slug:"add-event-listener"},{level:3,title:"Display Custom Event",slug:"display-custom-event"},{level:3,title:"Test Event Listener",slug:"test-event-listener"},{level:2,title:"Add Widgets to App Builder",slug:"add-widgets-to-app-builder"},{level:3,title:"Create Environment File",slug:"create-environment-file"},{level:3,title:"Run npm build",slug:"run-npm-build"},{level:3,title:"Create Public Folder",slug:"create-public-folder"},{level:3,title:"Add Widgets",slug:"add-widgets"},{level:3,title:"Add Page Template",slug:"add-page-template"},{level:3,title:"View on Homepage",slug:"view-on-homepage"},{level:2,title:"Angular to React",slug:"angular-to-react"},{level:3,title:"Create Angular Publisher",slug:"create-angular-publisher"},{level:3,title:"Add to App Builder",slug:"add-to-app-builder"}],lastUpdated:"7/14/2020, 4:40:55 PM",lastUpdatedTimestamp:1594759255e3,content:" Communicate Between Micro Frontends \n Recommended Learning \n \n Tutorial:  Create a React Micro Frontend \n Tutorial:  Create an Angular Micro Frontend \n \n \n Entando supports communication between micro frontends using  Custom Events , an established web standard. In this tutorial, we'll build: \n \n A React micro frontend that publishes an event \n A React micro frontend that listens to an event \n An Angular micro frontend that publishes an event to a React micro frontend \n Publisher \n Create a simple app to publish an event. \n npx create-react-app publisher-widget --use-npm\n \n Start the app. \n cd  publisher-widget\n \n npm  start\n Create Custom Event \n Next, add event firing logic. \n Add a new file  publisher-widget/src/PublisherWidgetElement.js . \n import  React  from   'react' ; \n import  ReactDOM  from   'react-dom' ; \n import  App  from   './App' ; \n\n const   EVENTS   =   { \n   greeting :   'greeting' , \n } ; \n\n class   PublisherWidgetElement   extends   HTMLElement   { \n\n   constructor ( )   { \n     super ( ) ; \n     this . onGreet   =   name   =>   this . publishWidgetEvent ( EVENTS . greeting ,   {  name  } ) ; \n   } \n\n   connectedCallback ( )   { \n     this . mountPoint  =  document . createElement ( 'div' ) ; \n     this . appendChild ( this . mountPoint ) ; \n     this . render ( ) ; \n   } \n\n   publishWidgetEvent ( eventId ,  detail )   { \n     const  widgetEvent  =   new   CustomEvent ( eventId ,   {  detail  } ) ; \n    window . dispatchEvent ( widgetEvent ) ; \n   } \n\n   render ( )   { \n    ReactDOM . render ( < App onGreet = { this . onGreet }   / > ,   this . mountPoint ) ; \n   } \n } \n\ncustomElements . define ( 'publisher-widget' ,  PublisherWidgetElement ) ; \n\n export   default  PublisherWidgetElement ; \n \n \n In the  CustomEvent  constructor,  detail  is the specific name to use in the event payload, as per the  DOM specification . \n Import Custom Element \n Update  publisher-widget/src/index.js . \n import   './index.css' ; \n import   './PublisherWidgetElement' ; \n Test Custom Element \n Update  publisher-widget/public/index.html , and view it in the browser. \n    < body > \n     < noscript > You need to enable JavaScript to run this app. </ noscript > \n     < publisher-widget   /> \n    ...\n   </ body > \n Update React App to Dispatch Event \n Update  publisher-widget/src/App.js . \n import  React  from   'react' ; \n import   './App.css' ; \n\n class   App   extends   React . Component   { \n   constructor ( props )   { \n     super ( props ) ; \n     this . state  =   {   name :   '' } ; \n   } \n\n   handleNameChange ( value )   { \n     this . setState ( prevState   =>   ( { \n       ... prevState , \n       name :  value , \n     } ) ) ; \n   } \n\n   render ( )   { \n     const   {  name  }   =   this . state ; \n     const   {  onGreet  }   =   this . props ; \n     return   ( \n       < div > \n         < h1 > Send a greeting < / h1 > \n         < label htmlFor = \"name\" > Name < / label > \n         < input id = \"name\"  onChange = { e   =>   this . handleNameChange ( e . target . value ) }  value = { name }   / > \n         < button onClick = { ( )   =>   onGreet ( name ) } > Say hello ! < / button > \n       < / div > \n     ) ; \n   } \n } \n\n export   default  App ; \n Test Event Dispatcher \n In the JavaScript console of your browser, enter: \n window . addEventListener ( 'greeting' ,   ( evt )   =>  console . log ( 'Hello' ,  evt . detail . name ) ) \n \n Write something in the text field. Click the \"Say hello!\" button and take a look at the JS console. It will show the event message. \n Congratulations! \n You’ve now published a custom event. \n Subscriber \n Next, let’s create the subscriber. \n npx create-react-app subscriber-widget --use-npm\n \n Start the app. \n cd  subscriber-widget\n \n npm  start\n Add Event Listener \n Add a new file  subscriber-widget/src/SubscriberWidgetElement.js . \n import  React  from   'react' ; \n import  ReactDOM  from   'react-dom' ; \n import  App  from   './App' ; \n\n const   EVENTS   =   { \n   greeting :   'greeting' , \n } ; \n\n class   SubscriberWidgetElement   extends   HTMLElement   { \n\n   constructor ( )   { \n     super ( ) ; \n     this . name  =   null ; \n     this . subscribeToWidgetEvent ( EVENTS . greeting ,   ( evt )   =>   this . onGreeting ( evt . detail . name ) ) ; \n   } \n\n   connectedCallback ( )   { \n     this . mountPoint  =  document . createElement ( 'div' ) ; \n     this . appendChild ( this . mountPoint ) ; \n     this . render ( ) ; \n   } \n\n   subscribeToWidgetEvent ( eventType ,  eventHandler )   { \n    window . addEventListener ( eventType ,  eventHandler ) ; \n   } \n\n   onGreeting ( name )   { \n     this . name  =  name ; \n     this . render ( ) ; \n   } \n\n   render ( )   { \n    ReactDOM . render ( < App name = { this . name }   / > ,   this . mountPoint ) ; \n   } \n } \n\ncustomElements . define ( 'subscriber-widget' ,  SubscriberWidgetElement ) ; \n\n export   default  SubscriberWidgetElement ; \n Import Custom Element \n Update  subscriber-widget/src/index.js . \n import   './index.css' ; \n import   './SubscriberWidgetElement' ; \n Test Micro Frontend \n Update  subscriber-widget/public/index.html , and view it in the browser. \n    < body > \n     < noscript > You need to enable JavaScript to run this app. </ noscript > \n     < subscriber-widget > \n    ...\n   </ body > \n Display Custom Event \n Update  subscriber-widget/src/App.js . \n import  React  from   'react' ; \n import   './App.css' ; \n\n function   App ( {  name  } )   { \n   return  name  ?   ( < h2 > Just got a greeting from  { name } < / h2 > ) \n     :   ( < h2 > Waiting  for  a greeting ... < / h2 > ) ; \n } \n\n export   default  App ; \n Test Event Listener \n In the JavaScript console of your browser, enter: \n const  widgetEvent  =   new   CustomEvent ( 'greeting' ,   { \n   detail :   { \n     name :   'Pippo' \n   } , \n } ) ; \nwindow . dispatchEvent ( widgetEvent ) ; \n \n The custom event should now display in the  subscriber-widget . \n Congratulations! \n You’ve now created a micro frontend that listens to custom events. \n Add Widgets to App Builder \n Now let's add the publisher and subscriber micro frontends in Entando. \n \n Note: These are the same steps as the  Create a React Micro Frontend  tutorial. \n Create Environment File \n Publisher Widget \n \n \n Create an  .env  file in the project root for the  publisher-widget . \n \n \n Open the  .env  file, and enter the  PUBLIC_URL  where the micro frontend will be hosted. \n \n \n Example: \n PUBLIC_URL=http://quickstart-entando.192.168.64.34.nip.io/entando-de-app/cmsresources/publisher-widget\n \n Notes \n \n Replace  quickstart-entando.192.168.64.34.nip.io  with the ingress you use to access Entando from your local browser. \n /entando-de-app/cmsresources/  is your Resource URL. \n publisher-widget  is the public folder we'll create to host the publisher micro frontend. \n Subscriber Widget \n \n \n Create an  .env  file in the project root for the  subscriber-widget . \n \n \n Open the  .env  file, and enter the  PUBLIC_URL  where the micro frontend will be hosted. \n \n \n \n Use  subscriber-widget  for the name of the public folder we'll create to host the subscriber micro frontend. \n \n Example: \n PUBLIC_URL=http://quickstart-entando.192.168.64.34.nip.io/entando-de-app/cmsresources/subscriber-widget\n Run npm build \n Publisher Widget \n \n \n Open a command line, and navigate to the project root of the  publisher-widget . \n \n \n Run build. \n \n \n npm  run build\n \n \n Rename the following generated files in the  build  directory. \n \n \n \n \n Example of Generated Build File \n Rename to \n Function \n \n \n \n \n build/static/js/2.f14073bd.chunk.js \n static/js/vendor.js \n Third-party libraries \n \n \n build/static/js/runtime-main.8a835b7b.js \n static/js/runtime.js \n Bootstrapping logic \n \n \n build/static/js/main.4a514a6d.chunk.js \n static/js/main.js \n App \n \n \n build/static/css/main.5f361e03.chunk.css \n static/css/main.css \n Stylesheet \n Subscriber Widget \n \n Repeat steps 1-3 for the  subscriber-widget . \n Create Public Folder \n Publisher Widget \n \n \n Navigate to  Entando App Builder  in your browser. \n \n \n Click  Configuration  at the upper right hand side of the screen. \n \n \n Click the  File Browser  tab. \n \n \n Click the  public  folder. \n \n \n Click  Create Folder . \n \n \n Enter  publisher-widget . \n \n \n Click  Save . \n \n \n Click  public  →  publisher-widget . \n \n \n Create the same folder structure as your generated build directory \n \n \n \n publisher-widget/static/css \n publisher-widget/static/js \n \n \n Upload the files we renamed in the corresponding  js  and  css  folders. \n \n \n publisher-widget/static/css/main.css \n publisher-widget/static/js/main.js \n publisher-widget/static/js/runtime.js \n publisher-widget/static/js/vendor.js \n Subscriber Widget \n \n Repeat steps 1-10 for the  subscriber-widget . \n Add Widgets \n Publisher Widget \n \n \n Go to  Entando App Builder  in your browser. \n \n \n Click  UX Patterns  →  Widgets  at the top nav. \n \n \n Click  Add  at the upper right. \n \n \n Enter the following: \n \n \n \n Title: Publisher Widget  → for both English and Italian languages \n Code: publisher_widget  → note: dashes are not allowed \n Group: Free Access \n Custom UI: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < link   rel = \" stylesheet \"   type = \" text/css \"   href = \" < @wp . resourceURL  /> publisher-widget/static/css/main.css \" > \n < script   async   src = \" < @wp . resourceURL  /> publisher-widget/static/js/runtime.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> publisher-widget/static/js/vendor.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> publisher-widget/static/js/main.js \" > </ script > \n < publisher-widget   /> \n \n \n Click  Save . \n Subscriber Widget \n Repeat steps 1-5 for the subscriber widget. \n \n Title: Subscriber Widget  → for both English and Italian languages \n Code: subscriber_widget  → note: dashes are not allowed \n Group: Free Access \n Custom UI: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < link   rel = \" stylesheet \"   type = \" text/css \"   href = \" < @wp . resourceURL  /> subscriber-widget/static/css/main.css \" > \n < script   async   src = \" < @wp . resourceURL  /> subscriber-widget/static/js/runtime.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> subscriber-widget/static/js/vendor.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> subscriber-widget/static/js/main.js \" > </ script > \n < subscriber-widget   /> \n Add Page Template \n \n \n Click  UX Patterns  →  Page Templates  →  Add . \n \n \n Enter the following: \n \n \n \n Code: two_widget  → note: dashes are not allowed \n Name: Two Widget \n JSON Configuration: \n \n { \n   \"frames\" :   [ \n     { \n       \"pos\" :   0 , \n       \"descr\" :   \"Sample Frame\" , \n       \"mainFrame\" :   false , \n       \"defaultWidget\" :   null , \n       \"sketch\" :   null \n     } , \n     { \n       \"pos\" :   1 , \n       \"descr\" :   \"Sample Frame Two\" , \n       \"mainFrame\" :   false , \n       \"defaultWidget\" :   null , \n       \"sketch\" :   null \n     } \n   ] \n } \n \n \n Template: \n \n < #assign  wp = JspTaglibs [ \"/aps-core\" ] > \n <! DOCTYPE   HTML   PUBLIC   \"-//W3C//DTD HTML 4.0 Transitional//EN\" > \n < html > \n   < head > \n       < title > < @wp . currentPage param = \"title\"   /> </ title > \n   </ head > \n   < body > \n     < h1 > < @wp . currentPage param = \"title\"   /> </ h1 > \n     < div > < @wp . show frame = 0   /> </ div > \n     < div > < @wp . show frame = 1   /> </ div > \n   </ body > \n </ html > \n \n \n Click  Save . \n View on Homepage \n \n \n Click  Page Designer  →  Page Tree . \n \n \n For the  Home  page  (folder icon) , in the  Actions  column, click the  ⋮  icon \n \n \n Click  Edit . \n \n \n In the  Settings  section, select: \n \n \n \n Page Model: Two Widget \n \n \n \n Click  Save and Configure . \n \n \n In the  WIDGETS  sidebar on the right: \n \n \n \n Drag  Publisher Widget  and  Subscriber Widget  into  Sample Frame  and  Sample Frame Two . \n \n \n \n Click  Publish . \n \n \n To view the home page, scroll to the top of the page, and click  Go to Homepage . \n \n \n Enter a greeting in the input field. Press the submit button. The subscriber widget will update with the greeting. Done! \n \n \n Congratulations! \n You can now communicate between micro frontends with  Custom Events . \n Angular to React \n We can also communicate between micro frontends using different JavaScript frameworks. \n In this next example, we’ll create an Angular micro frontend to publish an event, and we'll use the React micro frontend we created in the previous section to receive the event. \n Create Angular Publisher \n ng new angular-publisher-widget\n \n Choose the following options: \n ? Would you like to  add  Angular routing? No\n? Which stylesheet  format  would you like to use? CSS\n \n Serve the application. \n cd  angular-publisher-widget\n \n ng serve\n Convert to Custom Element \n Next, let's convert our Angular app into a custom element. We'll use  Angular elements  to transform components into custom elements. \n ng  add  @angular/elements\n \n Replace the contents of  angular-widget/src/app/app.module.ts . \n \n In this file, we bootstrap the custom element using the  ngDoBootstrap  method. \n \n import   {  BrowserModule  }   from   '@angular/platform-browser' ; \n import   {  NgModule ,  Injector  }   from   '@angular/core' ; \n import   {  createCustomElement  }   from   '@angular/elements' ; \n import   {  AppComponent  }   from   './app.component' ; \n import   {  ReactiveFormsModule  }   from   '@angular/forms' ; \n\n@ NgModule ( { \n   declarations :   [ \n    AppComponent\n   ] , \n   imports :   [ \n    BrowserModule , \n    ReactiveFormsModule\n   ] , \n   providers :   [ ] , \n   entryComponents :   [ AppComponent ] \n } ) \n export   class   AppModule   { \n   constructor ( private   injector :  Injector )   { } \n\n   ngDoBootstrap ( )   { \n     const  el  =   createCustomElement ( AppComponent ,   {   injector :   this . injector  } ) ; \n    customElements . define ( 'angular-publisher-widget' ,  el ) ; \n   } \n } \n Create Custom Event \n Replace the contents of  angular-widget/src/app/app.component.ts . \n \n Here, we're adding code to dispatch the custom event. \n \n import   {  Component  }   from   '@angular/core' ; \n import   {  FormControl ,  FormGroup  }   from   '@angular/forms' ; \n\n const   EVENTS   =   { \n   greeting :   'greeting' , \n } ; \n\n@ Component ( { \n   selector :   'app-root' , \n   templateUrl :   './app.component.html' , \n   styleUrls :   [ './app.component.css' ] \n } ) \n export   class   AppComponent   { \n  greetingForm  =   new   FormGroup ( { \n     name :   new   FormControl ( '' ) , \n   } ) ; \n\n   publishWidgetEvent ( eventId ,  detail )   { \n     const  widgetEvent  =   new   CustomEvent ( eventId ,   {  detail  } ) ; \n    window . dispatchEvent ( widgetEvent ) ; \n   } \n\n   onSubmit ( )   { \n     const  name  =   this . greetingForm . get ( 'name' ) . value ; \n     this . publishWidgetEvent ( EVENTS . greeting ,   {  name  } ) ; \n   } \n } \n Add HTML Form \n Replace the contents of  angular-widget/src/app/app.component.html . \n \n In the app component html, we're adding a simple form to call our component class  app.component.ts . \n \n < h1 > Send a greeting </ h1 > \n < form   [formGroup] = \" greetingForm \"   (ngSubmit) = \" onSubmit() \" > \n   < label > \n    Name\n     < input   type = \" text \"   formControlName = \" name \" > \n   </ label > \n   < button   type = \" submit \" > Say hello! </ button > \n </ form > \n View Micro Frontend \n Open  angular-publisher-widget/src/index.html . \n In the  <body> , replace  <app-root></app-root>  with your custom element  <angular-publisher-widget /> . \n < body > \n   < angular-publisher-widget   /> \n </ body > \n \n You can check to see if your micro frontend is working in your browser (e.g., localhost:4200) \n Add to App Builder \n Now we're ready to host our micro frontend in Entando. \n Build It \n From the project root, type: \n ng build --prod --outputHashing = none\n \n This will generate a  dist  directory. \n Create Public Folder \n \n \n Navigate to  Entando App Builder  in your browser. \n \n \n Click  Configuration  →   File Browser   →  public . \n \n \n Create a folder named  angular-publisher-widget . \n \n \n Click 'Upload Files`. \n \n \n From your generated  dist  folder, upload: \n \n \n \n main-es2015.js \n polyfills-es2015.js \n runtime-es2015.js \n Add Widget \n \n \n Click  UX Patterns  →  Widgets  at the top nav. \n \n \n Click  Add  at the upper right. \n \n \n Enter the following: \n \n \n \n Title: Angular Publisher Widget  → for both English and Italian languages \n Code: angular_publisher_widget  → note: dashes are not allowed \n Group: Free Access \n Custom UI: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < script   async   src = \" < @wp . resourceURL  /> angular-widget/main-es2015.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> angular-widget/polyfills-es2015.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> angular-widget/runtime-es2015.js \" > </ script > \n\n < angular-publisher-widget   /> \n \n \n Click  Save . \n View on Homepage \n \n \n Click  Page Designer  →  Page Tree  at the top nav. \n \n \n Next to the  Home  page  (folder icon) , in the  Actions  column, click the  ⋮  icon \n \n \n In the Search field in right-hand sidebar, enter  Angular Publisher Widget . \n \n \n Drag and drop  Angular Publisher Widget  into the  Sample Frame  in the main body of the page. \n \n \n \n Replace  Publisher Widget . \n \n \n \n Click  Publish . \n \n \n In the top navigation, on the right, click  Go to Homepage . \n \n \n Enter a greeting in the input field. Press the submit button. The subscriber widget will update with the greeting. Done! \n \n \n \n Note: If you don't see an input field, refresh the page. \n \n Congratulations! \n You've now created an Angular micro frontend that can communicate with a React micro frontend. \n \n"},{title:"Tutorial: create an angular microfrontend widget",frontmatter:{},regularPath:"/v6.1/tutorials/micro-frontends/micro-frontends/create-angular-microfrontend-widget.html",relativePath:"v6.1/tutorials/micro-frontends/micro-frontends/create-angular-microfrontend-widget.md",key:"v-b07a18da",path:"/v6.1/tutorials/micro-frontends/micro-frontends/create-angular-microfrontend-widget.html",headers:[{level:2,title:"Pre-requisites",slug:"pre-requisites"},{level:2,title:"Bootstrap an angular app",slug:"bootstrap-an-angular-app"},{level:2,title:"Wrap the angular app in custom element",slug:"wrap-the-angular-app-in-custom-element"},{level:2,title:"Build the widget",slug:"build-the-widget"},{level:2,title:"Create the Entando 6 widget in App Builder",slug:"create-the-entando-6-widget-in-app-builder"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:' Tutorial: create an angular microfrontend widget \n Pre-requisites \n Use last stable node version (at the time of writing  v13.8.0 ). We\nsuggest using  nvm  to handle node\ninstallations. \n Bootstrap an angular app \n Install Angular CLI globally, then generate a new angular application.\nWhen the CLI will ask you about routing and styling, go with no routing\nand with CSS. \n npm install -g @angular/cli \n ng new my-widget \n This is the expected output: \n my-widget\n├── e2e\n│   └── src\n│       ├── app.e2e-spec.ts\n│       └── app.po.ts\n│\n├── node_modules\n├── src\n│   ├── app\n│   │   ├── app.component.css\n│   │   ├── app.component.html\n│   │   ├── app.component.spec.ts\n│   │   ├── app.component.ts\n│   │   └── app.module.ts\n│   │\n│   ├── assets\n│   │   └── .gitkeep\n│   │\n│   ├── environment\n│   │   ├── environment.prod.ts\n│   │   └── environment.ts\n│   │\n│   ├── favicon.ico\n│   ├── index.html\n│   ├── main.ts\n│   ├── polyfills.ts\n│   ├── styles.css\n│   └── test.ts\n│\n├── .editorconfig\n├── .gitignore\n├── angular.json\n├── browserlist\n├── karma.conf.js\n├── package.json\n├── README.md\n├── tsconfig.app.json\n├── tsconfig.json\n├── tsconfig.spec.json\n└── tslint.json\n Wrap the angular app in custom element \n Easiest way is using  angular elements , the official angular custom\nelement solution. \n ng add @angular/elements \n \n Note \n install the angular elements package through CLI ( ng add ) and not\nthrough  npm install , as it does something more under the hood, like\nadding  document-register-element  polyfill. \n \n Now, edit the  AppModule  class, from \n import { BrowserModule } from \'@angular/platform-browser\';\nimport { NgModule } from \'@angular/core\';\n\nimport { AppComponent } from \'./app.component\';\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n \n to \n import { BrowserModule } from \'@angular/platform-browser\';\nimport { NgModule, Injector } from \'@angular/core\';\nimport { createCustomElement } from \'@angular/elements\';\nimport { AppComponent } from \'./app.component\';\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule\n  ],\n  providers: [],\n  entryComponents: [AppComponent]\n})\nexport class AppModule {\n  constructor(private injector: Injector) {}\n\n  ngDoBootstrap() {\n    const el = createCustomElement(AppComponent, { injector: this.injector });\n    customElements.define(\'my-widget\', el);\n  }\n}\n \n Please pay attention to  AppComponent  in the module declaration: it’s\nno more in the  bootstrap  property but in the  entryComponents  one. \n Now, to ensure our custom element is working fine we have to edit\n index.html . In the  body , replace  <app-root></app-root>  with\n <my-widget /> . \n <!doctype html>\n<html lang="en">\n<head>\n  <meta charset="utf-8">\n  <title>MyWidget</title>\n  <base href="/">\n  <meta name="viewport" content="width=device-width, initial-scale=1">\n  <link rel="icon" type="image/x-icon" href="favicon.ico">\n</head>\n<body>\n  <my-widget />\n</body>\n</html>\n \n \n Note \n \n \n the custom element name ( my-widget  in this tutorial)  must \nmatch the first parameter of  customElements.define  method \n \n \n custom element names  require a dash to be used in\nthem \n(kebab-case) - they can’t be single words \n \n \n \n Page should auto reload and…​ congrats! You’re running a barebones\nEntando 6 widget in isolation. \n Build the widget \n From the angular project root, type \n ng build --prod --output-hashing none \n and a  dist/my-widget  dir will be generated. Assuming ES2015 is enough\nas minimum JS version, we can ignore ES5 stuff and pay only attention\nto: \n \n \n main-es2015.js \n \n \n polyfills-es2015.js \n \n \n runtime-es2015.js \n \n \n styles.css \n \n \n \n Note \n omitting the  --output-hashing none  options you could keep the\noriginal names in order to avoid potential caching issues, but then\nyou will have to update the  Custom UI  field in the App Builder\nwidget screen every time a new version of the widget is deployed. DE\nbundles can help with this and are covered in another lab. \n Create the Entando 6 widget in App Builder \n For the purposes of this tutorial we are going to load the widget to the\nApp builder manually. In a live system you would include this in an\nEntando app, load via API, or via a Digital Exchange bundle. \n Open the Entando App Builder. \n \n \n Go to Configuration → File Browser \n \n \n Click public \n \n \n Click Create Folder \n \n \n Enter  my-widget \n \n \n Click save \n \n \n Click  my-widget  folder \n \n \n Click upload and load the js (main, polyfills and runtime) and css\nfor your widget \n \n \n \n Note \n You can also embed the widget directly in a local copy of an Entando\napp. Copy it into the Entando 6 instance under\n src\\main\\webapp\\resources\\my-widget \n \n Now create the widget in the App Builder. go to UX Patterns → Widgets\nand click on the  New  button. \n You’ll see a screen like this one \n \n Fill the form, e.g.: \n \n \n my_widget  as widget code (dashes are not allowed in a widget\ncode) \n \n \n My Widget  as title for all the languages \n \n \n Free access  as group \n \n \n the following code as  Custom UI \n \n \n \n <#assign wp=JspTaglibs[ "/aps-core"]>\n<link rel="stylesheet" type="text/css" href="<@wp.resourceURL />my-widget/styles.css">\n<script async src="<@wp.resourceURL />my-widget/main-es2015.js"><\/script>\n<script async src="<@wp.resourceURL />my-widget/polyfills-es2015.js"><\/script>\n<script async src="<@wp.resourceURL />my-widget/runtime-es2015.js"><\/script>\n\n<my-widget />\n \n \n Note \n let’s assume we don’t need ES5 polyfills that angular generated with\nthe build. \n \n Update the paths to match what you loaded to the app builder in the\nsteps above. And save the widget. \n \n Note \n <#assign wp=JspTaglibs[ "/aps-core"]>  is needed for your widget code\nto have access to  @wp  object which provides access to a environment\nvariables. \n \n Then, configure a page (let’s assume it’s called  mypage ) and drag the\nwidget  mywidget  in the page model. Publish, load the page (its url\nshould be ``) and  voilà , here’s our angular app embedded as a widget.\nDone! \n'},{title:"Tutorial: Add App Builder configuration screen for an Entando 6 widget",frontmatter:{},regularPath:"/v6.1/tutorials/micro-frontends/micro-frontends/create-config-screen-for-appbuilder-widget.html",relativePath:"v6.1/tutorials/micro-frontends/micro-frontends/create-config-screen-for-appbuilder-widget.md",key:"v-092b0aad",path:"/v6.1/tutorials/micro-frontends/micro-frontends/create-config-screen-for-appbuilder-widget.html",headers:[{level:2,title:"Generate a React app",slug:"generate-a-react-app"},{level:2,title:"Edit the root app component",slug:"edit-the-root-app-component"},{level:2,title:"Wrap the react app in a web component",slug:"wrap-the-react-app-in-a-web-component"},{level:2,title:"Add widget config screen in App Builder",slug:"add-widget-config-screen-in-app-builder"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:" Tutorial: Add App Builder configuration screen for an Entando 6 widget \n Entando 6 widgets can be customized through an App Builder configuration\nscreen so the citizen developers can avoid writing ad-hoc additional\ncode. \n In Entando 6, the configuration screen is also a micro frontend, which\ncan also be defined as a web component. That means you can develop and\ntest it in isolation, without a running Entando instance. \n Generate a React app \n Let’s start with the boilerplate provided by  Create React\nApp , probably the most popular one. \n npx create-react-app my-widget-config --use-npm \n my-widget-config\n├── README.md\n├── node_modules\n├── package.json\n├── .gitignore\n├── public\n│   ├── favicon.ico\n│   ├── index.html\n│   ├── logo192.png\n│   ├── logo512.png\n│   ├── manifest.json\n│   └── robots.txt\n└── src\n    ├── App.css\n    ├── App.js\n    ├── App.test.js\n    ├── index.css\n    ├── index.js\n    ├── logo.svg\n    ├── serviceWorker.js\n    └── setupTests.js\n \n Then, type  cd my-widget-config  and  npm start  to start the app. \n Edit the root app component \n Let’s start with a simple form: only an input with a label. So, let’s\nedit  App.js \n import React from 'react';\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { name: ''};\n  }\n\n  handleNameChange(value) {\n    this.setState(prevState => ({\n      ...prevState,\n      name: value,\n    }));\n  }\n\n  render() {\n    const { name } = this.state;\n    return (\n      <div>\n        <h1>Sample Entando 6 Widget Configuration</h1>\n        <label htmlFor=\"name\">Name</label>\n        <input id=\"name\" onChange={e => this.handleNameChange(e.target.value)} value={name} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n \n You are free to use your favorite form handling library e.g.,\n Formik ,\n redux-form  (that requirese redux) or others. \n In regards to styling, since this is going to be an App Builder screen,\nwe strongly suggest using  PatternFly\nv3  ( patternfly  and  patternfly-react \npackages) to keep UX coherence. \n Wrap the react app in a web component \n Now, let’s add the web component that will wrap the entire React app.\nLet’s name it  WidgetElement \n import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nclass WidgetElement extends HTMLElement {\n  constructor() {\n    super();\n    this.reactRootRef = React.createRef();\n    this.mountPoint = null;\n  }\n\n  get config() {\n    return this.reactRootRef.current ? this.reactRootRef.current.state : {};\n  }\n\n  set config(value) {\n    return this.reactRootRef.current.setState(value);\n  }\n\n  connectedCallback() {\n    this.mountPoint = document.createElement('div');\n    this.appendChild(this.mountPoint);\n    ReactDOM.render(<App ref={this.reactRootRef} />, this.mountPoint);\n  }\n}\n\ncustomElements.define('my-widget-config', WidgetElement);\n\nexport default WidgetElement;\n \n Its responsibility is rendering the react app and syncing the react app\nstate in a  config  property, that  must  be named that way. The key to\nApp builder communication is that it works in three steps: \n \n \n App Builder reads  config  property when the widget config screen is\nrendered \n \n \n config  property is mutated when a user configures the widget \n \n \n When a user saves the config, App Builder retrieves it (again, from\nthe  config  property) and persists it through Entando APIs \n \n \n This means the widget developer can focus on the configuration screens\nwithout having to call Entando APIs to read or write configuration. \n One more JS file to update:  index.js . Starting from this \n import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n \n You only have to import  WidgetElement  plus the css, if needed.\nSomething like \n import './index.css';\nimport './WidgetElement';\n \n We assume we don’t need a service worker for the widget, so we can\ndelete serviceWorker.js. \n To ensure our web component is working we have to edit\n public/index.html . Remove  <div id=\"root\"></div>  from the  body  (we\nprogrammatically generated the react root in the  connectedCallback \nmethod of  WidgetElement ) and add our new web component tag\n <my-widget /> . \n <!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <link rel=\"shortcut icon\" href=\"%PUBLIC_URL%/favicon.ico\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <title>React App</title>\n  </head>\n  <body>\n    <my-widget-config />\n  </body>\n</html>\n \n \n Note \n the web component tag name ( my-widget-config  in this tutorial)\n must  match the first parameter of the  customElements.define \nmethod. \n \n The page should auto reload and…​congrats, you’re running an Entando 6\nwidget in isolation. \n Add widget config screen in App Builder \n Before integrating the widget config screen, we need some widget info.\nOpen App Builder, go to UX Patterns → Widgets and click on the installed\nwidget that we’re creating the configuration screen for. \n You’ll see a screen like: \n \n Next, we’ll build our widget before embedding it into the Entando 6\ninstance. From the react project root, type \n npm run build \n and a  build/static  directory will be generated. Copy it into the\nEntando 6 instance under\n src\\main\\webapp\\cmsresources\\my-widget-config , then rename \n \n \n a file like  js/runtime~main.c7dcdf0b.js  to  js/runtime.js \n(bootstrapping logic) \n \n \n a file like  js/2.230b21ef.chunk.js  to  js/vendor.js  (third-party\nlibraries) \n \n \n a file like  js/main.1fd3965a.chunk.js  to  js/main.js  (app) \n \n \n Now, edit again the widget and update the  configUI  field. \n {\n  \"customElement\": \"my-widget-config\",\n  \"resources\": [\n    \"my-widget-config/static/js/runtime.js\",\n    \"my-widget-config/static/js/vendor.js\",\n    \"my-widget-config/static/js/main.js\"\n  ]\n}\n \n \n Note \n \n \n It is possible to keep the original names in order to avoid\npotential caching issues, but then you will have to update the\n Config UI  field in the App Builder widget screen each time a new\nversion of the widget is deployed. \n \n \n configUI  is a JSON object, so pay attention to save a\nwell-formed one (the integrated JSON editor will help you) \n \n \n value for  customElement  must match the name of custom tag in\n index.html  and the one passed as parameter to\n customElements.define  in  WidgetElement \n \n \n \n Last step: configure a page in App Builder, drag our widget into the\npage model slot and you’ll see the configuration screen we just built. \n"},{title:"Authentication",frontmatter:{},regularPath:"/v6.1/tutorials/micro-frontends/micro-frontends/authentication.html",relativePath:"v6.1/tutorials/micro-frontends/micro-frontends/authentication.md",key:"v-64e83e2d",path:"/v6.1/tutorials/micro-frontends/micro-frontends/authentication.html",lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:" Authentication \n Keycloak is used for authentication. \n To set up keycloak server, please refer to Keycloak\n documentation . \n As all MFE widgets use the same Keycloak instance, it should be\ninitialized on a container of all widgets. \n Using Details widget generated using Entando JHipster blueprint as an\nexample, let’s get familiar with authentication implementation. \n As mentioned before, widget auth implementation assumes that Keycloak is\ninitialized outside of the widget. In Details example, it is done in\nindex.html where Keycloak server’s keycloak.js is used. \n <head>\n    <script src=\"keycloak.js\"><\/script>\n    <script>\n        var keycloak = new Keycloak();\n        keycloak\n          .init({ onLoad: 'check-sso' })\n          .success(onInit);\n    <\/script>\n</head>\n \n \n Note \n keycloak.js is provided by your Keycloak server at\n <SERVER_URL:PORT>/auth/js/keycloak.js \n \n Keycloak is initialized by passing Keycloak server path, realm and\nclient ID and calling  init({/* options */})  function. \n const keycloak = Keycloak({\n  url: 'http://localhost:9080/auth',\n  realm: 'jhipster',\n  clientId: 'jhipster-entando-react-client',\n});\n\nkeycloak\n  .init({ onLoad: 'check-sso' })\n  .success(onInit);\n \n Depending on Keycloak version you are using,  init()  function can\nreturn a Promise (newer versions support  promiseType: 'native' \noption). \n keycloak\n  .init({ onLoad: 'check-sso', promiseType: 'native' })\n  .then(authenticated => {\n    alert(authenticated ? 'Authenticated' : 'Not authenticated');\n  })\n  .catch(() => {\n    alert('Failed to initialize');\n  });\n \n All the Keycloak events are made custom events - this way widgets could\nreact to them if a need arises. \n function createKcDispatcher(payload) {\n  return () => window.dispatchEvent(new CustomEvent('keycloak', { detail: payload }));\n}\n\nkeycloak.onReady = createKcDispatcher({ eventType: 'onReady' });\nkeycloak.onAuthSuccess = createKcDispatcher({ eventType: 'onAuthSuccess' });\nkeycloak.onAuthError = createKcDispatcher({ eventType: 'onAuthError' });\nkeycloak.onAuthRefreshSuccess = createKcDispatcher({ eventType: 'onAuthRefreshSuccess' });\nkeycloak.onAuthRefreshError = createKcDispatcher({ eventType: 'onAuthRefreshError' });\nkeycloak.onAuthLogout = createKcDispatcher({ eventType: 'onAuthLogout' });\nkeycloak.onTokenExpired = createKcDispatcher({ eventType: 'onTokenExpired' });\nconst onInit = createKcDispatcher({ eventType: 'onInit' });\n \n Keycloak object is then stored into  window.entando  object for widgets\nto have access to. \n window.entando = {\n  ...(window.entando || {}),\n  keycloak,\n};\n \n On the widget side inside the custom element creation logic Keycloak\nobject is accessed and passed into the component via Keycloak context \n const getKeycloakInstance = () =>\n  (window &&\n    window.entando &&\n    window.entando.keycloak &&\n    { ...window.entando.keycloak, initialized: true }\n  ) || { initialized: false };\n\n\n// ...\n\nconstructor(...args) {\n  // ...\n  this.keycloak = getKeycloakInstance();\n}\n\nconnectedCallback() {\n  // ...\n  ReactDOM.render(\n    <KeycloakContext.Provider value={this.keycloak}>\n      <ConferenceDetailsContainer />\n    </KeycloakContext.Provider>,\n    this.mountPoint\n  );\n}\n \n And on the component side you can show different content depending on\nthe authentication status \n At  auth/KeycloakViews.js \n export const AuthenticatedView = ({ children, keycloak }) => {\n  const authenticated = keycloak.initialized && keycloak.authenticated;\n  return authenticated ? children : null;\n};\n\nexport const UnauthenticatedView = ({ children, keycloak }) => {\n  const authenticated = keycloak.initialized && keycloak.authenticated;\n  return !authenticated ? children : null;\n};\n \n At  components/ConferenceDetailsContainer.js \n render() {\n  const { conference, loading } = this.state;\n  const { t, keycloak } = this.props;\n\n  return (\n    <ThemeProvider theme={this.theme}>\n      <UnauthenticatedView keycloak={keycloak}>\n        {t('common.notAuthenticated')}\n      </UnauthenticatedView>\n      <AuthenticatedView keycloak={keycloak}>\n        {loading && t('common.loading')}\n        {!loading && <ConferenceDetails conference={conference} />}\n      </AuthenticatedView>\n    </ThemeProvider>\n  );\n}\n \n \n Note \n Keycloak object is accessible via props because of  withKeycloak  HOC:\n export default withKeycloak(ConferenceDetailsContainer); \n \n"},{title:"Tutorial: create a react micro frontend widget",frontmatter:{},regularPath:"/v6.1/tutorials/micro-frontends/micro-frontends/create-react-microfrontend-widget.html",relativePath:"v6.1/tutorials/micro-frontends/micro-frontends/create-react-microfrontend-widget.md",key:"v-c73e25e6",path:"/v6.1/tutorials/micro-frontends/micro-frontends/create-react-microfrontend-widget.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Bootstrap a react app",slug:"bootstrap-a-react-app"},{level:2,title:"Wrap the react app in a custom element",slug:"wrap-the-react-app-in-a-custom-element"},{level:2,title:"Build the widget",slug:"build-the-widget"},{level:2,title:"Create the Entando 6 widget in App Builder",slug:"create-the-entando-6-widget-in-app-builder"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:' Tutorial: create a react micro frontend widget \n Prerequisites \n Use last stable node version (at the time of writing  v13.8.0 ). We\nsuggest using  nvm  to handle node\ninstallations. \n Bootstrap a react app \n In this tutorial we use  Create React\nApp , but feel free to adopt whatever\nboilerplate you like. \n npx create-react-app my-widget --use-npm \n This is the expected output: \n my-widget\n├── README.md\n├── node_modules\n├── package.json\n├── .gitignore\n├── public\n│   ├── favicon.ico\n│   ├── index.html\n│   ├── logo192.png\n│   ├── logo512.png\n│   ├── manifest.json\n│   └── robots.txt\n└── src\n    ├── App.css\n    ├── App.js\n    ├── App.test.js\n    ├── index.css\n    ├── index.js\n    ├── logo.svg\n    ├── serviceWorker.js\n    └── setupTests.js\n \n Now, type  cd my-widget  and  npm start  to start the app. \n Wrap the react app in a custom element \n Let’s add a new file  WidgetElement.js , containing the custom element\nthat will wrap the entire React app under the  src  folder. \n import React from \'react\';\nimport ReactDOM from \'react-dom\';\nimport App from \'./App\';\n\nclass WidgetElement extends HTMLElement {\n  connectedCallback() {\n    this.mountPoint = document.createElement(\'div\');\n    this.appendChild(this.mountPoint);\n    ReactDOM.render(<App />, this.mountPoint);\n  }\n}\n\ncustomElements.define(\'my-widget\', WidgetElement);\n\nexport default WidgetElement;\n \n \n Note \n connectedCallback  is a lifecycle hook method of custom elements,\npart of the web components spec. \n \n Then, the  index.js  file should be updated. Starting from this: \n import React from \'react\';\nimport ReactDOM from \'react-dom\';\nimport \'./index.css\';\nimport App from \'./App\';\nimport * as serviceWorker from \'./serviceWorker\';\n\nReactDOM.render(<App />, document.getElementById(\'root\'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n \n replace the whole file with these two lines \n import \'./index.css\';\nimport \'./WidgetElement\';\n \n You only have to import  WidgetElement  plus the css, if needed. \n We assume we don’t need a service worker for the widget, so we can\ndelete serviceWorker.js. \n Now, to ensure our custom element is working we have to edit\n public/index.html . Remove  <div id="root"></div>  from the  body  (we\nprogrammatically generated the react root in the  connectedCallback \nmethod of  WidgetElement ) and add our custom element  <my-widget /> . \n <!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" />\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\n    <title>React App</title>\n  </head>\n  <body>\n    <my-widget />\n  </body>\n</html>\n \n \n Note \n \n \n the custom element name ( my-widget  in this tutorial)  must \nmatch the first parameter of  customElements.define  method \n \n \n custom element names  require a dash to be used in\nthem \n(kebab-case) - they can’t be single words. \n \n \n \n Page should auto reload and…​ congrats! You’re running a barebones\nEntando 6 widget in isolation. \n Build the widget \n In order to avoid path issues, we should set up a one line  .env  file\nin the CRA project root: \n PUBLIC_URL=http://localhost:8080/entando/resources/static/my-widget\n \n Where `` is the path of the Entando 6 instance containing the widget. \n Ready to build now! From the react project root, type \n npm run build \n and a  build  dir will be generated. Now rename \n \n \n a file like  static/js/runtime~main.c7dcdf0b.js  to\n static/js/runtime.js  (bootstrapping logic) \n \n \n a file like  static/js/2.230b21ef.chunk.js  to  static/js/vendor.js \n(third-party libraries) \n \n \n a file like  static/js/main.1fd3965a.chunk.js  to\n static/js/main.js  (app) \n \n \n a file like  static/css/main.d1b05096.chunk.js  to\n static/css/main.css  (stylesheet) \n \n \n \n Note \n you could keep the original names in order to avoid potential caching\nissues, but then you will have to update the  Custom UI  field in the\nApp Builder widget screen every time a new version of the widget is\ndeployed. DE bundles can help with this and are covered in another\nlab. \n Create the Entando 6 widget in App Builder \n For the purposes of this tutorial we are going to load the widget to the\nApp builder manually. In a live system you would include this in an\nEntando app, load via API, or via a Component Repository bundle. \n Open the Entando App Builder \n \n \n Go to Configuration → File Browser \n \n \n Click public \n \n \n Click Create Folder \n \n \n Enter  my-widget \n \n \n Click save \n \n \n Click  my-widget  folder \n \n \n Recreate the same folder structure (my-widget/static/js,\nmy-widget/static/css) \n \n \n Upload files from js and css folders in the corresponding folders in\nfile browser \n \n \n \n Note \n You can also embed the widget directly in a local copy of an Entando\napp. Copy it into the Entando 6 instance under\n src\\main\\webapp\\resources\\my-widget \n \n Now create the widget in the App Builder \n go to UX Patterns → Widgets and click on the  New  button. \n You’ll see a screen like this one \n \n Fill the form, e.g.: \n \n \n my_widget  as widget code (dashes are not allowed in a widget\ncode) \n \n \n My Widget  as title for all the languages \n \n \n Free access  as group \n \n \n the following code as  Custom UI \n \n \n \n <#assign wp=JspTaglibs[ "/aps-core"]>\n<link rel="stylesheet" type="text/css" href="<@wp.resourceURL />my-widget/static/css/main.css">\n<script async src="<@wp.resourceURL />my-widget/static/js/runtime.js"><\/script>\n<script async src="<@wp.resourceURL />my-widget/static/js/vendor.js"><\/script>\n<script async src="<@wp.resourceURL />my-widget/static/js/main.js"><\/script>\n<my-widget />\n \n Update the paths to match what you loaded to the app builder in the\nsteps above. And save the widget. \n \n Note \n <#assign wp=JspTaglibs[ "/aps-core"]>  is needed for your widget code\nto have access to  @wp  object which provides access to environment\nvariables. \n \n Then, configure a page (let’s assume it’s called  mypage ) and drag the\nwidget  mywidget  in the page model. Publish, load the page (its url\nshould be ``) and  voilà , here’s our react app embedded as a widget.\nDone! \n'},{title:"Tutorial: using custom event for widget communication",frontmatter:{},regularPath:"/v6.1/tutorials/micro-frontends/micro-frontends/mixed-widget-communication.html",relativePath:"v6.1/tutorials/micro-frontends/micro-frontends/mixed-widget-communication.md",key:"v-76dcebcd",path:"/v6.1/tutorials/micro-frontends/micro-frontends/mixed-widget-communication.html",headers:[{level:2,title:"Fire an event from a widget",slug:"fire-an-event-from-a-widget"},{level:3,title:"app.module.ts",slug:"app-module-ts"},{level:3,title:"app.component.js",slug:"app-component-js"},{level:3,title:"app.template.html",slug:"app-template-html"},{level:2,title:"Consume an event in another widget",slug:"consume-an-event-in-another-widget"},{level:3,title:"SubscriberWidgetElement.js",slug:"subscriberwidgetelement-js"},{level:3,title:"App.js",slug:"app-js"},{level:2,title:"Make both widgets work in Entando",slug:"make-both-widgets-work-in-entando"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:" Tutorial: using custom event for widget communication \n Entando 6 widgets can communicate through  Custom\nEvents ,\nan established web standard. \n In this tutorial we’re going to build two widgets: the angular one will\nfire an event, the react one will intercept it. \n Fire an event from a widget \n ng new pub-widget-ng \n then follow the same steps or our  previous\ntutorial \n This time we need to add some form and custom event firing logic \n app.module.ts \n import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule, Injector } from '@angular/core';\nimport { createCustomElement } from '@angular/elements';\nimport { AppComponent } from './app.component';\nimport { ReactiveFormsModule } from '@angular/forms';\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    ReactiveFormsModule\n  ],\n  providers: [],\n  entryComponents: [AppComponent]\n})\nexport class AppModule {\n  constructor(private injector: Injector) {}\n\n  ngDoBootstrap() {\n    const el = createCustomElement(AppComponent, { injector: this.injector });\n    customElements.define('pub-widget-ng', el);\n  }\n}\n app.component.js \n import { Component } from '@angular/core';\nimport { FormControl, FormGroup } from '@angular/forms';\n\nconst EVENTS = {\n  greeting: 'greeting',\n};\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  greetingForm = new FormGroup({\n    name: new FormControl(''),\n  });\n\n  publishWidgetEvent(eventId, detail) {\n    const widgetEvent = new CustomEvent(eventId, { detail });\n    window.dispatchEvent(widgetEvent);\n  }\n\n  onSubmit() {\n    const name = this.greetingForm.get('name').value;\n    this.publishWidgetEvent(EVENTS.greeting, { name });\n  }\n}\n \n \n Note \n in the  CustomEvent  constructor,  detail  is the exact name to use in\nthe event payload, as for the\n specs . \n app.template.html \n <h1>Send a greeting</h1>\n<form [formGroup]=\"greetingForm\" (ngSubmit)=\"onSubmit()\">\n  <label>\n    Name\n    <input type=\"text\" formControlName=\"name\">\n  </label>\n  <button type=\"submit\">Say hello!</button>\n</form>\n \n To quickly test the event publishing we can execute from the JS console\nthis line of code \n window.addEventListener('greeting', (evt) => console.log('Hello', evt.detail.name))\n \n Then write something in the text field, click the \"Say hello!\" button\nand have a look ath the JS console: it will show the expected hello\nmessage. \n Consume an event in another widget \n Now, let’s create the react subscriber widget. \n npx create-react-app sub-widget-react --use-npm \n then follow the same steps or our  previous\ntutorial . \n Be careful to \n \n \n rename  WidgetElement.js  to  SubscriberWidgetElement.js \n \n \n edit  index.js : now you should import  SubscriberWidgetElement \n \n \n edit  index.html  updating the reference to the custom element: now\nit’s  <sub-widget-react> \n \n \n edit  SubscriberWidgetElement.js  and  App.js \n SubscriberWidgetElement.js \n (we’re renaming  WidgetElement  to  SubscriberWidgetElement  and update\nthe import in  index.js  accordingly) \n import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nconst EVENTS = {\n  greeting: 'greeting',\n};\n\nclass SubscriberWidgetElement extends HTMLElement {\n\n  constructor() {\n    super();\n    this.name = null;\n    this.subscribeToWidgetEvent(EVENTS.greeting, (evt) => this.onGreeting(evt.detail.name));\n  }\n\n  connectedCallback() {\n    this.mountPoint = document.createElement('div');\n    this.appendChild(this.mountPoint);\n    this.render();\n  }\n\n  subscribeToWidgetEvent(eventType, eventHandler) {\n    window.addEventListener(eventType, eventHandler);\n  }\n\n  onGreeting(name) {\n    this.name = name;\n    this.render();\n  }\n\n  render() {\n    ReactDOM.render(<App name={this.name} />, this.mountPoint);\n  }\n}\n\ncustomElements.define('sub-widget-react', SubscriberWidgetElement);\n\nexport default SubscriberWidgetElement;\n App.js \n import React from 'react';\nimport './App.css';\n\nfunction App({ name }) {\n  return name ? (<h2>Just got a greeting from {name}</h2>)\n    : (<h2>Waiting for a greeting...</h2>);\n}\n\nexport default App;\n \n To quickly test the event publishing we can execute from the JS console\nthese lines of code \n const widgetEvent = new CustomEvent('greeting', {\n  detail: {\n    name: 'Pippo'\n  },\n});\nwindow.dispatchEvent(widgetEvent);\n \n And then the widget will update the text. \n Make both widgets work in Entando \n To properly test widgets in an entando instance, follow those steps (you\ncan use the  basic microfrontend\ntutorial  as reference) \n \n \n build both widgets \n \n \n copy widget files \n \n \n create widgets from App Builder \n \n \n create a page model from App Builder \n \n \n create a page and assign the just created page model \n \n \n configure the page dragging both widget \n \n \n If you need a simple page model, you can use this one \n JSON Configuration \n {\n  \"frames\": [\n    {\n      \"pos\": 0,\n      \"descr\": \"Sample Frame\",\n      \"mainFrame\": false,\n      \"defaultWidget\": null,\n      \"sketch\": null\n    },\n    {\n      \"pos\": 1,\n      \"descr\": \"Sample Frame Two\",\n      \"mainFrame\": false,\n      \"defaultWidget\": null,\n      \"sketch\": null\n    }\n  ]\n}\n \n Template \n <#assign wp=JspTaglibs[\"/aps-core\"]>\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n<html>\n<head>\n    <title><@wp.currentPage param=\"title\" /></title>\n</head>\n<body>\n<h1><@wp.currentPage param=\"title\" /></h1>\n<div><@wp.show frame=0 /></div>\n<div><@wp.show frame=1 /></div>\n</body>\n</html>\n \n Now, go to the page you just created and you will find both widgets.\nWrite something in the publisher widget input, press the button and the\nsubscriber widget will update. Done! \n"},{title:"Tutorial: Display widget configuration data",frontmatter:{},regularPath:"/v6.1/tutorials/micro-frontends/micro-frontends/display-widget-config-data.html",relativePath:"v6.1/tutorials/micro-frontends/micro-frontends/display-widget-config-data.md",key:"v-4381b4cd",path:"/v6.1/tutorials/micro-frontends/micro-frontends/display-widget-config-data.html",headers:[{level:2,title:"Add an attribute to the custom element",slug:"add-an-attribute-to-the-custom-element"},{level:2,title:"Make react component handle the input",slug:"make-react-component-handle-the-input"},{level:2,title:"Rebuild the widget",slug:"rebuild-the-widget"},{level:2,title:"Update the Entando 6 widget in App Builder",slug:"update-the-entando-6-widget-in-app-builder"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:' Tutorial: Display widget configuration data \n So, we already created a react micro frontend widget and configuration\nscreen to customize a  name  field. \n In this tutorial we will display that field in our micro frontend\nwidget. \n Add an attribute to the custom element \n Edit  WidgetElement  to add attribute handling to the custom element,\nand make re-render our app when an attribute changes. Now, the  name \nattribute is being read from the custom element and passed as a prop to\nthe react root component ( App ). \n import React from \'react\';\nimport ReactDOM from \'react-dom\';\nimport App from \'./App\';\n\nconst ATTRIBUTES = {\n  name: \'name\',\n};\n\nclass WidgetElement extends HTMLElement {\n\n  static get observedAttributes() {\n    return Object.values(ATTRIBUTES);\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (!Object.values(ATTRIBUTES).includes(name)) {\n      throw new Error(`Untracked changed attribute: ${name}`);\n    }\n    if (this.mountPoint && newValue !== oldValue) {\n      this.render();\n    }\n  }\n\n  connectedCallback() {\n    this.mountPoint = document.createElement(\'div\');\n    this.appendChild(this.mountPoint);\n    this.render();\n  }\n\n  render() {\n    const name = this.getAttribute(ATTRIBUTES.name);\n    ReactDOM.render(<App name={name} />, this.mountPoint);\n  }\n}\n\ncustomElements.define(\'my-widget\', WidgetElement);\n\nexport default WidgetElement;\n \n \n Note \n attributeChangedCallback  is also a custom elements lifecycle hook\nmethod. \n Make react component handle the input \n Edit the  App  component now, to make it display the  name  prop. \n import React from \'react\';\nimport \'./App.css\';\n\nfunction App({name}) {\n  return (\n    <div className="App">\n      <header className="App-header">\n        <p>\n          Hello, {name}!\n        </p>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n \n Now, to ensure our custom element is working we can edit\n public/index.html  and set a value for the  name  attribute of the\ncustom element. \n <!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" />\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\n    <title>React App</title>\n  </head>\n  <body>\n    <my-widget name="Marco"/>\n  </body>\n</html>\n \n After page reload, you should be able to display a simple "Hello,\nMarco!" message. \n Rebuild the widget \n From the react project root, type: \n npm run build \n and the  build/static  directory will be (re)generated. Copy it again\ninto the Entando 6 instance under\n src\\main\\webapp\\resources\\static\\my-widget , then rename \n \n \n a file like  js/runtime~main.c7dcdf0b.js  to  js/runtime.js \n(bootstrapping logic) \n \n \n a file like  js/2.230b21ef.chunk.js  to  js/vendor.js  (third-party\nlibraries) \n \n \n a file like  js/main.1fd3965a.chunk.js  to  js/main.js  (app) \n \n \n a file like  css/main.d1b05096.chunk.js  to  css/main.css \n(stylesheet) \n \n \n \n Note \n you could keep the original names in order to avoid potential caching\nissues, but then you will have to update the  Custom UI  field in the\nApp Builder widget screen every time a new version of the widget is\ndeployed. \n \n If the application server you’re running does not have hot deploy\nenabled, restart it. \n Update the Entando 6 widget in App Builder \n Open the Entando App Builder, go to UX Patterns → Widgets, find the\nwidget  My Widget  and click to edit it. \n You’ll see a screen like this one \n \n Update the  Custom UI  field from: \n <#assign wp=JspTaglibs[ "/aps-core"]>\n<link rel="stylesheet" type="text/css" href="<@wp.resourceURL />static/my-widget/static/css/main.css">\n<script async src="<@wp.resourceURL />static/my-widget/static/js/runtime.js"><\/script>\n<script async src="<@wp.resourceURL />static/my-widget/static/js/vendor.js"><\/script>\n<script async src="<@wp.resourceURL />static/my-widget/static/js/main.js"><\/script>\n<my-widget />\n \n to \n <#assign wp=JspTaglibs[ "/aps-core"]>\n<link rel="stylesheet" type="text/css" href="<@wp.resourceURL />static/my-widget/static/css/main.css">\n<script async src="<@wp.resourceURL />static/my-widget/static/js/runtime.js"><\/script>\n<script async src="<@wp.resourceURL />static/my-widget/static/js/vendor.js"><\/script>\n<script async src="<@wp.resourceURL />static/my-widget/static/js/main.js"><\/script>\n<@wp.currentWidget param="config" configParam="name" var="configName" />\n<my-widget name="${configName}" />\n \n We basically added a JSTL tag to extract a field (under  configParam )\nfrom the config field of the current widget and put it in a  configName \nvariable, that we pass to the custom element. \n Save the widget and reload the page that contains the widget: you’ll see\n"Hello, Marco!" as expected. \n'},{title:"Tutorial: Blueprint generated widgets' overview",frontmatter:{},regularPath:"/v6.1/tutorials/micro-frontends/micro-frontends/generated-widgets.html",relativePath:"v6.1/tutorials/micro-frontends/micro-frontends/generated-widgets.md",key:"v-4a3a209f",path:"/v6.1/tutorials/micro-frontends/micro-frontends/generated-widgets.html",headers:[{level:2,title:"Common parts",slug:"common-parts"},{level:3,title:"Authentication",slug:"authentication"},{level:3,title:"Custom events",slug:"custom-events"},{level:3,title:"Tests and mocks",slug:"tests-and-mocks"},{level:3,title:"PropTypes",slug:"proptypes"},{level:3,title:"Fetching data",slug:"fetching-data"},{level:2,title:"Form widget",slug:"form-widget"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:' Tutorial: Blueprint generated widgets\' overview \n When you create an entity using Entando blueprint, it generates a few\npremade widgets. In this section we will review them. \n We will be using  Conference  as an entity name for the examples below. \n Common parts \n Each widget contains a README file that should help you with the setup. \n All generated widgets are web components created using Custom Elements\nAPI. \n Each widget is displayed using the custom element tag - e.g., inside the\nDetails widget folder  conference/detailsWidget/public/index.html  you\ncan find\n conference-details id="1" override-edit-handler hide-edit-button /> .\nThis element  <conference-details />  is defined in the component entry\npoint at\n conference/detailsWidget/src/custom-elements/ConferenceDetailsElement.js . \n \n Note \n custom element names ( conference-details ) require a dash in them to\nbe used, e.g., (kebab-case) - they can not be single words. \n \n For more information about web components, custom elements and micro\nfrontends, please refer to "Create a react micro frontend widget"\nsection. \n Authentication \n If widget requires authentication, component is wrapped in\n KeycloakContext.Provider  and Keycloak object is fetched from\n window.entando.keycloak  variable. Entando is using Keycloak as our\nauthentication provider, but you can add any providers you like. \n ReactDOM.render(\n  <KeycloakContext.Provider value={this.keycloak}>\n    <StylesProvider jss={this.jss}>\n      <ThemeProvider theme={this.muiTheme}>{FormContainer}</ThemeProvider>\n    </StylesProvider>\n  </KeycloakContext.Provider>,\n  this.mountPoint\n);\n \n For more information about authentication implementation, please refer\nto the "Authentication" section. \n Custom events \n All widgets rely on custom events for communication which is why custom\nevent creation and removal is in each widget, as well as event listener\ncreation. Note that when an event listener is created, it should be when\nthe element is no longer needed. It should be created in the custom\nelement’s  disconnectedCallback()  function. \n To add more events to listen to the widgets, add the event types to\n INPUT_EVENT_TYPES  object at\n detailsWidget/src/custom-elements/widgetEventTypes.js  which will add\nit to the listener list (or remove the event by removing the element). \n For more information about custom events and widget communication,\nplease refer to the section on "Widget communication". \n Tests and mocks \n Each widget has tests written for it. Entando uses\n react-testing-library , but developers are free to upgrade and use any\ntool. Tests are kept at  detailsWidget/src/components/  and mocks for\nthem are at  detailsWidget/src/components/ . \n PropTypes \n PropTypes for data used across several components are shared - you can\nsee and modify them at  detailsWidget/src/components/ . This way you can\navoid repeating same propTypes in each component and just import shared\nones \n import React from \'react\';\nimport conferenceType from \'components/__types__/conference\';\n\nconst ConferenceDetails = props => {\n  // ...\n};\n\nConferenceDetails.propTypes = {\n  conference: conferenceType,\n  t: PropTypes.func.isRequired,\n};\n\nexport default ConferenceDetails;\n Fetching data \n For data fetching from widgets use Fetch API. You can find functions for\nfetching data at  detailsWidget/src/api  in different files for\ndifferent contexts. \n Form widget \n For displaying forms within a widget use\n Formik  which helps with form state\nmanagement. For data validation use\n Yup . \n'},{title:"Tutorial: Using a custom event for widget communication",frontmatter:{},regularPath:"/v6.1/tutorials/micro-frontends/micro-frontends/widget-communication.html",relativePath:"v6.1/tutorials/micro-frontends/micro-frontends/widget-communication.md",key:"v-1316b766",path:"/v6.1/tutorials/micro-frontends/micro-frontends/widget-communication.html",headers:[{level:2,title:"Fire an event from a widget",slug:"fire-an-event-from-a-widget"},{level:3,title:"PublisherWidgetElement.js",slug:"publisherwidgetelement-js"},{level:3,title:"App.js",slug:"app-js"},{level:2,title:"Consume an event in another widget",slug:"consume-an-event-in-another-widget"},{level:3,title:"SubscriberWidgetElement.js",slug:"subscriberwidgetelement-js"},{level:3,title:"App.js",slug:"app-js-2"},{level:2,title:"Make both widgets work in Entando",slug:"make-both-widgets-work-in-entando"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:" Tutorial: Using a custom event for widget communication \n Entando 6 widgets can communicate through  Custom\nEvents ,\nan established web standard. \n In this tutorial we’re going to build two widgets: the first one will\nfire an event, the second one will intercept it. \n Fire an event from a widget \n npx create-react-app publisher-widget --use-npm \n then follow the same steps from our  previous\ntutorial . \n Be careful to: \n \n \n rename  WidgetElement.js  to  PublisherWidgetElement.js \n \n \n edit  index.js : now you should import  PublisherWidgetElement \n \n \n edit  index.html  updating the reference to the custom element: now\nit’s  <publisher-widget> \n \n \n edit  PublisherWidgetElement.js  and  App.js \n \n \n We need to add some event firing logic \n PublisherWidgetElement.js \n import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nconst EVENTS = {\n  greeting: 'greeting',\n};\n\nclass PublisherWidgetElement extends HTMLElement {\n\n  constructor() {\n    super();\n    this.onGreet = name => this.publishWidgetEvent(EVENTS.greeting, { name });\n  }\n\n  connectedCallback() {\n    this.mountPoint = document.createElement('div');\n    this.appendChild(this.mountPoint);\n    this.render();\n  }\n\n  publishWidgetEvent(eventId, detail) {\n    const widgetEvent = new CustomEvent(eventId, { detail });\n    window.dispatchEvent(widgetEvent);\n  }\n\n  render() {\n    ReactDOM.render(<App onGreet={this.onGreet} />, this.mountPoint);\n  }\n}\n\ncustomElements.define('publisher-widget', PublisherWidgetElement);\n\nexport default PublisherWidgetElement;\n \n \n Note \n in the  CustomEvent  constructor,  detail  is the specific name to use\nin the event payload, as for the\n specs . \n App.js \n import React from 'react';\nimport './App.css';\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { name: ''};\n  }\n\n  handleNameChange(value) {\n    this.setState(prevState => ({\n      ...prevState,\n      name: value,\n    }));\n  }\n\n  render() {\n    const { name } = this.state;\n    const { onGreet } = this.props;\n    return (\n      <div>\n        <h1>Send a greeting</h1>\n        <label htmlFor=\"name\">Name</label>\n        <input id=\"name\" onChange={e => this.handleNameChange(e.target.value)} value={name} />\n        <button onClick={() => onGreet(name)}>Say hello!</button>\n      </div>\n    );\n  }\n}\n\nexport default App;\n \n To quickly test the event publishing we can execute from the JS console\nthis line of code \n window.addEventListener('greeting', (evt) => console.log('Hello', evt.detail.name))\n \n then write something in the text field, click the \"Say hello!\" button\nand have a look at the JS console, it will show the expected hello\nmessage. \n Consume an event in another widget \n Now, let’s create the subscriber widget. \n npx create-react-app subscriber-widget --use-npm \n then follow the same steps from our  previous\ntutorial . \n Be careful to \n \n \n rename  WidgetElement.js  to  SubscriberWidgetElement.js \n \n \n edit  index.js : now you should import  SubscriberWidgetElement \n \n \n edit  index.html  updating the reference to the custom element: now\nit’s  <subscriber-widget> \n \n \n edit  SubscriberWidgetElement.js  and  App.js \n SubscriberWidgetElement.js \n (Rename  WidgetElement  to  SubscriberWidgetElement  and update the\nimport in  index.js  accordingly) \n import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nconst EVENTS = {\n  greeting: 'greeting',\n};\n\nclass SubscriberWidgetElement extends HTMLElement {\n\n  constructor() {\n    super();\n    this.name = null;\n    this.subscribeToWidgetEvent(EVENTS.greeting, (evt) => this.onGreeting(evt.detail.name));\n  }\n\n  connectedCallback() {\n    this.mountPoint = document.createElement('div');\n    this.appendChild(this.mountPoint);\n    this.render();\n  }\n\n  subscribeToWidgetEvent(eventType, eventHandler) {\n    window.addEventListener(eventType, eventHandler);\n  }\n\n  onGreeting(name) {\n    this.name = name;\n    this.render();\n  }\n\n  render() {\n    ReactDOM.render(<App name={this.name} />, this.mountPoint);\n  }\n}\n\ncustomElements.define('subscriber-widget', SubscriberWidgetElement);\n\nexport default SubscriberWidgetElement;\n App.js \n import React from 'react';\nimport './App.css';\n\nfunction App({ name }) {\n  return name ? (<h2>Just got a greeting from {name}</h2>)\n    : (<h2>Waiting for a greeting...</h2>);\n}\n\nexport default App;\n \n To quickly test the event publishing we can execute from the JS console\nthese lines of code \n const widgetEvent = new CustomEvent('greeting', {\n  detail: {\n    name: 'Pippo'\n  },\n});\nwindow.dispatchEvent(widgetEvent);\n \n and then the widget will update the text. \n Make both widgets work in Entando \n To properly test widgets in an Entando instance, follow these steps (you\ncan use the  basic microfrontend\ntutorial  as reference) \n \n \n build both widgets \n \n \n copy widget files \n \n \n create widgets from App Builder \n \n \n create a page model from App Builder \n \n \n create a page and assign the just created page model \n \n \n configure the page dragging both widgets to the page \n \n \n For a sample page model, use this one \n JSON Configuration \n {\n  \"frames\": [\n    {\n      \"pos\": 0,\n      \"descr\": \"Sample Frame\",\n      \"mainFrame\": false,\n      \"defaultWidget\": null,\n      \"sketch\": null\n    },\n    {\n      \"pos\": 1,\n      \"descr\": \"Sample Frame Two\",\n      \"mainFrame\": false,\n      \"defaultWidget\": null,\n      \"sketch\": null\n    }\n  ]\n}\n \n Template \n <#assign wp=JspTaglibs[\"/aps-core\"]>\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n<html>\n<head>\n    <title><@wp.currentPage param=\"title\" /></title>\n</head>\n<body>\n<h1><@wp.currentPage param=\"title\" /></h1>\n<div><@wp.show frame=0 /></div>\n<div><@wp.show frame=1 /></div>\n</body>\n</html>\n \n Now, go to the page you just created and you will find both widgets.\nWrite something in the publisher widget input, press the button and the\nsubscriber widget will update. Done! \n"},{title:"Tutorial: Display widget configuration data",frontmatter:{},regularPath:"/v6.1/tutorials/micro-frontends/widget-configuration/display-widget-config-data.html",relativePath:"v6.1/tutorials/micro-frontends/widget-configuration/display-widget-config-data.md",key:"v-5c95a127",path:"/v6.1/tutorials/micro-frontends/widget-configuration/display-widget-config-data.html",headers:[{level:2,title:"Add an attribute to the custom element",slug:"add-an-attribute-to-the-custom-element"},{level:2,title:"Make react component handle the input",slug:"make-react-component-handle-the-input"},{level:2,title:"Rebuild the widget",slug:"rebuild-the-widget"},{level:2,title:"Update the Entando 6 widget in App Builder",slug:"update-the-entando-6-widget-in-app-builder"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:' Tutorial: Display widget configuration data \n So, we already created a react micro frontend widget and configuration\nscreen to customize a  name  field. \n In this tutorial we will display that field in our micro frontend\nwidget. \n Add an attribute to the custom element \n Edit  WidgetElement  to add attribute handling to the custom element,\nand make re-render our app when an attribute changes. Now, the  name \nattribute is being read from the custom element and passed as a prop to\nthe react root component ( App ). \n import React from \'react\';\nimport ReactDOM from \'react-dom\';\nimport App from \'./App\';\n\nconst ATTRIBUTES = {\n  name: \'name\',\n};\n\nclass WidgetElement extends HTMLElement {\n\n  static get observedAttributes() {\n    return Object.values(ATTRIBUTES);\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (!Object.values(ATTRIBUTES).includes(name)) {\n      throw new Error(`Untracked changed attribute: ${name}`);\n    }\n    if (this.mountPoint && newValue !== oldValue) {\n      this.render();\n    }\n  }\n\n  connectedCallback() {\n    this.mountPoint = document.createElement(\'div\');\n    this.appendChild(this.mountPoint);\n    this.render();\n  }\n\n  render() {\n    const name = this.getAttribute(ATTRIBUTES.name);\n    ReactDOM.render(<App name={name} />, this.mountPoint);\n  }\n}\n\ncustomElements.define(\'my-widget\', WidgetElement);\n\nexport default WidgetElement;\n \n \n Note \n attributeChangedCallback  is also a custom elements lifecycle hook\nmethod. \n Make react component handle the input \n Edit the  App  component now, to make it display the  name  prop. \n import React from \'react\';\nimport \'./App.css\';\n\nfunction App({name}) {\n  return (\n    <div className="App">\n      <header className="App-header">\n        <p>\n          Hello, {name}!\n        </p>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n \n Now, to ensure our custom element is working we can edit\n public/index.html  and set a value for the  name  attribute of the\ncustom element. \n <!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" />\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\n    <title>React App</title>\n  </head>\n  <body>\n    <my-widget name="Marco"/>\n  </body>\n</html>\n \n After page reload, you should be able to display a simple "Hello,\nMarco!" message. \n Rebuild the widget \n From the react project root, type: \n npm run build \n and the  build/static  directory will be (re)generated. Copy it again\ninto the Entando 6 instance under\n src\\main\\webapp\\resources\\static\\my-widget , then rename \n \n \n a file like  js/runtime~main.c7dcdf0b.js  to  js/runtime.js \n(bootstrapping logic) \n \n \n a file like  js/2.230b21ef.chunk.js  to  js/vendor.js  (third-party\nlibraries) \n \n \n a file like  js/main.1fd3965a.chunk.js  to  js/main.js  (app) \n \n \n a file like  css/main.d1b05096.chunk.js  to  css/main.css \n(stylesheet) \n \n \n \n Note \n you could keep the original names in order to avoid potential caching\nissues, but then you will have to update the  Custom UI  field in the\nApp Builder widget screen every time a new version of the widget is\ndeployed. \n \n If the application server you’re running does not have hot deploy\nenabled, restart it. \n Update the Entando 6 widget in App Builder \n Open the Entando App Builder, go to UX Patterns → Widgets, find the\nwidget  My Widget  and click to edit it. \n You’ll see a screen like this one \n \n Update the  Custom UI  field from: \n <#assign wp=JspTaglibs[ "/aps-core"]>\n<link rel="stylesheet" type="text/css" href="<@wp.resourceURL />static/my-widget/static/css/main.css">\n<script async src="<@wp.resourceURL />static/my-widget/static/js/runtime.js"><\/script>\n<script async src="<@wp.resourceURL />static/my-widget/static/js/vendor.js"><\/script>\n<script async src="<@wp.resourceURL />static/my-widget/static/js/main.js"><\/script>\n<my-widget />\n \n to \n <#assign wp=JspTaglibs[ "/aps-core"]>\n<link rel="stylesheet" type="text/css" href="<@wp.resourceURL />static/my-widget/static/css/main.css">\n<script async src="<@wp.resourceURL />static/my-widget/static/js/runtime.js"><\/script>\n<script async src="<@wp.resourceURL />static/my-widget/static/js/vendor.js"><\/script>\n<script async src="<@wp.resourceURL />static/my-widget/static/js/main.js"><\/script>\n<@wp.currentWidget param="config" configParam="name" var="configName" />\n<my-widget name="${configName}" />\n \n We basically added a JSTL tag to extract a field (under  configParam )\nfrom the config field of the current widget and put it in a  configName \nvariable, that we pass to the custom element. \n Save the widget and reload the page that contains the widget: you’ll see\n"Hello, Marco!" as expected. \n'},{title:"Create a React Micro Frontend",frontmatter:{sidebarDepth:2},regularPath:"/v6.1/tutorials/micro-frontends/react.html",relativePath:"v6.1/tutorials/micro-frontends/react.md",key:"v-25348330",path:"/v6.1/tutorials/micro-frontends/react.html",headers:[{level:2,title:"Create React App",slug:"create-react-app"},{level:3,title:"Wrap with Custom Element",slug:"wrap-with-custom-element"},{level:3,title:"Import Custom Element",slug:"import-custom-element"},{level:3,title:"Test Micro Frontend",slug:"test-micro-frontend"},{level:2,title:"Get Resource URL",slug:"get-resource-url"},{level:2,title:"Build It",slug:"build-it"},{level:3,title:"npm build",slug:"npm-build"},{level:2,title:"Host Micro Frontend",slug:"host-micro-frontend"},{level:3,title:"Create Public Folder",slug:"create-public-folder"},{level:3,title:"Update Custom UI Field",slug:"update-custom-ui-field"},{level:3,title:"View in Homepage",slug:"view-in-homepage"}],lastUpdated:"7/10/2020, 12:19:38 PM",lastUpdatedTimestamp:1594397978e3,content:" Create a React Micro Frontend \n Prerequisites \n \n A working instance of Entando. \n \n \n Tested Versions \n node v13.8.0 → We suggest using  nvm  to handle node installations. \n Create React App \n We'll use  Create React App  to create a simple app in seconds. \n npx create-react-app my-widget --use-npm\n \n This is the expected output: \n my-widget\n├── README.md\n├── node_modules\n├── package.json\n├── .gitignore\n├── public\n│   ├── favicon.ico\n│   ├── index.html\n│   ├── logo192.png\n│   ├── logo512.png\n│   ├── manifest.json\n│   └── robots.txt\n└── src\n    ├── App.css\n    ├── App.js\n    ├── App.test.js\n    ├── index.css\n    ├── index.js\n    ├── logo.svg\n    ├── serviceWorker.js\n    └── setupTests.js\n \n Start the app. \n cd  my-widget\n npm  start\n Wrap with Custom Element \n Add a new file  src/WidgetElement.js  with the custom element that will wrap the entire React app. \n import  React  from   'react' ; \n import  ReactDOM  from   'react-dom' ; \n import  App  from   './App' ; \n\n class   WidgetElement   extends   HTMLElement   { \n     connectedCallback ( )   { \n         this . mountPoint  =  document . createElement ( 'div' ) ; \n         this . appendChild ( this . mountPoint ) ; \n        ReactDOM . render ( < App  / > ,   this . mountPoint ) ; \n     } \n } \n\ncustomElements . define ( 'my-widget' ,  WidgetElement ) ; \n\n export   default  WidgetElement ; \n \n TIP \n connectedCallback  is a lifecycle hook that  runs each time the element is added to the DOM. \n \n The React  root  node is programatically generated in the  connectedCallback  method when our custom element is added to the DOM. \n Custom Elements \n \n Must contain a hyphen  -  in the name. : \n Cannot be a single word. \n Should follow  kebab-case  for naming convention. \n Import Custom Element \n Open  src/index.js . Here's what the initial file looks like: \n import  React  from   'react' ; \n import  ReactDOM  from   'react-dom' ; \n import   './index.css' ; \n import  App  from   './App' ; \n import   *   as  serviceWorker  from   './serviceWorker' ; \n\nReactDOM . render ( < App  / > ,  document . getElementById ( 'root' ) ) ; \n\n // If you want your app to work offline and load faster, you can change \n // unregister() to register() below. Note this comes with some pitfalls. \n // Learn more about service workers: https://bit.ly/CRA-PWA \nserviceWorker . unregister ( ) ; \n \n Replace the entire file with these two lines. \n import   './index.css' ; \n import   './WidgetElement' ; \n Test Micro Frontend \n \n \n Open  public/index.html . \n \n \n Replace  <div id=\"root\"></div>  with the custom element  <my-widget /> . \n \n \n    < body > \n     < noscript > You need to enable JavaScript to run this app. </ noscript > \n     < my-widget   /> \n    ...\n   </ body > \n \n Congratulations! \n You’re now running  React  in a containerized micro frontend. \n Get Resource URL \n Let's add our micro frontend to Entando by adding our JavaScript and CSS files to the  public  folder. \n TIP \n Entando makes files publicly available through the  public  folder. \n Add Widget \n Initially, we'll add a widget to get the resource URL for the  public  folder. Later on, we'll use the same widget to add our micro frontend to Entando. \n \n \n Go to  Entando App Builder  in your browser. \n \n \n Click  UX Patterns  →  Widgets  at the top nav. \n \n \n Click  Add  at the upper right. \n \n \n Enter the following: \n \n \n \n \n Title: My Widget  → for both English and Italian languages \n Code: my_widget  → note: dashes are not allowed \n Group: Free Access \n Custom UI: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < @wp . resourceURL  /> \n \n TIP \n <#assign wp=JspTaglibs[ \"/aps-core\"]>  gives you access to the  @wp  object where you can use environment variables like  resourceURL . \n \n \n Click  Save . \n Add Page \n Next, let's add our widget to a page so we can view the  Resource URL . \n If you're getting started with a new install of Entando, let's add our widget to the  Home  page: \n \n \n For Experienced Entando users: \n Add a new page → Add your widget to the page \n \n \n \n \n Click  Page Designer  →  Page Tree  at the top nav. \n \n \n Next to the  Home  folder, under  Actions , click  Edit . \n \n \n Next to  Page Template  select  Service Page . \n \n \n Click  Save and Configure . \n \n \n In the Search field in right-hand sidebar, enter  My Widget . \n \n \n Drag and drop  My Widget  into the  Sample Frame  in the main body of the page. \n \n \n Click  Publish . \n \n \n At the upper right, click  Go to Homepage . \n \n \n \n This will take you to a blank home page with your widget. \n \n \n Copy the  Resource URL . \n \n /entando-de-app/cmsresources/\n Build It \n Now that we have the resource URL where we'll host our  Create React App , we're ready to build. \n \n \n Create an  .env  file in the project root of your  Create React App . \n \n \n Add the  PUBLIC_URL  where we'll be hosting our files. \n \n \n Example: \n PUBLIC_URL=http://quickstart-entando.192.168.64.34.nip.io/entando-de-app/cmsresources/my-widget\n \n \n Replace  quickstart-entando.192.168.64.34.nip.io/app-builder  with the URL for your Entando App Builder instance. →  How to find your Entando App Builder URL. \n \n Notes \n \n quickstart-entando.192.168.64.34.nip.io  represents your  Entando App Builder  instance. \n /entando-de-app/cmsresources/  is your Resource URL \n my-widget  is the public folder we'll create to host our files \n \n \n TIP \n When you run  npm run build ,  Create React App  will substitute  %PUBLIC_URL%  with a correct absolute path so your project works even if you use client-side routing or host it at a non-root URL. \n npm build \n \n \n Open a command line, and navigate to the project root of your  Create React App . \n \n \n Run the command: \n \n \n npm  run build\n \n \n Rename the following generated files in the  build  directory. \n \n \n \n \n Example of Generated Build File \n Rename to \n Function \n \n \n \n \n build/static/js/2.f14073bd.chunk.js \n static/js/vendor.js \n Third-party libraries \n \n \n build/static/js/runtime-main.8a835b7b.js \n static/js/runtime.js \n Bootstrapping logic \n \n \n build/static/js/main.4a514a6d.chunk.js \n static/js/main.js \n App \n \n \n build/static/css/main.5f361e03.chunk.css \n static/css/main.css \n Stylesheet \n \n \n \n Generated Build Files \n We rename the JavaScript and CSS files so we can deploy new versions of the micro frontend without having to update the  Custom UI  field of our widget to reference the new files. \n \n If you want to use the original  file names with the content hashes to avoid potential caching issues in your browser , update the  Custom UI  field of your widget when deploying new versions of your micro frontend. The  Custom UI  settings will be covered in the next section. \n Additional Deployment Options \n \n Install the micro frontend from a bundle in the  Entando Component Repository . \n Add the micro frontend to  Entando App Builder . \n Load the micro frontend from an API. \n Host Micro Frontend \n Now we're ready to host our micro frontend in Entando. \n Create Public Folder \n \n \n Navigate to  Entando App Builder  in your browser. \n \n \n Click  Configuration  at the upper right hand side of the screen. \n \n \n Click the  File Browser  tab. \n \n \n Click the  public  folder. \n \n \n Click  Create Folder . \n \n \n Enter  my-widget . \n \n \n Click  Save . \n \n \n Click  public  →  my-widget . \n \n \n Create the same folder structure as your generated build directory \n \n \n \n my-widget/static/css \n my-widget/static/js \n \n \n Upload the files we renamed in the corresponding  js  and  css  folders. \n \n \n my-widget/static/css/main.css \n my-widget/static/js/main.js \n my-widget/static/js/runtime.js \n my-widget/static/js/vendor.js \n \n Note: You can drag and drop the files in your browser. \n \n Upload the  React  logo. \n \n \n my-widget/static/media/logo.5d5d9eef.svg  → You don't need to rename this file. \n Update Custom UI Field \n \n \n Click  UX Patterns  →  Widgets . \n \n \n Under the  My Widgets  cateogory → next to  My Widget  → under  Action  → select  Edit . \n \n \n Update  Custom UI  field: \n \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < link   rel = \" stylesheet \"   type = \" text/css \"   href = \" < @wp . resourceURL  /> my-widget/static/css/main.css \" > \n < script   async   src = \" < @wp . resourceURL  /> my-widget/static/js/runtime.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> my-widget/static/js/vendor.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> my-widget/static/js/main.js \" > </ script > \n < my-widget   /> \n \n \n Click  Save . \n View in Homepage \n Let's see the React micro frontend in action on our page. \n \n \n In the  Entando App Builder  dashboard, click  Go to Homepage  at the upper right. \n \n \n Go to the page that you created, and click refresh. \n \n \n \n Congratulations! \n You now have a React micro frontend running in Entando. \n \n"},{title:"Add a Configuration Screen in App Builder",frontmatter:{},regularPath:"/v6.1/tutorials/micro-frontends/widget-configuration/",relativePath:"v6.1/tutorials/micro-frontends/widget-configuration/README.md",key:"v-62808372",path:"/v6.1/tutorials/micro-frontends/widget-configuration/",headers:[{level:2,title:"Create React App",slug:"create-react-app"},{level:2,title:"Add Input Field",slug:"add-input-field"},{level:2,title:"Custom Element",slug:"custom-element"},{level:2,title:"Configuration Screen",slug:"configuration-screen"},{level:2,title:"Add Attribute",slug:"add-attribute"},{level:2,title:"Display Input",slug:"display-input"},{level:2,title:"Build It",slug:"build-it"},{level:2,title:"Update Widget in App Builder",slug:"update-widget-in-app-builder"}],lastUpdated:"6/26/2020, 10:59:44 AM",lastUpdatedTimestamp:1593183584e3,content:' Add a Configuration Screen in App Builder \n Entando 6 widgets can be customized through an App Builder configuration\nscreen so the citizen developers can avoid writing ad-hoc additional\ncode. \n In Entando 6, the configuration screen is also a micro frontend, which\ncan also be defined as a web component. That means you can develop and\ntest it in isolation, without a running Entando instance. \n Create React App \n Let’s start with the boilerplate provided by  Create React\nApp , probably the most popular one. \n npx create-react-app my-widget-config --use-npm \n my-widget-config\n├── README.md\n├── node_modules\n├── package.json\n├── .gitignore\n├── public\n│   ├── favicon.ico\n│   ├── index.html\n│   ├── logo192.png\n│   ├── logo512.png\n│   ├── manifest.json\n│   └── robots.txt\n└── src\n    ├── App.css\n    ├── App.js\n    ├── App.test.js\n    ├── index.css\n    ├── index.js\n    ├── logo.svg\n    ├── serviceWorker.js\n    └── setupTests.js\n \n Then, type  cd my-widget-config  and  npm start  to start the app. \n Add Input Field \n Let’s start with a simple form: only an input with a label. So, let’s\nedit  App.js \n import React from \'react\';\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { name: \'\'};\n  }\n\n  handleNameChange(value) {\n    this.setState(prevState => ({\n      ...prevState,\n      name: value,\n    }));\n  }\n\n  render() {\n    const { name } = this.state;\n    return (\n      <div>\n        <h1>Sample Entando 6 Widget Configuration</h1>\n        <label htmlFor="name">Name</label>\n        <input id="name" onChange={e => this.handleNameChange(e.target.value)} value={name} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n \n You are free to use your favorite form handling library e.g.,\n Formik ,\n redux-form  (that requirese redux) or others. \n In regards to styling, since this is going to be an App Builder screen,\nwe strongly suggest using  PatternFly\nv3  ( patternfly  and  patternfly-react \npackages) to keep UX coherence. \n Custom Element \n Now, let’s add the web component that will wrap the entire React app.\nLet’s name it  WidgetElement \n import React from \'react\';\nimport ReactDOM from \'react-dom\';\nimport App from \'./App\';\n\nclass WidgetElement extends HTMLElement {\n  constructor() {\n    super();\n    this.reactRootRef = React.createRef();\n    this.mountPoint = null;\n  }\n\n  get config() {\n    return this.reactRootRef.current ? this.reactRootRef.current.state : {};\n  }\n\n  set config(value) {\n    return this.reactRootRef.current.setState(value);\n  }\n\n  connectedCallback() {\n    this.mountPoint = document.createElement(\'div\');\n    this.appendChild(this.mountPoint);\n    ReactDOM.render(<App ref={this.reactRootRef} />, this.mountPoint);\n  }\n}\n\ncustomElements.define(\'my-widget-config\', WidgetElement);\n\nexport default WidgetElement;\n \n Its responsibility is rendering the react app and syncing the react app\nstate in a  config  property, that  must  be named that way. The key to\nApp builder communication is that it works in three steps: \n \n \n App Builder reads  config  property when the widget config screen is\nrendered \n \n \n config  property is mutated when a user configures the widget \n \n \n When a user saves the config, App Builder retrieves it (again, from\nthe  config  property) and persists it through Entando APIs \n \n \n This means the widget developer can focus on the configuration screens\nwithout having to call Entando APIs to read or write configuration. \n One more JS file to update:  index.js . Starting from this \n import React from \'react\';\nimport ReactDOM from \'react-dom\';\nimport \'./index.css\';\nimport App from \'./App\';\nimport * as serviceWorker from \'./serviceWorker\';\n\nReactDOM.render(<App />, document.getElementById(\'root\'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n \n You only have to import  WidgetElement  plus the css, if needed.\nSomething like \n import \'./index.css\';\nimport \'./WidgetElement\';\n \n We assume we don’t need a service worker for the widget, so we can\ndelete serviceWorker.js. \n To ensure our web component is working we have to edit\n public/index.html . Remove  <div id="root"></div>  from the  body  (we\nprogrammatically generated the react root in the  connectedCallback \nmethod of  WidgetElement ) and add our new web component tag\n <my-widget /> . \n <!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" />\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\n    <title>React App</title>\n  </head>\n  <body>\n    <my-widget-config />\n  </body>\n</html>\n \n \n Note \n the web component tag name ( my-widget-config  in this tutorial)\n must  match the first parameter of the  customElements.define \nmethod. \n \n The page should auto reload and…​congrats, you’re running an Entando 6\nwidget in isolation. \n Configuration Screen \n Before integrating the widget config screen, we need some widget info.\nOpen App Builder, go to UX Patterns → Widgets and click on the installed\nwidget that we’re creating the configuration screen for. \n You’ll see a screen like: \n \n Next, we’ll build our widget before embedding it into the Entando 6\ninstance. From the react project root, type \n npm run build \n and a  build/static  directory will be generated. Copy it into the\nEntando 6 instance under\n src\\main\\webapp\\cmsresources\\my-widget-config , then rename \n \n \n a file like  js/runtime~main.c7dcdf0b.js  to  js/runtime.js \n(bootstrapping logic) \n \n \n a file like  js/2.230b21ef.chunk.js  to  js/vendor.js  (third-party\nlibraries) \n \n \n a file like  js/main.1fd3965a.chunk.js  to  js/main.js  (app) \n \n \n Now, edit again the widget and update the  configUI  field. \n {\n  "customElement": "my-widget-config",\n  "resources": [\n    "my-widget-config/static/js/runtime.js",\n    "my-widget-config/static/js/vendor.js",\n    "my-widget-config/static/js/main.js"\n  ]\n}\n \n \n Note \n \n \n It is possible to keep the original names in order to avoid\npotential caching issues, but then you will have to update the\n Config UI  field in the App Builder widget screen each time a new\nversion of the widget is deployed. \n \n \n configUI  is a JSON object, so pay attention to save a\nwell-formed one (the integrated JSON editor will help you) \n \n \n value for  customElement  must match the name of custom tag in\n index.html  and the one passed as parameter to\n customElements.define  in  WidgetElement \n \n \n \n Last step: configure a page in App Builder, drag our widget into the\npage model slot and you’ll see the configuration screen we just built. \n Display Widget Configuration \n So, we already created a react micro frontend widget and configuration\nscreen to customize a  name  field. \n In this tutorial we will display that field in our micro frontend\nwidget. \n Add Attribute \n Edit  WidgetElement  to add attribute handling to the custom element,\nand make re-render our app when an attribute changes. Now, the  name \nattribute is being read from the custom element and passed as a prop to\nthe react root component ( App ). \n import React from \'react\';\nimport ReactDOM from \'react-dom\';\nimport App from \'./App\';\n\nconst ATTRIBUTES = {\n  name: \'name\',\n};\n\nclass WidgetElement extends HTMLElement {\n\n  static get observedAttributes() {\n    return Object.values(ATTRIBUTES);\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (!Object.values(ATTRIBUTES).includes(name)) {\n      throw new Error(`Untracked changed attribute: ${name}`);\n    }\n    if (this.mountPoint && newValue !== oldValue) {\n      this.render();\n    }\n  }\n\n  connectedCallback() {\n    this.mountPoint = document.createElement(\'div\');\n    this.appendChild(this.mountPoint);\n    this.render();\n  }\n\n  render() {\n    const name = this.getAttribute(ATTRIBUTES.name);\n    ReactDOM.render(<App name={name} />, this.mountPoint);\n  }\n}\n\ncustomElements.define(\'my-widget\', WidgetElement);\n\nexport default WidgetElement;\n \n \n Note \n attributeChangedCallback  is also a custom elements lifecycle hook\nmethod. \n Display Input \n Edit the  App  component now, to make it display the  name  prop. \n import React from \'react\';\nimport \'./App.css\';\n\nfunction App({name}) {\n  return (\n    <div className="App">\n      <header className="App-header">\n        <p>\n          Hello, {name}!\n        </p>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n \n Now, to ensure our custom element is working we can edit\n public/index.html  and set a value for the  name  attribute of the\ncustom element. \n <!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" />\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\n    <title>React App</title>\n  </head>\n  <body>\n    <my-widget name="Marco"/>\n  </body>\n</html>\n \n After page reload, you should be able to display a simple "Hello,\nMarco!" message. \n Build It \n From the react project root, type: \n npm run build \n and the  build/static  directory will be (re)generated. Copy it again\ninto the Entando 6 instance under\n src\\main\\webapp\\resources\\static\\my-widget , then rename \n \n \n a file like  js/runtime~main.c7dcdf0b.js  to  js/runtime.js \n(bootstrapping logic) \n \n \n a file like  js/2.230b21ef.chunk.js  to  js/vendor.js  (third-party\nlibraries) \n \n \n a file like  js/main.1fd3965a.chunk.js  to  js/main.js  (app) \n \n \n a file like  css/main.d1b05096.chunk.js  to  css/main.css \n(stylesheet) \n \n \n \n Note \n you could keep the original names in order to avoid potential caching\nissues, but then you will have to update the  Custom UI  field in the\nApp Builder widget screen every time a new version of the widget is\ndeployed. \n \n If the application server you’re running does not have hot deploy\nenabled, restart it. \n Update Widget in App Builder \n Open the Entando App Builder, go to UX Patterns → Widgets, find the\nwidget  My Widget  and click to edit it. \n You’ll see a screen like this one \n \n Update the  Custom UI  field from: \n <#assign wp=JspTaglibs[ "/aps-core"]>\n<link rel="stylesheet" type="text/css" href="<@wp.resourceURL />static/my-widget/static/css/main.css">\n<script async src="<@wp.resourceURL />static/my-widget/static/js/runtime.js"><\/script>\n<script async src="<@wp.resourceURL />static/my-widget/static/js/vendor.js"><\/script>\n<script async src="<@wp.resourceURL />static/my-widget/static/js/main.js"><\/script>\n<my-widget />\n \n to \n <#assign wp=JspTaglibs[ "/aps-core"]>\n<link rel="stylesheet" type="text/css" href="<@wp.resourceURL />static/my-widget/static/css/main.css">\n<script async src="<@wp.resourceURL />static/my-widget/static/js/runtime.js"><\/script>\n<script async src="<@wp.resourceURL />static/my-widget/static/js/vendor.js"><\/script>\n<script async src="<@wp.resourceURL />static/my-widget/static/js/main.js"><\/script>\n<@wp.currentWidget param="config" configParam="name" var="configName" />\n<my-widget name="${configName}" />\n \n We basically added a JSTL tag to extract a field (under  configParam )\nfrom the config field of the current widget and put it in a  configName \nvariable, that we pass to the custom element. \n Save the widget and reload the page that contains the widget: you’ll see\n"Hello, Marco!" as expected. \n'},{title:"Entando Platform",frontmatter:{sidebarDepth:0},regularPath:"/v6.2/docs/",relativePath:"v6.2/docs/README.md",key:"v-3aec1854",path:"/v6.2/docs/",headers:[{level:2,title:"Entando Architecture",slug:"entando-architecture"},{level:2,title:"Why Kubernetes?",slug:"why-kubernetes"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:" Entando Platform \n Entando is a  micro frontend platform for Kubernetes  that helps enterprises innovate faster with parallel development teams that have end-to-end autonomy across the entire stack. \n With native support for Javascript app development, a micro frontend and microservices architecture, deployment of apps in containers that can be individually scaled up and down, and automated management of containers with Kubernetes, we simplify the move for enterprises looking to modernize across on-prem and cloud infrastructures. \n Entando Architecture \n \n The Entando platform includes the following major elements: \n \n Entando App Engine : assemble micro frontends & microservices and compose them on a page. \n Entando App Builder : the user interface to build and design applications. \n Entando Component Generator : provide advanced data modeling capabilities and automatically generate the corresponding microservices and micro frontends. \n Entando Component Repository : a shared, internal repository to encourage code reuse across the enterprise. \n Entando Identity Management : token-based authentication across multiple domains and connect service providers with identity providers. \n Entando WCMS : a web content management system that supports headless CMS. \n (optional)  Entando Business Automation Bundle : workflow and task automation including out of the box integration with Red Hat Process Automation Manager (PAM). \n Why Kubernetes? \n Instead of you doing the work to ensure your apps and services stay up and running, Kubernetes does the work for you. For each app or service, you can set resource limits, the number of pods you want backing each service, upgrade strategy, and auto-scaling. Kubernetes actively manages your cluster to match your defined resource utilization and ensures your site doesn't go down. \n How Google Runs Containers in Production \n Each week, Google deploys over 2 billion containers in production to run all of its services like Gmail, YouTube, and Search. Kubernetes is Google's open source solution to automate the management of containers at scale. \n \n Over 50% of Fortune 500 companies use Kubernetes with product offerings from Amazon Elastic Kubernetes Service (EKS), Google Cloud Platform (GKE), IBM (Red Hat) OpenShift, Microsoft Azure (AKS), and VMWare Pivotal (PKS). \n"},{title:"Contributing to Entando",frontmatter:{},regularPath:"/v6.2/docs/community/contributing.html",relativePath:"v6.2/docs/community/contributing.md",key:"v-696f6946",path:"/v6.2/docs/community/contributing.html",headers:[{level:2,title:"Contributing to the Source",slug:"contributing-to-the-source"},{level:2,title:"Java",slug:"java"},{level:2,title:"Javascript",slug:"javascript"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:" Contributing to Entando \n There are many ways to contribute to Entando including participating in the  Entando Forum , opening issues on GitHub,  updating documentation , building bundles using the  Entando Component Repository , and contributing directly to the source. \n Contributing to the Source \n Entando welcomes contributions to our source code repositories. This is a brief overview of how to create a pull request for an Entando repository. \n If you're new to forks in the git world checkout this guide  Working with Forks \n \n Find the repository you want to edit on the Entando GitHub\n \n https://github.com/entando \n https://github.com/entando-k8s \n \n \n Create a fork of the repository you want to update \n Make your changes or updates on your fork. We recommend making your changes on a branch so that you can update your commits as needed before creating your PR \n Submit a PR against the master branch of the repository you're working against. If you're fixing a specific issue reference that issue number in the notes and linked issues \n Watch the automated builds to make sure everything passes \n The Entando team will merge your changes! \n Code Style and Formatting \n Most Entando repositories enforce code style rules. References and setup for the main\nsource types are provided below. \n Java \n Java rules are based on checkstyle and PMD can be found at in the  entando-code-style  project. There are configuration files for Intellij, Eclipse, and Netbeans for automated formatting. \n Javascript \n Code style and formatting rules for all Entando javascript projects are enforced by linters in every project. For a reference example see: .sass-lint.yml and .eslintrc.js in the  App builder \n In the future these rules will be replaced by Prettier. \n Find the Code \n Entando source can be found on GitHub in the following organizations. \n \n https://github.com/entando \n https://github.com/entando-k8s \n \n For an overview of the key projects in both GitHub organizations and their role in the architecture see  Entando Deployment Structure \n Get Help \n If you have questions, need help, or want to find out more about contributing join us at \n \n Entando Forum \n Community Slack \n \n"},{title:"Entando Contributor Covenant Code of Conduct",frontmatter:{},regularPath:"/v6.2/docs/community/code-of-conduct.html",relativePath:"v6.2/docs/community/code-of-conduct.md",key:"v-415409a8",path:"/v6.2/docs/community/code-of-conduct.html",headers:[{level:2,title:"Our Pledge",slug:"our-pledge"},{level:2,title:"Our Standards",slug:"our-standards"},{level:2,title:"Enforcement Responsibilities",slug:"enforcement-responsibilities"},{level:2,title:"Scope",slug:"scope"},{level:2,title:"Enforcement",slug:"enforcement"},{level:2,title:"Enforcement Guidelines",slug:"enforcement-guidelines"},{level:3,title:"1. Correction",slug:"_1-correction"},{level:3,title:"2. Warning",slug:"_2-warning"},{level:3,title:"3. Temporary Ban",slug:"_3-temporary-ban"},{level:3,title:"4. Permanent Ban",slug:"_4-permanent-ban"},{level:2,title:"Attribution",slug:"attribution"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:" Entando Contributor Covenant Code of Conduct \n Our Pledge \n We as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, religion, or sexual identity\nand orientation. \n We pledge to act and interact in ways that contribute to an open, welcoming,\ndiverse, inclusive, and healthy community. \n Our Standards \n Examples of behavior that contributes to a positive environment for our\ncommunity include: \n \n Demonstrating empathy and kindness toward other people \n Being respectful of differing opinions, viewpoints, and experiences \n Giving and gracefully accepting constructive feedback \n Accepting responsibility and apologizing to those affected by our mistakes,\nand learning from the experience \n Focusing on what is best not just for us as individuals, but for the\noverall community \n \n Examples of unacceptable behavior include: \n \n The use of sexualized language or imagery, and sexual attention or\nadvances of any kind \n Trolling, insulting or derogatory comments, and personal or political attacks \n Public or private harassment \n Publishing others' private information, such as a physical or email\naddress, without their explicit permission \n Other conduct which could reasonably be considered inappropriate in a\nprofessional setting \n Enforcement Responsibilities \n Community leaders are responsible for clarifying and enforcing our standards of\nacceptable behavior and will take appropriate and fair corrective action in\nresponse to any behavior that they deem inappropriate, threatening, offensive,\nor harmful. \n Community leaders have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions that are\nnot aligned to this Code of Conduct, and will communicate reasons for moderation\ndecisions when appropriate. \n Scope \n This Code of Conduct applies within all community spaces, and also applies when\nan individual is officially representing the community in public spaces.\nExamples of representing our community include using an official e-mail address,\nposting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event. \n Enforcement \n Instances of abusive, harassing, or otherwise unacceptable behavior may be\nreported to the community leaders responsible for enforcement at\ncommunity@entando.com. \n All complaints will be reviewed and investigated promptly and fairly. \n All community leaders are obligated to respect the privacy and security of the\nreporter of any incident. \n Enforcement Guidelines \n Community leaders will follow these Community Impact Guidelines in determining\nthe consequences for any action they deem in violation of this Code of Conduct: \n 1. Correction \n Community Impact : Use of inappropriate language or other behavior deemed\nunprofessional or unwelcome in the community. \n Consequence : A private, written warning from community leaders, providing\nclarity around the nature of the violation and an explanation of why the\nbehavior was inappropriate. A public apology may be requested. \n 2. Warning \n Community Impact : A violation through a single incident or series\nof actions. \n Consequence : A warning with consequences for continued behavior. No\ninteraction with the people involved, including unsolicited interaction with\nthose enforcing the Code of Conduct, for a specified period of time. This\nincludes avoiding interactions in community spaces as well as external channels\nlike social media. Violating these terms may lead to a temporary or\npermanent ban. \n 3. Temporary Ban \n Community Impact : A serious violation of community standards, including\nsustained inappropriate behavior. \n Consequence : A temporary ban from any sort of interaction or public\ncommunication with the community for a specified period of time. No public or\nprivate interaction with the people involved, including unsolicited interaction\nwith those enforcing the Code of Conduct, is allowed during this period.\nViolating these terms may lead to a permanent ban. \n 4. Permanent Ban \n Community Impact : Demonstrating a pattern of violation of community\nstandards, including sustained inappropriate behavior,  harassment of an\nindividual, or aggression toward or disparagement of classes of individuals. \n Consequence : A permanent ban from any sort of public interaction within\nthe community. \n Attribution \n This Code of Conduct is adapted from the  Contributor Covenant ,\nversion 2.0, available at\nhttps://www.contributor-covenant.org/version/2/0/code_of_conduct.html. \n Community Impact Guidelines were inspired by  Mozilla's code of conduct\nenforcement ladder . \n For answers to common questions about this code of conduct, see the FAQ at\nhttps://www.contributor-covenant.org/faq. Translations are available at\nhttps://www.contributor-covenant.org/translations. \n"},{title:"Entando's Custom Resources for Kubernetes",frontmatter:{},regularPath:"/v6.2/docs/concepts/custom-resources.html",relativePath:"v6.2/docs/concepts/custom-resources.md",key:"v-82dc7c74",path:"/v6.2/docs/concepts/custom-resources.html",headers:[{level:2,title:"Objective",slug:"objective"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"The Core Entando Custom Resources",slug:"the-core-entando-custom-resources"},{level:2,title:"EntandoKeycloakServer",slug:"entandokeycloakserver"},{level:3,title:"Overview",slug:"overview-2"},{level:3,title:"Example",slug:"example"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties"},{level:2,title:"EntandoClusterInfrastructure",slug:"entandoclusterinfrastructure"},{level:3,title:"Overview",slug:"overview-3"},{level:3,title:"Example",slug:"example-2"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-2"},{level:2,title:"EntandoApp",slug:"entandoapp"},{level:3,title:"Overview",slug:"overview-4"},{level:3,title:"Example",slug:"example-3"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-3"},{level:2,title:"EntandoPlugin",slug:"entandoplugin"},{level:3,title:"Overview",slug:"overview-5"},{level:3,title:"Example",slug:"example-4"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-4"},{level:2,title:"EntandoAppPluginLink",slug:"entandoapppluginlink"},{level:3,title:"Overview",slug:"overview-6"},{level:3,title:"Example",slug:"example-5"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-5"},{level:2,title:"EntandoDatabaseService",slug:"entandodatabaseservice"},{level:3,title:"Example",slug:"example-6"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-6"},{level:2,title:"EntandoCompositeApp",slug:"entandocompositeapp"},{level:3,title:"Overview",slug:"overview-7"},{level:3,title:"Example",slug:"example-7"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-7"}],lastUpdated:"12/15/2021, 2:22:26 PM",lastUpdatedTimestamp:1639596146e3,content:' Entando\'s Custom Resources for Kubernetes \n Objective \n This document provides an overview of the Entando Kubernetes Custom Resources and their semantics in Entando 6. \n Prerequisites \n \n Basic knowledge of Kubernetes and how to deploy Docker images to it \n Basic knowledge of Helm and how Helm Charts use YAML templates for parameterized deployments to Kubernetes \n Overview \n Amongst the many features it offers, Kubernetes also comes with a REST API that for dozens of different resources types.\nGenerally these API off full Create/Retrieve/Update/Delete (CRUD) access to each of the resource types. We\ntypically format these resources in YAML or JSON and use commandline tools such as\n kubectl  or  oc  to manage them. Each of these resources has a clearly defined structure\nthat is well documented in the  Kubernetes API  .\nKubernetes  also allows clients to subscribe to events generated as these resources get updated. These subscriptions\nare called \'watches\' and allow clients to be notified whenever the state of a resource changes. Kubernetes also\nenforces very strong role based access control (RBAC) support on all resources, with permissions down to the level\nof granularity of operation (Create/Retrieve/Update/Delete/Watch) per resource. \n The basic architecture for Kubernetes worked so well for the developers of Kubernetes that they decided to also make it\navailable to third  party developers. Kubernetes now offers a mechanism to allow 3rd parties to provide its own custom\nresource types that still leverage the CRUD support, event subscriptions and RBAC provided by Kubernetes out of the box.\nThis mechanism is referred to as Custom Resources. \n Custom Resources are very commonly used with Kubernetes Operators. Operators are Docker images that have been\ndeployed to Kubernetes Deployments. The generally observe a set of custom resources and perform some operations against\nthe Kubernetes API to reflect the state changes in the Custom Resource. We can say that the Custom Resources are associated\nwith specific semantics in how they are translated to \n One can introduce a new Custom Resource into Kubernetes by registering a Custom Resource Definition (CRD). This is really\njust another yaml or json resource that defines the structure of the Custom Resource to be installed using the OpenAPI\nJSON Schema format. When talking about Custom Resources, it is very important to distinguish between Custom Resource\nDefinitions and Custom Resources. CRD\'s are static type definitions provided by an Operator\nprovider such as Entando. For those familiar with programming languages, CRD\'s are like class definitions, whereas\nCustom Resources are actual instances of that class. \n Entando introduces two groups of Custom Resources. On the one hand, there are the core Entando Custom Resources required\nfor a basic installation of Entando in a Kubernetes cluster. These Custom Resources directly result in other\nKubernetes resources being deployed in the cluster. On the other hand, there are the Custom Resources specific\nto the Entando Component Repository that serve primarily as metadata for other Entando components. \n The Core Entando Custom Resources \n The Entando Operator observes all the Core Entando Custom Resources in one or more namespaces. This means that if a Core\nEntando Custom Resource is created, updated or deleted, the Entando Operator will trigger a new run-to-completion Pod\nthat will translate that state change into a state change in the actual Kubernetes Cluster. Often, this will\nresult in the Deployment of one or more Docker images, but also one or more Services and sometimes and Ingress\ntoo. We refer to the Docker Images that implement these run-to-completion Pods as Entando Kubernetes Controllers. \n The Entando Operator itself is also implemented as a Docker Image. You can have a closer look at how it works in the\n entando-k8s-controller-coordinator  project on Github.\nApart from the normal Maven, Java and Docker files one would expect, you will also notice the\n entando-k8s-controller-coordinator Helm Chart .\nThis Helm Chart is basically the entrypoint for installations of Entando 6 on Kubernetes. More detailed instructions\non how to install the Entando 6 Operator are available in our\n installation instructions \n EntandoKeycloakServer \n The EntandoKeycloakServer Custom Resource is used to deploy and configure a Red Hat Keycloak Server instance on the\ncluster. After deploying this Keycloak instance, the Entando Operator will create a Kubernetes Secret that provides\nthe necessary information for subsequent deployment operations to access the Keycloak instance as the Admin user. This\nallows the rest of the Entando Kubernetes Controllers to create a Keycloak OIDC client for every HTTP service that\ngets deployed. If you already have a Keycloak instance that you would use, you can skip this custom resource entirely\nand simply create the `keycloak-admin-secret\' in the operator\'s namespace as specified in\n this tutorial \n Overview \n \n Entando Cluster Citizen:  Keycloak \n Custom Resource Definition:  EntandoKeycloakServer \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-keycloak-controller \n Github Repo:  entando-k8s/entando-k8s-keycloak-controller \n \n \n Deployment Details:\n \n Docker image:  entando/entando-keycloak \n Github Repo:  entando/entando-keycloak \n \n \n Possible Database Images:\n \n MySQL:  docker.io/centos/mysql-57-centos7 \n PostgreSQL:  docker.io/centos/postgresql-96-centos7 \n Example \n ---\nkind: "EntandoKeycloakServer"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-keycloak"\n  namespace: "keycloak-namespace"\nspec:\n  dbms: "postgresql"\n  imageName: "entando/entando-keycloak"\n  ingressHostName: "test-keycloak.ampie.dynu.net"\n  isDefault: true\n  parameters: \n    KEYCLOAK_WELCOME_THEME: my-custom-theme\n  tlsSecretName: my-tls-secret\n  replicas: 1\n Explanation of properties \n \n spec.dbms  is used to select the database management of choice. If this value matches up to the  spec.dbms  property\nof a previously  configured  EntandoDatabaseService ,\nthe Keycloak image will be configured to use this service.\nAlternatively, the Entando Operator will use this value to deploy a dedicated Database instance in this namespace\nfor Keycloak to use. If left empty, or given value of \'none\', Keycloak will be deployed using its own internal\nH2 database. \n spec.imageName  is used to provide a customized image. By default, the operator will use the  entando/entando-keycloak \ndiscussed above. When using the default image, please refer to the\n relevant section \nin the README of the Entando Operator to determine how the Docker registry and version of this image will be calculated.\nWhen you need to customize the theme or add extensions to Keycloak, you can create your own custom image and provide\nthe value in this property. In this custom image, make sure you use the default image ( entando/entando-keycloak )\nas a base image. You can then add your customizations and build your own image. Please use a fully qualified\nDocker image name here. \n spec.ingressHostName  is the hostname of the Kubernetes Ingress to be created for Keycloak. Please ensure that this is\naccessible using the default routing suffix of your Entando Operator Deployment, or a DNS name previously\nregistered with your DNS provider. \n spec.isDefault  is \'true\' by default and this should suffice for most conditions. This will result in the standard\n keycloak-admin-secret  being replaced by a Secret connecting you to this newly created Keycloak instance.\nTheoretically one could use multiple Keycloak instances in a cluster, in which case this property should be false. \n spec.parameters  is a Map of environment variables to pass to the Keycloak Docker image. For example, this could\nbe used to select a specific theme for Keycloak to use using the variable KEYCLOAK_WELCOME_THEME. These parameters\nare applied to the container\'s environment variables after all variables have been calculated. It can therefore\nalso be used as a mechanism to override any of the default environment variables that need customization. \n spec.tlsSecretName  is the name of a standard Kubernetes\n TLS Secret  that will be used for the\nresulting Ingress. This is only required if the\n globally configured TLS Secret \nfor the Operator is absent or has not been created with a wildcard hostname that supports this Keycloak instance\'s hostname. \n spec.replicas  - the number of replicas to be made available on the Deployment of this Keycloak Server \n EntandoClusterInfrastructure \n The EntandoClusterInfrastructure custom resource can be used to create the shared services that Entando requires in a cluster.\nAt the time of the writing of this document, there is really only one service, which is the Entando K8S Service, but this\nmay change in future. Deployments resulting from this custom resources are configured to use the default Keycloak\nServer specified in the  keycloak-admin-secret  using the  entando  realm. An Ingress will also be created as part of this\ndeployment. At this point, there is no way to customize the image in question. \n Overview \n \n Entando Cluster Citizen:  Entando Kubernetes Service \n Custom Resource Definition:  EntandoClusterInfrastructure \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-cluster-infrastructure-controller \n Github Repo:  entando-k8s/entando-k8s-keycloak-controller \n \n \n Deployment Details:\n \n Docker image:  entando/entando-k8s-service \n Github Repo:  entando-k8s/entando-k8s-service \n \n \n Possible Database Images: none \n Example \n ---\nkind: "EntandoClusterInfrastructure"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-eci"\n  namespace: "eci-namespace"\nspec:\n  keycloakSecretToUse: some-keycloak-secret\n  ingressHostName: "test-keycloak.ampie.dynu.net"\n  isDefault: true\n  parameters: \n    KEYCLOAK_WELCOME_THEME: my-custom-theme\n  tlsSecretName: my-tls-secret\n  replicas: 1\n Explanation of properties \n \n spec.keycloakSecretToUse  is used to determine which Kubernetes Secret to use to connect to the correct\nKeycloak instance. If not specified, the default Secret  keycloak-admin-secret  will be used. Only useful\nif you have more than one Keycloak server in your cluster. \n spec.ingressHostName  is the hostname of the Kubernetes Ingress to be created for the Entando K8S Service. Please\nensure that this is accessible using the default routing suffix of your Entando Operator Deployment, or a DNS\nname previously registered with your DNS provider. \n spec.isDefault  is \'true\' by default and this should suffice for most conditions. This will result in the standard\n entando-cluster-infrastructure-secret  being replaced by a Secret connecting you to this newly created\nEntando K8S Service.  Theoretically one could use multiple Entando K8S Services in a cluster, in which\ncase this property should be false for new Entando K8S Services that should not override the default Secret. \n spec.parameters  is a Map of environment variables to pass to the Entando K8S Service Docker image. For example, this could\nbe used to override the ENTANDO_NAMESPACES_TO_OBSERVE variable that configures the set of Kubernetes namespaces\nthis service should read EntandoDeBundles from. Also note that all of the\n Spring variables in entando-k8s-service project \ncan also be overridden here by specifying the equivalent SNAKE_CASE names of the dot-delimited Spring properties.\nThese parameters are applied to the container\'s environment variables after all variables have been calculated.\nIt can therefore also be used as a mechanism to override any of the default environment variables that need customization. \n spec.tlsSecretName  is the name of a standard Kubernetes\n TLS Secret  that will be used for the\nresulting Ingress. This is only required if the\n globally configured TLS Secret \nfor the Operator is absent or has not been created with a wildcard hostname that supports this Keycloak instance\'s hostname. \n spec.replicas  - the number of replicas to be made available on the Deployment of this Entando K8S Service \n EntandoApp \n An EntandoApp is a Deployment of a Docker image that hosts an Entando and Java based web application. Entando offers two\nstandard images that can be used, but generally we expect our customers to provide their own images here. An EntandoApp\nDeployment packages three images into a single Pod: the Entando App Image in question, AppBuilder and Component Manager. \n Overview \n \n Custom Resource Definition:  EntandoApp \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-app-controller \n Github Repo:  entando/entando-k8s-app-controller \n \n \n Deployment Details - Entando App:\n \n Docker image:  entando/entando-de-app-wildfly   or    entando/entando-de-app-eap \n Github Repo:  entando-k8s/entando-de-app \n Entando Cluster Citizen:  Entando App \n \n \n Deployment Details - AppBuilder:\n \n Docker image:  entando/app-builder \n Github Repo:  entando/app-builder \n \n \n Deployment Details - ComponentManager:\n \n Docker image:  entando/entando-component-manager \n Github Repo:  entando-k8s/entando-component-manager \n Entando Cluster Citizen:  Component Manager \n \n \n Possible Database Images:\n \n MySQL:  docker.io/centos/mysql-57-centos7 \n PostgreSQL:  docker.io/centos/postgresql-96-centos7 \n Example \n ---\nkind: "EntandoApp"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-app"\n  namespace: "my-namespace"\nspec:\n  standardServerImage: wildfly\n  customServerImage: your-org/your-image:4.3.2\n  dbms: "postgresql"\n  ingressPath: my-app\n  keycloakSecretToUse: some-kc-secret\n  clusterInfrastructureToUse: some-eci-secret  \n  ingressHostName: "test-app.my-routing-suffix.com"\n  parameters: \n    ENTANDO_VAR1: my-var1\n  tlsSecretName: my-tls-secret\n  replicas: 1\n Explanation of properties \n \n spec.standardServerImage  can be either wildfly  or  eap . This instructs the Entando Operator to use one of the\ntwo standard Entando App images.\n \n For  wildfly  it will deploy the  entando/entando-de-app-wildfly  image \n For  eap  it will deploy the  entando/entando-de-app-eap  image\nThis property and the  spec.customServerImage  are  assumed to be mutually exclusive. Only provide a value to\none of the two. Please refer to the\n relevant section \nin the README of the Entando Operator to determine how the Docker registry and version of these images will be calculated. \n \n \n spec.customServerImage  can be used to deploy the Docker image containing your own custom Entando App. Please\nfollow the instructions on how to  build your own image . \nThis property and the  spec.standardServerImage  are  assumed to be mutually exclusive. Only provide a\nvalue to one of the two. \n spec.dbms  is used to select the database management of choice. If left empty, a default value of  postgresql \nis assumed. The value  none  is not supported. If this value matches up to the  spec.dbms  property\nof a previously configured  EntandoDatabaseService ,\nthe Entando App will be configured to use this service.\nAlternatively, the Entando Operator will use this value to deploy a dedicated Database instance in this namespace\nfor the EntandoApp to use. \n spec.ingressPath  specifies the web context of the Entando App to be deployed. This is required to create a single\npath entry in the Ingress that is used to expose the Entando App. The default behaviour of Wildfly and\nJBoss EAP is to use the name of the WAR file that is deployed, but it is possible to override this in the EntandoApp\nproject itself using a  jboss-web.xml  file .\nIn the absence of the  jboss-web/xml  file, the web context  would be the the\nMaven artifactId of the Entando Opp project. It is also possible to modify this by changing the  <finalName>  element\nin the Maven  pom.xml \n spec.clusterInfrastructureToUse  is the name of the Kubernetes Secret that provides the connection details to the\nEntandoClusterInfrastructure containining the Entando Component Repository for this App to use. This is only\nrequired if more than one EntandoClusterInfrastructure is available and this value can be omitted entirely under\nmost conditions. \n spec.keycloakSecretToUse  is used to determine which Kubernetes Secret to use to connect to the correct\nKeycloak instance. If not specified, the default Secret  keycloak-admin-secret  will be used. Only useful\nif you have more than one Keycloak server in your cluster. \n spec.ingressHostName  is the hostname of the Kubernetes Ingress to be created for the Entando App. Please\nensure that this is accessible using the default routing suffix of your Entando Operator Deployment, or a DNS\nname previously registered with your DNS provider. Keep in mind that EntandoPlugins linked to this app will\nalso be made available on this host. \n spec.parameters  is a Map of environment variables to pass to the EntandoApp Docker image. For example, this could\nbe used to provide connection details for custom datasources or message queues as discussed in the\n custom datasources tutorial . Also note that all of the\n Spring variables in an Entando project \ncan also be overridden here by specifying the equivalent SNAKE_CASE names of the dot-delimited Spring properties.\nThese parameters are applied to the container\'s environment variables after all variables have been calculated.\nIt can therefore also be used as a mechanism to override any of the default environment variables that need customization.\nKeep in mind that these parameters will be passed to each of the three containers in this Pod as environment\nvariables, and that care needs to be taken to avoid conflicting variable names. \n spec.tlsSecretName  is the name of a standard Kubernetes\n TLS Secret  that will be used for the\nresulting Ingress. This is only required if the\n globally configured TLS Secret \nfor the Operator is absent or has not been created with a wildcard hostname that supports this Keycloak instance\'s hostname. \n spec.replicas  - the number of replicas to be made available on the Deployment of this Entando App \n EntandoPlugin \n An Entando Plugin is a microservice that can be made available to one or more EntandoApps in the cluster. Please follow\nour instructions on using our blueprint to  build your own EntandoPlugin . The\nDeployment resulting from an EntandoPlugin is also a multi-container Pod deployment, and will include both the\nplugin Docker image specified and the EntandoPluginSidecar Docker Image \n Overview \n \n Custom Resource Definition:  EntandoPlugin \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-plugin-controller \n Github Repo:  entando/entando-k8s-plugin-controller \n \n \n Deployment Details - plugin:\n \n Docker image: as provided by user \n Entando Cluster Citizen:  Plugin \n \n \n Deployment Details - EntandoPluginSidecar:\n \n Docker image:  entando/entando-plugin-sidecar \n Github Repo:  entando/entando-plugin-sidecar \n \n \n Possible Database Images:\n \n MySQL:  docker.io/centos/mysql-57-centos7 \n PostgreSQL:  docker.io/centos/postgresql-96-centos7 \n Example \n ---\nkind: "EntandoPlugin"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-plugin"\n  namespace: "my-namespace"\nspec:\n  image: your-org/your-image:4.3.2\n  securityLevel: lenient\n  ingressPath: /my-plugin\n  healthCheckPath: /actuator/health\n  dbms: "postgresql"\n  keycloakSecretToUse: some-kc-secret\n  clusterInfrastructureToUse: some-eci-secret  \n  ingressHostName: "test-app.my-routing-suffix.com"\n  roles:\n    - code: admin\n      name: Administrators\n    - code: user\n      name: Users\n  permissions: \n    - clientId: some-keycloak-client \n      role: some-admin\n    - clientId: another-keycloak-client \n      role: another-admin\n  parameters: \n    ENTANDO_VAR1: my-var1\n  tlsSecretName: my-tls-secret\n  replicas: 1\n Explanation of properties \n \n spec.image  is the Docker image you can provide for the plugin you want to deploy. Please follow\nour instructions on using our blueprint to  build your own EntandoPlugin \nCurrently only Docker images hosting Spring Boot applications are supported. It is therefore of  utmost\nimportance to start off with our blueprint and ensure that the resulting Spring Boot application respects\nthe Spring variables to be set from the Entando Operator. \n spec.dbms  is used to select the database management of choice. If left empty, or if the value is  none , it\nis assumed that the plugin in question does not required a database. If this value matches up to\nthe  spec.dbms  property  of a previously  configured\n EntandoDatabaseService ,\nthe Entando Plugin will be configured to use this service.\nAlternatively, the Entando Operator will use this value to deploy a dedicated Database instance in this namespace\nfor the Entando Plugin to use. \n spec.ingressPath  specifies the web context where the Entando Plugin will be made available when linked to EntandoApps.\nPlease ensure this is in sync with the  server.servlet.context-path  property set on your Spring Boot application. \n spec.clusterInfrastructureToUse  is the name of the Kubernetes Secret that provides the connection details to the\nEntandoClusterInfrastructure this Plugin will use. This is only\nrequired if more than one EntandoClusterInfrastructure is available and this value can be omitted entirely under\nmost conditions. \n spec.keycloakSecretToUse  is used to determine which Kubernetes Secret to use to connect to the correct\nKeycloak instance. If not specified, the default Secret  keycloak-admin-secret  will be used. Only useful\nif you have more than one Keycloak server in your cluster. \n spec.ingressHostName  is the hostname of the Kubernetes Ingress to be created for the Entando Plugin. Please\nensure that this is accessible using the default routing suffix of your Entando Operator Deployment, or a DNS\nname previously registered with your DNS provider. This hostname will not be used from your Widgets that you\nhave implemented for this plugin as these widgets will use the hostname of the EntandoApp they are being used from.\nThis hostname is useful for embedded web user interfaces used only on this plugin, such as admin user interfaces\nor diagnostic user interface. \n spec.roles  specifies the set of roles that this plugin expects. At deployment time, the Entando Operator ensures\nthat each of these roles are created on Keycloak for the Keycloak client representing this EntandoPlugin. It is\nup to the Plugin provider to ensure that Spring Security has been set up to enforce the access rules implied\nby the individual roles. Each role has a unique  code  and a more human readable   name  as property. \n spec.permissions  specifies the set of permissions this plugin requires on other services with known Keycloak Clients.\nAt deployment time, the Entando Operator will use the service account user of this EntandoPlugin\'s Keycloak Client\nand create the necessary role bindings on the specified client id of the service to be used.\nEach permission specifies the  clientId  in Keycloak of the target service, and the  role  that this EntandoPlugin\nshould be bound to in that Keycloak client. \n spec.parameters  is a Map of environment variables to pass to the EntandoPlugin Docker image.\nIt is entirely up to the plugin provider to determine the semantics of each variable. We strongly suggest for\nplugin provider  to use  the standard Spring Property Resolver syntax for Spring variables, as this would allow\nany of these variables to be overridden here by specifying the equivalent SNAKE_CASE names of the dot-delimited\nSpring properties.\nThese parameters are applied to the container\'s environment variables after all variables have been calculated.\nIt can therefore also be used as a mechanism to override any of the default environment variables that need customization.\nKeep in mind that these parameters will be passed to both containers in this Pod as environment\nvariables, and that care needs to be taken to avoid conflicting variable names. \n spec.tlsSecretName  is the name of a standard Kubernetes\n TLS Secret  that will be used for the\nresulting Ingress. This is only required if the\n globally configured TLS Secret \nfor the Operator is absent or has not been created with a wildcard hostname that supports this Keycloak instance\'s hostname. \n spec.replicas  - the number of replicas to be made available on the Deployment of this Entando Plugin \n EntandoAppPluginLink \n The EntandoAppPluginLink custom resource is created when an AppBuilder user links an EntandoPlugin to the current\nEntandoApp, or deploys an EntandoPlugin for use in the current EntandoApp. The Entando Operator processes the resulting\nEntandoAppPluginLink and creates a path for the Plugin on the Ingress that exposes the EntandoApp in question. This path\nis determined by the  spec.ingressPath  property on the EntandoPlugin custom resource itself. If the EntandoPlugin\nresides in a namespace other than the namespace of the EntandoApp, the EntandoOperator creates a Kubernetes\nService in the namespace of the EntandoApp that simply delegates to the Service in the namespace of the EntandoPlugin. \n Overview \n \n Custom Resource Definition:  EntandoAppPluginLink \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-app-plugin-link-controller \n Github Repo:  entando/entando-k8s-app-plugin-link-controller \n Example \n ---\nkind: "EntandoAppPluginLink"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-link"\n  namespace: "my-namespace"\nspec:\n  entandoAppName: my-app\n  entandoAppNamespace: my-namespace\n  entandoPluginName: my-app\n  entandoPluginNamespace: my-namespace\n Explanation of properties \n \n spec.entandoAppName  specifies the name of the EntandoApp that requires the plugin, found in  EntandoApp.metadata.name \n spec.entandoAppNamespace  specifies the namespace of the EntandoApp that requires the plugin, found in  EntandoApp.metadata.namespace \n spec.entandoPluginName  specifies the name of the EntandoApp that requires the plugin, found in  EntandoPlugin.metadata.name \n spec.entandoPluginNamespace  specifies the namespace of the EntandoApp that requires the plugin, found in  EntandoPlugin.metadata.namespace \n EntandoDatabaseService \n By default, the Entando Operator deploys one of either the MySQL or PostgreSQL database Docker images for every custom\nresource that requires a database. Many customers may however have existing infrastructure for their databases which\nthey may want to leverage. The EntandoDatabaseService custom resource allows customers to deploy a Service that points\nto an external database. When deploying one of the Entando custom resources that require a database, the Entando\nOperator will look for EntandoDatabases in the same namespace, and if it finds one with the same  spec.dbms  setting\nas the database required by the custom resource , it will create a dedicated schema/username/password combination\nfor the custom resource and point the deployment emanating from custom resource to this external database. \n \n Custom Resource Definition:  EntandoDatabaseService \n Example \n ---\nkind: "EntandoDatabaseService"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-database-service"\n  namespace: "my-namespace"\nspec:\n  dbms: "osracle"\n  host: 10.0.12.41\n  port: 1521\n  databaseName: mydb \n  tablespace: \n  secretName: some-secret\n  jdbcParameters:\n    maxStatements: 300 \n    loginTimeout: 180\n Explanation of properties \n \n spec.dbms  is used to select the database management of choice. If this value matches up to the  spec.dbms  property\nof the Entando custom resource that will use it. Valid values are  oracle ,  postgresql  and  mysql . \n spec.host  can either be a valid IPv4 address, or a hostname. Where an IP address is provided, the Entando Operator\nwill create a Kubernetes Service with an associated EndPoints resource to allow for routing to this address. Where\na hostname is provided, the Entando Operator will simply create a Kubernetes Service of type  cname \n spec.port  is the port that the external database service is running on. This value is optional in which case we will\nuse the default port for the DBMS vendor in question \n spec.databaseName  is the name of the database that the Entando Operator should be creating schemas in. This property\nis only for use with PostgreSQL and Oracle, as MySQL doesn\'t distinguish between schemas and databases. \n spec.tablespace  is only required for Oracle so that Schemas can be created in different tablespaces. \n spec.secretName  should be the name ( Secret.metadata.name ) of a Kubernetes Secret in the same namespace that has\na  username  key and a  password  key that will provide the Entando Operator with the necessary access and permissions\nto create Schemas and users on the database in question. \n spec.jdbcParameters  is a map of name/value pairs that will be appended to the JDBC connection string to allow for\nfurther customization of the actual connection to the database. \n EntandoCompositeApp \n The EntandoCompositeApp custom resource can be used to package a collection of Entando Core Custom Resources in a\nsingle YAML file for sequential deployment. Keep in mind that one can already use standard YAML syntax to package\na set of Kubernetes resources in a single file, separating each resource with a triple dash ( --- ). The purpose\nof this custom resource is therefor specifically to ensure that the deployment of the previous \'component\' has\ncompleted, and that  the resulting Pod is up and running before commencing deploying on the \'component\'. \n The primary use case of this custom resource is to package a full Entando App and all its supporting service and\nplugins for easy installation as is often required for demos and POCs. Creating this kind of dependency for typical\nproduction deployments is not advised, as it will inevitably result in a violation of pipeline isolation. The\nmore commonly recommended approach is for your Entando Apps and Plugins to be fully deployable in isolation. Use this\ncustom resource with care. \n Overview \n \n Custom Resource Definition:  EntandoCompositeApp \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-composite-app-controller \n Github Repo:  entando/entando-k8s-composite-app-controller \n Example \n ---\nkind: "EntandoCompositeApp"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-composite-app"\n  namespace: "my-namespace"\nspec:\n  components:\n    - kind: "EntandoKeycloakServer"\n         metadata:\n           name: "my-kc"\n         spec:\n           dbms: postgresql\n           isDefault: true\n           replicas: 1\n       - kind: "EntandoClusterInfrastructure"\n         metadata:\n           name: "my-eci"\n         spec:\n           dbms: postgresql\n           replicas: 1\n           isDefault: true\n       - kind: "EntandoApp"\n         metadata:\n           name: "my-app"\n         spec:\n           dbms: postgresql\n           replicas: 1\n           standardServerImage: wildfly\n           ingressPath: /entando-de-app\n       - kind: "EntandoPlugin"\n         metadata:\n           name: "my-pda"\n         spec:\n           image: "docker.io/entando/entando-process-driven-plugin:latest"\n           replicas: 1\n           dbms: "mysql"\n Explanation of properties \n \n spec.components  specifies the list of Entando Core Custom Resources to be deployed  in sequence . Please note\nthat only the Entando Custom Resources discussed in this section can be used in this list. Custom resources\nrelated to the Entando Component Repository never result in actual deployments on the Kubernetes cluster and\ntherefore do not need to be specified in any sequence. You can use the normal triple dash YAML notation to\ninclude them in the same YAML file \n \n'},{title:"Overview",frontmatter:{},regularPath:"/v6.2/docs/concepts/",relativePath:"v6.2/docs/concepts/README.md",key:"v-80ada3b6",path:"/v6.2/docs/concepts/",headers:[{level:2,title:"Entando App Engine",slug:"entando-app-engine"},{level:2,title:"Entando App Builder",slug:"entando-app-builder"},{level:2,title:"Entando Component Generator",slug:"entando-component-generator"},{level:2,title:"Entando Component Repository",slug:"entando-component-repository"},{level:2,title:"Entando Identity Management",slug:"entando-identity-management"},{level:2,title:"Entando WCMS",slug:"entando-wcms"},{level:2,title:"Entando Cluster Citizens",slug:"entando-cluster-citizens"},{level:3,title:"Architecture diagram",slug:"architecture-diagram"},{level:3,title:"Members of the cluster",slug:"members-of-the-cluster"},{level:2,title:"Entando Ingresses",slug:"entando-ingresses"},{level:3,title:"What is an ingress",slug:"what-is-an-ingress"},{level:3,title:"How ingresses are used in an Entando Cluster",slug:"how-ingresses-are-used-in-an-entando-cluster"},{level:3,title:"Default Ingress HTTP Routes",slug:"default-ingress-http-routes"},{level:3,title:"Exposing plugins in the EntandoApp domain",slug:"exposing-plugins-in-the-entandoapp-domain"},{level:3,title:"How to check ingresses in my cluster",slug:"how-to-check-ingresses-in-my-cluster"},{level:3,title:"Learn more",slug:"learn-more"}],lastUpdated:"9/9/2020, 3:54:34 PM",lastUpdatedTimestamp:1599681274e3,content:' Overview \n A portal, website, web app, or mobile app built with Entando is called an Entando application.\nAn Entando application is an assembly of out of the box and/or custom built components running on the\nEntando Platform. Components can be widgets, micro frontends, microservices, page templates,\nWCMS content or WCMS content types. \n Entando App Engine \n The Entando App Engine is the heart of the Entando Platform by providing the primary out-of-the-box services for\ndeveloping applications. Key features: \n \n Expose the APIs the Entando App Builder uses to provide the page and content management interface for your application. \n Handle the work of assembling micro frontends and microservices and combining them on specific pages as defined by the Entando App Builder. \n Provide the data access layer to persist the page and application design. \n Manage the cluster infrastructure. \n \n See also:  APIs tutorial \n Entando App Builder \n The Entando App Builder is the feature-rich management interface used to design and build pages for Entando applications. \n See also:  Widget Tutorial \n Entando Component Generator \n The Entando Component Generator is Entando\'s implementation of  JHipster  that allows users to\nquickly and efficiently generate the skeleton of an Entando Component. The Entando Component Generator provides advanced\ndata modeling capabilities including object relational mapping and automatic generation of micro frontends and microservices.\nThe generated skeleton serves as a starting point to help a development team swiftly meet the needs of the business. \n See also:  Entando JHipster Blueprint \n Entando Component Repository \n The Entando Component Repository (ECR) is used to store and retrieve shareable components so they can be used in multiple\nEntando applications across the enterprise. \n See also:  ECR Overview \n Entando Identity Management \n Entando Identity Management is the  Keycloak -based token-based authentication mechanism used by the\nEntando platform. It provides the ability to add Single Sign On capabilities across multiple domains and to connect service\nproviders with identity providers. \n See also:  Entando Authentication \n Entando WCMS \n The Entando Web Content Management System (WCMS) is a lightweight content and digital asset management system with support\nfor headless operation. It allows management of widgets and html fragments so they can be placed within an Entando application. \n See also:  Content Types  or  Content Templates \n Entando Cluster Citizens \n The purpose of this guide is to give an overview of the members of an Entando cluster and their role. \n Architecture diagram \n Let’s start with a picture of an Entando 6 cluster and how the various\nmembers interact with each other. \n Members of the cluster \n An Entando 6 cluster is composed of various citizens which interact with\neach other. Most of these citizens have a Custom Resource Definition\nfile associated with them and are deployable on Kubernetes using the\nEntando operator and controllers. \n Entando app \n An Entando application is composed of three parts: \n \n \n Entando App Builder : the user interface to customize and build an Entando application, as well as interact with the Entando Component Repository. \n \n \n Entando App Engine : the backend APIs providing access to Entando\nservices. \n \n \n Entando Component Manager : the service providing the Entando\nComponent Repository functionality, e.g. listing the available\nbundles, install/uninstall a bundle, etc. Check the  dedicated\nsection  for more details. \n \n \n The interaction between these three components (and the rest of the\nEntando cluster) use the authorization/authentication features provided\nby Keycloak. \n Entando Component Manager \n As briefly introduced before, the Entando component manager is able to\nlist the EntandoDeBundles accessible from the EntandoApp and provide the\ninstall/uninstall services to install a bundle on an Entando App. All of\nthese services are made possible by the communication with the Entando\nKubernetes service, the only service of the Entando ecosystem (other\nthan the operator itself) able to interact with the cluster and some of\nthe Entando custom resources. \n Entando Kubernetes Service \n The Entando Kubernetes Service is part of the Entando cluster\ninfrastructure custom resource, and provides an access point to some of\nthe custom resources defined by Entando, in particular: \n \n \n Entando applications \n \n \n Entando plugins \n \n \n Entando links \n \n \n Entando Component Repository bundles \n \n \n Some of the main services provided by the Entando Kubernetes Service\nare: \n \n \n Provide a list of the available EntandoDeBundles to the\ncomponent-manager \n \n \n Deploy a plugin during the installation of a bundle or discovery of\nan already available plugin and expose that to an app \n \n \n Create a link between an EntandoApp and an EntandoPlugin to expose\nthe plugin’s APIs to the EntandoApp and the micro frontends (MFEs) \n Entando Component Repository bundles \n An EntandoDeBundle - or Component Repository bundle - is a package with\na set of Entando components and resources. The Entando component manager\nis able to read these kind of packages and install the components to\nextend the functionalities of an EntandoApp. For more details on the\nEntandoDeBundle and the Entando Component Repository, check the\n component repository overview \ndocumentation \n Entando plugin \n An Entando plugin is a microservice that exposes APIs reusable by one or\nmore Entando apps. Usually the plugin services are exposed to the\nEntando developer and the end users via micro frontends. Check the\n micro frontends  tutorials for more details. You can\nquickly generate an Entando plugin using the  Entando JHipster Blueprint . The generated project\nwill be ready to work in an Entando environment providing the\nintegration with Keycloak, generating a set of default micro frontends\nand exposing the plugin’s logic via an EntandoDeBundle (check the\nreferences for details). \n Keycloak \n Keycloak in Entando 6 is responsible for authorization and\nauthentication All the members of an Entando 6 cluster interact with\nkeycloak to verify user/service authorization to perform any specific\ntask. Check out the references below for more details on keycloak. \n Entando Ingresses \n What is an ingress \n An Ingress is a Kubernetes resource which purpose is to expose HTTP and HTTPS routes from outside the cluster to services within the cluster. Traffic routing is controlled by rules defined on the Ingress resource. \n How ingresses are used in an Entando Cluster \n When deploying an Entando Cluster, ingresses are generated for the resources that requires to be exposed to the outside world. The process of creating an ingress, setup the correct routes and the certificates is done by the via the Entando Operator and the entando custom resource controllers. \n Keycloak ingress \n An dedicated ingress is created for keycloak to expose the authentication and authorization functionalities. Having a dedicated ingress is required to guarantee that both token issuing and token validation work correctly, even when the services using the keycloak instance are on different namespaces. \n Cluster infrastructure ingress \n Another ingress is created for the cluster infrastructure services in order to expose the api endpoint to interact with the cluster correctly \n Entando App ingress \n Another ingress is automatically created to expose App builder, App engine and the Entando component manager, a service part of the ECR.\nThe three containers are served under the same domain, and this is beneficial as they are able to interact without cross-origin issues. \n The Entando App ingress is also used when linking an Entando Plugin with and Entando App, operation that usually happens when a bundle containing an Entando Plugin is installed via the ECR in an Entando App. Check out the dedicated section for details. \n Entando Plugin ingress \n Also Entando Plugins are automatically exposed via an ingress when deployed in an Entando Cluster. \n Default Ingress HTTP Routes \n In this table you can see what are the default routes that are exposed for each ingress\n \n \n \n \n \n \n \n Ingress \n Ingress Http route \n Application \n \n \n \n \n Keycloak ingress \n /auth \n Keycloak \n \n \n Entando cluster infrastructure ingress \n /k8s \n Entando K8S service \n \n \n Entando App ingress \n /entando-de-app \n App engine \n \n \n /app-builder/ \n App builder \n \n \n /digital-exchange \n Entando component manager \n \n \n /<plugin-ingressPath> \n Entando plugin linked to the app \n \n \n Entando plugin ingress \n /<plugin-ingressPath> \n Entando plugin \n \n \n \n Note : The Entando plugin  ingressPath  variable is defined in the Entando Plugin custom resource under the  spec  element. The plugin ingress path is also used to expose the plugin under the Entando App domain \n Exposing plugins in the EntandoApp domain \n The process of exposing an Entando Plugin under the same domain (ingress) of the Entando App is made possible from the creation of an  EntandoAppPluginLink  custom resource and the corresponding controller. \n Once the link between the Entando App and the Entando Plugin is created, the controller reads the specification of such link and automatically creates the HTTP routes in the Entando App so that the plugin is exposed on the same domain as the App builder, App engine and Component manager. \n This allows the Microfrontend developers that need to access the plugin to not worry about CORS policy or knowing what is the full path where the plugin is exposed. The plugin is referencable using relative urls. \n How to check ingresses in my cluster \n Using the Openshift dashboard \n On the Openshift dashboard, Ingresses are not exposed directly as pods and deployments. The dashbaord provides direct access to the Ingress Routes (or simply routes) under the  Applications > Routes  menu. \n \n To see the ingress resources, you need to access them from the  Resources > Other resources  menu. From the dropdown you should select the  Ingress  resource and therefore you should be able to see the ingress available on that specific project/namespace \n Using kubectl from the command line \n From the command line, getting the ingress is very easy. Once you know the namespace(s) where your Entando Cluster is deployed, you simply need to use the \n kubect get ingresses.extensions -n <namespace>\n \n Here an example of the result in a test namespace \n > kubectl get ingresses.extensions -n local\n\nNAME               CLASS    HOSTS                               ADDRESS     PORTS   AGE\nqst-eci-ingress   <none>   qst-eci-local.192.168.1.9.nip.io   127.0.0.1   80      2d1h\nqst-ingress       <none>   qst-local.192.168.1.9.nip.io       127.0.0.1   80      2d1h\nqst-kc-ingress    <none>   qst-kc-local.192.168.1.9.nip.io    127.0.0.1   80      2d1h\n \n To get more details about a specific ingress, you can use the  get  command specifing the ingress name you want to check and the  yaml  output format \n > kubectl get ingresses.extensions -n local qst-ingress -o yaml\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  creationTimestamp: "2020-05-13T15:27:08Z"\n  generation: 1\n  labels:\n    EntandoApp: qst\n  managedFields:\n  - apiVersion: extensions/v1beta1\n    fieldsType: FieldsV1\n    fieldsV1:\n      f:status:\n        f:loadBalancer:\n          f:ingress: {}\n    manager: nginx-ingress-controller\n    operation: Update\n    time: "2020-05-13T15:27:08Z"\n  name: qst-ingress\n  namespace: local\n  ownerReferences:\n  - apiVersion: entando.org/v1\n    blockOwnerDeletion: true\n    controller: true\n    kind: EntandoApp\n    name: qst\n    uid: aa7053e1-fd8b-419f-bdee-df3018c013fa\n  resourceVersion: "16802097"\n  selfLink: /apis/extensions/v1beta1/namespaces/local/ingresses/qst-ingress\n  uid: e9b6f027-369a-4b84-b4b1-736a6e49f180\nspec:\n  rules:\n  - host: qst-local.192.168.1.9.nip.io\n    http:\n      paths:\n      - backend:\n          serviceName: qst-server-service\n          servicePort: 8080\n        path: /entando-de-app\n        pathType: ImplementationSpecific\n      - backend:\n          serviceName: qst-server-service\n          servicePort: 8083\n        path: /digital-exchange\n        pathType: ImplementationSpecific\n      - backend:\n          serviceName: qst-server-service\n          servicePort: 8081\n        path: /app-builder/\n        pathType: ImplementationSpecific\nstatus:\n  loadBalancer:\n    ingress:\n    - ip: 127.0.0.1\n Learn more \n For more details about ingress concept in Kubernetes please refer to the official documentation: \n \n Kubernetes Ingress documentation \n Openshift Routes documentation \n \n'},{title:"Filtering bundles",frontmatter:{},regularPath:"/v6.2/docs/ecr/ecr-bundle-filters.html",relativePath:"v6.2/docs/ecr/ecr-bundle-filters.md",key:"v-1699d844",path:"/v6.2/docs/ecr/ecr-bundle-filters.html",headers:[{level:2,title:"Filtering bundles by component",slug:"filtering-bundles-by-component"},{level:3,title:"Supported labels keys are:",slug:"supported-labels-keys-are"},{level:3,title:"Example",slug:"example"},{level:2,title:"Filtering bundles by status",slug:"filtering-bundles-by-status"},{level:2,title:"Filtering bundles by textual search",slug:"filtering-bundles-by-textual-search"},{level:2,title:"Mixing search criteria",slug:"mixing-search-criteria"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:' Filtering bundles \n ECR bundles are filterable by component, by status or by textual research. \n Filtering bundles by component \n ECR bundles are filterable by component from App Builder user interface. \n \n Behind the scenes, filtering is done using the label-based filtering provided out of the box from Kubernetes. \n To enable filtering of a bundle, the custom-resource representing the bundle on the Entando Cluster needs to contain the correct labels. An important note on the values to add the  labels  field, even if to correctly define a label in a k8s resource both the key and the value are required, from an Entando point of view only the key part of the label is used for filtering. The value could be set to anything, but our reccomendation is to use  "true"  for clarity and simplicity. \n Supported labels keys are: \n \n \n \n \n \n \n \n Label entry \n Description \n \n \n \n \n widget: "true" \n The bundle contains one or more microfrontends (widgets)  \n \n \n plugin: "true" \n The bundle contains one or more microservices (plugins) \n \n \n fragment: "true" \n The bundle contains one or more fragments \n \n \n pageTemplate: "true" \n The bundle contains one or more page templates \n \n \n contentType: "true" \n The bundle contains one or more content types \n \n \n contentTemplate: "true" \n The bundle contains one or more content templates \n Example \n Here is an example of the metadata for a ecr bundle containg micro-frontends, some microservices and page templates \n apiVersion: entando.org/v1\nkind: EntandoDeBundle\nmetadata:\n  name: demo-bundle\n  labels:\n    widget: "true"\n    plugin: "true"\n    pageTemplate: "true"\nspec:\n  details:\n  ...\n Filtering bundles by status \n ECR bundles are filterable by status from App Builder user interface. \n \n You can choose to see the full list of the bundles available in Kubernetes cluster by selecting the  Explore  tab, or the list of the currently installed bundles by clicking on the  Installed  tab. \n Filtering bundles by textual search \n You can search for bundles containing some keywords by executing a textual search. \n \n You can open the menu on the left to select which field to target. \n If you are creating a new bundle, keep in mind the textual search is performed against data extracted from the bundle CRD file. \n Mixing search criteria \n You can mix all previous search criteria to refine the scope of your search as you want.\nFor example, you could search for all available bundles ( Explore  tab) that contain  Page Templates  components\n(using the checkboxes) and the word  Login  in their name (using the textual search). \n'},{title:"PDA Architecture",frontmatter:{},regularPath:"/v6.2/docs/concepts/pda-architecture.html",relativePath:"v6.2/docs/concepts/pda-architecture.md",key:"v-606945f4",path:"/v6.2/docs/concepts/pda-architecture.html",headers:[{level:2,title:"PDA MFEs",slug:"pda-mfes"},{level:2,title:"PDA API",slug:"pda-api"},{level:2,title:"Sidecar",slug:"sidecar"},{level:2,title:"PDA Core",slug:"pda-core"},{level:2,title:"PAM Impl",slug:"pam-impl"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:" PDA Architecture \n The objective of this document is to provide an explanation for the components\nthat compose the Process Driven Applications plugin (PDA) architecture from a\ndeployment perspective as well as how they interact with each other. \n The image below shows the components in high level: \n PDA MFEs \n The PDA Micro Frontends run on the browser and they render the UI custom\ncomponents the user interacts with. These components are written in React and\nthey fetch data from the PDA API, passing the Keycloak token for authentication.\nThe MFEs also make calls to the Entando Core API in order to retrieve the\nsettings required for the configuration UI. These components will be available\non Entando App Builder after the PDA plugin bundle is installed and the user\ncan create pages with them. \n The source code for this component:\n https://github.com/entando/entando-process-driven-plugin/tree/master/widgets \n PDA API \n The Spring Boot application that communicates with the engine and make its data\navailable in a Rest API. It interacts with Keycloak to validate the token and\nwith the sidecar to retrieve the connections/sensitive data, depending on how it\nwas deployed. The application shouldn't call specific engine classes directly,\ninstead it always calls the abstractions defined in PDA Core library. The engine\nimplementation to use is decided at runtime based on the connection details\nprovided. It is important to note that the PDA API application is stateless,\nsince it doesn't have a database. All data available on the API is retrieved\nfrom the BPM engine. After bundle installation, it will be deployed as a\nmicroservice in the Kubernetes infrastructure and an Ingress will be created to\nmake the API available to the MFEs, as described by the Entando Plugin custom\nresource. \n The source code for this component:\n https://github.com/entando/entando-process-driven-plugin \n Sidecar \n The sidecar is another application (docker container) deployed in the same Pod\nas the PDA API. It exposes services to manage connection details, which will be\nstored as secrets in Kubernetes. The PDA API communicates with the sidecar to\nmanage BPM engine connection details. \n The source code for this component:\n https://github.com/entando/entando-plugin-sidecar \n PDA Core \n This is the library that defines the interfaces and abstractions that should be\nimplemented to interact with specific BPM engines. This way it is possible to\nhave multiple engine implementations at the same time. \n The source code for this component:\n https://github.com/entando/pda-core-engine \n PAM Impl \n The Red Hat PAM implementation for the PDA Core library. If the connection maps\nto a PAM engine, these are the classes that are going to be executed when the\nPDA API requests for engine operations. This implementation communicates with\nthe Kie Server, which executes the defined process operations. \n The source code for this component:\n https://github.com/entando/pda-redhatpam-engine \n"},{title:"Bundle and components details",frontmatter:{},regularPath:"/v6.2/docs/ecr/ecr-bundle-details.html",relativePath:"v6.2/docs/ecr/ecr-bundle-details.md",key:"v-498cc790",path:"/v6.2/docs/ecr/ecr-bundle-details.html",headers:[{level:2,title:"Bundle conventions",slug:"bundle-conventions"},{level:2,title:"Descriptor File",slug:"descriptor-file"},{level:2,title:"Plugin Descriptor",slug:"plugin-descriptor"},{level:2,title:"Widget Descriptor",slug:"widget-descriptor"},{level:2,title:"Fragment Descriptor",slug:"fragment-descriptor"},{level:2,title:"Page Template Descriptor",slug:"page-template-descriptor"},{level:2,title:"Content Type Descriptor",slug:"content-type-descriptor"},{level:2,title:"Content Template Descriptor",slug:"content-template-descriptor"},{level:2,title:"Static Files",slug:"static-files"}],lastUpdated:"6/1/2021, 10:21:20 AM",lastUpdatedTimestamp:162255728e4,content:' Bundle and components details \n In order for the entando-component-manager to read the content of a\nbundle and install components, a  descriptor.yaml  file is required at\nthe root of the bundle package. \n Here is a generic bundle structure \n .\n├ descriptor.yaml\n├ resources/\n│ └ ...\n└ ... (folders reported in descriptor.yaml file)\n Bundle conventions \n \n \n The bundle descriptor file needs to be named  descriptor.yaml \notherwise the bundle will not be recognized. \n \n \n Static resources are not defined in the  descriptor.yaml  file as\nthey are by default read from a  resources  folder. If you need to\ninstall static resources, please follow the following convention. \n Descriptor File \n The descriptor file will aggregate all components inside and has the\nfollowing structure. \n \n Warning \n Remember the file needs to be named  descriptor.yaml . \n \n Descriptor.yaml. \n code: survey_bundle # The bundle ID\ndescription: This is the survey bundle # The description of the bundle\n\ncomponents: # All components will be here\nOptional. Use if the component requires a deployment\n  plugins:\n    - folder/you/want/my_plugin_descriptor.yaml\n    - folder/you/want/another_plugin_descriptor.yaml\nTo create widgets you will need to add references to the descriptor file\'s\n  widgets:\n    - widgets/my_widget_descriptor.yaml\n    - widgets/another_widget_descriptor.yaml\nTo create fragments, you will need to add references to the descriptor file\'s\n  fragments:\n    - fragments/my_fragment.yaml\nTo create Page Templates you will need to add references to the descriptor file\'s\n  pageModels:\n    - pagemodels/my_page_model_descriptor.yaml\n    - pagemodels/another_page_model_descriptor.yaml\nTo create Content Types you will need to add references to the descriptor file\'s\n  contentTypes:\n    - contenttypes/my_content_type_descriptor.yaml\nTo create Content Templates you will need to add references to the descriptor file\'s\n  contentModels:\n    - contentmodels/my_content_model_descriptor.yaml\n    - contentmodels/another_content_model_descriptor.yaml\nLabels on the system\n  labels:\n    - key: HELLO # This is the label identifier\n      titles: # The titles on the label\n        it: Mio Titolo # The title in Italian\n        en: My Title # The title in English\n Plugin Descriptor \n Here is an example of a plugin descriptor. \n WARNING \n Note: the CRD format is deprecated as of Entando 6.3. \n \n Plugin descriptor.yaml (CRD format) \n kind: "EntandoPlugin"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "helloworld-plugin"\nspec:\n  image: entando/my-image:1.0..0 # The docker image used to create the plugin\n  replicas: 1\n  dbms: postgresql # The DMBS the plugin will use\n  parameters: {}\n  ingressPath: "/helloWorld"\n  healthCheckPath: "/management/health"\n  securityLevel: "strict"\n  connectionConfigNames: []\n  permissions: []\n  roles: # The roles the plugin will expose in keycloak\n    - name: task-list\n      code: "task-list"\n    - name: task-get\n      code: "task-get"\n Widget Descriptor \n Here is an example of a widget descriptor \n Widget descriptor.yaml. \n code: another_todomvc_widget # The Widget identification\n\ntitles: # Widget\'s Titles\n  en: TODO MVC Widget # Title in English\n  it: TODO MVC Widget # Title in Italian\n\ngroup: free # The owner group of the widget\nOptional. The UI Path, the widget.ftl file will have the customUi content\ncustomUiPath: widget.ftl\nOptional. The Custom UI\ncustomUi: >-\n    <h1>My custom widget UI</h1>\nOptional. ConfigUI\nconfigUi:\n  customElement: todomvc-config # The name of the custom-element used to render the configUI\n  resources:\n    - <bundleid>/static/js/main.js # The resources necessary to the custom element to render the configUI, like the code\n Fragment Descriptor \n Fragment descriptor.yaml. \n code: my-fragment # The fragment identification\nOptional. The fragment content\nguiCode: >-\n  "<div>Here the content</div>"\nOptional. The GuiCode Path, the fragment.ftl file will have the guiCde conent in it\nguiCodePath: fragment.ftl\n Page Template Descriptor \n Page Template descriptor.yaml. \n code: todomvc_page_template # The Page Template identification\ndescription: TODO MVC basic page template # The Page Template description\n\ntitles: # Page Template\'s Titles\n  en: TODO MVC PageTemplate # Title in English\n  it: TODO MVC PageTemplate # Title in Italian\nThe Page Template configuration\nconfiguration:\n  frames: # All frames\n    - pos: 0 # Frame position\n      description: Header # Frame description\n      sketch: # Frame sketch configuration\n        x1: 0\n        y1: 0\n        x2: 11\n        y2: 0\n      defaultWidget:\n        code: my-widget # the code of the widget to apply when using the button "apply default widgets" in the page configuration UI\nA simplified way to define a Frame\n    - pos: 1\n      description: Breadcrumb\n      sketch: { x1: 0, y1: 1, x2: 11, y2: 1 }\nOptional. Define the Page Template in a separate file or inside the descriptor file with `template`\ntemplatePath: page.ftl\nOptional. Define the Page Template this way or in a separate file with `templatePath`\ntemplate: >-\n  <#assign wp=JspTaglibs[\\"/aps-core\\"]>\n  <!DOCTYPE HTML PUBLIC \\"-//W3C//DTD HTML 4.0 Transitional//EN\\">\n  <html>\n      <head>\n          <title><@wp.currentPage param=\\"title\\" /></title>\n      </head>\n      <body>\n          <h1><@wp.currentPage param=\\"title\\" /></h1>\n          <a href=\\"<@wp.url page=\\"homepage\\"/>\\">Home</a><br>\n          <div>\n              <h1>Bundle 1 Page Template</h1>\n              <@wp.show frame=0 />\n          </div>\n      </body>\n  </html>\n Content Type Descriptor \n For more details on the properties, refer to the Content Type\ndocumentation. \n Content-type descriptor.yaml. \n code: CNG\nname: Demo\nstatus: 0\n\nattributes:\n  - code: title\n    type: Text\n    name: Title\n    roles:\n      - code: jacms:title\n        descr: The main title of a Content\n    disablingCodes: []\n    mandatory: true\n    listFilter: false\n    indexable: false\n\n    enumeratorStaticItems: string\n    enumeratorStaticItemsSeparator: string\n    enumeratorExtractorBean: string\n\n    validationRules:\n      minLength: 0\n      maxLength: 100\n      regex: string\n      rangeStartString: string\n      rangeEndString: string\n      rangeStartStringAttribute: string\n      rangeEndStringAttribute: string\n      equalString: string\n      equalStringAttribute: string\n      rangeStartDate: string\n      rangeEndDate: string\n      rangeStartDateAttribute: string\n      rangeEndDateAttribute: string\n      equalDate: string\n      equalDateAttribute: string\n      rangeStartNumber: 0\n      rangeStartNumberAttribute: string\n      rangeEndNumber: 0\n      rangeEndNumberAttribute: string\n      equalNumber: 0\n      equalNumberAttribute:\n      ognlValidation:\n        applyOnlyToFilledAttr: false\n        errorMessage: Something\n        keyForErrorMessage: some\n        keyForHelpMessage: thing\n        ognlExpression: string\n Content Template Descriptor \n Content-template descriptor.yaml. \n id: 8880003\ncontentType: CNG\ndescription: Demo Content Template\nOptional. Define the Content Template Shape in a separate file or inside descriptor file with `contentShape`\ncontentShapePath:\nOptional. Define the Content Template Shape this way or in a separate file with `contentShapePath`\ncontentShape: >-\n  <article>\n    <h1>$content.Title.text</h1>\n    <h2>Demo content template</h2>\n    #if ( $content.MainBody.text != "" )\n    $content.MainBody.text\n    #end\n  </article>\n Static Files \n In order to upload static files, you will need to create a folder called\n resources/ , all files inside this folder will be uploaded in the same\nfolder structure that is inside. \n resources/\n├ css/\n│ └ styles.css\n├ js/\n│ └ script.js\n├ images/\n│ ├ favicon.ico\n│ └ logo.png\n└ page.html\n \n On the structure mentioned above, the resulting files in the Entando\narchitecture will be: \n yourbundleid/\n├ css/\n│ └ styles.css\n├ js/\n│ └ script.js\n├ images/\n│ ├ favicon.ico\n│ └ logo.png\n└ page.html\n \n \n Important \n yourbundleid  is the  code  property inside  descriptor.yaml \n \n So if you need to use the file in a widget or page template, use this FTL\ntag  <@wp.resourceURL /> : \n <img src="<@wp.resourceURL />yourbundleid/images/logo.png">\n<link rel="stylesheet" href="<@wp.resourceURL />yourbundleid/css/styles.css">\n<link rel="shortcut icon" href="<@wp.resourceURL />yourbundleid/images/favicon.ico" type="image/x-icon"/>\n<script type="application/javascript" src="<@wp.resourceURL />yourbundleid/js/script.js"><\/script>\n \n '},{title:"How to customize bundle info shown in Entando App Builder",frontmatter:{},regularPath:"/v6.2/docs/ecr/ecr-bundle-presentation-config.html",relativePath:"v6.2/docs/ecr/ecr-bundle-presentation-config.md",key:"v-76c4832a",path:"/v6.2/docs/ecr/ecr-bundle-presentation-config.html",lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:" How to customize bundle info shown in Entando App Builder \n \n In the image above you can see an example of a bundle as is displayed in the ECR user interface inside the Entando App Builder. \n The corresponding custom-resource file on Kubernetes is similar to this: \n apiVersion: entando.org/v1\nkind: EntandoDeBundle\nmetadata:\n  name: simple-entando-bundle\nspec:\n  details:\n    name: \"Entando Bundle\"\n    description: An example of an Entando bundle\n    dist-tags:\n      latest: v0.0.1\n    time:\n      created: '2020-05-20T15:59:21.946Z'\n      modified: '2020-05-20T15:59:21.946Z'\n      v0.0.1: '2020-05-20T15:59:21.946Z'\n    versions:\n      - v0.0.1\n    keywords:\n      - entando6\n    author: Entando\n    thumbnail: >-\n      data:image/jpeg;base64,....\n  tags:\n....\n \n In order to change the UI elements, you need to update the custom-resource in accordance with this table \n \n \n \n Field \n UI Element \n \n \n \n \n spec.details.name \n Set the bundle title \n \n \n spec.details.description \n Set the bundle description (only visible in the list presentation format) \n \n \n spec.details.thumbnail \n Set the bundle thumbnail, expressed as a base64 encoded string \n \n \n spec.details.dist-tags.latest \n Set what's the latest version of the bundle \n \n \n \n"},{title:"ECR: How Microservices get Connected to Entando Apps",frontmatter:{},regularPath:"/v6.2/docs/ecr/ecr-how-microservices-connects-to-apps.html",relativePath:"v6.2/docs/ecr/ecr-how-microservices-connects-to-apps.md",key:"v-677a6224",path:"/v6.2/docs/ecr/ecr-how-microservices-connects-to-apps.html",headers:[{level:2,title:"How a Microservice from a Bundle gets Deployed with the ECR?",slug:"how-a-microservice-from-a-bundle-gets-deployed-with-the-ecr"},{level:2,title:"Other Options",slug:"other-options"},{level:2,title:"Kubernetes naming conventions",slug:"kubernetes-naming-conventions"}],lastUpdated:"12/8/2021, 3:41:44 PM",lastUpdatedTimestamp:1638996104e3,content:" ECR: How Microservices get Connected to Entando Apps \n In this document we will describe some of the assumptions and details related to the process of connecting a microservice part of a bundle to an Entando App. \n In order to fully understand the concepts explained in this piece of the documentation, please make sure you have familiarity with these concepts: \n \n Entando custom resources \n Entando ingresses \n How a Microservice from a Bundle gets Deployed with the ECR? \n When a bundle containing a microservice is installed using the ECR, behind the scenes some actions take place. \n \n To begin, an  EntandoPlugin custom resource  is generated starting from the PluginDescriptor. Some fields will be automatically generated from the provided image. \n \n \n From the  image  field in the PluginDescriptor, we will extract the  organization ,  name  and  version  of the image. \n organization ,  name  and  version  are then converted to valid characters and composed to form the plugin name ( metadata.name ), the labels ( metadata.labels ) and the ingressPath ( spec.ingressPath ) of the custom resource. \n \n NOTE : Two PluginDescriptors having images with the same organization, name and version will generate a custom resource with the same  metadata.name  and  spec.ingressPath . \n \n Next, a check for a microservice with the same name is performed to verify if a new deployment is required for the microservice. \n If a microservice with the same name is not available in the namespace where the Entando App has been deployed, a new EntandoPlugin custom resource is created and deployed in the namespace using the details defined in the bundle. \n At the same time, an EntandoAppPluginLink custom resource is deployed in the namespace in order to expose the microservice ingress path on the EntandoApp ingress. \n If both the EntandoPlugin custom resource and the EntandoAppPluginLink are deployed correctly, the APIs of the microservice will be available from the same domain of the EntandoApp, making it possible reach those APIs from the EntandoApp using relative urls. \n \n This is the standard flow when no other micorservice with a given name is already available in the EntandoApp namespace. \n If there is an existing microservice with the same name as the one generated from the PluginDescriptor, the ECR will connect the EntandoApp to\nthe existing microservice by generating and deploying the required EntandoAppPluginLink per step 3 above.\nThis way, plugins can be reused by many applications at the same time. \n Other Options \n The naming convention recommendations above are accurate for creating bundles and for self contained applications where the Entando operator is managing the lifecycle of your microservices. If you have a substantial API infrastructure or you intend to deploy a large number of versioned microservices you can also utilize Entando with API management infrastructure like API gateways. If you are using an API gateway or other API abstraction layer you will need to manually manage the ingress for your micro frontends in your application to point to the API gateway deployment. \n In cases where conflicts occur bundles can easily be renamed by updating metdata. \n Kubernetes naming conventions \n Here some rules about naming conventions extracted from the  Kubernetes documentation on object names and ids \n \n Most resource types require a name that can be used as a DNS subdomain name as defined in RFC 1123. This means the name must: \n \n contain no more than 253 characters \n contain only lowercase alphanumeric characters, '-' or '.' \n start with an alphanumeric character \n end with an alphanumeric character \n \n \n"},{title:"Bundle versions and updates - FAQ",frontmatter:{},regularPath:"/v6.2/docs/ecr/ecr-bundle-versions-faq.html",relativePath:"v6.2/docs/ecr/ecr-bundle-versions-faq.md",key:"v-65ff98cc",path:"/v6.2/docs/ecr/ecr-bundle-versions-faq.html",headers:[{level:2,title:"Does the ECR support versioning?",slug:"does-the-ecr-support-versioning"},{level:2,title:"How is a bundle version defined?",slug:"how-is-a-bundle-version-defined"},{level:2,title:"What format should I use to version my bundle?",slug:"what-format-should-i-use-to-version-my-bundle"},{level:2,title:"As a bundle developer, how should I create a new version of a bundle?",slug:"as-a-bundle-developer-how-should-i-create-a-new-version-of-a-bundle"},{level:2,title:"How to prevent a particular bundle version from being visible in the ECR?",slug:"how-to-prevent-a-particular-bundle-version-from-being-visible-in-the-ecr"},{level:2,title:"My bundle contains a microservice generated with the Entando Component Generator, does the version of the microservice have to be the same as the bundle version?",slug:"my-bundle-contains-a-microservice-generated-with-the-entando-component-generator-does-the-version-of-the-microservice-have-to-be-the-same-as-the-bundle-version"},{level:2,title:"How bundle versions are installed from the ECR",slug:"how-bundle-versions-are-installed-from-the-ecr"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:" Bundle versions and updates - FAQ \n Does the ECR support versioning? \n A bundle, as discussed in the  overview , is a package containing one or more components.\nAs in many other packaging systems, the ECR supports bundle versioning, allowing developers to create and release improvements of their package over time. \n How is a bundle version defined? \n In the ECR, the bundle custom resource comes with a set of  tags , each one representing a version of the bundle.\nHere an example for a CMS quickstart bundle \n apiVersion: entando.org/v1\nkind: EntandoDeBundle\nmetadata:\n    name: cms-quickstart-bundle\nspec:\n  details:\n    name: Entando Example CMS Bundle\n    description: Example Bundle containing CMS components for the Quickstart experience\n  tags:\n    - integrity: ''\n      shasum: ''\n      tarball: 'https://github.com/entando/entando-cms-quickstart-bundle.git'\n      version: v0.0.1\n    - integrity: ''\n      shasum: ''\n      tarball: 'https://github.com/entando/entando-cms-quickstart-bundle.git'\n      version: v0.0.2\n \n As you can see from the code above, the bundle  cms-quickstart-bundle  has 2 versions available.\nEach version in the  tags  object must correspond a tag in the git repository provided in the  tarball  field. \n What format should I use to version my bundle? \n The ECR requires versions to follow the  semantic versioning 2.0.0 , with the possibility to prepend a  v  to the version itself. Some valid bundle versions are: \n \n 1.0 \n v0.1.0-alpha \n 1.0.1-SNAPSHOT \n 22.109.10234-RC.1 \n As a bundle developer, how should I create a new version of a bundle? \n If you're a bundle developer and you want to release a new version of your bundle, you can simply update the content of your bundle and commit the changes to the bundle git repository.\nOnce all the required changes are committed, you can create a new tag in the git repository using the  git tag  command and publish it to the remote repository using the  git push --tags  command \n For example, let's assume my bundle already has a version  1.0.0  and I want to publish the version  2.0.0  of my bundle, here the commands I need to use to create and publish the new tag: \n     git tag -a \"2.0.0\" -m \"My new version\"\n    git push --tags\n How to prevent a particular bundle version from being visible in the ECR? \n If, for some reason, you don't want a particular version to be available for the installation, you can proceed as follows: \n \n You can edit the bundle directly using the command  kubectl edit entandodebundles.entando.org -n <namespace-of-the-bundle> <name-of-the-bundle> \n \n or if you still have the original file you can also: \n \n remove the undesired version from the tag list in your bundle Kubernetes file ( integrity ,  shasum ,  tarball  and  version ) \n delete your bundle from your cluster using a command like this  kubectl delete -f your-bundle-file.yml [-n your-cluster-namespace] \n upload your bundle again to Kubernetes using a command like this  kubectl create -f your-bundle-file.yml [-n your-cluster-namespace] \n My bundle contains a microservice generated with the Entando Component Generator, does the version of the microservice have to be the same as the bundle version? \n The version of the microservice - or to be more precise the docker image associated with the microservice - isn't bound to the version of the bundle containing the microservice itself. \n This gives the bundle developer complete control over the bundle release process, especially in those situations where the bundle contains more components and even more microservices. \n How bundle versions are installed from the ECR \n When the user decides to install a version of the bundle, the ECR checks the provided tag in the git repository and clones locally just the content of the repository for that tag. \n For this reason it's important that for each provided tag in the custom-resource a corresponding tag is available in the git repository, otherwise the ECR will not be able to donwload the bundle and will throw an error. Note that the ECR can only see published tags, so make sure that all the time you create a new tag in your git repository you publish it to the remote repository too. \n"},{title:"Troubleshooting ECR",frontmatter:{},regularPath:"/v6.2/docs/ecr/ecr-troubleshooting-guide.html",relativePath:"v6.2/docs/ecr/ecr-troubleshooting-guide.md",key:"v-1e6c858c",path:"/v6.2/docs/ecr/ecr-troubleshooting-guide.html",headers:[{level:2,title:"A bundle installation/removal has failed, how to access the logs?",slug:"a-bundle-installation-removal-has-failed-how-to-access-the-logs"},{level:3,title:"Overview",slug:"overview"},{level:3,title:"Solution",slug:"solution"},{level:2,title:"My bundle has an issue, how should I publish a new version of the bundle?",slug:"my-bundle-has-an-issue-how-should-i-publish-a-new-version-of-the-bundle"},{level:3,title:"Overview",slug:"overview-2"},{level:3,title:"Solution",slug:"solution-2"},{level:2,title:"Bundle installation fails because a file has not been found in the bundle",slug:"bundle-installation-fails-because-a-file-has-not-been-found-in-the-bundle"},{level:3,title:"Overview",slug:"overview-3"},{level:3,title:"Solution",slug:"solution-3"},{level:2,title:"Bundle installation failed due to plugin(s) images not reachable",slug:"bundle-installation-failed-due-to-plugin-s-images-not-reachable"},{level:3,title:"Overview",slug:"overview-4"},{level:3,title:"Solution",slug:"solution-4"},{level:2,title:"I can't uninstall a bundle because some components are in use",slug:"i-can-t-uninstall-a-bundle-because-some-components-are-in-use"},{level:3,title:"Overview",slug:"overview-5"},{level:3,title:"Solution",slug:"solution-5"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:" Troubleshooting ECR \n A bundle installation/removal has failed, how to access the logs? \n Overview \n Currently the Entando component manager logs are available in kubernetes via dashboard (openshift) or cli tools (k9s or kubectl).\nIf in you Entando cluster you have more than one Entando App custom resource, you will need to know what's the correct component-manager to check using the corresponding Entando App name and namespace where the app has been deployed. \n Solution \n Using  kubectl  and assuming for simplicity that you have only one Entando App named  quickstart  and your Entando cluster is only composed of one namespace, also named  quickstart ,\nyou can get the component-manager logs using the command \n kubectl logs -f deployment/quickstart-server-deployment --namespace quickstart -c de-container\n \n Note : the  -f  flag is optional and could be used to follow the logs for debugging purposes \n My bundle has an issue, how should I publish a new version of the bundle? \n Overview \n Sometimes a bundle could have some issues: typos in the  descriptor.yaml  file, wrong references of components or to not available docker images are just a few of the possible errors. \n Solution \n \n If the bundle is shared using a git repository, you can make the required changes to your project and publish the new version to git and generate a new tag for it. \n Once the new tag is published, update the bundle costum-resource avaialble in you Entando Cluster by adding the new tag to the  tags  objects  and replacing the latest  dist-tags  to point to this new version. \n Proceed with the new installation \n \n If you're actively working on your bundle and you simply want to verify things are working correctly, instead of generating a new tag for each release of the bundle you can try to keep overriding a specific tag using the git command  git tag -f . We suggest you to follow this practice only during development and not in production. \n Bundle installation fails because a file has not been found in the bundle \n Overview \n When a component that is referenced in the  descriptor.yaml  is missing in the bundle or not correctly referenced, the bundle installation fails and in the logs is reported which file has not been found. \n ERROR - File with name {filename} not found in the bundle\n Solution \n When such a problem happens, verify that the component referenced in the descriptor file are actually present in the bundle and that the reference is properly typed. \n Publish a new version of your bundle as described in the\n \"My bundle has an issue\"  section \n Bundle installation failed due to plugin(s) images not reachable \n Overview \n Plugin included in a bundle are referenced using their docker image. Sometime the image is not available - maybe has not yet be published or is in a private docker registry - and plugin installation can't happen and the entire bundle installation process can't finish successfully \n Solution \n Verify that the docker image you are referencing is correct and publicly available. \n \"My bundle has an issue\"  section \n I can't uninstall a bundle because some components are in use \n Overview \n When removing an installed bundle, the Entando component manager verfies that the bundle components\nare not in use by any other component. Removing such components would cause an error during removal\nas in certain case the deleting a component in use is not permitted. \n Solution \n In order to prevent such errors, the user is alerted and required to manually decouple the bundle\ncomponents before beign able to completely remove the bundle from the system. \n"},{title:"Bundle uninstall",frontmatter:{},regularPath:"/v6.2/docs/ecr/ecr-uninstall-flow.html",relativePath:"v6.2/docs/ecr/ecr-uninstall-flow.md",key:"v-492826e8",path:"/v6.2/docs/ecr/ecr-uninstall-flow.html",headers:[{level:2,title:"Uninstall process",slug:"uninstall-process"},{level:2,title:"Troubleshooting",slug:"troubleshooting"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:" Bundle uninstall \n Uninstall process \n To uninstall a bundle that was previously installed on an Entando App Engine, from Entando App builder UI go to\nthe  Component Repository  tab and select the bundle you want to uninstall \n \n An initial check is made to verify none of the bundle components are in use.\nIf any of the components are in use, a popup will alert you.\nNote that you can't force the removal of a bundle if its components are in use. \n Once the removal process starts: \n \n Bundle resources are deleted from the Entando App Engine \n Components included in the bundle are removed from the Entando App Engine \n Plugins are unlinked \n Troubleshooting \n If any error happens during the uninstall process and you don't know what to do,\ncheck out the  Troubleshooting guide  or the  Entando Forum \n"},{title:"Overview",frontmatter:{},regularPath:"/v6.2/docs/ecr/ecr-overview.html",relativePath:"v6.2/docs/ecr/ecr-overview.md",key:"v-4a485be8",path:"/v6.2/docs/ecr/ecr-overview.html",headers:[{level:2,title:"Introduction",slug:"introduction"},{level:2,title:"Glossary",slug:"glossary"},{level:3,title:"Component",slug:"component"},{level:3,title:"ECR Bundle",slug:"ecr-bundle"},{level:3,title:"EntandoDeBundle custom resource",slug:"entandodebundle-custom-resource"},{level:3,title:"Entando-component-manager",slug:"entando-component-manager"},{level:3,title:"Entando-K8S-service",slug:"entando-k8s-service"},{level:2,title:"Architecture",slug:"architecture"},{level:2,title:"Example flow",slug:"example-flow"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:" Overview \n Introduction \n The Entando Component Repository (ECR) is meant to be a repository to\nshare reusable components among different Entando instances. \n The following glossary relates to the ECR and related concepts: \n Glossary \n Component \n An Entando component - simply referred to as component - is a piece of\nreusable code/resource to be used in an Entando widget, page or\napplication. Examples of components are widgets, microfrontends,\ncontent-types, labels, plugins, and static resources \n ECR Bundle \n An ECR bundle - is a package containing one or more components and a\n'descriptor.yaml' file providing information about the bundle. The\nbundle is published on an Git registry and is shared with an Entando\napplication using the EntandoDeBundle custom resource. \n EntandoDeBundle custom resource \n The EntandoDeBundle custom resource is a Kubernetes custom resource\nreadable by the Entando6 operator. It’s used to provide information\nabout an ECR bundle and make the bundle available in kubernetes for the\nentando-component-manager. \n Entando-component-manager \n The entando-component-manager - a.k.a component-manager is part of the\nEntando6 app and dialogs both with the Kubernetes cluster via the\nentando-k8s-service and with the entando-core. The\nentando-component-manager reads the bundles from the cluster and exposes\nthem via an API accessible from AppBuilder. The component-manager is\nalso responsible of the installation/removal of components from\nentando-core \n Entando-K8S-service \n The Entando-K8S-Service is part of the Entando infrastructure and is\nresponsible for the low-level communication with the K8S cluster API. \n Architecture \n \n From an architectural point of view, the ECR is composed of \n \n The EntandoDeBundles which contain the metadata associated with a bundle \n The Entando-k8s-service which reads the bundles from the\ncluster/namspace(s) and serves them via a consumable API \n The Component-manager which creates the connection between the EntandoApp\nand the K8S-service. \n Example flow \n \n \n The user lands on the ECR page in app-builder and wants to see the\nlist of bundles shared with that EntandoApp \n \n \n AppBuilder asks the component-manager for the list of available\nbundles \n \n \n Component-manager queries the k8s-service to get the available\nbundles \n \n \n The k8s-service queries the cluster/namespace(s) it is able to read\nfrom for available bundles and returns the list to the\ncomponent-manager \n \n \n Component-manager returns a list to App-Builder \n \n \n The user is able to see the available bundles and is able to install\none or more of them \n \n \n"},{title:"Quick Reference",frontmatter:{},regularPath:"/v6.2/docs/getting-started/quick-reference.html",relativePath:"v6.2/docs/getting-started/quick-reference.md",key:"v-0f23bca8",path:"/v6.2/docs/getting-started/quick-reference.html",headers:[{level:2,title:"Quick Reference",slug:"quick-reference"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:" Quick Reference \n Just the steps, for advanced users. \n \n Install  Multipass \n Launch VM \n multipass launch --name ubuntu-lts --cpus  4  --mem 8G --disk 20G\n \n Open Ubuntu shell \n multipass shell ubuntu-lts\n \n Install k3s \n curl  -sfL https://get.k3s.io  |   sh  -\n \n Check for node ready \n sudo  kubectl get  node \n \n Download custom resource definitions \n curl  -L -C - https://raw.githubusercontent.com/entando/entando-releases/v6.2.0/dist/qs/custom-resources.tar.gz  |   tar  -xz\n \n Create custom resources \n sudo  kubectl create -f dist/crd\n \n Create namespace \n sudo  kubectl create namespace entando\n \n Download Helm chart (or  generate your own ) \n curl  -L -C - -O https://raw.githubusercontent.com/entando/entando-releases/v6.2.0/dist/qs/entando.yaml\n \n Configure external access to your cluster with your VM IP \n IP = $( hostname  -I  |   awk   '{print $1}' ) \n \n sed  -i  \"s/192.168.64.25/ $IP /\"  entando.yaml\n \n Deploy Entando \n sudo  kubectl create -f entando.yaml\n \n Check for quickstart-composite-app-deployer  Completed \n sudo  kubectl get pods -n entando --watch\n \n Get URL to access Entando App Builder from your browser \n sudo  kubectl get ingress -n entando -o  jsonpath = \\ \n '{.items[2].spec.rules[*].host}{.items[2].spec.rules[*].http.paths[2].path}{\"\\n\"}' \n \n "},{title:"Add a New Datasource in EAP Server",frontmatter:{},regularPath:"/v6.2/docs/reference/add_datasource_to_eap_image.html",relativePath:"v6.2/docs/reference/add_datasource_to_eap_image.md",key:"v-26ff67a8",path:"/v6.2/docs/reference/add_datasource_to_eap_image.html",headers:[{level:2,title:"Other resources",slug:"other-resources"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:' Add a New Datasource in EAP Server \n With EAP should be enough to add a set of parameters the EntandoApp\ncustom resource. \n \n \n Set the standardServerImage to eap \n \n \n Add a  parameters  object \n \n \n \n Parameters environment variables reference \n \n \n \n \n \n \n \n Env variable \n Value \n Example with PortDB \n \n \n \n \n DATASOURCES \n "PORTDB,SERVDB, <YOUR-DS-PREFIX>" \n \n \n \n <YOUR-DS-PREFIX>_NONXA \n Defines the datasource as a non-XA datasource. Defaults to  false \n PORTDB_NONXA="true" \n \n \n <YOUR-DS-PREFIX>_JTA \n Defines Java Transaction API (JTA) option for the non-XA datasource. The XA datasources are already JTA capable by default Defaults to  true \n PORTDB_JTA="false" \n \n \n <YOUR-DS-PREFIX>_URL \n Defines connection URL for the datasource. \n PORTDB_URL="jdbc:derby:/entando-data/databases/entandoPort;create=true" \n \n \n <YOUR-DS-PREFIX>_JNDI \n Defines the JNDI name for the datasource. This setting is useful if you want to override the default generated JNDI name \n PORTDB_JNDI="java:jboss/datasources/entandoPortDataSource" \n \n \n <YOUR-DS-PREFIX>_DRIVER \n Defines Java database driver for the datasource \n PORTDB_DRIVER="derby" \n \n \n <YOUR-DS-PREFIX>_USERNAME \n Defines the username for the datasource \n PORTDB_USERNAME="agile" \n \n \n <YOUR-DS-PREFIX>_PASSWORD \n Defines the password for the datasource \n PORTDB_PASSWORD="agile" \n \n \n <YOUR-DS-PREFIX>_SERVICE_HOST \n Defines the database server’s host name or IP address to be used in the datasource’s connection-url property. \n PORTDB_SERVICE_HOST="dummy" \n \n \n <YOUR-DS-PREFIX>_SERVICE_PORT \n Defines the database server’s port for the datasource. \n PORTDB_SERVICE_PORT="1527" \n \n \n \n \n Note \n For more details on other standard variables check the  EAP\ndocumentation \n \n Here a potential example \n apiVersion: entando.org/v1\nkind: "EntandoApp"\nmetadata:\n  annotations: {}\n  labels: {}\n  name: "quickstart"\nspec:\n  dbms: #tbd\n  replicas: 1\n  standardServerImage: eap\n  ingressPath: /entando-de-app\n  parameters:\n    DATASOURCES: "PORTDB,SERVDB,MYDATASOURCE"\n    MYDATASOURCE_NONXA: "true"\n    MYDATASOURCE_JTA: "false"\n    ...\n Other resources \n \n EAP Official Documentation: Runtime\nArtifacts/Datasources \n \n'},{title:"Cluster Resource Limits",frontmatter:{},regularPath:"/v6.2/docs/reference/cluster-resource-limits.html",relativePath:"v6.2/docs/reference/cluster-resource-limits.md",key:"v-3118c32c",path:"/v6.2/docs/reference/cluster-resource-limits.html",headers:[{level:3,title:"Cluster Resource Limits",slug:"cluster-resource-limits"},{level:3,title:"Bundle size limitations",slug:"bundle-size-limitations"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:" Cluster Resource Limits \n Entando needs a well-defined amount of resources in order to start and Kubernetes takes care of using only the needed amount of them.\nHowever, you can choose to impose boundaries on the minimum and maximum used/allocated resources by updating the downloaded  entando.yaml  file and setting the  ENTANDO_K8S_OPERATOR_IMPOSE_DEFAULT_LIMITS  property to true.\nIn this way, Entando will allocate a predefined amount of resources and Kubernetes will act more strictly checking for resource availability. See  Kubernetes resources  for more information. \n By not imposing limits you can minimize initial needed resources and startup time, leaving Kubernetes free to manage its resources as he wants.\nBy imposing limits you can obtain a better-balanced system. \n It's important to note that, accordingly to the Kubernetes documentation, in order to deploy on a namespace with a\n ResourceQuotas  on memory and cpu, \n \n every Container must have a memory request, memory limit, cpu request, and cpu limit \n \n so, in that case, you will need to set  ENTANDO_K8S_OPERATOR_IMPOSE_DEFAULT_LIMITS  to true, otherwise your deploy will fail. \n Here you can see the detailed resource requests/limits per container: \n \n \n \n Component \n Mem requests \n CPU requests \n Mem limits \n CPU limits \n \n \n \n \n AppBuilderDeployableContainer \n 128Mi \n 125m \n 512Mi \n 500m \n \n \n EntandoAppDeployableContainer \n 448Mi \n 375m \n 1792Mi \n 1500m \n \n \n ComponentManagerDeployableContainer \n 192Mi \n 188m \n 768Mi \n 750m \n \n \n EntandoPluginSidecarDeployableContainer \n 192Mi \n 188m \n 768Mi \n 750m \n \n \n EntandoPluginDeployableContainer \n 256Mi \n 250m \n 1024Mi \n 1000m \n \n \n EntandoK8SServiceDeployableContainer \n 192Mi \n 250m \n 768Mi \n 1000m \n \n \n KeycloakDeployableContainer \n 192Mi \n 250m \n 768Mi \n 1000m \n Bundle size limitations \n Entando supports bundles without size limitations, you can install as many bundles as you want and bundles as big as you desire. \n The only thing you have to check is the  <YOUR-APP-NAME>-de-pvc  volume size. Each bundle is installed in that volume, so when it reaches its maximum capacity you will not be able to install bundles anymore. \n You can find  quickstart-de-pvc  volume inside de-container container, that is part of the pod named  <YOUR-APP-NAME>-server-deployment-*** , where asterisks should assume values based on your instance.\nFeel free to set its size accordingly to your needs. \n"},{title:"Manage Entando Databases",frontmatter:{},regularPath:"/v6.2/docs/reference/databases.html",relativePath:"v6.2/docs/reference/databases.md",key:"v-16600c28",path:"/v6.2/docs/reference/databases.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Lightweight, low-config Databases with PostgreSQL and MySQL",slug:"lightweight-low-config-databases-with-postgresql-and-mysql"},{level:2,title:"Existing External Databases",slug:"existing-external-databases"},{level:3,title:"Structure",slug:"structure"},{level:3,title:"How it works",slug:"how-it-works"},{level:3,title:"Keeping track of credentials",slug:"keeping-track-of-credentials"},{level:2,title:"Vendor specific notes",slug:"vendor-specific-notes"},{level:3,title:"Oracle",slug:"oracle"},{level:3,title:"Notes",slug:"notes"},{level:3,title:"MySQL",slug:"mysql"},{level:3,title:"Resulting Connection String",slug:"resulting-connection-string-2"},{level:3,title:"Notes",slug:"notes-2"},{level:3,title:"PostgreSQL",slug:"postgresql"},{level:2,title:"Skipping database preparation",slug:"skipping-database-preparation"},{level:3,title:"How it works",slug:"how-it-works-2"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:' Manage Entando Databases \n Overview \n Entando’s Docker images currently support three different relational\ndatabase management systems: PostgreSQL, MySQL and Oracle. With\nPostgreSQL and MySQL, by default, Entando’s will automatically create a\nKubernetes Deployment hosting the database management systems. However,\nfor Oracle, and also for other scenarios that may require it, Entando\nsupports connectivity to existing external databases. This document\nprovides the user with the necessary information to decide how to manage\nEntando’s databases. \n Lightweight, low-config Databases with PostgreSQL and MySQL \n When deploying Entando Custom Resources that require databases to a new\nNamespace, the default behavior for Entando is to create a Kubernetes\nDeployment. It uses the standard Openshift compliant images: \n \n \n centos/mysql-57-centos7 and \n \n \n centos/postgresql-96-centos7) \n \n \n This is a fairly low-configuration approach, as Entando will create and\ninitialize the databases transparently. Persistent data is stored on any\nPersistent Volume that meets our Persistent Volume Claim requirements.\nWhen an Entando Custom Resource is redeployed, the Persistent Volumes\nremain in tact. Since the subsequent data initialization is idempotent,\nthe supporting Deployments will scale up and behave as expected. \n Generally our services encapsulate the database they use entirely, and\nprovide facilities to import and export the data without needing any\nknowledge of the internal workings of the underlying data store. For\nmost simple Entando Apps the database doesn’t grow too large and is\nfairly easy to manage. This state of affairs allowed us to keep our\ndatabases isolated from each other, thus allowing for isolated\ndeployments without needing complex coordination of database migration\nfor the different deployment pipelines. \n It is worth noting that these database Deployments are not clustered.\nThe customer is therefore strongly advised to provide redundancy and\nclustering in the form of clustered storage. These database deployments\ndo specify a restartPolicy of \'Always\', so in the event of a\nnon-corrupting failure, the database Pod should therefore restart in\nabout 30 seconds. This by no means offers the features of a full\ndatabase cluster, but may suffice for many scenarios. \n However, in more advanced use cases, such as the use of our CMS\nfunctionality, this simplistic approach may not scale. And where there\nis a a centralized database admin team, or where there is a requirement\nto comply to strict organizational governance w.r.t. databases, this\napproach does result in a multitude of databases that may be difficult\nfor the database admin team to manage. \n Existing External Databases \n For this reason, Entando can also be configured to use an existing\ndatabase service provided by the customer. In these scenarios, the\ncustomer is expected to take responbility for the lower level database\noperations such as tablespace creation, permissions and clustering.\nEntando will however still be responsible for creating and populating\nthe tables, indices and foreing keys. Entando will also create all of\nthese in the appropriate table \'container\' for the DBMS in question such\nas a schema (Oracle/PostgreSQL) or a database (MySQL). In order to\nachieve this, Entando installs a dedicated CustomResourceDefinition in\nKubernetes, called an \'EntandoDatabaseService\' \n The idea is for EntandoDatabaseService custom resources to be created in\nthe namespace the EntandoApps and EntandoPlugin that should use them\nwill be created. The EntandoDatabaseService is usually created along\nwith a secret that carries admin credentials to the database in\nquestion. \n Structure \n The EntandoDatabaseService custom resource looks like this: \n  EntandoDatabaseService\nmetadata:\n  name: string, any K8S compliant name\n  namespace: string, the namespace this will be created in\nspec:\n  dbms: string, one of oracle, postgresql or mysql\n  host: string, either an ip address or hostname where the database service is hosted\n  port: integer, the port on which the database service is hosted\n  databaseName: string, the name of the database, only required for PostgreSQL and Oracle\n  secretName: the name of the Secret in the same namespace carrying admin credentials to the database service\n  tablespace: (Oracle only)  the tablespace to use to create the required schemas in\n  jdbcParameters: a map containing name-value pairs for any additional parameters required for the JDBC driver to connect to the database.\n \n The Secret that will provide the admin credentials, identified by the\nabove  secretName  should look like this: \n Secret:\n  name: string, any K8S compliant name\n  namespace: string, the namespace this will be created in\n  stringData:\n    username: string, name of an admin user that can create schemas and other users\n    password: string, password of the above user\n How it works \n In order for the EntandoApp and EntandoPlugin deployer to pick up the\ncorrect database service, the EntandoDatabaseService needs to be created\nBEFORE the EntandoApps and EntandoPlugins are created. There can be\nmultiple EntandoDatabaseServices in the namespace, but they need to\npoint to database services of different vendors, i.e. PostgreSQL, Oracle\nand MySQL. Entando currently cannot enforce any validation but if there\nare two EntandoDatabaseServices that have the same DBMS vendor, it will\nsimply pick the first one and continue. Please ensure that only one\nEntandoDatabaseService exists for each DBMS vendor you need to use. \n Once the appropriate EntandoDatabaseServices have been created, any\nEntandoApp or EntandoPlugin that is created will have to specify the\nappropriate DBMS vendor in their  spec.dbms  property. If the\nEntandoOperator detects an EntandoDatabaseService with a matching DBMS\nvendor, it will continue to create the necessary schemas on the specific\ndatabase. If the EntandoOperator does not detect an\nEntandoDatabaseService with a matching DBMS vendor, it will fall back\nonto its default behaviour which is to create a matching Deployment and\nspin up a database service from the same namespace. If the  spec.dbms \nproperty is not specified on an EntandoApp, the EntandoOperator will\ndefault to PostgreSQL. If the  spec.dbms  property is not specified on\nan EntandoPlugin, the EntandoOperator will assume that the EntandoPlugin\nin question does not require a database and hence bypass any database\nand schema creation. \n When the EntandoOperator processes your Entandoapp or EntandoPlugin with\nan appropriate  spec.dbms  specified, it will create a Schema/User pair\nfor each datasource required. A typical EntandoApp deployment requires 3\ndatasources (portdb,servdb and dedb). Plugins generally only require one\ndatasource (plugindb). \n The database schema and user created will have the same name. The name\nis derived from the name of the EntandoPlugin or EntandoApp by replacing\nall characters that are not ANSI-SQL compliant with an underscore. The\ndatasource name is then suffixed to the schema name. When defining the\nname of your app or plugin, please keep in mind that some DBMS vendors\ndo not support long schema names. Future versions of Entando will allow\nyou to override the schema prefix for an app or plugin, but for now this\nis a limitation one has to keep in mind. \n Keeping track of credentials \n The EntandoOperator generates a Kubernetes Secret for each schema/user\ncombination it creates. The name of this secret is the concatenation of\nthe name of the EntandoApp or EntandoPlugin, the datasource qualifier\nand then the suffix "-secret". For instance, for an EntandoApp called\n"my-app" the "portdb" datasource will have a corresponding Kubernetes\nSecret called "my-app-portdb-secret". The EntandoOperator will never\noverwrite or update an existing database secret. We generate a random\nstring for the password which is generally considered the safest\napproach. If you do however wish to change the password in for the\nresulting user, please remember to update the password on the Kubernetes\nSecret too. Such an operation is however error prone and could result in\nsubsequent deployments failing. \n The EntandoOperator’s schema creation logic is idempotent. If it\ntherefore finds that the generated schema/user combination found in the\nassociated Kuberentes Secret already exists, it won’t do anything.\nHowever, it will attempt to log in, and if it fails to log in, it will\nattempt to create the user. If the user already exists, but with a\ndifferent password than the one in the Kubernetes Secret, all subsequent\ndeployment operations will fail. \n Vendor specific notes \n Oracle \n Example \n   EntandoDatabaseService\n    metadata:\n      name:oracle-service\n    spec:\n      dbms: oracle\n      host: 10.0.0.13\n      port: 1521\n      databaseName: ORCLPDB1.localdomain\n      secretName: oracle-secret\n      tablespace: entando_ts\n      jdbcParameters: {}\n  Secret:\n    metadata:\n      name: oracle-secret\n    stringData:\n      username: admin\n      password: admin123\n Resulting connection string: \n jdbc:oracle:thin:@//10.0.0.13:1521/ORCLPDB1.localdomain \n Notes \n Oracle has some rather complicated rules in building the correct\nconnection string. Please note that for the sake of portability and\nlightweight image we are limited to the thin driver. The  databaseName \ncould also be an Oracle service as opposed to an Oracle  SID . Please\ncoordinate with your Oracle DB Admin to determine exactly what value to\nuse here. We strongly recommend testing your settings with some code or\na tool that constructs JDBC connection. \n When the EntandoOperator prepares the schemas for your EntandoApp or\nEntandoPlugin, it will create a user for every datasource required, and\nas is standard behaviour for Oracle, that user will have its own schema\nwith the same name. Permissions are set up to ensure that one user\ncannot access tables from another user’s schema. Please note that Oracle\nlimits schema names to 30 characters. If you intend to use Oracle,\nplease keep the name of your apps and plugins short enough. The suffixes\nthat we append to the app or plugin name to ensure the resulting schema\nname is unique are usually shorter than 8 characters, so names of about\n20 characters should be safe. \n You can specify which tablespace Entando should use to create the\nschemas in using the  spec.tablespace  property \n ORA-01704: string literal too long \n Entando requires extended datatypes to be activated in Oracle 12c and\nhigher\n( https://oracle-base.com/articles/12c/extended-data-types-12cR1 ) \n MySQL \n Example \n EntandoDatabaseService\n  metadata:\n    name:mysql-service\n  spec:\n    dbms: mysql\n    host: 10.0.0.13\n    port: 3306\n    databaseName:\n    secretName: mysql-secret\n    jdbcParameters:\n       useSSL: "true"\nSecret:\n  metadata:\n    name: mysql-secret\n  stringData:\n    username: admin\n    password: admin123\n Resulting Connection String \n jdbc:mysql://10.0.0.13:3306 \n Notes \n MySQL doesn’t really support schemas, or more accurately, it doesn’t\ndistinguish between schemas and databases. For this reason, no\ndatabaseName is required. The EntandoOperator will therefore create an\nentirely new database for each datasource your EntandoApp or\nEntandoPlugin requires. It will also create a user with the same name as\nthe database with permission set up to ensure one user cannot access the\ndatabase of another user. Please note that MySQL limits database names\nto 63 characters. Keep this in mind when defining the names of your\nEntandoApps and EntandoPlugins \n PostgreSQL \n Example \n   EntandoDatabaseService\n    metadata:\n      name:postgresql-service\n    spec:\n      dbms: postgresql\n      host: 10.0.0.13\n      port: 5432\n      databaseName: my_db\n      secretName: postgresql-secret\n      jdbcParameters: {}\n\n  Secret:\n    metadata:\n      name: postgresql-secret\n    stringData:\n      username: admin\n      password: admin123\n Resulting Connection String \n jdbc:postgresql://10.0.0.13:5432/my_db \n Notes \n PostgreSQL behaves very similar to Oracle when it comes to how it\nassociates a user with its own schema. The current username is used as a\ndefault schema/prefix to resolve tables. As with Oracle, Entando ensures\nthat two users don’t have access to each other’s schemas. \n Skipping database preparation \n When an Entando App is being deployed, there is an operator responsible for the entire deployment process. It takes care also of DB creation and preparation.\nIf you have an already prepared DB (schemas, tables, and all other stuff), you could skip schemas creation and DB preparation of the EntandoApp in order to speed up the deploy process. \n You can achieve this by specifying some properties for the EntandoApp component present in the helm generated file. Look at  this  for more info. \n For  spec.dbms  property you should choose  none , then you should add all needed DB connection parameters.\nAfter updating parameters with the one you need, you should end with a yaml like this: \n - kind: "EntandoApp"\n  metadata:\n    annotations: {}\n    labels: {}\n    name: "example-qs"\n  spec:\n    dbms: "none"\n    replicas: 1\n    standardServerImage: wildfly\n    ingressPath: /entando-de-app\n    parameters:\n      SPRING_DATASOURCE_USERNAME: "admin"\n      SPRING_DATASOURCE_PASSWORD: "adminadmin"\n      SPRING_DATASOURCE_URL: "jdbc:postgresql://192.168.1.82:5432/testdb?currentSchema=admin_qs_dedb"\n      SPRING_JPA_DATABASE_PLATFORM: "org.hibernate.dialect.PostgreSQLDialect"\n      PORTDB_URL: "jdbc:postgresql://192.168.1.82:5432/testdb?currentSchema=admin_qs_portdb"\n      PORTDB_USERNAME: "admin"\n      PORTDB_PASSWORD: "adminadmin"\n      PORTDB_CONNECTION_CHECKER: "org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLValidConnectionChecker"\n      PORTDB_EXCEPTION_SORTER: "org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLExceptionSorter"\n      SERVDB_URL: "jdbc:postgresql://192.168.1.82:5432/testdb?currentSchema=admin_qs_servdb"\n      SERVDB_USERNAME: "admin"\n      SERVDB_PASSWORD: "adminadmin"\n      SERVDB_CONNECTION_CHECKER: "org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLValidConnectionChecker"\n      SERVDB_EXCEPTION_SORTER: "org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLExceptionSorter"\n How it works \n Using  spec.dbms: "none"  will cause the operator to skip that initial schema/user creation step entirely.\nThen adding those variables under the  spec.parameters  section will supply connection parameters that will be used agnostically by EntandoApp.\nKeep in mind that all these parameters will be applied to each of the containers in the EntandoApp pod and that they will also override existing values. \n'},{title:"Accessing Entando APIs",frontmatter:{sidebarDepth:0},regularPath:"/v6.2/docs/reference/entando-apis.html",relativePath:"v6.2/docs/reference/entando-apis.md",key:"v-64f145d0",path:"/v6.2/docs/reference/entando-apis.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Setup",slug:"setup"},{level:2,title:"Overview",slug:"overview"},{level:3,title:"API structure",slug:"api-structure"},{level:3,title:"Models",slug:"models"},{level:2,title:"Tutorial:",slug:"tutorial"}],lastUpdated:"12/15/2021, 2:22:26 PM",lastUpdatedTimestamp:1639596146e3,content:" Accessing Entando APIs \n Prerequisites \n \n \n Java 8 \n \n \n maven \n Setup \n \n \n Clone the Entando reference app if you don’t already have it. \n git clone https://github.com/entando/entando-de-app\n \n \n \n Start the app for local execution and enable the swagger profile by\npassing  -Dspring.profiles.active=swagger  to the jetty command. Set\nthe value of  -Djetty.port  to something available on your machine\ne.g. 8085. \n  mvn clean package jetty:run-war -Pjetty-local -Pderby -Dspring.profiles.active=swagger -Djetty.port=8085 -Dorg.slf4j.simpleLogger.log.org.eclipse.jetty.annotations.AnnotationParser=error\n \n \n \n \n Note: If you don't have docker installed or running add  -DskipDocker=true  to the command above \n \n \n \n Wait for the app to start. \n \n \n Once started, navigate to the swagger ui in a browser. \n \n \n \n http://localhost:[your port]/entando-de-app/api/swagger-ui.html\n Overview \n The Entando core exposes REST APIs for every action that can be taken in\nthe App Builder and Admin Console environments. For example, you can use\nthese apis to create pages, create page templates or to add widgets to\npages. The APIs can be used to support automation, testing, or\nintegrations with external systems. \n API structure \n All of the APIs share a common top level structure. Each response will\ncontain a top level entry for  errors ,  metadata , and  payload . \n The  errors  will always contain code and a message string indicating an\nerror condition in the request. The  metadata  section is used for\npaging, sorting, filtering and data that is distinct from the body. The\nbody of each response is included in the  payload  section of the\nresponse and varies according to each API. \n Models \n All of the model classes returned by the Entando core are annotated so\nthat the model definition is included in the swagger documentation. At\nthe bottom of the swagger page all of the model classes returned by the\nAPI endpoints can be found. \n Tutorial: \n \n \n Stop the Entando instance if it is running. \n \n \n In the project open  src/main/conf/systemParams.properties . \n \n \n Change the value of this property to reflect the port you are using\nto run the app. \n \n \n applicationBaseURL \n \n \n For example if running on 8085 you would have\n applicationBaseURL=http://localhost:8085/${entando.engine.web.context}/ \n \n \n \n \n Login to the admin console at  http://localhost:8085/entando-de-app/do/login \n \n \n Once logged in go to  Administration - API Management - Consumers. \n \n \n Select the kebab button on the row labeled swagger. \n \n \n On that screen enable the button for  client_credentials . \n \n \n On that screen enter  swagger  as the value for the secret. \n \n \n Click  Save \n \n \n Return to the Swagger UI, e.g.  http://localhost:8085/entando-de-app/api/swagger-ui.html \n \n \n Click  Authorize \n \n \n Enter \n \n \n user: admin \n \n \n password: adminadmin \n \n \n client: swagger \n \n \n client_secret: swagger \n \n \n \n \n Use the  Try it out  button on the APIs \n \n \n Scroll to  widget-controller \n \n \n Select the blue GET row \n \n \n Select  Try it out \n \n \n Look at the results in the window \n \n \n \n \n"},{title:"Get Started with Entando in 3 Easy Steps",frontmatter:{sidebarDepth:2},regularPath:"/v6.2/docs/getting-started/",relativePath:"v6.2/docs/getting-started/README.md",key:"v-7e970e22",path:"/v6.2/docs/getting-started/",headers:[{level:2,title:"Install Kubernetes",slug:"install-kubernetes"},{level:3,title:"Enable Hypervisor",slug:"enable-hypervisor"},{level:3,title:"Launch Ubuntu VM",slug:"launch-ubuntu-vm"},{level:3,title:"Run Kubernetes",slug:"run-kubernetes"},{level:2,title:"Prepare Kubernetes Environment",slug:"prepare-kubernetes-environment"},{level:3,title:"Add Custom Resources",slug:"add-custom-resources"},{level:3,title:"Create Namespace",slug:"create-namespace"},{level:3,title:"Download Helm Chart",slug:"download-helm-chart"},{level:3,title:"EntandoCompositeApp",slug:"entandocompositeapp"},{level:3,title:"Configure Access to Your Cluster",slug:"configure-access-to-your-cluster"},{level:2,title:"Deploy Entando",slug:"deploy-entando"}],lastUpdated:"9/22/2020, 4:28:19 PM",lastUpdatedTimestamp:1600806499e3,content:" Get Started with Entando in 3 Easy Steps \n New to Kubernetes, hypervisors, and Helm charts? \n This in-depth guide takes a learn-as-you-go approach, and will give you a working knowledge of Kubernetes as you get Entando up and running in a local environment. \n \n Install Kubernetes \n Prepare Kubernetes Environment \n Deploy Entando \n \n Note: For advanced or long-time Entando users, check out our  Quick Reference  install guide with just the steps. \n Install Kubernetes \n Since Entando is designed to run on Kubernetes, let's get started by installing our own instance of Kubernetes locally. \n We've tested a variety of Kubernetes implementations including Minikube, Minishift, CodeReady Containers, K3s, and Microk8s to find the best combination of low cpu/memory usage, fast startup times, and minimal configuration so we can get started quickly. After downloading the necessary files, we'll have our own instance of Kubernetes up and running in < 60 seconds. \n What's Needed to Run Kubernetes \n Kubernetes is a container orchestrator designed to manage a server cluster. It requires at least one master node running a Linux OS. We'll be using Multipass to create a lightweight Ubuntu VM in seconds that runs on a bare metal hypervisor for speed and performance. \n Enable Hypervisor \n TIP \n Hypervisors allow you to create and run virtual machines. Virtualization software that run on top of your operating system like VirtualBox or VMWare Workstation are Type 2 hypervisors. Type 1 hypervisors run on bare metal. \n \n Let's install a bare metal hypervisor for optimal performance. \n Mac:  Install  hyperkit . \n brew  install  hyperkit\n \n Windows:   Install Hyper-V \n \n What if my machine doesn't support hyperkit or Hyper-V? \n Use a Type 2 hypervisor that runs on top of your operating system: \n \n Install Virtual Box:\n Mac \n Windows \n Launch Ubuntu VM \n TIP \n Multipass is a tool developed by the publishers of Ubuntu to create lightweight Ubuntu VMs in seconds. \n \n \n \n Install  Multipass \n \n \n Launch VM \n \n \n multipass launch --name ubuntu-lts --cpus  4  --mem 8G --disk 20G\n \n \n Open a shell \n \n multipass shell ubuntu-lts\n Run Kubernetes \n TIP \n K3s is a certified Kubernetes distribution designed for production workloads in resource-constrained environments. \n It's packaged as a single <40MB binary that reduces the dependencies and steps needed to install, run and auto-update a production Kubernetes cluster. \n \n \n Install  k3s \n \n curl  -sfL https://get.k3s.io  |   sh  -\n \n \n Check for  Ready   STATUS . \n \n sudo  kubectl get  node \n \n \n What's running out of the box? \n sudo  kubectl get pods -A\n \n \n \n Congratulations! \n You now have a local instance of Kubernetes up and running. \n Prepare Kubernetes Environment \n To install Entando, we'll add  Custom Resources , create a  Namespace , download a  Helm  chart, and configure external access to our cluster. \n Add Custom Resources \n TIP \n Standard resources in Kubernetes include things like  Pods , which are a group of one or more containers,  Services , the way to call or access your pods, and  Ingresses , for managing external access to your cluster. \n Custom resources let you store and retrieve structured data.  Combining a custom resource with a custom controller allows you to define a desired state to automate the running of your applications or services in a Kubernetes cluster. \n \n Examples of custom resources in Entando are: \n \n Entando App Engine \n Entando Identity Management System \n \n From your Ubuntu shell: \n \n Download custom resource definitions. \n \n wget  -c https://raw.githubusercontent.com/entando/entando-releases/v6.2.0/dist/qs/custom-resources.tar.gz -O -  |   tar  -xz\n \n \n Create custom resources \n \n sudo  kubectl create -f dist/crd\n Create Namespace \n TIP \n Kubernetes supports multiple virtual clusters backed by the same physical cluster. These virtual clusters are called namespaces. \n You can use namespaces to allocate resources and set cpu/memory limits for individual projects or teams. They can also encapsulate projects from one another. \n \n sudo  kubectl create namespace entando\n Download Helm Chart \n TIP \n Helm is a package manager for Kubernetes that helps you define, install, and upgrade Kubernetes applications.\nThis  Getting Started  guide uses a Helm-generated file with a number of default values to help get you started faster,\ne.g. use embedded databases, don't include OpenShift support, don't include PDA widgets, etc. If you want to\nchange any of those defaults please see  https://github.com/entando-k8s/entando-helm-quickstart . \n \n curl  -L -C - -O https://raw.githubusercontent.com/entando/entando-releases/v6.2.0/dist/qs/entando.yaml\n EntandoCompositeApp \n To quickly deploy an application, Entando uses a Kubernetes Custom Resource named  EntandoCompositeApp . It's composed of 3 parts: \n \n EntandoKeycloakServer  (authentication manager) \n EntandoClusterInfrastructure  (interface between Entando app and Kubernetes) \n EntandoApp  (core logic application) \n \n To speed up the  Getting Started  environment, embedded databases are used by default for these components.\nSee  this tutorial  for more information on how to change your\ndatabase connection. \n Configure Access to Your Cluster \n TIP \n Entando sets up  Ingresses  in Kubernetes to access services from outside your server cluster.\nWe'll use this to access Entando from a local browser. \n If you run into network issues during startup or if you are using Windows for your local development instance, please see  the tips . Symptoms can include having Entando fail to completely start the first time or a working Entando installation may fail to restart later. \n \n To set up external access to your cluster, you'll need to replace the value of\n ENTANDO_DEFAULT_ROUTING_SUFFIX  with your Ubuntu IP. You can look up your Ubuntu IP, and edit the\nYAML file manaully, but running the below commands will automatically update the IP address for you. \n IP = $( hostname  -I  |   awk   '{print $1}' ) \n \n sed  -i  \"s/192.168.64.25/ $IP /\"  entando.yaml\n Deploy Entando \n Deploying the Helm chart will deploy all of the Kubernetes resources required for Entando to run. \n sudo  kubectl create -f entando.yaml\n \n sudo  kubectl get pods -n entando --watch\n \n \n What does a successful startup look like? \n \n First, you'll see the Entando operator:  ContainerCreating  >  Running \n Next, the Entando composite app deployer:  Pending  >  ContainerCreating  >  Running \n Then, Keycloak:  kc-deployer  >  kc-db-deployment \n \n Jobs / Deployments \n \n Jobs, like  kc-db-preparation-job  run once, and are  Completed :  0/1 \n Database deployments, like  kc-db-deployment , should end up as  Running :  1/1 \n The Keycloak server deployment  kc-server-deployment , should end up as  Running :  1/1 \n The  quickstart-server-deployment  should end up as  3/3 \n \n Lifecycle Events \n \n Each line represents an event:  Pending ,  ContainerCreating ,  Running  or  Completed \n Restarts should ideally be  0 ; otherwise, there was a problem with your cluster, and Kubernetes is trying to self-heal \n \n ubuntu@test-vm : ~ $   sudo  kubectl get pods -n entando --watch \n NAME                                   READY   STATUS              RESTARTS   AGE\nquickstart-operator-8556c9c6f8-9ghwg   0/1     ContainerCreating   0          3s\nquickstart-operator-8556c9c6f8-9ghwg   0/1     Running             0          49s\nquickstart-composite-app-deployer-picaju7bf0   0/1     Pending             0          0s\nquickstart-composite-app-deployer-picaju7bf0   0/1     Pending             0          0s\nquickstart-composite-app-deployer-picaju7bf0   0/1     ContainerCreating   0          0s\nquickstart-composite-app-deployer-picaju7bf0   1/1     Running             0          20s\nquickstart-kc-deployer-mx7ms3sc2l              0/1     Pending             0          0s\nquickstart-kc-deployer-mx7ms3sc2l              0/1     Pending             0          0s\nquickstart-kc-deployer-mx7ms3sc2l              0/1     ContainerCreating   0          0s\nquickstart-operator-8556c9c6f8-9ghwg           1/1     Running             0          88s\nquickstart-kc-deployer-mx7ms3sc2l              1/1     Running             0          19s\nquickstart-kc-db-deployment-c57f75d7f-wxmqr    0/1     Pending             0          0s\nquickstart-kc-db-deployment-c57f75d7f-wxmqr    0/1     Pending             0          7s\nquickstart-kc-db-deployment-c57f75d7f-wxmqr    0/1     ContainerCreating   0          7s\nquickstart-kc-db-deployment-c57f75d7f-wxmqr    0/1     Running             0          77s\nquickstart-kc-db-deployment-c57f75d7f-wxmqr    1/1     Running             0          87s\nquickstart-kc-db-preparation-job-1d6ab9b6-7    0/1     Pending             0          0s\nquickstart-kc-db-preparation-job-1d6ab9b6-7    0/1     Pending             0          0s\nquickstart-kc-db-preparation-job-1d6ab9b6-7    0/1     Init:0/1            0          0s\nquickstart-kc-db-preparation-job-1d6ab9b6-7    0/1     Init:0/1            0          13s\nquickstart-kc-db-preparation-job-1d6ab9b6-7    0/1     PodInitializing     0          15s\nquickstart-kc-db-preparation-job-1d6ab9b6-7    0/1     Completed           0          17s\nquickstart-kc-server-deployment-66484d596d-qr78q   0/1     Pending             0          0s\nquickstart-kc-server-deployment-66484d596d-qr78q   0/1     Pending             0          0s\nquickstart-kc-server-deployment-66484d596d-qr78q   0/1     ContainerCreating   0          0s\nquickstart-kc-server-deployment-66484d596d-qr78q   0/1     Running             0          3m\nquickstart-kc-server-deployment-66484d596d-qr78q   1/1     Running             0          4m36s\nquickstart-kc-deployer-mx7ms3sc2l                  0/1     Completed           0          6m50s\nquickstart-eci-deployer-kx9nhop22g                 0/1     Pending             0          0s\nquickstart-eci-deployer-kx9nhop22g                 0/1     Pending             0          0s\nquickstart-eci-deployer-kx9nhop22g                 0/1     ContainerCreating   0          0s\nquickstart-eci-deployer-kx9nhop22g                 1/1     Running             0          5s\nquickstart-eci-k8s-svc-deployment-7c58c78b55-z52xj   0/1     Pending             0          0s\nquickstart-eci-k8s-svc-deployment-7c58c78b55-z52xj   0/1     Pending             0          0s\nquickstart-eci-k8s-svc-deployment-7c58c78b55-z52xj   0/1     ContainerCreating   0          0s\nquickstart-eci-k8s-svc-deployment-7c58c78b55-z52xj   0/1     Running             0          97s\nquickstart-eci-k8s-svc-deployment-7c58c78b55-z52xj   1/1     Running             0          2m7s\nquickstart-eci-deployer-kx9nhop22g                   0/1     Completed           0          2m15s\nquickstart-deployer-os19rw3eto                       0/1     Pending             0          0s\nquickstart-deployer-os19rw3eto                       0/1     Pending             0          0s\nquickstart-deployer-os19rw3eto                       0/1     ContainerCreating   0          1s\nquickstart-deployer-os19rw3eto                       1/1     Running             0          6s\nquickstart-db-deployment-7fff4c8479-qf469            0/1     Pending             0          0s\nquickstart-db-deployment-7fff4c8479-qf469            0/1     Pending             0          4s\nquickstart-db-deployment-7fff4c8479-qf469            0/1     ContainerCreating   0          4s\nquickstart-db-deployment-7fff4c8479-qf469            0/1     Running             0          7s\nquickstart-db-deployment-7fff4c8479-qf469            1/1     Running             0          19s\nquickstart-db-preparation-job-5a55b267-6             0/1     Pending             0          0s\nquickstart-db-preparation-job-5a55b267-6             0/1     Pending             0          0s\nquickstart-db-preparation-job-5a55b267-6             0/1     Init:0/4            0          0s\nquickstart-db-preparation-job-5a55b267-6             0/1     Init:0/4            0          4s\nquickstart-db-preparation-job-5a55b267-6             0/1     Init:1/4            0          5s\nquickstart-db-preparation-job-5a55b267-6             0/1     Init:1/4            0          8s\nquickstart-db-preparation-job-5a55b267-6             0/1     Init:2/4            0          9s\nquickstart-db-preparation-job-5a55b267-6             0/1     Init:2/4            0          6m42s\nquickstart-db-preparation-job-5a55b267-6             0/1     Init:3/4            0          7m20s\nquickstart-db-preparation-job-5a55b267-6             0/1     Init:3/4            0          7m22s\nquickstart-db-preparation-job-5a55b267-6             0/1     PodInitializing     0          7m23s\nquickstart-db-preparation-job-5a55b267-6             0/1     Completed           0          7m25s\nquickstart-server-deployment-5597597575-gtptz        0/3     Pending             0          0s\nquickstart-server-deployment-5597597575-gtptz        0/3     Pending             0          4s\nquickstart-server-deployment-5597597575-gtptz        0/3     ContainerCreating   0          4s\nquickstart-server-deployment-5597597575-gtptz        0/3     Running             0          2m35s\nquickstart-server-deployment-5597597575-gtptz        1/3     Running             0          2m37s\nquickstart-server-deployment-5597597575-gtptz        2/3     Running             0          2m38s\nquickstart-server-deployment-5597597575-gtptz        3/3     Running             0          3m5s\nquickstart-deployer-os19rw3eto                       0/1     Completed           0          11m\nquickstart-composite-app-deployer-picaju7bf0         0/1     Completed           0          20m\n \n \n \n Press  Ctrl-C  to exit the watch command once everything is up and running. \n \n What pods come out of the box? \n sudo  kubectl get pods -n entando\n \n NAME                                                 READY   STATUS      RESTARTS   AGE\nquickstart-operator-8556c9c6f8-9ghwg                 1/1     Running     0          132m\nquickstart-kc-db-deployment-c57f75d7f-wxmqr          1/1     Running     0          130m\nquickstart-kc-db-preparation-job-1d6ab9b6-7          0/1     Completed   0          129m\nquickstart-kc-server-deployment-66484d596d-qr78q     1/1     Running     0          128m\nquickstart-kc-deployer-mx7ms3sc2l                    0/1     Completed   0          130m\nquickstart-eci-k8s-svc-deployment-7c58c78b55-z52xj   1/1     Running     0          123m\nquickstart-eci-deployer-kx9nhop22g                   0/1     Completed   0          124m\nquickstart-db-deployment-7fff4c8479-qf469            1/1     Running     0          121m\nquickstart-db-preparation-job-5a55b267-6             0/1     Completed   0          121m\nquickstart-server-deployment-5597597575-gtptz        3/3     Running     0          113m\nquickstart-deployer-os19rw3eto                       0/1     Completed   0          121m\nquickstart-composite-app-deployer-picaju7bf0         0/1     Completed   0          131m\n Log in to Entando \n Now that we've installed Entando, let's log in to  Entando App Builder . \n TIP \n Ingress exposes HTTP routes from outside the cluster to services within the cluster. \n \n Get the URL to access Entando from your local browser. \n sudo  kubectl get ingress -n entando -o  jsonpath = \\ \n '{.items[2].spec.rules[*].host}{.items[2].spec.rules[*].http.paths[2].path}{\"\\n\"}' \n \n \n Example URL: \n \n quickstart-entando.192.168.64.33.nip.io/app-builder/\n \n \n \n \n Username: admin \n Password: adminadmin \n \n After login, change your password to activate your account. \n \n Note: If the login process hangs for more than 5 seconds, refresh the browser. \n \n \n The App Builder is where we'll compose our micro frontends alongside CMS pages and content. \n Congratulations! \n We now have Entando up and running on Kubernetes in our local environment. \n \n \n For Developers: Learn how Ingresses work behind the scenes. \n\n``` bash\nsudo kubectl describe ingress -n entando\n```\n\n``` shell-session\nName:             quickstart-kc-ingress\nNamespace:        entando\nAddress:          192.168.64.33\nDefault backend:  default-http-backend:80 ( )\nRules:\n  Host                                        Path  Backends\n  ----                                        ----  --------\n  quickstart-kc-entando.192.168.64.33.nip.io\n                                              /auth   quickstart-kc-server-service:8080 (10.42.0.14:8080)\n```\n\nThe Ingress provides the `Host` and `Path` to access our `Services`.\n\n#### Identity Management\n\n1. Find the URL to the Keycloak server.\n\n``` shell-session\n  Host                                        Path  Backends\n  ----                                        ----  --------\n  quickstart-kc-entando.192.168.64.33.nip.io\n                                              /auth   quickstart-kc-server-service:8080 (10.42.0.14:8080)\n```\n\n- Example URL:\n\n``` bash\nhttp://quickstart-kc-entando.192.168.64.33.nip.io/auth/\n```\n\nNote: Replace the first part of the URL with the value of your `Host`\n\n2. Get the Kubernetes `Secret` for the login and password.\n\n``` bash\nsudo kubectl get secrets -n entando\n```\n\nWe're interested in the `keycloak-admin-secret`:\n\n``` shell-session\nNAME                                                 TYPE                                  DATA   AGE\nquickstart-kc-db-admin-secret                        Opaque                                2      78m\nquickstart-kc-db-secret                              Opaque                                2      76m\nquickstart-kc-admin-secret                           Opaque                                2      76m\nquickstart-kc-realm                                  Opaque                                1      76m\nkeycloak-admin-secret                                Opaque                                3      70m\n```\n\n3. Decode the secret.\n\n``` bash\nsudo kubectl get secret keycloak-admin-secret -n entando -o jsonpath=\\\n'{\"\\n Username: \"}{.data.username | base64decode}{\"\\n Password: \"}{.data.password | base64decode}{\"\\n\"}'\n\"{{println}}Username: {{.data.username | base64decode}}{{println}}Password: {{.data.password | base64decode}}{{println}}{{println}}\"\n```\n\n- Example Username and Password:\n\n``` shell-session\nUsername: entando_keycloak_admin\nPassword: MZ8bY4phMd\n```\n\n4. In your Keycloak browser, click `Administration Console`\n\nEnter the Username and Password from your shell.\n\n#### Entando App Builder\n\n``` bash\nsudo kubectl describe ingress -n entando\n```\n\n``` shell-session\nName:             quickstart-ingress\nNamespace:        entando\nAddress:          192.168.64.33\nDefault backend:  default-http-backend:80 ( )\nRules:\n  Host                                     Path  Backends\n  ----                                     ----  --------\n  quickstart-entando.192.168.64.33.nip.io\n                                           /entando-de-app     quickstart-server-service:8080 (10.42.0.22:8080)\n                                           /digital-exchange   quickstart-server-service:8083 (10.42.0.22:8083)\n                                           /app-builder/       quickstart-server-service:8081 (10.42.0.22:8081)\n                                           /pda                quickstart-pda-server-service:8081 (10.42.0.28:8081)\n```\n\n- Example URL:\n\n``` bash\nhttp://quickstart-entando.192.168.64.33.nip.io/app-builder/\n```\n\n \n\n--- --\x3e\n"},{title:"Entando Deployment Structure",frontmatter:{},regularPath:"/v6.2/docs/reference/deployment-structure.html",relativePath:"v6.2/docs/reference/deployment-structure.md",key:"v-3cd17670",path:"/v6.2/docs/reference/deployment-structure.html",headers:[{level:2,title:"entando-operator",slug:"entando-operator"},{level:2,title:"database init containers",slug:"database-init-containers"},{level:2,title:"entando-de-app",slug:"entando-de-app"},{level:2,title:"app-builder",slug:"app-builder"},{level:2,title:"component-manager",slug:"component-manager"},{level:2,title:"entando-k8s-service",slug:"entando-k8s-service"},{level:2,title:"keycloak",slug:"keycloak"},{level:2,title:"Other Key Repositories",slug:"other-key-repositories"},{level:3,title:"entando-core",slug:"entando-core"},{level:3,title:"entando-cms",slug:"entando-cms"},{level:3,title:"entando-components",slug:"entando-components"},{level:3,title:"Entando Kubernetes Controllers",slug:"entando-kubernetes-controllers"}],lastUpdated:"12/15/2021, 2:22:26 PM",lastUpdatedTimestamp:1639596146e3,content:" Entando Deployment Structure \n This page provides a high level overview of the key Entando GitHub repositories along with a brief description\nof how those repositories are realized in a running Entando deployment. The descriptions provided here are meant\nas a guide for identifying opportunities to dig deeper into the architecture and how things are structured\nrather than a panacea for understanding the architecture. \n entando-operator \n The Entando operator coordinates the installation and configuration of all of the components of an Entando\nCluster. The operator can be installed once per Entando Cluster and used to coordinate the plugin lifecycle for\nmultiple Entando applications across many namespaces. \n \n GitHub:  https://github.com/entando-k8s/entando-k8s-controller-coordinator/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-k8s-controller-coordinator \n Customization \n It is unlikely that the operator will be customized as part of an Entando implementation. It is not built to\nbe extended inside the codebase. The most common pattern will be to use the existing custom resources that the\noperator knows how to deploy to extend the Entando platform. \n database init containers \n During installation an Entando application needs to create several databases and also to initialize those\ndatabases with information when deploying from a backup in your images. At initialization the  entando-k8s-dbjob \nwill be run 5 times in total. Once for keycloak, twice for the entando application (port and serv dbs), once to\npopulate the Entando application database, and once to create the Component Repository database. \n \n GitHub:  https://github.com/entando-k8s/entando-k8s-dbjob \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-k8s-dbjob \n \n The screenshot below highlights the init containers for the Entando application schema creation, db\ninitialization, and component repository database. \n \n Many managed kubernetes instances like OpenShift won’t show init containers in their dashboards. So if you’re\ntroubleshooting you may need to look deeper. When fetching logs for an init container using kubectl you must\npass the container name as an argument to the call. For example, \n     kubectl logs <pod> -c <container> -n <namespace>        \n    kubectl logs quickstart-kc-db-preparation-job-ddbdbddb-a  -c quickstart-kc-db-schema-creation-job -n sprint1-rc\n Customization \n It is unlikely that the init containers will be customized as part of an Entando project. The init containers\nwill automatically restore a backup included in your application so that you can create custom images that\ninclude your application setup.\nSee  Backing Up and Restoring Your Environment . \n entando-de-app \n The  entando-de-app  is a J2EE application and is an instance of the  entando-core  (see a description of the\n entando-core  repo below). Reviewing the dependencies of this application in the pom.xml will reveal the\ndependencies on the  entando-core ,  entando-engine , and  admin-console  which encompass the core\nfunctionality in versions of Entando prior to Entando 6. In a quickstart deployment the  entando-de-app  is deployed as part of the  entando-composite-app  multi\ncontainer pod. \n \n GitHub:  https://github.com/entando/entando-de-app/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-de-app-eap , https://hub.docker.com/repository/docker/entando/entando-de-app-wildfly \n Customization \n The  entando-de-app  is very likely to be customized as part of an Entando implementation. This image can be\ncustomized with new APIs, legacy Entando plugins, new database tables, or other extensions to the  entando-core .\nIt is highly recommended that most extensions to the platform in Entando 6 occur in microservices. However, legacy\nintegrations, extensions to the CMS, and migrations from earlier Entando versions may require changes to the  entando-de-app . \n app-builder \n The  app-builder  is the front end of the  entando-de-app . It communicates with the  entando-de-app  via  REST\nAPIs . The  app-builder  is a React JS application and is served via node in the default\ndeployment. In a quickstart deployment the  app-builder  container is deployed in the  entando-composite-app \nmultiple container pod. The  app-builder  also communicates with the Component Manager via REST API to fetch\ninformation about Entando Bundles deployed to the Entando Component Repository (ECR). \n \n GitHub:  https://github.com/entando/app-builder/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/app-builder/ \n Customization \n The  app-builder  is built to be customized and will be customized as part of many Entando implementations.\nThe  app-builder  can be customized at runtime via micro frontends\n widget configuration . The  app-builder  can also be\ncustomized via the integration of custom modules that are added at\n build time . \n component-manager \n The  component-manager  provides the link between the entando-de-app (or your custom core instance) and the\nEntando Component Repository (ECR). The  component-manager  queries the entando-k8s service to fetch available\nbundles that have been deployed as custom resources inside of an Entando cluster.\nThe  component-manager  also manages the relationships between an Entando application and the\ninstalled plugins. This can be seen in the plugin link custom resources in Kubernetes. \n \n GitHub:  https://github.com/entando-k8s/entando-component-manager/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-component-manager/ \n Customization \n It is unlikely that the  component-manager  will be customized as part of an Entando implementation. \n entando-k8s-service \n The  entando-k8s-service  acts as an abstraction layer to fetch data from kubernetes APIs. The primary\nfunctionality is in discovering and making available for installation Entando plugins. The\n entando-k8s-service  is invoked by the  component-manager . \n \n GitHub:  https://github.com/entando-k8s/entando-k8s-service/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-k8s-service/ \n Customization \n It is very unlikely that the  entando-k8s-service  will be customized as part of an Entando implementation. \n keycloak \n The  entando-keycloak  project is an extension of the base Keycloak images. The extension provides the default\nthemes for Entando, a customized realm and clients, and adds the Oracle ojdbc jars for connection to Oracle\ndatabases. \n \n GitHub:  https://github.com/entando/entando-keycloak/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-keycloak/ \n Customization \n The keycloak image will often be customized as part of an Entando implementation. Common extensions will\ninclude changing the theme, adding default connections, adding default social logins, adding default clients,\nor other changes. \n Other Key Repositories \n entando-core \n The entando-core project is a J2EE application that exposes APIs for the Entando CMS, includes the legacy\nadmin console, and includes the portal-ui project that performs the server side composition for pages\nrendered via an Entando application. Note that only the composition is performed server side.\nJavascript code is rendered on the client. The entando-core is realized via an instance that includes the\nWAR files generated from a core build as dependencies. In a default deployment this is the  entando-de-app . \n \n GitHub:  https://github.com/entando/entando-core/ \n DockerHub: None (deployed to maven central) \n Customization \n For users familiar with versions prior to Entando 6 there will be cases where the  entando-core  is customized.\nIn most cases these customizations will be delivered via WAR overlay in the instance project.\nUsing WAR overlay is a functional approach for users already  familiar with the process but it is highly\nrecommended to extend the platform using microservices for new projects. \n entando-cms \n The  entando-cms  project is the  app-builder  (React JS) side of the Entando WCMS. It is bundled into the\n app-builder  at build time and will be included in the default deployment of the  app-builder  in almost all cases. \n \n GitHub:  https://github.com/entando/entando-cms/ \n DockerHub: None (deployed to npm) \n Customization \n In some cases the  entando-cms  may be customized if new custom features are added to CMS specific\nfunctionality. However, most cases will use the more general  app-builder  extension points noted above.\nThe  entando-cms  does not expose any dedicated extension interfaces outside of those already provided by the\n app-builder . \n entando-components \n The entando-components project is a collection of legacy plugins for Entando 5 and earlier. These plugins are deployed as WAR dependencies in an entando-core instance. \n \n GitHub:  https://github.com/entando/entando-components/ \n DockerHub: None (deployed to maven central) \n Entando Kubernetes Controllers \n There are a number of controllers that are available to the Entando operator to manage installations and\ncomponents in an Entando Cluster. Those controllers are small and lightweight images that are executed as\nrun to completion pods to manage the installation flow for different parts of the infrastructure. The\ncontrollers are implemented using Quarkus. For more information on the controllers, the Entando custom\nresources, and configuring your Entando deployment see also:\n Custom Resources . \n GitHub: \n \n https://github.com/entando-k8s/entando-k8s-composite-app-controller/ \n https://github.com/entando-k8s/entando-k8s-plugin-controller/ \n https://github.com/entando-k8s/entando-k8s-cluster-infrastructure-controller/ \n https://github.com/entando-k8s/entando-k8s-app-controller/ \n https://github.com/entando-k8s/entando-k8s-app-plugin-link-controller/ \n \n DockerHub: \n \n https://hub.docker.com/repository/docker/entando/entando-k8s-composite-app-controller/ \n https://hub.docker.com/repository/docker/entando/entando-k8s-plugin-controller/ \n https://hub.docker.com/repository/docker/entando/entando-k8s-cluster-infrastructure-controller/ \n https://hub.docker.com/repository/docker/entando/entando-k8s-app-controller/ \n https://hub.docker.com/repository/docker/entando/entando-k8s-app-plugin-link-controller/ \n Customization \n It is unlikely that the controllers will be customized as part of an Entando implementation. \n"},{title:"Aps Core Tag Library",frontmatter:{},regularPath:"/v6.2/docs/reference/freemarker-tags/freemarker-core-tags.html",relativePath:"v6.2/docs/reference/freemarker-tags/freemarker-core-tags.md",key:"v-71f160b3",path:"/v6.2/docs/reference/freemarker-tags/freemarker-core-tags.html",headers:[{level:2,title:"Tag action",slug:"tag-action"},{level:3,title:"Description",slug:"description"},{level:3,title:"Example",slug:"example"},{level:3,title:"Attributes",slug:"attributes"},{level:3,title:"Tag class",slug:"tag-class"},{level:2,title:"Tag categories",slug:"tag-categories"},{level:3,title:"Description",slug:"description-2"},{level:3,title:"Example",slug:"example-2"},{level:3,title:"Attributes",slug:"attributes-2"},{level:3,title:"Tag class",slug:"tag-class-2"},{level:2,title:"Tag checkHeadInfoOuputter",slug:"tag-checkheadinfoouputter"},{level:3,title:"Description",slug:"description-3"},{level:3,title:"Attributes",slug:"attributes-3"},{level:3,title:"Tag class",slug:"tag-class-3"},{level:2,title:"Tag cssURL",slug:"tag-cssurl"},{level:3,title:"Description",slug:"description-4"},{level:3,title:"Example",slug:"example-3"},{level:3,title:"Attributes",slug:"attributes-4"},{level:3,title:"Tag class",slug:"tag-class-4"},{level:2,title:"Tag currentPage",slug:"tag-currentpage"},{level:3,title:"Description",slug:"description-5"},{level:3,title:"Example",slug:"example-4"},{level:3,title:"Attributes",slug:"attributes-5"},{level:3,title:"Tag class",slug:"tag-class-5"},{level:2,title:"Tag currentWidget",slug:"tag-currentwidget"},{level:3,title:"Description",slug:"description-6"},{level:3,title:"Example",slug:"example-5"},{level:3,title:"Attributes",slug:"attributes-6"},{level:3,title:"Tag class",slug:"tag-class-6"},{level:2,title:"Tag fragment",slug:"tag-fragment"},{level:3,title:"Description",slug:"description-7"},{level:3,title:"Attributes",slug:"attributes-7"},{level:3,title:"Tag class",slug:"tag-class-7"},{level:2,title:"Tag freemarkerTemplateParameter",slug:"tag-freemarkertemplateparameter"},{level:3,title:"Description",slug:"description-8"},{level:3,title:"Attributes",slug:"attributes-8"},{level:3,title:"Tag class",slug:"tag-class-8"},{level:2,title:"Tag headInfo",slug:"tag-headinfo"},{level:3,title:"Description",slug:"description-9"},{level:3,title:"Example",slug:"example-6"},{level:3,title:"Attributes",slug:"attributes-9"},{level:3,title:"Tag class",slug:"tag-class-9"},{level:2,title:"Tag i18n",slug:"tag-i18n"},{level:3,title:"Description",slug:"description-10"},{level:3,title:"Example",slug:"example-7"},{level:3,title:"Attributes",slug:"attributes-10"},{level:3,title:"Tag class",slug:"tag-class-10"},{level:2,title:"Tag ifauthorized",slug:"tag-ifauthorized"},{level:3,title:"Description",slug:"description-11"},{level:3,title:"Example",slug:"example-8"},{level:3,title:"Attributes",slug:"attributes-11"},{level:3,title:"Tag class",slug:"tag-class-11"},{level:2,title:"Tag imgURL",slug:"tag-imgurl"},{level:3,title:"Description",slug:"description-12"},{level:3,title:"Example",slug:"example-9"},{level:3,title:"Attributes",slug:"attributes-12"},{level:3,title:"Tag class",slug:"tag-class-12"},{level:2,title:"Tag info",slug:"tag-info"},{level:3,title:"Description",slug:"description-13"},{level:3,title:"Example",slug:"example-10"},{level:3,title:"Attributes",slug:"attributes-13"},{level:3,title:"Tag class",slug:"tag-class-13"},{level:2,title:"Tag internalServlet",slug:"tag-internalservlet"},{level:3,title:"Description",slug:"description-14"},{level:3,title:"Example",slug:"example-11"},{level:3,title:"Attributes",slug:"attributes-14"},{level:3,title:"Tag class",slug:"tag-class-14"},{level:2,title:"Tag nav",slug:"tag-nav"},{level:3,title:"Description",slug:"description-15"},{level:3,title:"Example",slug:"example-12"},{level:3,title:"Attributes",slug:"attributes-15"},{level:3,title:"Tag class",slug:"tag-class-15"},{level:2,title:"Tag outputHeadInfo",slug:"tag-outputheadinfo"},{level:3,title:"Description",slug:"description-16"},{level:3,title:"Attributes",slug:"attributes-16"},{level:3,title:"Tag class",slug:"tag-class-16"},{level:2,title:"Tag pageInfo",slug:"tag-pageinfo"},{level:3,title:"Description",slug:"description-17"},{level:3,title:"Attributes",slug:"attributes-17"},{level:3,title:"Tag class",slug:"tag-class-17"},{level:2,title:"Tag pager",slug:"tag-pager"},{level:3,title:"Description",slug:"description-18"},{level:3,title:"Example",slug:"example-13"},{level:3,title:"Attributes",slug:"attributes-18"},{level:3,title:"Tag class",slug:"tag-class-18"},{level:2,title:"Tag parameter",slug:"tag-parameter"},{level:2,title:"Tag pager",slug:"tag-pager-2"},{level:3,title:"Description",slug:"description-19"},{level:3,title:"Example",slug:"example-14"},{level:3,title:"Attributes",slug:"attributes-19"},{level:3,title:"Tag class",slug:"tag-class-19"},{level:2,title:"Tag printHeadInfo",slug:"tag-printheadinfo"},{level:3,title:"Description",slug:"description-20"},{level:3,title:"Attributes",slug:"attributes-20"},{level:3,title:"Tag class",slug:"tag-class-20"},{level:2,title:"Tag resourceURL",slug:"tag-resourceurl"},{level:3,title:"Description",slug:"description-21"},{level:3,title:"Example",slug:"example-15"},{level:3,title:"Attributes",slug:"attributes-21"},{level:3,title:"Tag class",slug:"tag-class-21"},{level:2,title:"Tag show",slug:"tag-show"},{level:3,title:"Description",slug:"description-22"},{level:3,title:"Example",slug:"example-16"},{level:3,title:"Attributes",slug:"attributes-22"},{level:3,title:"Tag class",slug:"tag-class-22"},{level:2,title:"Tag url",slug:"tag-url"},{level:3,title:"Description",slug:"description-23"},{level:3,title:"Example",slug:"example-17"},{level:3,title:"Attributes",slug:"attributes-23"},{level:3,title:"Tag class",slug:"tag-class-23"},{level:2,title:"Tag pageWithWidget",slug:"tag-pagewithwidget"},{level:3,title:"Description",slug:"description-24"},{level:3,title:"Example",slug:"example-18"},{level:3,title:"Attributes",slug:"attributes-24"},{level:3,title:"Tag class",slug:"tag-class-24"},{level:2,title:"Tag currentUserProfileAttribute",slug:"tag-currentuserprofileattribute"},{level:3,title:"Description",slug:"description-25"},{level:3,title:"Attributes",slug:"attributes-25"},{level:3,title:"Tag class",slug:"tag-class-25"},{level:2,title:"Tag userProfileAttribute",slug:"tag-userprofileattribute"},{level:3,title:"Description",slug:"description-26"},{level:3,title:"Attributes",slug:"attributes-26"},{level:3,title:"Tag class",slug:"tag-class-26"}],lastUpdated:"11/3/2020, 4:20:16 AM",lastUpdatedTimestamp:1604395216e3,content:' Aps Core Tag Library \n \n \n Version: 2.3 \n \n \n Short Name: wp \n \n \n URI: /aps-core \n Tag  action \n Description \n Build the URL to call a jsp or a functionality of a servlet defined\nwithin the system. This tag can use the ParameterTag sub-tag to add url\nparameters. \n Example \n (<@wp.action path="/do/my.action" var="myaction" />)  or\n (<@wp.action path="/JSP/my.jsp" var="my.jsp"/>) \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n path \n no \n The relative path of jsp or servlet to invoke, relative to the context of web-application \n \n \n var \n no \n Name of the page-scoped variable where to place the URL. \n Tag class \n com.agiletec.aps.tags.ActionURLTag \n Tag  categories \n Description \n Return the list of the system categories on SelectItem objects. \n Example \n <@wp.categories var="systemCategories" titleStyle="prettyFull" root="$\\{userFilterOptionVar.userFilterCategoryCode}" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n titleStyle \n no \n The style of the single select item. Currently it can be \'default\' (single title node), \'full\' (title with all parents) or \'prettyFull\' (title with all parents in form of \'..\'). The default when none is given is \'default\'. \n \n \n fullTitleSeparator \n no \n The separator beetwen the titles when \'titleStyle\' is \'full\' or \'prettyFull\'. \n \n \n var \n no \n Name of the page-scoped variable where to place the list of categories. \n \n \n root \n no \n The root of the categories to show. The default is the system root categories \n Tag class \n com.agiletec.aps.tags.CategoriesTag \n Tag  checkHeadInfoOuputter \n Description \n This sub-tag verifies the availability of the information to display.\nThis sub-tag can be used only in a page template, in conjunction with\n\'outputHeadInfo\'. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n type \n yes \n Specifies the type of information to analyse. \n Tag class \n com.agiletec.aps.tags.CheckHeadInfoOutputterTag \n Tag  cssURL \n Description \n Extension of the ResourceURL tag. It returns the URL of the css files. \n Example \n <@wp.cssURL />href="<@wp.cssURL />myportal.css" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n Tag class \n com.agiletec.aps.tags.CssURLTag \n Tag  currentPage \n Description \n Returns the requested information held by the current page bean. \n Example \n <@wp.currentPage param="code" var="currentViewCode" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n param \n false \n The wanted parameter: actually can be either "title", "owner" (group), "code", "hasChild" or "childOf" (with attribute "targetPage"). The default when none is given is "title". \n \n \n langCode \n no \n Code of the language to use for the page information being returned. \n \n \n var \n no \n Name of the page context variable where the information are placed. Please note that the in this case the special characters will not be escaped. \n \n \n targetPage \n no \n Target page when "param" is "childOf". \n \n \n escapeXml \n no \n Decides whether to escape the special characters in the information retrieved or not. Value admitted (true, false), the default is true. \n Tag class \n com.agiletec.aps.tags.CurrentPageTag \n Tag  currentWidget \n Description \n Returns information about the widget where the tag resides. To obtain\ninformation about a widget placed in a frame other than the current, use\nthe "frame" attribute. \n Example \n <@wp.currentWidget param="config" configParam="name" var="configName" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n param \n yes \n The requested parameter. It can assume one of the following values: - "code" returns the code of the associated widget type (empty if none associated) - "title" returns the name of the associated widget type (empty if none associated) - "config" returns the value of the configuration parameter declared in the "configParam" attribute. The default is "title". \n \n \n configParam \n no \n Name of the configuration parameter request. This attribute is mandatory when the attribute "param" is set to "config". \n \n \n var \n no \n Name of the page context variable where the requested information is pushed. In this case the special characters will not be escaped. \n \n \n frame \n false \n Id of the frame hosting the widget with the desired information. \n \n \n escapeXml \n no \n Toggles the escape of the special characters. Admitted value are (true, false), the default is "true". \n Tag class \n com.agiletec.aps.tags.CurrentWidgetTag \n Tag  fragment \n Description \n Print a gui fragment by the given code. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n code \n true \n The code of the fragment to return. \n \n \n var \n false \n Name of the page context variable where the requested information is pushed. In this case the special characters will not be escaped. \n \n \n escapeXml \n false \n Toggles the escape of the special characters. Admitted value are (true, false), the default is "true". \n Tag class \n org.entando.entando.aps.tags.GuiFragmentTag \n Tag  freemarkerTemplateParameter \n Description \n Add a parameter into the Freemarker’s TemplateModel Map. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n var \n true \n Name of the variable where the requested information is pushed. \n \n \n valueName \n true \n Name of the variable of the page context where extract the information. \n \n \n removeOnEndTag \n false \n Whether to remove the parameter on end of Tag. Possible entries (true, false). Default value: false. \n Tag class \n org.entando.entando.aps.tags.FreemarkerTemplateParameterTag \n Tag  headInfo \n Description \n Declares the information to insert in the header of the HTML page. The\ninformation can be passed as an attribute or, in an indirect manner,\nthrough a variable of the page context. It is mandatory to specify the\ntype of the information. \n Example \n <@wp.headInfo type="JS" info="entando-misc-bootstrap/bootstrap.min.js" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n type \n yes \n Declaration of the information type. Currently only "CSS" is currently supported. \n \n \n info \n no \n Information to declare. This is an alternative of the "var" attribute. \n \n \n var \n no \n Name of the variable holding the information to declare. This attribute is the alternative of the "info" one. This variable can be used for those types of information that cannot be held by an attribute. \n Tag class \n com.agiletec.aps.tags.HeadInfoTag \n Tag  i18n \n Description \n Return the string associated to the given key in the specified language.\nThis string is either returned (and rendered) or can be optionally\nplaced in a page context variable. This tag can use the ParameterTag\nsub-tag to add label parameters. \n Example \n <@wp.i18n key="COPYRIGHT" escapeXml="false" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n key \n yes \n Key of the label to return. \n \n \n lang \n no \n Code of the language requested for the lable. \n \n \n var \n no \n Name of the variable (page scope) where to store the wanted information. In this case the special characters will not be escaped. \n \n \n escapeXml \n no \n Toggles the escape of the special characters of the returned label. Admitted values (true, false), the default is true. \n Tag class \n com.agiletec.aps.tags.I18nTag \n Tag  ifauthorized \n Description \n Toggles the visibility of the elements contained in its body, depending\non user permissions. \n Example \n <@wp.ifauthorized permission="enterBackend"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n permission \n no \n The code of the permission required. \n \n \n groupName \n no \n The name of the group membership required. \n \n \n var \n no \n The name of the (boolean) page context parameter where the result of the authorization check is placed. \n Tag class \n com.agiletec.aps.tags.CheckPermissionTag \n Tag  imgURL \n Description \n Extension of the ResourceURL tag. It returns the URL of the images to\ndisplay as static content outside the cms. \n Example \n <@wp.imgURL />entando-logo.png" alt="Entando - Access. Build. Connect." /> \n Attributes \n Tag class \n com.agiletec.aps.tags.ImgURLTag \n Tag  info \n Description \n Returns the information of the desired system parameter. \n Example \n <@wp.info key="systemParam" paramName="applicationBaseURL" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n key \n yes \n Key of the desired system parameter, admitted values are: "startLang" returns the code of start language of web browsing "defaultLang" returns the code of default language "currentLang" returns the code of current language "langs" returns the list of the languages defined in the system "systemParam" returns the value of the system param specified in the "paramName" attribute. \n \n \n var \n no \n Name of the variable where to store the retrieved information (page scope). In this case the special characters will not be escaped. \n \n \n paramName \n no \n Name of the wanted system parameter; it is mandatory if the "key" attribute is "systemParam", otherwise it is ignored. \n \n \n escapeXml \n no \n Toggles the escape of the special characters in the information returned. Admitted values are (true,false), the former being the default value. \n Tag class \n com.agiletec.aps.tags.InfoTag \n Tag  internalServlet \n Description \n Tag for the "Internal Servlet" functionality. Publishes a function\nserved by an internal Servlet; the servlet is invoked from a path\nspecified in the attribute "actionPath" or by the widget parameter\nsharing the same name. This tag can be used only in a widgets. \n Example \n <@wp.internalServlet actionPath="/ExtStr2/do/jpuserreg/UserReg/initRegistration" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n actionPath \n false \n The init action path. \n \n \n staticAction \n false \n Whether to execute only the given action path. Possible entries (true, false). Default value: false. \n Tag class \n com.agiletec.aps.tags.InternalServletTag \n Tag  nav \n Description \n Generates through successive iterations the so called "navigation" list.\nFor every target/page being iterated (inserted in the page context) are\nmade available the page code, the title (in the current language) and\nthe link. Is it also possible to check whether the target page is empty\n-that is, with no configured positions- or not. \n Example \n <@wp.nav var="page"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n spec \n no \n Declares the set of the pages to generate. \n \n \n var \n yes \n Name of the page context variable where the data of target being iterated are made available. \n Tag class \n com.agiletec.aps.tags.NavigatorTag \n Tag  outputHeadInfo \n Description \n Iterates over various information in HTML header displaying them; this\ntag works in conjunction with other specific sub-tags. Please note that\nthe body can contain only a sub-tag, or information, at once. This tag\nmust be used only in a page template. E.g (<@wp.outputHeadInfo\ntype="CSS">) \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n type \n yes \n Specifies the type of information to return, in accordance with the sub-tag to use. \n Tag class \n com.agiletec.aps.tags.HeadInfoOutputterTag \n Tag  pageInfo \n Description \n Returns the information of the specified page. This tag can use the\nsub-tag "ParameterTag" to add url parameters if the info attribute is\nset to \'url\'. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n pageCode \n true \n The code of the page. \n \n \n info \n false \n Code of required page parameter. Possible entries: "code" (default value) , "title", "owner" (group), "url", "hasChild" or "childOf" (with attribute "targetPage"). \n \n \n langCode \n false \n Code of the language to use for the returned information. \n \n \n var \n false \n Name used to reference the value pushed into the pageContext. In this case, the system will not escape the special characters in the value entered in pageContext. \n \n \n targetPage \n no \n Target page when "param" is "childOf". \n \n \n escapeXml \n false \n Whether to escape HTML. Possible entries (true, false). Default value: true. \n Tag class \n com.agiletec.aps.tags.PageInfoTag \n Tag  pager \n Description \n List pager. \n Example \n <@wp.pager listName="result" objectName="groupContent" max="10" pagerIdFromFrame="true" advanced="true" offset="5"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n max \n no \n The maximum value for each object group. \n \n \n listName \n yes \n Name of the list as found in the request. \n \n \n objectName \n yes \n Name of the object currently iterated. The following methods are exposed:  getMax, getPrevItem, getNextItem, getCurrItem, getSize, getBegin, getEnd, getMaxItem, getPagerId. \n \n \n pagerId \n no \n Sets the ID of the pager itself, it has to be used when two or more pagers exist in the same page. This attributes overrides "pagerIdFromFrame". \n \n \n pagerIdFromFrame \n no \n Sets the ID of the pager (mandatory when two or more pagers share the same page) based upon the frame where the tag is placed. Admitted values are (true, false), the latter being the default. Please note that the "pagerId" attribute takes precedence over this one. \n \n \n advanced \n no \n Toggles the pager in advanced mode. Admitted values are (true, false). the advanced mode of the tag is used when the list to iterate over is huge. \n \n \n offset \n no \n This attribute is considered only when the pager is in advanced mode. This is the numeric value of the single step increment (or decrement) when iterating over the list \n Tag class \n com.agiletec.aps.tags.PagerTag \n Tag  parameter \n Tag  pager \n Description \n This tag can be used to parameterise other tags. The parameter value can\nbe added through the \'value\' attribute or the body tag. When you declare\nthe param tag, the value can be defined in either a value attribute or\nas text between the start and the ending of the tag. \n Example \n <@wp.parameter name="resourceName"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n name \n true \n The name of the parameter. \n \n \n value \n false \n The value of the parameter. \n Tag class \n com.agiletec.aps.tags.ParameterTag \n Tag  printHeadInfo \n Description \n Returns the information to display. This sub-tag must be used only in a\npage template, in conjunction with \'outputHeadInfo\'. \n Attributes \n Tag class \n com.agiletec.aps.tags.HeadInfoPrinterTag \n Tag  resourceURL \n Description \n Returns URL of the resources. \n Example \n <@wp.resourceURL />static/js/entando-misc-html5-essentials/html5shiv.js"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n root \n no \n Declares the resource root. If not otherwise specified, the value of SystemConstants.PAR_RESOURCES_ROOT_URL is used. \n \n \n folder \n no \n Declares a specific directory for the desired resources. Unless specified, the value "" (empty string) is used in the generation of the URL. \n Tag class \n com.agiletec.aps.tags.ResourceURLTag \n Tag  show \n Description \n Defines the position of inclusion of a widget. This tag can be used only\nin a page template. \n Example \n <@wp.show frame="0" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n frame \n yes \n The positional number of the frame, starting from 0. \n Tag class \n com.agiletec.aps.tags.WidgetTag \n Tag  url \n Description \n Generates the complete URL of a portal page. The URL returned is either\nreturned (and rendered) or placed in the given variable. To insert\nparameters in the query string the sub-tag "ParameterTag" is provided. \n Example \n <@wp.url paramRepeat="true" > \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n page \n no \n Code of the destination page. The default is the current page. \n \n \n lang \n no \n Code of the language to use in the destination page. \n \n \n var \n no \n Name of the page-scoped variable where to place the URL. \n \n \n paramRepeat \n no \n Repeats in the URL all the parameters of the actual request. \n \n \n excludeParameters \n no \n Sets the list of parameter names (comma separated) to exclude from repeating. By default, this attribute excludes only the password parameter of the login form. Used only when paramRepeat="true". \n Tag class \n com.agiletec.aps.tags.URLTag \n Tag  pageWithWidget \n Description \n Search and return the page (or the list of pages) with the given widget\ntype. When "filterParamName" and "filterParamValue" attributes are\npresent, the returned list will be filtered by a specific widget\nconfiguration. \n Example \n <@wp.pageWithWidget widgetTypeCode="userprofile_editCurrentUser" var="userprofileEditingPageVar" listResult="false" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n var \n true \n Attribute_description: \n \n \n widgetTypeCode \n true \n The code of the widget to search \n \n \n filterParamName \n false \n Optional widget config param name \n \n \n filterParamValue \n false \n Optional widget config param value \n \n \n listResult \n false \n Optional, dafault false. When true the result is a list of pages, when false the returned page is the first occurence \n Tag class \n com.agiletec.aps.tags.PageWithWidgetTag \n Tag  currentUserProfileAttribute \n Description \n Current User Profile tag. Return a attribute value of the current user\nprofile. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n attributeName \n false \n the name of the attribute from which extract the value. \n \n \n attributeRoleName \n false \n the name of the attribute role from which extract the value. \n \n \n var \n false \n Name used to reference the value pushed into the pageContext. \n \n \n escapeXml \n false \n Decides whether to escape the special characters in the information retrieved or not. Value admitted (true, false), the default is true. \n Tag class \n org.entando.entando.aps.tags.CurrentUserProfileAttributeTag \n Tag  userProfileAttribute \n Description \n User Profile tag. Return a attribute value from the profile givea an\nusername. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n username \n true \n the username \n \n \n attributeName \n false \n the name of the attribute from which extract the value. \n \n \n attributeRoleName \n false \n the name of the attribute role from which extract the value. \n \n \n var \n false \n Name used to reference the value pushed into the pageContext. \n \n \n escapeXml \n false \n Decides whether to escape the special characters in the information retrieved or not. Value admitted (true, false), the default is true. \n Tag class \n org.entando.entando.aps.tags.UserProfileAttributeTag \n'},{title:"jACMS Aps Core Tag Library",frontmatter:{},regularPath:"/v6.2/docs/reference/freemarker-tags/freemarker-JACMS-tags.html",relativePath:"v6.2/docs/reference/freemarker-tags/freemarker-JACMS-tags.md",key:"v-a7953bc2",path:"/v6.2/docs/reference/freemarker-tags/freemarker-JACMS-tags.html",headers:[{level:2,title:"Tag content",slug:"tag-content"},{level:3,title:"Tag Class com.agiletec.plugins.jacms.aps.tags.ContentTag",slug:"tag-class-com-agiletec-plugins-jacms-aps-tags-contenttag"},{level:3,title:"Description",slug:"description"},{level:3,title:"Attributes",slug:"attributes"},{level:2,title:"Tag contentInfo",slug:"tag-contentinfo"},{level:3,title:"Tag Class com.agiletec.plugins.jacms.aps.tags.ContentInfoTag",slug:"tag-class-com-agiletec-plugins-jacms-aps-tags-contentinfotag"},{level:3,title:"Description",slug:"description-2"},{level:3,title:"Attributes",slug:"attributes-2"},{level:2,title:"Tag contentList",slug:"tag-contentlist"},{level:3,title:"Tag Class com.agiletec.plugins.jacms.aps.tags.ContentListTag",slug:"tag-class-com-agiletec-plugins-jacms-aps-tags-contentlisttag"},{level:3,title:"Description",slug:"description-3"},{level:3,title:"Attributes",slug:"attributes-3"},{level:2,title:"Tag contentListFilter",slug:"tag-contentlistfilter"},{level:3,title:"Tag Class Tag class: com.agiletec.plugins.jacms.aps.tags.ContentListFilterTag",slug:"tag-class-tag-class-com-agiletec-plugins-jacms-aps-tags-contentlistfiltertag"},{level:3,title:"Description",slug:"description-4"},{level:3,title:"Attributes",slug:"attributes-4"},{level:2,title:"Tag contentListUserFilterOption",slug:"tag-contentlistuserfilteroption"},{level:3,title:"Tag Class Tag class: com.agiletec.plugins.jacms.aps.tags.ContentListUserFilterOptionTag=",slug:"tag-class-tag-class-com-agiletec-plugins-jacms-aps-tags-contentlistuserfilteroptiontag"},{level:3,title:"Description",slug:"description-5"},{level:3,title:"Attributes",slug:"attributes-5"},{level:2,title:"Tag searcher",slug:"tag-searcher"},{level:3,title:"Tag Class com.agiletec.plugins.jacms.aps.tags.SearcherTag",slug:"tag-class-com-agiletec-plugins-jacms-aps-tags-searchertag"},{level:3,title:"Description",slug:"description-6"},{level:3,title:"Attributes",slug:"attributes-6"},{level:2,title:"Tag rowContentList",slug:"tag-rowcontentlist"},{level:3,title:"Tag Class Tag class: com.agiletec.plugins.jacms.aps.tags.RowContentListTag",slug:"tag-class-tag-class-com-agiletec-plugins-jacms-aps-tags-rowcontentlisttag"},{level:3,title:"Description",slug:"description-7"},{level:3,title:"Attributes",slug:"attributes-7"}],lastUpdated:"11/3/2020, 4:20:16 AM",lastUpdatedTimestamp:1604395216e3,content:' jACMS Aps Core Tag Library \n \n \n Version: 2.3 \n \n \n Short Name: jacmsaps \n \n \n URI: /jacms-aps-core \n Tag  content \n Tag Class  com.agiletec.plugins.jacms.aps.tags.ContentTag \n Description \n Displays the content given its ID. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n contentId \n false \n ID of the content to display. It can accept "expression language". \n \n \n modelId \n false \n Id of the model to use to display the content. The model ID can be either specified explicitly (the model must match the content to serve) or the type name ("list" or "default"); in the latter case the model specified in the configuration will be used. The model must adhere to the content being returned. "Expression language" is accepted. \n \n publishExtraTitle \n false \n Toggles the insertion of the values of the titles in the Request Context. The title values are extracted from the attribute marked with the role "jacms:title". Admitted values are (true, false), default \'false\'. \n \n \n var \n false \n Inserts the rendered content in a variable of the page context with the name provided. \n \n \n attributeValuesByRoleVar \n false \n Inserts the map of the attribute values indexed by the attribute role, in a variable of the page context with the name provided. \n Tag  contentInfo \n Tag Class  com.agiletec.plugins.jacms.aps.tags.ContentInfoTag \n Description \n Return information of a specified content. The content can will be extracted by id from widget parameters or from request parameter. The tag extract any specific parameter (by "param" attribute) or entire ContentAuthorizationInfo object (setting "var" attribute and anything on "param" attribute). \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n contentId \n false \n ID of the content \n \n \n param \n false \n Admitted values for "param" attribute are: \'contentId\' (returns the code of content id), \'mainGroup\' (returns the code of owner group), \'authToEdit\' (returns true if the current user can edit the content, else false). \n \n \n var \n false \n Inserts the required parameter (or the entire authorization info object) in a variable of the page context with the name provided. \n Tag  contentList \n Tag Class  com.agiletec.plugins.jacms.aps.tags.ContentListTag \n Description \n Loads a list of contents IDs by applying the filters (if any). Only the IDs of the contents accessible in the portal can be loaded. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n listName \n true \n Name of the variable in the page context that holds the search result. \n \n \n contentType \n false \n Sets the code of the content types to search. The name must match the configured one, respecting capital letters and spaces. \n \n \n category \n false \n Identifier string of the category of the content to search. \n \n \n cacheable \n false \n Toggles the system caching usage when retrieving the list. Admitted values (true, false), default "true". \n \n \n titleVar \n false \n Inserts the title on a variable of the page context with the name provided. \n \n \n pageLinkVar \n false \n Inserts the code of the page to link on a variable of the page context with the name provided. \n \n \n pageLinkDescriptionVar \n false \n Inserts the description of the page to link on a variable of the page context with the name provided. \n \n \n userFilterOptionsVar \n false \n Name of the variable in the page context that holds the user filter options \n Tag  contentListFilter \n Tag Class  Tag class: com.agiletec.plugins.jacms.aps.tags.ContentListFilterTag \n Description \n "ContentListTag" sub-tag, it creates a filter to restrict the result of the content search. Please note that the filters will be applied in the same order they are declared and the result of the search will reflect this fact. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n key \n true \n String used to filter and sort the contents. This string can be: - the name of a content attribute compatible with the type declared in the "contentListTag" (it requires the "attributeFilter" attribute to be "true") - the ID of one of the content metadata (the "attributeFilter" must be false) The allowed filter key that can be applied to content metadata are: - "created" allows sorting by date of creation of content - "modified" allows sorting by date of modification of content. \n \n \n attributeFilter \n true \n Decides whether the filter must be applied to an attribute or to a content metadata, admitted values are (true, false). The "key" attribute will be checked for validity if the filter is going to be applied to a metadata \n \n \n value \n false \n The filtering value. \n \n \n start \n false \n Filters the contents by attribute type or by the field specified with the key (respect the following matches): Text field -→ start Text Text attribute type -→ start Text Numeric attribute type -→ start Numeric date attribute type -→ start data If the data filter is used: - today, oggi or odierna will select all the contents with a date greater or equal to the system date - using date with the pattern "dd/MM/yyyy" will select all the contents with a date greater or equal to the one inserted. \n \n \n end \n false \n Similar the the "start" attribute but with the opposite behavior. \n \n \n order \n false \n Specifies the sorting behavior of the IDs found: "ASC"ending or "DESC"ending. By default no ordering is performed. \n \n \n likeOption \n false \n Toggles the \'like\' functionality. Admitted values: (true, false). Default: false. The option is available for metadata and on Text Content attributes. \n Tag  contentListUserFilterOption \n Tag Class  Tag class: com.agiletec.plugins.jacms.aps.tags.ContentListUserFilterOptionTag = \n Description \n "ContentListTag" sub-tag, it creates a custom user filter to restrict the result of the content search by front-end user. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n key \n true \n The key of the filter. This string can be: - the name of a content attribute compatible with the type declared in the "contentListTag" (it requires the "attributeFilter" attribute to be "true") - the ID of one of the content metadata (the "attributeFilter" must be false) The allowed filter key that can be applied to content metadata are: - "fulltext" allows filter by full-text search<br /> - "category" allows filter by a system category. \n \n \n attributeFilter \n true \n Decides whether the filter must be applied to an attribute or to a content metadata, admitted values are (true, false). The "key" attribute will be checked for validity if the filter is going to be applied to a metadata. \n Tag  searcher \n Tag Class  com.agiletec.plugins.jacms.aps.tags.SearcherTag \n Description \n Generates a list of content IDs, restricting them to the key word contained in the "search" parameter of the http request. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n listName \n yes \n Name of the variable, stored in the page context, containing the list of content IDs. \n Tag  rowContentList \n Tag Class  Tag class: com.agiletec.plugins.jacms.aps.tags.RowContentListTag \n Description \n Publish a list of contents. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n listName \n true \n Name of the variable in the page context that holds the contents (list of properties of key "contentId" and "modelId"). \n \n \n titleVar \n false \n Inserts the title on a variable of the page context with the name provided. \n \n \n pageLinkVar \n false \n Inserts the code of the page to link on a variable of the page context with the name provided. \n \n \n pageLinkDescriptionVar \n false \n Inserts the description of the page to link on a variable of the page context with the name provided. \n \n \n \n'},{title:"Entando Identity Management -- Keycloak",frontmatter:{},regularPath:"/v6.2/docs/reference/identity-management.html",relativePath:"v6.2/docs/reference/identity-management.md",key:"v-7b34316c",path:"/v6.2/docs/reference/identity-management.html",headers:[{level:2,title:"Logging into your Keycloak Instance",slug:"logging-into-your-keycloak-instance"},{level:2,title:"Authentication",slug:"authentication"},{level:2,title:"Authorization",slug:"authorization"},{level:3,title:"Plugins/Microservices",slug:"plugins-microservices"},{level:3,title:"Core",slug:"core"},{level:2,title:"Social Login",slug:"social-login"},{level:2,title:"One Time Passwords",slug:"one-time-passwords"},{level:2,title:"Themes and Look and Feel",slug:"themes-and-look-and-feel"}],lastUpdated:"12/1/2020, 2:08:17 PM",lastUpdatedTimestamp:1606849697e3,content:' Entando Identity Management -- Keycloak \n Entando Identity Management is powered by Keycloak. The Keycloak instance used for your Entando apps\ncan be  externally installed  or you can use a dedicated instance on a per application basis. The sections below details the architecture and documentation required to customize your Keycloak instance. \n Logging into your Keycloak Instance \n In an Entando deployment Keycloak is protected by a Secret deployed in your Kubernetes instance. To get the default admin credentials you can query Kubernetes for the secret with this command: \n kubectl get secret <project-name>kc-admin-secret -n <namespace> -o go-template="{{println}}Username: {{.data.username | base64decode}}{{println}}Password: {{.data.password | base64decode}}{{println}}{{println}}"\n \n Replace  <project-name>  and  <namespace>  with your values. If you\'re not sure of the secret name you can run \n kubectl get secrets -n <namespace>\n \n And search for the secret that ends in  kc-admin-secret \n Authentication \n In Entando 6 all authentication goes through Keycloak. This ensures that a micro frontend can call a microservice with a token that is available on the client. \n \n By using Keycloak as a central point of authentication the Entando architecture is able to provide a single unified view of identity to the entire architecture. With this architecture Entando becomes more portable and can be integrated into other IDPs without changes to the source. Keycloak acts as an  abstraction to the underlying IDP. \n Authorization \n Plugins/Microservices \n Authorization for the microservices comes from clients and roles in keycloak. The authorizations are stored in the JWT token and are available to the services when invoked. \n Core \n Authorization for the entando-core and WCMS is provided by the Entando user management database. When a user is authenticated to the entando-core  a copy of that user is added to the Entando user management database.  That copy is made in support of the authorization flow noted below. \n As noted above when a user is authenticated to the entando-core via keycloak a copy of that user is added to the entando-core user management database in support of WCMS functionality.  Using the App Builder WCMS roles and groups can be assigned to a user for access to functions in the App Builder or for portal-ui based content access in the runtime application The code that copies the user into the entando-core can be customized to automatically create groups and roles as needed for an application but it is something that must be done on a per implementation basis. \n For more details on the code that copies users and data to the WCMS database see the  entando-keycloak-plugin . The readme in that project includes properties that are available to your Entando app. \n For a deeper look See:  KeycloakAuthorizationManager.java  in the plugin for an example of adding attributes programatically. In particular, the  processNewUser  method. \n Social Login \n Keycloak allows Entando to provide social login as an out of the box capability. See the  Keycloak Social Identity Providers  for documentation on enabling and configuring social logins in your Entando apps. \n One Time Passwords \n Keycloak enables Entando applications to provide login via One Time Passwords (OTP) as well. See the  Keycloak OTP Policies  for more details on configuring and enabling OTP in your application. \n Themes and Look and Feel \n Developers can also customize the look and feel of the login page and all of the identity management system that ships with Entando. The  Keycloak Theme Documentation  provides a lot of details on creating your own theme. \n You can also review the code for the  Entando Theme  as an example Keycloak theme to start from. \n'},{title:"Tutorials Overview",frontmatter:{},regularPath:"/v6.2/tutorials/",relativePath:"v6.2/tutorials/README.md",key:"v-25510810",path:"/v6.2/tutorials/",headers:[{level:2,title:"How to Use This Guide",slug:"how-to-use-this-guide"},{level:2,title:"Frontend Developers",slug:"frontend-developers"},{level:2,title:"Backend Developers",slug:"backend-developers"},{level:2,title:"DevOps",slug:"devops"}],lastUpdated:"9/9/2020, 11:58:42 AM",lastUpdatedTimestamp:1599667122e3,content:" Tutorials Overview \n Entando simplifies the development of modern apps: \n \n Built using modern JavaScript frameworks \n Backed by microservices deployed in containers, and \n Orchestrated by Kubernetes for fully automated DevOps lifecycles \n \n \n Entando supports full stack micro frontend and microservice architectures for codebases that are easier to undestand, maintain, and debug across large, distributed teams, and comes with a private component repository that makes it easy for teams to share and reuse components. \n How to Use This Guide \n Use the categories on the left to find step-by-step tutorials for common tasks. Or check out our learning paths for a more structured approach. \n Frontend Developers \n \n \n \n Basic \n Intermediate \n Advanced \n \n \n \n \n Build a Basic Widget \n Add Configuration to a Widget \n Generate Micro Frontends and Microservices Based on a Database Entity \n \n \n Create a React Micro Frontend \n Enable Communication between MFEs \n \n \n \n Create an Angular Micro Frontend \n \n \n \n \n Create and Manage Content \n Backend Developers \n \n \n \n Basic \n Intermediate \n Advanced \n \n \n \n \n Generate Micro Frontends and Microservices Based on a Database Entity \n Build and Deploy an Entando Bundle \n Extend the Entando App Builder \n \n \n Run Micro Frontends and Microservices in your local env \n Use JDL Studio to Create a Complex Database Entity (Coming Soon) \n DevOps \n \n \n \n Basic \n Intermediate \n Advanced \n \n \n \n \n Set Up Entando on a Local Kubernetes Cluster \n Backing Up and Restoring Your Entando Environment \n Automate Integration Testing With a CI/CD Pipeline   (Coming Soon) \n \n \n Set Up Entando on Amazon Elastic Kubernetes Service (EKS) \n Customize the base Entando Application via a Docker Image \n \n \n \n Set Up Entando on Azure Kubernetes Service (AKS) \n Connect your Entando Application to an External Database \n \n \n \n Set Up Entando on Google Kubernetes Engine (GKE) \n \n \n \n \n Set Up Entando on Red Hat OpenShift \n \n \n \n \n \n"},{title:"Entando 6.2.0 Release Notes",frontmatter:{},regularPath:"/v6.2/docs/releases/",relativePath:"v6.2/docs/releases/README.md",key:"v-58f64e85",path:"/v6.2/docs/releases/",headers:[{level:2,title:"New Features and Major Fixes",slug:"new-features-and-major-fixes"},{level:3,title:"Infrastructure",slug:"infrastructure"},{level:3,title:"Security",slug:"security"},{level:3,title:"Quickstart:",slug:"quickstart"},{level:3,title:"Entando Component Repository (ECR)",slug:"entando-component-repository-ecr"},{level:3,title:"Entando App Builder",slug:"entando-app-builder"},{level:3,title:"Entando Component Generator",slug:"entando-component-generator"},{level:2,title:"Key Open Issues",slug:"key-open-issues"},{level:3,title:"Keycloak RCE",slug:"keycloak-rce"},{level:2,title:"Other Open Issues",slug:"other-open-issues"},{level:2,title:"Previous Releases",slug:"previous-releases"}],lastUpdated:"8/14/2020, 12:14:40 PM",lastUpdatedTimestamp:159742168e4,content:" Entando 6.2.0 Release Notes \n New Features and Major Fixes \n Infrastructure \n \n \n Initial support for deployment on Google GKE, Azure AKS, and Amazon EKS. \n \n \n k3s 1.8.X is now the official choice for developer installations \n \n \n The only fully supported and tested production database is PostgreSQL at the moment \n \n \n Entando now fully relies on Keycloak for identity management. The previous native authentication is no longer supported. \n Security \n \n Fixed CSRF vulnerability discovered in 6.1 \n Quickstart: \n \n \n Support for embedded databases (derby) \n \n \n Now capable to reuse existing external databases created by a previous installation \n \n \n Reduced the memory footprint and improved the startup times \n \n \n Documented  two workarounds  for the IP change issue, e.g. an Entando quickstart installation fails to restart when the IP of the VM changes. A more structured solution will come with the next release. \n Entando Component Repository (ECR) \n \n \n ECR now relies only on GIT repositories for the distribution of bundles \n \n \n Enabled support for bundles with multiple versions \n \n \n Reliability improvements in the installation/uninstallation process, e.g. ability to install/uninstall a specific bundle version \n \n \n Fixes and improvements to the web interface \n \n \n Updated documentation, e.g. common use cases, uninstall flow, CRDs, ingresses and a troubleshooting guide \n \n \n Temporarily disabled support for Pages in bundles (introduced with 6.1) due to problems during uninstallation \n \n \n Added full support for composite CMS attributes \n Entando App Builder \n \n \n Fixed the role-based UX so the UI properly accounts for the current user role. \n \n \n UX improvements and nomenclature updates \n \n \n Reliability improvements and rationalization in several areas, e.g. user management, page design, content management, asset management, error messaging \n \n \n Essential plugins are now part of the base distribution, e.g. SEO, Content Versioning, Content Workflow, Content Scheduler, email. \n \n \n A new React-based UX was implemented for SEO and Content Versioning \n \n \n Included a set of additional default widgets, content types, content templates, and page templates \n Entando Component Generator \n \n \n Improved Microsoft Windows Support (specifically Windows 10 Professional) \n \n \n Support for the Italian Locale \n \n \n Added ability to skip MFE generation \n \n \n Completed support for all possible field types of an entity \n \n \n Added support for entity deletion \n \n \n Added support for missing attribute types \n \n \n Fixed support for complex attribute configurations \n \n \n Several fixes in code generation and build \n Key Open Issues \n Keycloak RCE \n \n The keycloak version used by Entando has a security vulnerability -  https://github.com/keycloak/keycloak/pull/7138 . This issue has been fixed in the latest version of keycloak and will be included in the next version of Entando. This vulnerability can only be exploited if you have a way to obtain a valid token, e.g. via a valid username/password. \n Other Open Issues \n General \n \n Support for older versions of Oracle is not yet complete \n Documentation  and  Tutorials  have been updated to reflect 6.2 but some work remains \n \n Entando App Builder \n \n There are a few visual issues with the redesigned UX/UI \n The user is unable to set their personal profile data from the  My profile  screen \n In  Content - Assets , deleting a duplicate image results in the removal of the original image \n In  Content - Management , some built-in content types will not function correctly if  Content Template = Default . Users will need to explicitly select the Content Template. \n \n Entando Component Generator \n \n Lack of support for generation of microservices with no backend \n Support of old versions of Oracle not complete yet \n Previous Releases \n Please see the  Versions  list in the main navigation menu above to access documentation and release notes for previous versions of Entando. \n"},{title:"Objective",frontmatter:{},regularPath:"/v6.2/tutorials/backend-developers/generate-microservices-and-micro-frontends.html",relativePath:"v6.2/tutorials/backend-developers/generate-microservices-and-micro-frontends.md",key:"v-17045d64",path:"/v6.2/tutorials/backend-developers/generate-microservices-and-micro-frontends.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Installation",slug:"installation"}],lastUpdated:"9/3/2020, 3:34:28 PM",lastUpdatedTimestamp:1599161668e3,content:" Objective \n This tutorial will take you through the steps to install and run the Entando Component Generator powered by JHipster. At the end of the tutorial you can continue your journey by running your components locally or creating an Entando Bundle for the Entando Component Repository. \n Prerequisites \n \n Java 1.8 \n Maven 3.0.5+ \n npm 6+ \n git \n Docker \n node 12+ (or LTS) \n A Docker Hub account or access to a docker registry \n Installation \n \n \n Install JHipster  npm install -g generator-jhipster@6.9.1 \n \n \n Install the Entando Blueprint  npm install -g generator-jhipster-entando@6.2.0 \n \n \n Create an empty directory to hold your project (this will hold your microservice and micro frontends) \n \n \n On a command line  cd  into your directory and create an Entando plugin using the blueprint  jhipster --blueprints entando \n \n \n You'll be presented with a series of prompts to configure your application. The list below provides a set of choices.  You can select the defaults in every step of the tutorial if you want to go fast through this. Just hit Enter at each step \n \n \n \n If you want to go through the choices follow this guide. Except where noted below in bold you can choose what works best for you. Base values for the tutorial are in parentheses.\n \n What is the base name of your application?  (my-app or a name of your choice) \n As you are running in a microservice architecture, on which port would like your server to run? It should be unique to avoid port conflicts.  (8081) \n What is your default Java package name?  (Up to you) \n Which *type* of database would you like to use?  (SQL)\n \n If you pick no database here you'll be building a stateless microservice which is a valid choice but the rest of this tutorial won't work) \n \n \n Which *production* database would you like to use?  (PostgreSQL or MySQL) \n Which *development* database would you like to use?  (H2 with disk-based persistence ) \n Do you want to use the Spring cache abstraction?  (Yes, with the Caffeine implementation) \n  Do you want to use Hibernate 2nd level cache?  (Yes) \n Would you like to use Maven or Gradle for building the backend?   Maven  <-- this is required for Entando and is the default \n Which other technologies would you like to use?  (Don't select any other technologies) \n What name would you give to the bundle to share on an Entando digital-exchange?  Enter a name for your Entando Bundle or accept the default \n Which is the organization name to use when publishing the docker image?   At this point enter the name of the organization where you are going to push your docker image. If you're using your own docker hub account you should enter your username here.  (this can be changed later as needed) \n Would you like to generate micro frontends when creating entities?  (Always) \n Would you like to enable internationalization support  (Up to you) \n Please choose the native language of the application  (Up to you) \n Please choose additional languages to install  (if you picked internationalization) \n Besides JUnit and Jest, which testing frameworks would you like to use?  (Up to you) \n Would you like to install other generators from the JHipster Marketplace?  (No) \n \n \n \n \n Next you will add an Entity to your microservice and create Micro Frontends. In your project run  jhipster entity Conference  where Conference is the name of the entity you want to generate \n \n \n Add Fields \n \n Do you want to add a field to your entity?  (Yes) \n What is the name of your field?  (Enter  name ) \n What is the type of your field?  (Select  String ) \n Do you want to add validation rules to your field?  (No) \n Do you want to add a field to your entity?  (Yes) \n What is the name of your field?  (Enter  location ) \n What is the type of your field?  (Select  String ) \n Do you want to add validation rules to your field?  (No) \n Do you want to add a field to your entity?  (No) \n Do you want to add a relationship to another entity?  (No) \n Do you want to use separate service class for your business logic?  (Up to you) \n Do you want to add filtering?  (Up to you or  Not Needed  if you're unsure) \n Do you want pagination on your entity?  (Yes, with infinite scroll) \n At this point the blueprint will generate controllers, repositories, services, and micro frontends for your entity generation. \n \n \n Overwrite src/main/resources/config/liquibase/master.xml?  When prompted with a conflict at this stage enter  a  for All. This will override existing files with the configuration changes needed for your new entity. \n \n \n \n \n \n At this point you have a choice: \n \n Build your Entando Bundle and deploy your microservice and micro frontends to the Entando Component Repository. \n Go to the Running Locally tutorial to run your micro frontends and microservice in your local dev environment. \n Learn about the key elements included in the Blueprint generated widgets \n \n"},{title:"Build and Deploy an Entando Bundle",frontmatter:{sidebarDepth:2},regularPath:"/v6.2/tutorials/backend-developers/build-and-deploy.html",relativePath:"v6.2/tutorials/backend-developers/build-and-deploy.md",key:"v-866830ac",path:"/v6.2/tutorials/backend-developers/build-and-deploy.html",headers:[{level:2,title:"Build Docker Image for Microservices",slug:"build-docker-image-for-microservices"},{level:2,title:"Build your Bundle and publish to git",slug:"build-your-bundle-and-publish-to-git"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:' Build and Deploy an Entando Bundle \n This page will walk you through building a docker image from your microservice, creating your Entando bundle, checking your bundle into git, and deploying it to the Entando Component Repository. \n If you haven\'t run the generator yet head to the tutorial on running the  Entando Component Generator  first and you\'ll be at the starting point for this one. \n You\'ll need: \n \n Docker \n A running Entando instance (see  Getting Started  for steps if needed) \n A bash shell \n git \n An empty git repository \n Build Docker Image for Microservices \n \n In your microservice project on a command line run  ./mvnw -Pprod clean package jib:dockerBuild \n \n \n Note \n By default the organization used to generate the docker image is  entando , but you can provide a custom value during project initialization, as well as by changing the  pom.xml  file or by providing the  -Djib.to.image=<org>/<name>:<version>  to the  jib:dockerBuild  command. \n \n \n Note \n Output image name is generated using the organization value defined during project initialization. You can override the provided values by altering the  pom.xml  file or by customizing the  -Djib.to.image  parameter used in the  ./mvnw  command \n \n \n Warning \n If you manually override the target image of the docker build, remember to update the plugin metadata in the bundle accordingly in the bundle steps. \n \n \n View your image and tag with  docker images \n \n docker images\nREPOSITORY               TAG                 IMAGE ID            CREATED             SIZE\nmyusername/example-app   0.0.1-SNAPSHOT      4ec7f05b2b27        33 seconds ago      213MB\n \n \n Publish the Docker image to Docker repository (DockerHub or equivalent)  docker push <name-of-the-image:tag> , e.g.  docker push myusername/example-app:0.0.1-SNAPSHOT . You may need to first login via  docker login . \n \n \n Note \n The first time your run this command it will have to push all of the layers. Subsequent runs will be much faster \n \n docker push myusername/example-app:0.0.1-SNAPSHOT\nThe push refers to repository [docker.io/myusername/example-app]\n545361404af4: Pushed\n...\nf1b5933fe4b5: Pushed\n0.0.1-SNAPSHOT: digest: sha256:804b3b91b83094c45020b4748b344f7199e3a0b027f4f6f54109cbb3b8a1f867 size: 2626\n Build your Bundle and publish to git \n \n In your microservice project populate the bundle with the generated micro frontends, run the  ./buildBundle.sh  script or use  npm run populate-bundle \n \n \n Important \nThe bundle population with the micro frontends requires some time to be processed. You should be able to follow the progress of the operation on screen. \n \n \n \n The output of your bundle will be in the top level  bundle  folder in your microservice \n \n \n Create a new git repository and name it  my-bundle  (or a name of your choice). You\'ll need the URL for this repo in the next step \n \n \n Add the /bundle/ folder to the .gitignore file of your microservice project and initialize a new and different git repository for the bundle itself. From the top of your microservices project run these commands. \n \n \n echo bundle >> .gitignore\ncd bundle/\ngit init\ngit add .\ngit commit -m "Init Git repository"\ngit remote add origin https://your/remote/repository.git\ngit push -u origin master\n\n \n \n Important \nThe file descriptor.yaml should be at the top of your repository \n \n \n \n cd  into your bundle folder (you should already be there from the step above) \n \n \n Add the files to git  git add . \n \n \n Commit the files to git  git commit -a -m "Your commit message here" \n \n \n Push the files to git  git push \n \n \n Tag your bundle  git tag -a "v0.0.1" -m "My first tag" \n \n \n Push the tags  git push --tags \n \n \n Install the  entando-bundle-cli  using  npm install -g  @entando/entando-bundle-cli@6.2.0 \n \n \n Generate your bundle \n \n \n     entando-bundle from-git --name=<bundle-name> --namespace=<your namespace> --thumbnail-url=<thumbnail-url> --repository=<your-repository-url> --dry-run > example-bundle.yaml\n \n     - In the command above you must set:\n       - <bundle-name> - A name of your choice\n       - <your-namespace> - The namespace where you are going to install your bundle\n       - <thumbnail-url> - Optionally add a URL to a publicly availble image to use for your bundle in the ECR\n       - <your-repository-url> - The git url of your bundle repository\n \n \n \n Install your bundle in Kubernetes  kubectl create -f example-bundle.yaml \n \n \n Log into the  App Builder \n \n \n Select  Component Repository  in the upper right \n \n \n See your bundle and select install \n \n \n At this point the Entando platform will download and install your docker image and install the micro frontends into the Entando app. You can add those micro frontends to the page \n'},{title:"Running a Blueprint Generated Microservices and Micro Frontend in Local Dev",frontmatter:{},regularPath:"/v6.2/tutorials/backend-developers/run-local.html",relativePath:"v6.2/tutorials/backend-developers/run-local.md",key:"v-6478fde6",path:"/v6.2/tutorials/backend-developers/run-local.html",headers:[{level:2,title:"Running a Blueprint Generated Microservices and Micro Frontend in Local Dev",slug:"running-a-blueprint-generated-microservices-and-micro-frontend-in-local-dev"},{level:2,title:"Start Keycloak using docker-compose",slug:"start-keycloak-using-docker-compose"},{level:3,title:"Notes:",slug:"notes"},{level:2,title:"Start the microservice",slug:"start-the-microservice"},{level:3,title:"Notes:",slug:"notes-2"},{level:2,title:"Start the table widget",slug:"start-the-table-widget"},{level:2,title:"Start the form widget",slug:"start-the-form-widget"},{level:3,title:"Form widget notes:",slug:"form-widget-notes"},{level:2,title:"Start the details widget",slug:"start-the-details-widget"},{level:3,title:"Widget Details notes:",slug:"widget-details-notes"},{level:2,title:"Notes",slug:"notes-3"},{level:3,title:"Change keycloak dev settings",slug:"change-keycloak-dev-settings"},{level:3,title:"The service-url Variable",slug:"the-service-url-variable"},{level:3,title:"User is not authenticated message",slug:"user-is-not-authenticated-message"},{level:2,title:"Open the project in an IDE",slug:"open-the-project-in-an-ide"}],lastUpdated:"9/30/2020, 11:01:17 AM",lastUpdatedTimestamp:1601478077e3,content:' Running a Blueprint Generated Microservices and Micro Frontend in Local Dev \n This tutorial will take you through running an Entando microservice and micro frontend in a local development environment. If you haven\'t generated your Entando Plugin yet start with the  Generate Microservice and Micro Frontend  tutorial and then run these steps. \n All of the steps below assume you are in the directory where you generated your Entando Plugin \n Start Keycloak using docker-compose \n \n \n Startup the Keycloak server: \n docker-compose -f src/main/docker/keycloak.yml up\n Notes: \n if you have to install docker compose you can follow this guide:\n https://docs.docker.com/compose/install/ \n Start the microservice \n \n \n Start the generated Microservice executing the command: \n ./mvnw\n Notes: \n If you want to reset the widget data (as example if you deleted all rows from the table widget) if during the generation of the microservice you selected "H2 with disk-based persistence" you can delete the target folder, restart the microservice and the data will be regenerated. \n Start the table widget \n Now you can start your generated table widget: \n \n \n Go to the table widget folder in your project: \n cd ui/widgets/<your-entity-name>/tableWidget\n \n \n \n Then install and start your widget executing the command: \n npm install && npm start\n \n \n \n When the widget is started a browser window is opened and the widget URL is loaded \n \n \n If you’re not logged in you’re redirected to the login page. \n \n \n Log in using: \n Username: user\nPassword: user\n \n \n \n After the login process you’ll be redirected to the widget page and you can see the table widget with some generated data. \n Start the form widget \n Now you can start your generated form widget: \n \n \n If you are running another widget, stop it clicking  Ctrl+C  in your widget command line window \n \n \n Go to the form widget folder in your project: \n cd ui/widgets/<your-entity-name>/formWidget\n \n \n \n Then install and start your widget executing the command: \n npm install && npm start\n \n \n \n When the widget is started a browser window is opened with and the widget URL is loaded \n \n \n If you’re not logged in you’re redirected to the login page. \n \n \n Log in using: \n Username: user\nPassword: user\n \n \n \n You’ll be redirected to the widget page and you can see the widget form with the ID 1 loaded. \n Form widget notes: \n If you want to load other data you have to change the index.html file in the folder: \n cd ui/widgets/<your-entity-name>/formWidget/public\n \n and change the id attribute in this line: \n <my-entity-form service-url="%REACT_APP_SERVICE_URL%" id="1" />\n Start the details widget \n You can also start your generated details widget: \n \n \n If you are running another widget, stop it clicking  Ctrl+C  in your widget command line window \n \n \n Go to the details widget folder in your project: \n cd ui/widgets/<your-entity-name>/detailsWidget\n \n \n \n Then install and start your widget executing the command: \n npm install && npm start\n \n \n \n When the widget is started a browser window is opened with and the widget URL is loaded \n \n \n If you’re not logged in you’re redirected to the login page. \n \n \n Log in using: \n Username: user\nPassword: user\n \n \n \n You’ll be redirected to the widget page and you can see the widget form with the ID 1 loaded. \n Widget Details notes: \n If you want to load other data you have to change the index.html file in the public folder: \n cd ui/widgets/<your-entity-name>/detailsWidget/public\n \n and change the "id" attribute in this line: \n <my-entity-details service-url="%REACT_APP_SERVICE_URL%" id="1" />\n Notes \n Change keycloak dev settings \n If you want to change your keycloak settings to use another keycloak installation (not the docker compose pre configured one) or if you want to change the service-url of your widget you can change the parameters set in the .env.local file that was generated by the entando-blueprint in the root folder of your react widgets: \n cd ui/widgets/<your-entity-name>/tableWidget\n \n then edit the file  .env.local \n By default this variables are set to: \n REACT_APP_SERVICE_URL=http://localhost:8081/services/<your-application-name>/api\nREACT_APP_KEYCLOAK_URL=http://localhost:9080/auth\nREACT_APP_KEYCLOAK_REALM=jhipster\nREACT_APP_KEYCLOAK_CLIENT_ID=web_app\n The service-url Variable \n The  service-url  variable is the api Microservice API URL. \n User is not authenticated message \n When you run the widgets if you see the message:  User is not authenticated . This means that probably your keycloak application is not running so please check if the docker-compose command is still in execution. \n Open the project in an IDE \n This section just walks through the anatomy of the project and the micro frontends.\nYou can skip this or review later as desired. The top level project is a normal Spring Boot application.\nYou can look through the code and configuration in src/main/java to get a view of the server side.\nThe micro frontends are in the ui folder. Each entity gets an MFE for details, table, and form. \n'},{title:"Hello World  Widget in the App builder",frontmatter:{},regularPath:"/v6.2/tutorials/cms/app-builder/hello-world.html",relativePath:"v6.2/tutorials/cms/app-builder/hello-world.md",key:"v-8bb9a4fe",path:"/v6.2/tutorials/cms/app-builder/hello-world.html",headers:[{level:2,title:"Basic Widget Tutorial",slug:"basic-widget-tutorial"},{level:2,title:"Simple Fragment tutorial",slug:"simple-fragment-tutorial"},{level:2,title:"Freemarker Basics in Entando",slug:"freemarker-basics-in-entando"},{level:2,title:"Useful Links",slug:"useful-links"}],lastUpdated:"9/2/2020, 8:58:49 AM",lastUpdatedTimestamp:1599051529e3,content:' Hello World  Widget in the App builder \n This tutorial will take you through the basics of creating an Entando\nwidget and placing it on a page. This document will also review the\nbasics of fragments which are re-usable pieces of a user interface. \n Basic Widget Tutorial \n For this example you will use the Entando App Builder to build and\nassign your widget on a page. In a production system or a larger\ndevelopment environment you would build and deploy widgets differently,\nhowever this example provides a quick idea of the building blocks. \n \n \n In the App Builder menu, go to:  Components → Micro frontends & Widgets \n \n At bottom of the page, select ADD \n \n \n \n Now create a widget with the sample HTML code.  Enter into the following fields: \n \n Code: MyHelloWorld \n en Title: Hello World \n it Title: Ciao Mondo \n Custom UI field:  <h2>Hello World</h2> \n Select SAVE \n Note: the Custom UI Field is a freemarker template where you can put raw html and include freemarker logic. This allows you to import javascript, css, or any normal HTML. \n \n \n \n Select a new Home Page \n \n Go To:  Pages → Settings \n From the “Home Page” dropdown menu, select “Home / Service” and select SAVE \n \n \n \n Place the widget on the page \n \n Go To:  Pages → Management \n On the row that says "Service", on the far right side, select the Kebab button and select CONFIGURE \n From the right hand column, drag and drop the new widget into an open frame in the page \n From the top of the page, select PREVIEW \n You should see "Hello World" on the page \n \n \n \n Publish the updated page \n \n Go To:  Pages → Management \n Note for the row showing the Services page, the Status is now yellow \n Select the Kebab button and select PUBLISH \n Simple Fragment tutorial \n A fragment is a way to take a common piece of front end code and reuse\nit across multiple pages or widgets. Common elements such as basic html,\njavascript, or freemarker logic can be stored as fragments and\nreferenced via the  <@wp.fragment …  tag. \n Starting from the simple widget tutorial above: \n \n \n Create a new fragment: \n \n In the App Builder Go To:  Components → UX Fragments \n At bottom of page, select ADD, and enter the following fields \n Code: test \n Gui Code:  <h2>Hello World</h2> \n Select SAVE \n \n \n \n Place the fragment in a template: \n \n Go To:  Pages → Page Templates \n On the row for service, select EDIT \n In the  Template  text box, add   <@wp.fragment code="test"/>  on a new line between the   and    tags \n SAVE the page template \n \n \n \n View the page with the new fragment: \n \n Go To:  Pages → Management \n On the row that says "Service", on the far right side, select the Kebab button and select CONFIGURE \n From the top of the page, select PREVIEW \n Note: You will see the fragment  <h2> This is a fragment. </h2>  which includes the HTML tags. By default html embedded via a fragment tag is escaped so you get it rendered exactly as you enter it. You’ll need to un-escape it to get it to render correctly. \n \n \n \n Update the Fragment: \n \n Go To:  Pages → Page Templates \n On the row for service, select EDIT \n Change the tag to:  <@wp.fragment code="test" escapeXml=false/> \n \n \n \n View the page with the updated fragment: \n \n Go To:  Pages → Management \n On the row that says "Service", on the far right side, select the Kebab button and select CONFIGURE \n From the top of the page, select PREVIEW \n See correctly rendered fragment \n Freemarker Basics in Entando \n The freemarker templating language gives you a lot of flexibility and\npower in how pages are rendered. You can include conditional logic,\ninject information from the backend, check for query parameters and\nroute to different pages. \n For example, to check for a query parameter you can use:\n <#if RequestParameters.myParam?exists > … \n To check the current username, use:\n <#if (Session.currentUser.username != "guest") > \n When you need dynamic behavior in your widgets consider using the power\nof freemarker. \n Useful Links \n https://freemarker.apache.org \n'},{title:"Content Templates",frontmatter:{},regularPath:"/v6.2/tutorials/cms/content-templates-tutorial.html",relativePath:"v6.2/tutorials/cms/content-templates-tutorial.md",key:"v-6e1ce060",path:"/v6.2/tutorials/cms/content-templates-tutorial.html",headers:[{level:2,title:"Objective",slug:"objective"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"How to define a Content Templates",slug:"how-to-define-a-content-templates"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:" Content Templates \n Objective \n This document provides a description of Content Templates and how they\nare defined and used. \n Overview \n The purpose of Content Templates is to define how the information,\nenclosed in the Content, displayed to the end user, after the content is\npublished within the pages. Simplifying the concept, Content Templates\nprovide styling and layout for the Contents Types; consequently they\nallow to show the same content in different ways. \n The Content Templates can be managed using the App Builder’s user\ninterface, in which the Web CMS has been integrated. The interface: \n \n \n displays the list of the content templates already existing, for each\nContent Types to which they refer. \n \n \n provides the tools to create a new content template; the template is\nwritten using the Velocity language. \n How to define a Content Templates \n Creating a Content Template is fairly simple. From the App Builder\napplication \n \n \n Select  Content > Templates \n \n \n Click on the  Add content template  to create a new Content\nTemplate. \n \n \n \n \n \n Access the  Add Content Template  page, where you can \n \n \n Edit the  Code . It is the unique identifier of the content template.\nYou can insert up to 10 numbers. It’s mandatory. \n \n \n Edit the  Name . It is the name or description of the content\ntemplate. \n \n \n Choose the  Content Type  in the dropdown list. \n \n \n Edit the  HTML Model  based on Velocity language \n \n \n (Optional) Define the CSS  Style Sheet  to be applied to the  HTML Model \n \n \n Press the Save button \n \n \n \n \n \n"},{title:"Content Creation",frontmatter:{},regularPath:"/v6.2/tutorials/cms/content-tutorial.html",relativePath:"v6.2/tutorials/cms/content-tutorial.md",key:"v-1cd37820",path:"/v6.2/tutorials/cms/content-tutorial.html",headers:[{level:2,title:"Objective",slug:"objective"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"Creating Content",slug:"creating-content"},{level:2,title:"Finding Content",slug:"finding-content"},{level:2,title:"Content Actions",slug:"content-actions"}],lastUpdated:"9/3/2020, 10:15:11 AM",lastUpdatedTimestamp:1599142511e3,content:" Content Creation \n Objective \n This document provides an overview of Content Management and how to create Content that can be displayed in an application. \n Overview \n The App Builder is used to create, edit and position content stored in the web content management system WCMS. \n Creating Content \n To SEE/MANAGE what Content is already defined in the WCMS: \n \n Select  Content - Management . All existing\ncontent is displayed in a table list. \n \n \n To CREATE NEW Content and add it to the list \n \n Select the  Add Content  button. A drop-down list will let you\nchoose which Content Type the content will be based on. \n \n \n You will be asked to provide the following information: \n \n \n Info \n \n \n Content Type . This information is pre-defined, and lists the\ncontent type for the content. \n \n \n Description . The specific Content's name or description. This field\nis mandatory. \n \n \n \n \n Groups \n \n \n Owner Group.  Use the drop-down list to choose the\navailable user group that can manage the content.\nThis field is mandatory and may be predefined. \n \n \n Join Group.  Use the drop-down list to choose the\navailable user group to share the content with and select +. The group\nselected will only be able to share and can not\nadministrate this content. This field is not mandatory. \n \n \n Categories.  Select the category(s) and select + to add a classification to the\ncontent to use for searching and sorting.  This field is not mandatory. \n \n \n Content Attributes.  Define each required attributes field and any optional fields\ndefined by the content types used for this Content. This field is mandatory. \n \n \n \n \n \n SAVE THE NEW CONTENT added by selecting: \n \n \n Save : The content will be saved in a draft version. \n \n \n Save and Continue : The content will be saved and the editable form will be displayed. \n \n \n Save and Approve : The content will be saved, approved and published. \n Finding Content \n You can list specific Content by using the filters: \n \n \n All : All created Content is displayed (Draft, To Approve and\nApproved/Published) \n \n \n Pending Changes : All created Content that was saved by only clicking on the\n Save  or  Save and Continue  button. The content is not\napproved and therefore is not ready to be published. \n \n \n Ready for Approval : All created Content that is in  Ready  status,\nand saved by clicking on the  Save  or  Save and Continue  button.\nThe content is ready for review but has not yet been approved and\ntherefore has not been published. \n \n \n Published : All created Content that has been saved and approved\nby clicking on the  Save and Approve  button. This content has been\npublished. \n \n \n \n In the table list, contents are listed with several parameters: Name,\nCreated by, Last Edited, Type, Created Date, Owner Group, Join Group,\nStatus, Restrictions, Code, Actions. Fields can be added or deleted from view by selecting or unselecting them\nin the Columns drop-down menu. \n Content Actions \n For all Content in the list, you have access to a set of actions\nthrough the  Actions  kebab button, such as: \n \n \n Edit : update the data fields in the content definition \n \n \n Delete : remove the content \n \n \n Clone : replicate the content \n \n \n Publish : make the content visible \n \n \n Unpublish : hide the content \n \n \n \n All Content in the list can be saved to your local file system by clicking the\n Download  button and selecting either CSV or XLS format. \n \n"},{title:"Hello World for a Widget Using the App builder",frontmatter:{},regularPath:"/v6.2/tutorials/cms/custom-html-widgets.html",relativePath:"v6.2/tutorials/cms/custom-html-widgets.md",key:"v-cf987aa0",path:"/v6.2/tutorials/cms/custom-html-widgets.html",headers:[{level:2,title:"Basic Widget Tutorial",slug:"basic-widget-tutorial"},{level:2,title:"Simple Fragment tutorial",slug:"simple-fragment-tutorial"},{level:2,title:"Freemarker Basics in Entando",slug:"freemarker-basics-in-entando"},{level:2,title:"Useful Links",slug:"useful-links"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:' Hello World for a Widget Using the App builder \n This tutorial will take you through the basics of creating an Entando\nwidget and placing it on a page. This document will also review the\nbasics of fragments which are re-usable pieces of a user interface. \n Basic Widget Tutorial \n For this example you will use the Entando App Builder to build and\nassign your widget on a page. In a production system or a larger\ndevelopment environment you would build and deploy widgets differently,\nhowever this example provides a quick idea of the building blocks. \n \n \n In the App Builder menu, at the top, Go To: UX Patterns -→ Widgets \n \n \n Select NEW \n \n \n The Custom UI Field is a freemarker template where you can put raw\nhtml and include freemarker logic, \n \n \n It allows you to import javascript, css, or any normal HTML \n \n \n Example, put <h2>Hello World</h2> into your widget, give it\na name and save it \n \n \n \n \n Go To: Page Designer -→ Page Settings \n \n \n In the Home Page dropdown select Home / Service and select SAVE \n \n \n Now place the widget on the page \n \n \n Go To: Page Designer -→ Page Tree \n \n \n On the row that says "Service", on the far right side, select the\nKebab button and select CONFIGURE \n \n \n Find the widget created in step 5 on the right hand side \n \n \n Drag and drop the widget onto the open frame of the page \n \n \n Select PUBLISH at the bottom of the screen \n \n \n Then select GO TO HOME PAGE in the upper right \n \n \n You should see "Hello World" on the page \n Simple Fragment tutorial \n A fragment is a way to take a common piece of front end code and reuse\nit across multiple pages or widgets. Common elements such as basic html,\njavascript, or freemarker logic can be stored as fragments and\nreferenced via the  <@wp.fragment …​  tag. \n Starting from the simple widget tutorial above: \n \n \n In the app builder Go To: UX Patterns -→ Fragments \n \n \n Enter the code for the fragment as  test \n \n \n In the  Gui Code  enter  <h2>This is a fragment</h2> \n \n \n Next place the fragment on a page \n \n \n Go To: Ux Patterns -→ Page Templates \n \n \n On the row for  service , select EDIT \n \n \n Use the fragment tag to place the fragment on the page\n <@wp.fragment code="test"/> \n \n \n SAVE the Page Template \n \n \n Go To: homepage (assuming you’ve set the service page to the\nhomepage) \n \n \n Note that the fragment is printed including the HTML tags. By\ndefault html embedded via a fragment tag is escaped so you get it\nrendered exactly as you enter it. You’ll need to un-escape it to get\nit to render correctly. \n \n \n Go back to your page template (UX Patterns -→ Page Templates) select\nSERVICE and EDIT \n \n \n Change the tag to:  <@wp.fragment code="test" escapeXml=false/> \n \n \n Go back to the homepage \n \n \n See correctly rendered fragment \n Freemarker Basics in Entando \n The freemarker templating language gives you a lot of flexibility and\npower in how pages are rendered. You can include conditional logic,\ninject information from the backend, check for query parameters and\nroute to different pages. \n For example, to check for a query parameter you can use:\n <#if RequestParameters.myParam?exists > …​ \n To check the current username, use:\n <#if (Session.currentUser.username != "guest") > \n When you need dynamic behavior in your widgets consider using the power\nof freemarker. \n Useful Links \n https://freemarker.apache.org \n'},{title:"Content Types",frontmatter:{},regularPath:"/v6.2/tutorials/cms/content-types-tutorial.html",relativePath:"v6.2/tutorials/cms/content-types-tutorial.md",key:"v-66e5dae0",path:"/v6.2/tutorials/cms/content-types-tutorial.html",headers:[{level:2,title:"Objective",slug:"objective"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"How to create a Content Type",slug:"how-to-create-a-content-type"}],lastUpdated:"8/10/2020, 5:33:01 PM",lastUpdatedTimestamp:1597095181e3,content:" Content Types \n Objective \n This document provides an overview of the Content Types, as well as how\nthey are created and represented. \n Overview \n The Content Type is a construct used to represent or to model a Content.\nIt is characterized by a set of  Attribute Types , each of which\ndefines the value of their properties, called Attributes. A Content is\nan instance or specialization of the Content Type. \n How to create a Content Type \n Creating Contents Types is fairly simple. The Content Types are managed\nthrough the Web CMS, its user interface is made available in the App\nBuilder application. \n \n \n From App Builder, go to  Content > Types \n \n \n Click on the  Add Content Type  button to create a new Content\nType. \n \n \n \n \n \n You be asked to provide \n \n \n Code . The code is the unique identifier of the content type,\nthat must be 3 uppercase letters, (e.g. CNN). It’s mandatory. \n \n \n Name.  The name must be max 50 characters uppercase and\nlowercase letters, including numbers and special characters,\n(e.g. Conference_News). It’s mandatory. \n \n \n \n \n \n \n \n Select the  Save  button, then you’ll see \n \n \n Content Type Information : \n \n \n Code . The value is pre-filled. \n \n \n Name . The name is pre-filled. \n \n \n \n \n Metadata \n \n \n Page for on-the-fly publishing \n \n \n Default content template \n \n \n Default content template for lists \n \n \n \n \n \n \n Default content template  and  Default content template for lists  are used\nrespectively to show the detailed view of the Content and its\nrepresentation as an element in a list. \n \n Attributes \n \n In the Attributes section, select the  Type  from the drop-down list.\nThe list contains all the available attributes types that define which\nproperties/attributes will characterize the Content. \n \n The Add button will start the configuration of the single attribute\ntype. Every attribute type has its own configuration. \n For example, to configure the  Text  Attribute Type, choose Text from\nthe Types drop-down menu and then press the Add button. \n \n \n \n You should specify the following fields \n \n \n Type:  the value is pre-filled. It represents the selected\nattribute type. \n \n \n Code : You should insert the name of the attribute. (You\ncan insert max 10 characters uppercase and lowercase letters,\nnumbers, and special characters _ ). (e.g. title) \n \n \n Name : You should insert the description of the attribute.\n(You can insert max 50 characters uppercase and lowercase letters,\nincluding numbers and special characters). (e.g. Title). \n \n \n You should declare if the attribute is  mandatory ,\n searchable , and  to be used as a filter in the list. \n \n \n The  Roles  section it is possible to assign the  jacms:title\nAttribute Role  to this attribute; in this way other plugins or\nservices will know that within the CNG entity this attribute is a\ntitle, whatever the key is; however, for sake of clarity, the Code\nof the attribute is Title. \n \n \n The remaining fields related to  Sections  and  Validation -\nOGNL  sections are not mandatory and can be left empty. \n \n \n Press the  Continue  button. The Text attribute type requires no\nadditional configuration step. \n \n \n You can add other Attributes Types. \n \n \n Press the  Save  button. The Content type will be saved and displayed\nin the table list \n \n \n"},{title:"Digital Assets",frontmatter:{},regularPath:"/v6.2/tutorials/cms/digital-assets-tutorial.html",relativePath:"v6.2/tutorials/cms/digital-assets-tutorial.md",key:"v-0cb4fbc8",path:"/v6.2/tutorials/cms/digital-assets-tutorial.html",headers:[{level:2,title:"Objective",slug:"objective"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"How to create a Digital Asset",slug:"how-to-create-a-digital-asset"},{level:2,title:"Editing Assets",slug:"editing-assets"},{level:3,title:"Cropping Images",slug:"cropping-images"},{level:2,title:"Embedding an Asset in a Page",slug:"embedding-an-asset-in-a-page"},{level:2,title:"Including an Asset in a Content",slug:"including-an-asset-in-a-content"},{level:2,title:"Configuring Allowed File Extensions for Upload",slug:"configuring-allowed-file-extensions-for-upload"}],lastUpdated:"8/10/2020, 5:33:01 PM",lastUpdatedTimestamp:1597095181e3,content:" Digital Assets \n Objective \n This document provides an overview of the Digital Assets and\nfunctionalities needed to manage images and documents. \n Overview \n The WEB CMS includes capabilities that let you manage contents and\ndigital assets. Digital Assets are images, documents, and other media\nfiles supported in specific format. \n Default Supported Document Formats:  The Entando CMS can be\nconfigured to allow you to load or exclude any type of file extension\nfrom being loaded to your site. For the app builder you should also include the MIME type of the asset you want to allow. The default set of extensions are: \n pdf,xls,doc,ppt,txt,rtf,sxw,sxc,odt,ods,odp,tar,gz,zip,rar,flv,swf,avi,wmv,ogg,mp3,wav,ogm,mov,iso,nrg,docx,docm,xlsx,xlsm,xlsb,pptx,pptm,ppsx,ppsm,sldx,sldm. \n Default Supported Image Formats : jpg, jpeg, png, svg,svg+xml \n How to create a Digital Asset \n To manage the Digital Assets through the Web CMS integrated with App\nBuilder application \n \n From App Builder, go to  Content > Types \n \n Add a new image or a new document file \n \n Press the  Drag and Drop or Browse your computer  button and\nchoose, from your file system, images and documents files that you\nwould like to upload \n \n \n \n From the  Add file  modal window, you must choose one of the\navailable Groups and then the  Upload  button. If categories have\nbeen defined, you can apply them to the asset in this step. \n \n \n \n \n The image file that you just uploaded is displayed in the list; a\nstatistical overview of the number of the uploaded resources (images\nand documents) is provided. The App Builder’s interface allows the\nusers to choose grid and list view; most of the time, users prefer\nto use list view when they are searching with specific requirements,\nwhile they love grid view for exploring. For every resource, image,\nor document, the list shows the following information: \n \n \n Preview \n \n \n Name \n \n \n Type \n \n \n Uploaded By \n \n \n Uploaded At \n \n \n Group \n \n \n Categories \n \n \n Actions \n \n \n \n \n Furthermore, the interface lets you perform all management actions, as: \n \n \n Edit:  update the information data related to every single\nresource (image and document) \n \n \n Duplicate:  copy identically the resource from the original \n \n \n Download:  transfer the resource to your local machine \n \n \n Delete:  remove the resource \n \n \n \n You can list the contents by filtering with: \n \n \n All : All added files are displayed, images and documents both. \n \n \n Images : All added images are displayed \n \n \n Documents : All added documents are displayed. \n Editing Assets \n Once you have a digital asset in place, you have several editing and viewing options. Click the asset's  Actions  button and select  Edit  to update the asset's name/description, categories, and the file represented. \n Cropping Images \n You can crop images newly uploaded via Digital Assets. You can either crop the image dynamically or by using pre-configured crop ratios. \n To set pre-configured crop ratios: \n \n Select  CMS > Content Settings \n Under  Settings Image Crop Dimensions,  click  Add crop dimension . \n Enter a crop ratio, using numeric values separated by a colon. \n Click  Save . \n \n To dynamically crop an image: \n \n Edit the asset by opening  Actions  menu > Edit.\n \n Buttons representing your pre-defined crop ratios are below the image. Clicking any of those buttons changes the selected crop area based on the chosen ratio. \n You can create multiple crops of a single image as part of the upload process. The right side of the screen displays the list of crops created during the current session. \n \n \n \n \n \n Use your mouse or the buttons below the image to move or change the crop area, then click  Save  to crop the selected area. Repeat the process as many times as needed.\n \n Click  Close  to return to the Digital Assets screen. \n Embedding an Asset in a Page \n The uploaded asset can be embedded in a page by using  <@wp.resourceUrl path/to/asset . The path can be found in the CMS Configuration > File Browser page. \n \n Example usage:\n <img src=\"<@wp.resourceUrl cms/images/butterfly_d0_d3.jpg\" \n Including an Asset in a Content \n The asset can be included in a content of a type that has an  Attach  or  Image  attribute. \n \n Create a content type with an image attribute.\n \n Create a content based on the created  type.\n \n Under the  Content Attributes  section at the bottom of the page, click the  Add  button beside the image attribute. It will then open a modal that allows you to select an asset by clicking the  Use  action.\n Configuring Allowed File Extensions for Upload \n The types of files that can be uploaded to an Entando application are controlled by\nconfiguration in the server side of the app builder. If you're using the quickstart this will be the\n entando-de-app . \n There are two properties that control these settings and they are set in  src/main/conf/systemParams.properties  and are a comma delimitted list of values. The property keys are \n \n jacms.imageResource.allowedExtensions= \n jacms.attachResource.allowedExtensions= \n \n If you are configuring the upload for both the App Builder and the legacy Admin Console you should include\nboth the MIME type of the asset and the file extension. The APIs that support resources will check MIME type of the uploaded asset. \n An example configuration for images. \n \n jacms.imageResource.allowedExtensions=jpg,jpeg,png,svg,svg+xml \n \n Where  svg+xml  is the MIME type for an svg image. \n The  systemParams.properties  file is bundled into the WAR and the image for the application so you will need to create and deploy image to reflect changes for these properties in your application. \n"},{title:"List of Attribute Types",frontmatter:{},regularPath:"/v6.2/tutorials/cms/list-of-Content-attributes.html",relativePath:"v6.2/tutorials/cms/list-of-Content-attributes.md",key:"v-737fcee0",path:"/v6.2/tutorials/cms/list-of-Content-attributes.html",headers:[{level:2,title:"Objective",slug:"objective"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"Simple Attribute Types",slug:"simple-attribute-types"},{level:2,title:"Composed attribute types",slug:"composed-attribute-types"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:" List of Attribute Types \n Objective \n This document provides a list and an overview of all available attribute\ntypes. \n Overview \n Attributes can be seen as the smallest elements that compose a Content\nType. In other words, a Content Type is just a collection of different\nattributes. Attributes are responsible for carrying the actual\ninformation inside a Content in Entando and could be of different types.\nIn this chapter, we will review and describe the different attribute\ntypes. \n Firstly, we can distinguish simple attribute types from composite\nattribute types. In the first case, the attribute type carries a single\npiece of information (for example, an image), while the latter is an\naggregation of simple attribute types (for example, a set of images). \n Simple Attribute Types \n Attach \n This represents the information carried by a file, which is attached to\nthe content. \n It consists of an URL corresponding to the desired file present in the\nsystem’s resources, and a text which can either indicate the description\nor the name of the file. \n This attribute type is rendered as a button named “Add”. By pushing that\nbutton, the user is prompted to select a desired file present in the\nsystem’s Digital Assets Attachments list. \n Boolean \n This attribute type represents a boolean value which can either be true\nor false. This attribute type is rendered as two radio buttons labeled\n“Yes” and “No”. \n Checkbox \n This attribute type behaves in the same way as a Boolean does – it is\nactually an alternative to the Boolean attribute type - but it is\nrendered with a checkbox labeled “Yes” or “No”. \n Date \n This attribute type represents a date, tracking time within a content;\nit is often used to filter contents appearing in lists by publication\ndate, etc. \n It is rendered as a datepicker. \n Timestamp \n This attribute type is specialized for the Date attribute, allowing you\nto also specify the hour, minute and second. \n It is rendered as a datepicker for the date, and a select for hours,\nminutes and seconds. \n Enumerator \n The enumerator attribute type represents textual information with a\npredefined set of choices; it is defined by: \n \n \n Elements which are mandatory and declares the set of available\nchoices; \n \n \n Separator, which is optional and declares the character to use to\nseparate the arguments of the enumerator. By default the comma “,”\nis used. \n \n \n ExtractorBean: this parameter represents the name of the Spring bean\nto use to process the values of the enumerator. The name must\nexactly match the id of the bean as defined in the Spring\nconfiguration file. \n \n \n It is rendered as a select list. \n Enumerator Map \n The enumerator map attribute type represent textual information with a\npredefined set of choices; it is defined by: \n \n \n Elements in the form of a separated list of key=value pairs, (i.e.\nkey1=value1,key2=value2) \n \n \n Separator, which is optional and declares the character to use to\nseparate the key, values pairs. By default the comma is used. \n \n \n It is rendered as a select list which shows the available values. \n Hypertext \n This attribute type holds HTML tagged text; it retains a single value\nfor all languages. \n Even if this attribute type could support all HTML tags, we strongly\nrecommend using only tags which provide meaning and avoid those which\ndecorate or add graphics. \n Hypertext attributes are rendered as a text area in the content edit\npage; if the CKEditor is active, the user has access to a set of\nadditional functionalities from a dedicated editor’s toolbar. Such as\ntable insertion and table manipulation, special characters insertion,\nstring formatting, links creation. \n Image \n This attribute type binds an image resource to the content. \n The image is always taken from the Digital Assets images list. The user\nwill need to specify the description accompanying the image. \n Usually attributes of type Image are not indexed and are not used to\nfilter contents. \n It is rendered as a button named “Add” that, when pushed, allows the\nuser to select an image from the Digital Assets images list. Once\nselected the user is presented with a preview, as a thumbnail, of the\nimage and has the possibility to define some parameters: \n \n \n Text which is mandatory and by default takes the name of the\nselected image \n \n \n legend (optional) \n \n \n alt (optional) \n \n \n description (optional) \n \n \n title (optional) \n \n \n Link \n This attribute type represents an hypertext link; it is normally used to\ninclude a link in your content: it is possible to define up to three\ndifferent types of links: \n \n \n external links: a link pointing to a location external to the Entando\nportal \n \n \n link to page: a link which points to a page of the portal \n \n \n link to a content: a link to another content \n \n \n It is rendered as a button named “Add” that when pushed opens up a modal\nwindow from which the user can select the link type. \n Longtext \n This attribute type represents a simple unformatted text; it supports\nseveral languages and is normally used for small descriptions, when a\nshort string won’t suffice. \n It supports minimum length , maximal length and regular expressions as\noptional parameters. \n It is rendered as a textarea. \n Monotext \n Monotext represents the information in textual form, but supports only a\nlanguage; it is used for all \n those fields which do not require localization. \n It supports minimum length, maximal length, and regular expressions as\noptional parameters. \n It is rendered as a textfield. \n Number \n This attribute type holds an integer number; it retains a single value\nfor all languages. \n Supports the optional parameters: From, To, and Equal to. \n It is rendered as a textfield. \n Text \n This attribute type holds a string; it retains a single value for all\nlanguages. \n It supports minimum length, maximal length, and regular expressions as\noptional parameters. \n It is rendered as a textfield. \n ThreeState \n Conceptually similar to the Boolean attribute, this attribute type\nallows a third status “Both” to be present. \n It is rendered as a radio button with “Yes”, “No”, “Both” options. \n Composed attribute types \n All the attributes types of the previous chapter can only retain a\nsingle type of information, but sometimes it is desirable to aggregate\ndifferent types of attributes into one attribute: this is where composed\nattributes are used. \n From a functional point of view, it would be perfectly legal to build a\ncontent type specifying all the attributes back to back: the content\nwould be formally complete, but from a logical point of view the\nattributes would appear mutually unrelated and, worse, the relationship\nbetween them would not be explicit. \n Entando offers three types of composed attributes: List, Monolist,\nComposite. \n List \n This Attribute Type represents a set of independent and homogeneous\nelementary Attribute types, each associated with one of the languages\ndefined in the system. \n An immediate consequence is that this kind of list can handle only\nmono-language basic attributes. \n It is rendered with a button named “Add” that if pushed presents the\nuser a prompt to select or define the single elements which compose the\nlist. \n Monolist \n This attribute type is a list that is common to all the system\nlanguages; this kind of list handles multi-language and mono-language\nattributes. \n It is rendered with a button named “Add” that, if pushed, presents the\nuser with a prompt to select or define the single elements that compose\nthe monolist. \n Composite \n This attribute type is an aggregate of different, non-homogeneous,\nsimple attributes types. The aggregation of different types is treated\nas a single unit. \n It is rendered as a combination of the elementary attribute types, where\neach attribute type presents the proper rendering. \n"},{title:"Adding a new API to the core app",frontmatter:{},regularPath:"/v6.2/tutorials/customize-the-platform/add-rest-api.html",relativePath:"v6.2/tutorials/customize-the-platform/add-rest-api.md",key:"v-2bc8a194",path:"/v6.2/tutorials/customize-the-platform/add-rest-api.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:" Adding a new API to the core app \n Prerequisites \n \n \n Java 8 \n \n \n maven \n Overview \n This guide will take you through adding a new REST API to the Entando\ncore app. In some cases it is better to add new APIs to the core rather\nthan creating a new microservice. Some example cases where adding new\nAPIs to the core is recommended are: \n \n \n When extending or adding functionality to the WCMS \n \n \n When you have a simple use case requiring persistence that is\nspecific to only the application you’re working within \n \n \n When exposing configurations that are needed by the portal-ui during\npage rendering \n \n \n For small changes that don’t warrant a full stand-alone microservice \n \n \n You can build widgets and micro frontends that take advantage of these\nAPIs in the same way that your micro-frontends can invoke APIs exposed\nby other services. \n Tutorial \n Creating a controller and services \n \n \n Create a new java package in the project using your favorite IDE at\nthe path  org.entando.training . \n \n \n Under that package add packages for  controllers  and  services . \n \n \n Create a class called  DemoController.java  from the\ntraining package into the controllers package. \n \n This is a normal Spring rest controller and it will be\ndiscovered by annotations. \n \n \n \n Copy  DemoService.java  from the\ntraining package into the services package. \n \n This is a normal Spring service that will be autowired into the\ncontroller. The data in this service is hardcoded but this is\nwhere you can wire in external services or other parts of the\nEntando architecture to fetch the data. \n \n \n \n Copy  commonConfig.xml  to\n src/main/resources/spring/aps/managers . \n \n \n The goal is to enable package scanning for annotation driven\nspring services. This includes the package scan for your package\ndefined above. If you want to scan another package, then you\nneed to add another path to this file. This is the only spring\nXML you will need to change if you want to build annotation\ndriven beans in Entando. \n \n \n See also web.xml for deeper details. \n \n \n \n \n Review the code and annotations in the controller to understand how\nthe APIs are protected and integrated. \n \n \n @RestAccessControl  is a custom Entando annotation that can be used\nto restrict APIs by role. \n \n The rest of the annotations are normal Spring annotations. \n \n \n \n Restart your app using jetty. \n \n \n if you get an error add the entries below to\n src/main/conf/systemParams.properties  This is temporary \nParameters for Argon2 algorithm encryption\nalgo.argon2.type=ARGON2i\nalgo.argon2.hash.length=32\nalgo.argon2.salt.length=16\nalgo.argon2.iterations=4\nalgo.argon2.memory=65536\nalgo.argon2.parallelism=4\nalgo.default.key=changeit\n \n \n \n \n \n Go to Swagger \n \n \n Find the demo-controller and try your new endpoints out using\nswagger \n \n \n"},{title:"Publish A Content",frontmatter:{},regularPath:"/v6.2/tutorials/cms/publish-a-content-tutorial.html",relativePath:"v6.2/tutorials/cms/publish-a-content-tutorial.md",key:"v-413a89a0",path:"/v6.2/tutorials/cms/publish-a-content-tutorial.html",headers:[{level:2,title:"Objective",slug:"objective"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"How to publish a Content",slug:"how-to-publish-a-content"}],lastUpdated:"8/11/2020, 4:23:51 PM",lastUpdatedTimestamp:1597177431e3,content:" Publish A Content \n Objective \n This document provides an overview of how to publish a Content in your\napplication page. \n Overview \n The App Builder application provides the capabilities to publish\nContent in your application page to the final user. \n How to publish a Content \n To publish a Content, through the App Builder application, in your page \n \n Go to  Pages > Management \n Click  Add \n \n \n A page must have a title, a code, a placement in the page tree, an owner\ngroup, a join group and a page template. When you create a new page, you\nmust to \n \n \n Provide a title and a code in the Info section. \n \n \n Provide, selecting them from the dropdown menus, an Owner Group and\na Join Group in the Page Groups section, \n \n \n Select a Page Template from the available templates. \n \n \n \n \n Click the green  Save and Configure  button. This brings you to\nthe configuration section, which lists all the frames defined in the\npage template you associated with that page. \n \n \n \n Add widgets by dragging them from the right column on to the desired frame. \n If you select the  Content  widget, its corresponding settings page will be shown. \n \n \n \n Click  Change content  to bring up the Content selection view. \n \n \n \n \n In the Search field, you can type the name of the content that you\nwould like to publish. Remember\nthat in order to publish the content on your page, it must first be saved\nand approved. \n \n \n Select the appropriate content item from the list. \n \n \n Press the  Save  button. \n \n \n \n \n \n The title of the selected content item will now be displayed in the widget settings. \n \n \n Press the  Save  button. \n \n \n \n \n \n Click on the  Preview  button to show the page preview with the updated settings. \n \n \n Finally, click on the  Publish  button to publish the page. \n \n \n \n"},{title:"Add a New Datasource in EAP Server",frontmatter:{},regularPath:"/v6.2/tutorials/customize-the-platform/add_datasource_to_eap_image.html",relativePath:"v6.2/tutorials/customize-the-platform/add_datasource_to_eap_image.md",key:"v-1c9022e6",path:"/v6.2/tutorials/customize-the-platform/add_datasource_to_eap_image.html",headers:[{level:2,title:"Other resources",slug:"other-resources"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:' Add a New Datasource in EAP Server \n With EAP should be enough to add a set of parameters the EntandoApp\ncustom resource. \n \n \n Set the standardServerImage to eap \n \n \n Add a  parameters  object \n \n \n \n Parameters environment variables reference \n \n \n \n \n \n \n \n Env variable \n Value \n Example with PortDB \n \n \n \n \n DATASOURCES \n "PORTDB,SERVDB, <YOUR-DS-PREFIX>" \n \n \n \n <YOUR-DS-PREFIX>_NONXA \n Defines the datasource as a non-XA datasource. Defaults to  false \n PORTDB_NONXA="true" \n \n \n <YOUR-DS-PREFIX>_JTA \n Defines Java Transaction API (JTA) option for the non-XA datasource. The XA datasources are already JTA capable by default Defaults to  true \n PORTDB_JTA="false" \n \n \n <YOUR-DS-PREFIX>_URL \n Defines connection URL for the datasource. \n PORTDB_URL="jdbc:derby:/entando-data/databases/entandoPort;create=true" \n \n \n <YOUR-DS-PREFIX>_JNDI \n Defines the JNDI name for the datasource. This setting is useful if you want to override the default generated JNDI name \n PORTDB_JNDI="java:jboss/datasources/entandoPortDataSource" \n \n \n <YOUR-DS-PREFIX>_DRIVER \n Defines Java database driver for the datasource \n PORTDB_DRIVER="derby" \n \n \n <YOUR-DS-PREFIX>_USERNAME \n Defines the username for the datasource \n PORTDB_USERNAME="agile" \n \n \n <YOUR-DS-PREFIX>_PASSWORD \n Defines the password for the datasource \n PORTDB_PASSWORD="agile" \n \n \n <YOUR-DS-PREFIX>_SERVICE_HOST \n Defines the database server’s host name or IP address to be used in the datasource’s connection-url property. \n PORTDB_SERVICE_HOST="dummy" \n \n \n <YOUR-DS-PREFIX>_SERVICE_PORT \n Defines the database server’s port for the datasource. \n PORTDB_SERVICE_PORT="1527" \n \n \n \n \n Note \n For more details on other standard variables check the  EAP\ndocumentation \n \n Here a potential example \n apiVersion: entando.org/v1\nkind: "EntandoApp"\nmetadata:\n  annotations: {}\n  labels: {}\n  name: "quickstart"\nspec:\n  dbms: #tbd\n  replicas: 1\n  standardServerImage: eap\n  ingressPath: /entando-de-app\n  parameters:\n    DATASOURCES: "PORTDB,SERVDB,MYDATASOURCE"\n    MYDATASOURCE_NONXA: "true"\n    MYDATASOURCE_JTA: "false"\n    ...\n Other resources \n \n EAP Official Documentation: Runtime\nArtifacts/Datasources \n \n'},{title:"Hello World for a Widget Using the App builder",frontmatter:{},regularPath:"/v6.2/tutorials/customize-the-platform/app-builder/hello-world.html",relativePath:"v6.2/tutorials/customize-the-platform/app-builder/hello-world.md",key:"v-c350580e",path:"/v6.2/tutorials/customize-the-platform/app-builder/hello-world.html",headers:[{level:2,title:"Basic Widget Tutorial",slug:"basic-widget-tutorial"},{level:2,title:"Simple Fragment tutorial",slug:"simple-fragment-tutorial"},{level:2,title:"Freemarker Basics in Entando",slug:"freemarker-basics-in-entando"},{level:2,title:"Useful Links",slug:"useful-links"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:' Hello World for a Widget Using the App builder \n This tutorial will take you through the basics of creating an Entando\nwidget and placing it on a page. This document will also review the\nbasics of fragments which are re-usable pieces of a user interface. \n Basic Widget Tutorial \n For this example you will use the Entando App Builder to build and\nassign your widget on a page. In a production system or a larger\ndevelopment environment you would build and deploy widgets differently,\nhowever this example provides a quick idea of the building blocks. \n \n \n In the App Builder menu, at the top, Go To: UX Patterns -→ Widgets \n \n \n Select Add \n \n \n The Custom UI Field is a freemarker template where you can put raw\nhtml and include freemarker logic, \n \n \n It allows you to import javascript, css, or any normal HTML \n \n \n Example, put <h2>Hello World</h2> into your widget, give it\na name and save it \n \n \n \n \n Go To: Page Designer -→ Page Settings \n \n \n In the Home Page dropdown select Home / Service and select SAVE \n \n \n Now place the widget on the page \n \n \n Go To: Page Designer -→ Page Tree \n \n \n On the row that says "Service", on the far right side, select the\nKebab button and select CONFIGURE \n \n \n Find the widget created in step 5 on the right hand side \n \n \n Drag and drop the widget onto the open frame of the page \n \n \n Select PUBLISH at the bottom of the screen \n \n \n Then select GO TO HOME PAGE in the upper right \n \n \n You should see "Hello World" on the page \n Simple Fragment tutorial \n A fragment is a way to take a common piece of front end code and reuse\nit across multiple pages or widgets. Common elements such as basic html,\njavascript, or freemarker logic can be stored as fragments and\nreferenced via the  <@wp.fragment …​  tag. \n Starting from the simple widget tutorial above: \n \n \n In the app builder Go To: UX Patterns -→ Fragments \n \n \n Enter the code for the fragment as  test \n \n \n In the  Gui Code  enter  <h2>This is a fragment</h2> \n \n \n Next place the fragment on a page \n \n \n Go To: Ux Patterns -→ Page Templates \n \n \n On the row for  service , select EDIT \n \n \n Use the fragment tag to place the fragment on the page\n <@wp.fragment code="test"/> \n \n \n SAVE the page template \n \n \n Go To: homepage (assuming you’ve set the service page to the\nhomepage) \n \n \n Note that the fragment is printed including the HTML tags. By\ndefault html embedded via a fragment tag is escaped so you get it\nrendered exactly as you enter it. You’ll need to un-escape it to get\nit to render correctly. \n \n \n Go back to your page template (UX Patterns -→ Page Templates) select\nSERVICE and EDIT \n \n \n Change the tag to:  <@wp.fragment code="test" escapeXml=false/> \n \n \n Go back to the homepage \n \n \n See correctly rendered fragment \n Freemarker Basics in Entando \n The freemarker templating language gives you a lot of flexibility and\npower in how pages are rendered. You can include conditional logic,\ninject information from the backend, check for query parameters and\nroute to different pages. \n For example, to check for a query parameter you can use:\n <#if RequestParameters.myParam?exists > …​ \n To check the current username, use:\n <#if (Session.currentUser.username != "guest") > \n When you need dynamic behavior in your widgets consider using the power\nof freemarker. \n Useful Links \n https://freemarker.apache.org \n'},{title:"Building a Docker Image for the Entando Core",frontmatter:{},regularPath:"/v6.2/tutorials/customize-the-platform/app-engine/build-core-image.html",relativePath:"v6.2/tutorials/customize-the-platform/app-engine/build-core-image.md",key:"v-19281c9a",path:"/v6.2/tutorials/customize-the-platform/app-engine/build-core-image.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Introduction",slug:"introduction"},{level:2,title:"Setup",slug:"setup"}],lastUpdated:"12/15/2021, 2:22:26 PM",lastUpdatedTimestamp:1639596146e3,content:" Building a Docker Image for the Entando Core \n Prerequisites \n \n \n Java 8 \n \n \n Docker installed locally\n( https://docs.docker.com/docker-for-windows/install/ ) \n \n \n maven \n \n \n Access to a docker repository (docker.io or other) \n Introduction \n This tutorial will take you through the basic steps to create a docker\nimage from an Entando core application. A more detailed guide with\nadditional commands and configuration can be found here: \n https://github.com/entando/entando-de-app \n Setup \n \n \n Clone the application at:\n https://github.com/entando/entando-de-app  using \n git clone https://github.com/entando/entando-de-app\n \n \n \n On a command line, cd into the entando-de-app you just cloned: \n cd entando-de-app\n \n \n \n Build a docker image from the core app \n mvn clean package -Pwildfly -Pderby docker:build\n \n \n \n View the images installed on your local docker instance \n docker images\n \n Look for \n entando/entando-de-app:latest\n \n \n \n Create a repository on your docker repository to house your new\napplication \n \n \n Re-tag the image you just built with your repo \n  docker tag entando/entando-de-app:latest <YOUR-USER>/<YOUR-REPO-NAME>:latest\n \n \n \n Push the Image to your Repository \n docker push <YOUR-USER>/<YOUR-REPO-NAME>:latest\n \n \n \n"},{title:"Building a Docker Image and Deploying a Pre-Packaged App",frontmatter:{},regularPath:"/v6.2/tutorials/customize-the-platform/app-engine/building-prepackaged-image.html",relativePath:"v6.2/tutorials/customize-the-platform/app-engine/building-prepackaged-image.md",key:"v-8585111a",path:"/v6.2/tutorials/customize-the-platform/app-engine/building-prepackaged-image.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Introduction",slug:"introduction"},{level:2,title:"Setup",slug:"setup"}],lastUpdated:"12/15/2021, 2:22:26 PM",lastUpdatedTimestamp:1639596146e3,content:' Building a Docker Image and Deploying a Pre-Packaged App \n Prerequisites \n \n \n Java 8 \n \n \n Docker installed locally\n( https://docs.docker.com/docker-for-windows/install/ ) \n \n \n maven \n \n \n Access to a docker repository (docker.io or other) \n Introduction \n This tutorial will show you how you can use an Entando application that\nyou have built as a launching point for creating new applications. \n In this lab you’ll take a demo application previously built, install the\nbackups in a blank application, build an image from the updated app, and\ndeploy it as a new application. \n Setup \n \n \n Clone the application at:\n https://github.com/entando/entando-de-app  using \n git clone https://github.com/entando/entando-de-app\n \n \n \n On a command line, cd into the entando-de-app you just cloned: \n cd entando-de-app\n \n \n \n Take the provide zip file and unzip it in a location of your choice. \n \n \n This zip contains all of the assets, content, and metadata\nneeded to launch an Entando application. We are going to package\nthem the assets and DB an image and \n \n \n Entando will automatically instantiate and populate the app from\nthe most recent backup \n \n \n \n \n Move the resources and protected folders from the zip file into your\n entando-de-app  in  src/main/webapp  replacing any content that is\nalready there \n \n \n Build a docker image from the app \n mvn clean package -Pwildfly -Pderby docker:build\n \n \n Note that the "derby" option here is only for the initialization\nphase of the DB when deploying. It isn’t the final database\nchoice \n \n \n \n View the images installed on your local docker instance \n docker images\n \n Look for \n entando/entando-de-app:latest\n \n \n \n Create a repository on your docker repository to house your new\napplication \n \n \n Re-tag the image you just built with your repo \n  docker tag entando/entando-de-app:latest <YOUR-USER>/<YOUR-REPO_NAME>:latest\n \n \n \n Push the Image to your Repository \n docker push <YOUR-USER>/<YOUR-REPO_NAME>:latest\n \n \n \n Now we need to generate a new application for deployment to\nKubernetes using the Helm chart \n \n \n If you have an output from helm from before you can re-use it\nand just apply the changes to the config map. \n \n \n Or you can re-run helm and change the output \n \n \n \n \n Re-run the helm command for your environment. \n \n \n Open the output yaml file from the helm command in the text editor\nof your choice \n \n For example:  vi training-alpha.yaml \n \n \n \n In that file look for the  ConfigMap \n \n \n The config map defines all of the images that are available as\npart of the deployment. They aren’t all used concurrently. \n \n \n You can also view this config map in kubernetes/OpenShift \n \n \n \n \n Now you need to update the deployment to use your customized Wildfly\nimage. Find  entando-de-app-wildfly  in the config map \n \n Note that we are changing the de-app but you could create a\ncustom version of any of the included images \n \n \n \n Change the version to match the version you used for your image \n \n \n Change the "organization" to the name of your main image repository\norganization and if you aren’t using docker.io (DockerHub) then\nchange the registry as well. \n \n \n Save the file \n \n \n Follow the deployment steps you went through when you originally\ndeployed your Entando application to your Kubernetes instance \n \n \n Once deployed go to the app builder in your app \n \n \n Click Go To Homepage \n \n \n'},{title:"The Entando Core APIs",frontmatter:{},regularPath:"/v6.2/tutorials/customize-the-platform/app-engine/core-swagger.html",relativePath:"v6.2/tutorials/customize-the-platform/app-engine/core-swagger.md",key:"v-e4d3f29a",path:"/v6.2/tutorials/customize-the-platform/app-engine/core-swagger.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Setup",slug:"setup"},{level:2,title:"Overview",slug:"overview"},{level:3,title:"API structure",slug:"api-structure"},{level:3,title:"Models",slug:"models"},{level:2,title:"Tutorial:",slug:"tutorial"}],lastUpdated:"12/15/2021, 2:22:26 PM",lastUpdatedTimestamp:1639596146e3,content:" The Entando Core APIs \n Prerequisites \n \n \n Java 8 \n \n \n maven \n Setup \n \n \n Clone the Entando sample app if you don’t already have it. \n git clone https://github.com/entando/entando-de-app\n \n \n \n Start the app for local execution and enable the swagger profile by\npassing  -Dspring.profiles.active=swagger  to the jetty command. Set\nthe value of  -Djetty.port  to something available on your machine\ne.g. 8081. \n mvn clean package jetty:run-war -Pjetty-local -Pderby -Dspring.profiles.active=swagger -Djetty.port=8085 -Dorg.slf4j.simpleLogger.log.org.eclipse.jetty.annotations.AnnotationParser=error \n \n \n \n Note: If you don't have docker installed or running add  -DskipDocker=true  to the command above \n \n \n \n Wait for the app to start. \n \n \n Once started, navigate to the swagger ui in a browser. \n \n \n \n http://localhost:[your port]/entando-de-app/api/swagger-ui.html\n Overview \n The Entando core exposes REST APIs for every action that can be taken in\nthe App Builder and Admin Console environments. For example, you can use\nthese apis to create pages, create page templates or to add widgets to\npages. The APIs can be used to support automation, testing, or\nintegrations with external systems. \n API structure \n All of the APIs share a common top level structure. Each response will\ncontain a top level entry for  errors ,  metadata , and  payload . \n The  errors  will always contain code and a message string indicating an\nerror condition in the request. The  metadata  section is used for\npaging, sorting, filtering and data that is distinct from the body. The\nbody of each response is included in the  payload  section of the\nresponse and varies according to each API. \n Models \n All of the model classes returned by the Entando core are annotated so\nthat the model definition is included in the swagger documentation. At\nthe bottom of the swagger page all of the model classes returned by the\nAPI endpoints can be found. \n Tutorial: \n \n \n Stop the Entando instance if it is running. \n \n \n In the project open  src/main/conf/systemParams.properties . \n \n \n Change the value of this property to reflect the port you are using\nto run the app. \n \n \n applicationBaseURL \n \n \n For example if running on 8085 you would have\n applicationBaseURL=http://localhost:8085/${entando.engine.web.context}/ \n \n \n \n \n Login to the admin console at\n http://localhost:8085/entando-de-app/do/login . \n \n \n Once logged in go to Integration -→ API Management -→ Consumers. \n \n \n Select the kebab button on the row labeled swagger. \n \n \n On that screen enable the button for  client_credentials . \n \n \n On that screen enter  swagger  as the value for the secret. \n \n \n Hit save \n \n \n Return to swagger  your\nport /entando-de-app/api/swagger-ui.html \n \n \n Hit authorize \n \n \n Enter \n \n \n User: admin \n \n \n PW: adminadmin \n \n \n client: swagger \n \n \n client_secret: swagger \n \n \n \n \n Use the  Try it out  button on the APIs \n \n \n Scroll to  widget-controller \n \n \n Select the blue GET row \n \n \n Select  Try it out \n \n \n Look at the results in the window \n \n \n \n \n"},{title:"Change Default Datasources and Connections",frontmatter:{},regularPath:"/v6.2/tutorials/customize-the-platform/change-default-datasources-and-connections/",relativePath:"v6.2/tutorials/customize-the-platform/change-default-datasources-and-connections/README.md",key:"v-5503dfd0",path:"/v6.2/tutorials/customize-the-platform/change-default-datasources-and-connections/",headers:[{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Create a Docker project for your own base image to Entando's standard base image(s)",slug:"_1-create-a-docker-project-for-your-own-base-image-to-entando-s-standard-base-image-s"},{level:3,title:"2. Customize the standalone.xml/standalone-openshift.xml file using environment variables.",slug:"_2-customize-the-standalone-xml-standalone-openshift-xml-file-using-environment-variables"},{level:3,title:"3. Build your own Docker base image",slug:"_3-build-your-own-docker-base-image"},{level:3,title:"4. Modify your Entando App project to use the new Docker base image",slug:"_4-modify-your-entando-app-project-to-use-the-new-docker-base-image"},{level:3,title:"5. Build and push your custom Docker image",slug:"_5-build-and-push-your-custom-docker-image"},{level:3,title:"6. Deploy your EntandoApp with the correct environment variables",slug:"_6-deploy-your-entandoapp-with-the-correct-environment-variables"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:' Change Default Datasources and Connections \n Purpose \n This tutorial explains how to customize our EAP and Wildfly base Docker images, and then configure the EntandoApp\ncustom resource to use these customizations \n Requirements \n \n \n The Entando Operator is running in the target names \n \n \n Keycloak and the Entando Cluster Infrastructure have been deployed \n \n \n The required external databases and other services are up and running. \n \n \n Your own custom project as described in  the tutorial \n Steps \n 1. Create a Docker project for your own base image to Entando\'s standard base image(s) \n Create a project, ideally in Git repository, and put the following files in the folder \n 1.1. The standalone.xml/standalone-openshift.xml file of choice \n It is essential for your custom Docker image to use a file from one of the official Entando Docker base images. \n If you intend to use provide your own EAP based image, please use this\n standalone-openshift.xml \nfile. \n If you intend to use provide your own Wildfly based image, please use this\n standalone.xml \nfile. \n Please note that if you create your own base image with a different version of EAP or Wildfly, using these files\nmay have unintended consequences. \n 1.2. Any modules that may be required for your datasource or other connection resource \n If the resource you need to connect to requires some custom classes, such as JDBC drivers, please add these as \na module to Wildfly/EAP. As an example, you can look at our\n Derby database module \nthat Entando uses for embedded databases. Please ensure that the path of the folder containing the jar files reflects\nthe fully qualified name of the module in the module.xml file. \n 1.3 Dockerfile \n In your Dockerfile, please be sure to extend the correct base image, and add the correct configuration file to\nthe correct location in the target image. \n For EAP, a most basic Dockerfile would look like this: \n FROM entando/entando-eap71-clustered-base:6.1.2\nCOPY --chown=185:0 ./standalone-openshift.xml /opt/eap/standalone/configuration\n \n For Wildfly, a most basic Dockerfile would look like this: \n FROM entando/entando-eap71-clustered-base:6.1.2\nCOPY --chown=1001:0 ./standalone.xml /wildfly/standalone/configuration\n \n Please take note of the user ownership in these different Dockerfiles. This is quite important as Openshift will\nexpect the user/group ownership to be respected. \n 2. Customize the standalone.xml/standalone-openshift.xml file using environment variables. \n You can now modify your Wildfly/EAP configuration to meet your requirements. Where the configuration could differ\nfrom one environment to a next, we strongly advise using environment variable expressions ( ${env.VAR_NAME} ). The most likely change\nthat would be required in this file is the addition of a datasource. Here is an example of how to add a datasource\nto the datasources subsystem. All the environment variables starting with \'YOURDB\' can be specified from the Docker\ncontainer. \n    ...\n    <subsystem xmlns="urn:jboss:domain:datasources:5.0">\n      <datasources>\n        <datasource jndi-name="${env.YOURDB_JNDI}" enabled="true" use-java-context="true" pool-name="yourDbDataSource" use-ccm="true">\n          <connection-url>${env.YOURDB_URL}</connection-url>\n          <driver>${env.YOURDB_DRIVER}</driver>\n          <security>\n            <user-name>${env.YOURDB_USERNAME}</user-name>\n            <password>${env.YOURDB_PASSWORD}</password>\n          </security>\n        </datasource>\n \n Please take extra care not to remove any lines from these files. This is of particular importance in the case of the\nEAP image as, on startup, scripts in the official EAP look for certain placeholders in this file and populates them\nfrom other environment variables. \n 3. Build your own Docker base image \n You can now build your Docker base image. It is highly recommended that you consider using a dedicated CI/CD build\ntool such as Jenkins X to build the base image and maintain traceability between your source code and the resulting\nDocker image. One possible build command could look like this: \n docker build . -t your-docker-registry.com/your-org/your-base-image:1.0.0 \n 4. Modify your Entando App project to use the new Docker base image \n You can now modify your Entando App project that you have forked as described in the\n relevant tutorial . You would require two changes to the pom.xml file\nof the sample project. \n \n Firstly, you would need to change the variable  server.base.image  to reflect the fully\nqualified URI of your Docker image for EAP and/or Wildfly. For example, if you decided to extend the Wildfly image,\ngo to the Maven profile with the id  wildfly  and change the   server.base.image  to look like this: \n \n <server.base.image>your-docker-registry.com/your-org/your-base-image:1.0.0</server.base.image> \n \n Then you need to change the  <from>  element in the Fabric8 Maven Docker Plugin to reflect this variable.\nNavigate to the first  <image>  element in the pom.xml file. You have found the correct one\nif it contains the following xml: \n \n <from>entando/${server.base.image}:${entando.version}</from> \n Delete the  entando/  prefix and the  :${entando.version}  suffix: \n <from>${server.base.image}</from> \n Please note that, should you still require support for both Wildfly and EAP in your Maven pom, you may need to\nrepeat this exercise for both the  eap  and  wildfly  profiles. \n 5. Build and push your custom Docker image \n Before building your Docker image, it would be a good idea to change the name of the image you want to build. Navigate\nto the previously modified  <image>  element in the Fabric8 Maven Docker Plugin.You can change the  <name>  element\nto reflect your preferred name, e.g. \n <name>your-docker-registry.com/your-org/your-entando-app:1.0.0</name> \n Run: \n mvn clean package -Pwildfly -Pderby \n A new Docker image should now be available named  your-docker-registry.com/your-org/your-entando-app:1.0.0 \n Log into the Docker registry in question and then push the image: \n docker push your-docker-registry.com/your-org/your-entando-app:1.0.0 \n You are now ready to deploy this image. \n 6. Deploy your EntandoApp with the correct environment variables \n The final step is to configure your EntandoApp deployment with the correct environment variables. As is the case with\nall the Entando Custom Resources that result in actual deployments, the property  spec.parameters  will be translated\ninto environment variables on each of the Containers in the Deployment\'s Pod. For an EntandoApp named \'my-app\',\nthe new state of the EntandoApp would could be placed in a file named  my-app.yaml  that would look something like this: \n       kind: "EntandoApp"\n      metadata:\n        name: "my-app"\n      spec:\n        dbms: postgresql\n        replicas: 1\n        customServerImage: your-docker-registry.com/your-org/your-entando-app:1.0.0\n        ingressPath: /your-entando-app\n        parameters:\n          YOURDB_JNDI: java/your-ds\n          YOURDB_URL: jdbc:postgresql://somehost.com:5432/mydb\n          YOURDB_DRIVER: postgresql\n          YOURDB_USERNAME: my_user\n          YOURDB_PASSWORD: mypassword\n      entandoStatus:\n        entandoDeploymentPhase: requested\n\n \n Notice how this Custom Resource specifies a  parameter  for each environment variable that was referenced from the\n standalone.xml  file referenced earlier. \n To apply the changes to your deployment, change the  entandoStatus.entandoDeploymentPhase  property to requested and\napply the file: \n kubectl apply -f my-app.yaml\n \n '},{title:"Tutorial: how to configure custom datasources and connections for Entando Apps on EAP and Wildfly",frontmatter:{},regularPath:"/v6.2/tutorials/customize-the-platform/change-default-datasources-and-connections/tutorials/how-to-configure-custom-datasource.html",relativePath:"v6.2/tutorials/customize-the-platform/change-default-datasources-and-connections/tutorials/how-to-configure-custom-datasource.md",key:"v-1bf60ac0",path:"/v6.2/tutorials/customize-the-platform/change-default-datasources-and-connections/tutorials/how-to-configure-custom-datasource.html",headers:[{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Create a Docker project for your own base image to Entando's standard base image(s)",slug:"_1-create-a-docker-project-for-your-own-base-image-to-entando-s-standard-base-image-s"},{level:3,title:"2. Customize the standalone.xml/standalone-openshift.xml file using environment variables.",slug:"_2-customize-the-standalone-xml-standalone-openshift-xml-file-using-environment-variables"},{level:3,title:"3. Build your own Docker base image",slug:"_3-build-your-own-docker-base-image"},{level:3,title:"4. Modify your Entando App project to use the new Docker base image",slug:"_4-modify-your-entando-app-project-to-use-the-new-docker-base-image"},{level:3,title:"5. Build and push your custom Docker image",slug:"_5-build-and-push-your-custom-docker-image"},{level:3,title:"6. Deploy your EntandoApp with the correct environment variables",slug:"_6-deploy-your-entandoapp-with-the-correct-environment-variables"}],lastUpdated:"12/15/2020, 3:24:13 PM",lastUpdatedTimestamp:1608063853e3,content:' Tutorial: how to configure custom datasources and connections for Entando Apps on EAP and Wildfly \n Purpose \n This tutorial explains how to customize our EAP and Wildfly base Docker images, and then configure the EntandoApp\ncustom resource to use these customizations \n Requirements \n \n \n The Entando Operator is running in the target names \n \n \n Keycloak and the Entando Cluster Infrastructure have been deployed \n \n \n The required external databases and other services are up and running. \n \n \n Your own custom project as described in  the tutorial \n Steps \n 1. Create a Docker project for your own base image to Entando\'s standard base image(s) \n Create a project, ideally in Git repository, and put the following files in the folder \n 1.1. The standalone.xml/standalone-openshift.xml file of choice \n It is essential for your custom Docker image to use a file from one of the official Entando Docker base images. \n If you intend to use provide your own EAP based image, please use this\n standalone-openshift.xml \nfile. \n If you intend to use provide your own Wildfly based image, please use this\n standalone.xml \nfile. \n Please note that if you create your own base image with a different version of EAP or Wildfly, using these files\nmay have unintended consequences. \n 1.2. Any modules that may be required for your datasource or other connection resource \n If the resource you need to connect to requires some custom classes, such as JDBC drivers, please add these as \na module to Wildfly/EAP. As an example, you can look at our\n Derby database module \nthat Entando uses for embedded databases. Please ensure that the path of the folder containing the jar files reflects\nthe fully qualified name of the module in the module.xml file. \n 1.3 Dockerfile \n In your Dockerfile, please be sure to extend the correct base image, and add the correct configuration file to\nthe correct location in the target image. \n For EAP, a most basic Dockerfile would look like this: \n FROM entando/entando-eap71-clustered-base:6.1.2\nCOPY --chown=185:0 ./standalone-openshift.xml /opt/eap/standalone/configuration\n \n For Wildfly, a most basic Dockerfile would look like this: \n FROM entando/entando-eap71-clustered-base:6.1.2\nCOPY --chown=1001:0 ./standalone.xml /wildfly/standalone/configuration\n \n Please take note of the user ownership in these different Dockerfiles. This is quite important as Openshift will\nexpect the user/group ownership to be respected. \n 2. Customize the standalone.xml/standalone-openshift.xml file using environment variables. \n You can now modify your Wildfly/EAP configuration to meet your requirements. Where the configuration could differ\nfrom one environment to a next, we strongly advise using environment variable expressions ( ${env.VAR_NAME} ). The most likely change\nthat would be required in this file is the addition of a datasource. Here is an example of how to add a datasource\nto the datasources subsystem. All the environment variables starting with \'YOURDB\' can be specified from the Docker\ncontainer. \n    ...\n    <subsystem xmlns="urn:jboss:domain:datasources:5.0">\n      <datasources>\n        <datasource jndi-name="${env.YOURDB_JNDI}" enabled="true" use-java-context="true" pool-name="yourDbDataSource" use-ccm="true">\n          <connection-url>${env.YOURDB_URL}</connection-url>\n          <driver>${env.YOURDB_DRIVER}</driver>\n          <security>\n            <user-name>${env.YOURDB_USERNAME}</user-name>\n            <password>${env.YOURDB_PASSWORD}</password>\n          </security>\n        </datasource>\n \n Please take extra care not to remove any lines from these files. This is of particular importance in the case of the\nEAP image as, on startup, scripts in the official EAP look for certain placeholders in this file and populates them\nfrom other environment variables. \n 3. Build your own Docker base image \n You can now build your Docker base image. It is highly recommended that you consider using a dedicated CI/CD build\ntool such as Jenkins X to build the base image and maintain traceability between your source code and the resulting\nDocker image. One possible build command could look like this: \n docker build . -t your-docker-registry.com/your-org/your-base-image:1.0.0 \n 4. Modify your Entando App project to use the new Docker base image \n You can now modify your Entando App project that you have forked as described in the\n relevant tutorial . You would require two changes to the pom.xml file\nof the sample project. \n \n Firstly, you would need to change the variable  server.base.image  to reflect the fully\nqualified URI of your Docker image for EAP and/or Wildfly. For example, if you decided to extend the Wildfly image,\ngo to the Maven profile with the id  wildfly  and change the   server.base.image  to look like this: \n \n <server.base.image>your-docker-registry.com/your-org/your-base-image:1.0.0</server.base.image> \n \n Then you need to change the  <from>  element in the Fabric8 Maven Docker Plugin to reflect this variable.\nNavigate to the first  <image>  element in the pom.xml file. You have found the correct one\nif it contains the following xml: \n \n <from>entando/${server.base.image}:${entando.version}</from> \n Delete the  entando/  prefix and the  :${entando.version}  suffix: \n <from>${server.base.image}</from> \n Please note that, should you still require support for both Wildfly and EAP in your Maven pom, you may need to\nrepeat this exercise for both the  eap  and  wildfly  profiles. \n 5. Build and push your custom Docker image \n Before building your Docker image, it would be a good idea to change the name of the image you want to build. Navigate\nto the previously modified  <image>  element in the Fabric8 Maven Docker Plugin.You can change the  <name>  element\nto reflect your preferred name, e.g. \n <name>your-docker-registry.com/your-org/your-entando-app:1.0.0</name> \n Run: \n mvn clean package -Pwildfly -Pderby \n A new Docker image should now be available named  your-docker-registry.com/your-org/your-entando-app:1.0.0 \n Log into the Docker registry in question and then push the image: \n docker push your-docker-registry.com/your-org/your-entando-app:1.0.0 \n You are now ready to deploy this image. \n 6. Deploy your EntandoApp with the correct environment variables \n The final step is to configure your EntandoApp deployment with the correct environment variables. As is the case with\nall the Entando Custom Resources that result in actual deployments, the property  spec.parameters  will be translated\ninto environment variables on each of the Containers in the Deployment\'s Pod. For an EntandoApp named \'my-app\',\nthe new state of the EntandoApp would could be placed in a file named  my-app.yaml  that would look something like this: \n       kind: "EntandoApp"\n      metadata:\n        name: "my-app"\n      spec:\n        dbms: postgresql\n        replicas: 1\n        customServerImage: your-docker-registry.com/your-org/your-entando-app:1.0.0\n        ingressPath: /your-entando-app\n        parameters:\n          YOURDB_JNDI: java/your-ds\n          YOURDB_URL: jdbc:postgresql://somehost.com:5432/mydb\n          YOURDB_DRIVER: postgresql\n          YOURDB_USERNAME: my_user\n          YOURDB_PASSWORD: mypassword\n      entandoStatus:\n        entandoDeploymentPhase: requested\n\n \n Notice how this Custom Resource specifies a  parameter  for each environment variable that was referenced from the\n standalone.xml  file referenced earlier. \n To apply the changes to your deployment, change the  entandoStatus.entandoDeploymentPhase  property to requested and\napply the file: \n kubectl apply -f my-app.yaml\n \n '},{title:"Tutorial: Invoking Entando Core APIs",frontmatter:{},regularPath:"/v6.2/tutorials/customize-the-platform/invoking-api.html",relativePath:"v6.2/tutorials/customize-the-platform/invoking-api.md",key:"v-69b9a4cc",path:"/v6.2/tutorials/customize-the-platform/invoking-api.html",headers:[{level:2,title:"General Overview",slug:"general-overview"},{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Set up a Postman environment",slug:"_1-set-up-a-postman-environment"},{level:3,title:"2. Get an access token",slug:"_2-get-an-access-token"},{level:3,title:"2. Prepare a generic API request",slug:"_2-prepare-a-generic-api-request"},{level:2,title:"QE ready APIs",slug:"qe-ready-apis"},{level:2,title:"Notes on QE requests collections structure",slug:"notes-on-qe-requests-collections-structure"},{level:2,title:"Conclusion",slug:"conclusion"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:' Tutorial: Invoking Entando Core APIs \n General Overview \n Entando supports Swagger and it is accessible, if activated, from its\nweb interface from the base application URL at /api/swagger-ui.html. A\ncomplete list of all available core APIs can be obtained from Swagger. \n Core APIs can be invoked directly from Swagger or from any other\nsuitable tool, i.e., curl or Postman are two common ones. Postman has\nbeen extensively used in API testing and automated API testing because\nof the possibilities it offers and it is the suggested tool. \n All Entando core APIs are accessible from the base URL, for example:\nlocalhost:8080/entando-de-app/api. For example, the Page Controller will\nbe available under /pages from the Base URL (i.e.\nlocalhost:8080/entando-de-app/api/pages), or the Page Template Controller\nwill available under /pageModels (i.e.\nlocalhost:8080/entando-de-app/api/pageModels) and so on. \n Before being able to perform any API request, we will first need to\nobtain an  authorization token , that is achieved with a specific POST\nrequest sent to the oauth/token endpoint, after successful\nauthentication, an access token is returned which grants access to all\nAPI endpoints and actions for which the authenticated user has defined\nprivileges. \n (Refer to User Management Roles for details) \n The best way to proceed in case of extensive testing with APIs with\nPostman, is to set up an environment and define a variable that will\nkeep the access token saved from the POST request to /oauth/token. \n Purpose \n Set up an environment ready to invoke Entando core APIs \n Requirements \n To complete this tutorial you will need: \n \n \n Postman \n \n \n A running Entando 6 instance \n Steps \n 1. Set up a Postman environment \n Create a new Postman environment and define the following variables: \n access_token: (no value)\nrefresh_token: (no value)\nurl: URL of your application (i.e. http://localhost:8080/entando-de-app)\n \n Be careful with the URL variable and make sure you do not have a\ntrailing slash. \n Set Postman to use this environment. \n 2. Get an access token \n Getting an access token is a prerequisite to be able to invoke any API.\nThe following is the required activity. \n \n \n create a Postman collection, name it for example "Access Token" \n \n \n create a new POST request with the following parameters: \n \n \n \n URL field\n{{url}}/api/oauth/token\n \n Note that we are calling the "url" environmental variable for\nconvenience. \n Autorization section\n   Type: Basic Auth\n   Username: (a valid Entando consumer must be defined in Entando) (Refer to appropriate documentation on how to do that) (i.e. appbuilder)\n   Password: (password of the defined consumer) (i.e. appbuilder_secret)\n\nHeaders section\n    Content-Type: application/x-www-form-urlencoded\n\nBody section\nSelect from the radio button the option: x-www-form-urlencoded\n    username: (valid Entando user (i.e. admin))\n    password: (password of the valid user)\n    grant_type: password\n \n The tests section is convenient as we can then set any new API request\nin such a way to make use of that access token. The first line of code\ndefines a variable called "data", which hosts the JSON parsed\nresponseBody from the POST request just sent to /oauth/token; The second\nline sets the environment variable "access_token" to the value returned\nby the POST request. \n Tests section\n    var data = JSON.parse(responseBody);\n    postman.setEnvironmentVariable("access_token", data.access_token);\n \n Launch the POST request to test it, and if successful, you should get a\nresponse like this: \n {\n    "access_token": "b96096493a40b1a7364bd54a6ffb609b",\n    "token_type": "bearer",\n    "refresh_token": "79ff84062b5dc13663961a833b0788f9",\n    "expires_in": 3599\n}\n \n also if you open in edit the Postman environment, you should see that\nthe access_token and the refresh_token variables values have been\nupdated. \n 2. Prepare a generic API request \n Create a new request with the following parameters: \n Authorization section: Inherit auth from parent\n\nHeaders section:\n create the key Authorization with Value: Bearer{{access_token}}\n create the key Content-Type with Value: application/json\n \n Select the appropriate method (GET, DELETE, POST etc.) for your request\nand fill up the URL with appropriate values i.e.\n(localhost:8080/entando-de-app/api/pages) then add to the Body section,\nif needed, the appropriate payload in JSON format, remember to select\nraw and JSON (application/json). \n QE ready APIs \n QE has developed a set of collection requests to automate API testing,\nexamples of that are available on github at\n https://github.com/entando/entando-QE/tree/master/postman_API . \n To use them ,first git clone the project and use the built in Postman\nimporting features. \n Import first the Postman Environment file which can be found under the\nenvironment folder. When imported, from Postman, open in edit that\nenvironment and change the "url" variable to the appropriate value for\nyour specific installation, i.e  http://localhost:8080/entando-de-app/ \nand save it. \n Import from Postman the collections you would like to use and they will\nbecome available in the Postman collections Panel ready to be run. \n Notes on QE requests collections structure \n Each collection is so designed to test a particular use case i.e.\n"Delete an existent page", "Delete a page which has children" etc. \n By design each QE Postman collection is: \n \n \n indipendent (does not require other collections) \n \n \n general (does not make any assumption on the specific Entando\napplication) \n \n \n can be run automatically, with newman, please refer to\n https://github.com/entando/entando-QE  for details \n \n \n Following those requirements, each collection will need to "prepare" the\nenvironment for the actual test. That is achieved by using specific\nrequests, called "helpers", and their only purpose is to create/delete\nall the needed objects. \n Another class of helpers is used to check the persistence of the actions\nperformed by the APIs, i.e. check that after a DELETE, something really\nhas been deleted. \n The request that implements the use case, we can call it main request,\ndoes not contain the word "HELPER" in its name, and it is the only one\ninside a given collection. \n Because collections are designed primarily to run automatically, we have\ndone extensive use of collection variables, so variables like the API\nURL, object names, object codes or payloads are usually defined as a\ncollection variable and can be accessed by all requests inside the\ncollection. \n Conclusion \n This guide let you start invoking Entando 6 APIs \n'},{title:"Tutorial: Connecting to an External Database",frontmatter:{},regularPath:"/v6.2/tutorials/customize-the-platform/connecting-external-db.html",relativePath:"v6.2/tutorials/customize-the-platform/connecting-external-db.md",key:"v-012cd40c",path:"/v6.2/tutorials/customize-the-platform/connecting-external-db.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:" Tutorial: Connecting to an External Database \n Overview \n This document provides a guide to connecting to an external database. In\nmany (not all) production configurations it is recommended to use a DBMS\noutside of the cluster where your Entando applicaiton is running to\nsimplify maintenance, duplication of resources, and to establish a\nbackup workflow that will scale with your application. \n See  Databases  for other details on Entando databases. \n Prerequisites \n \n \n An environment to install your Entando applicaiton \n \n \n A running PostgreSQL, MySQL, or Oracle environment \n \n \n Administrator access to the database \n \n \n Network access from your Kubernetes cluster to your database \n Tutorial \n \n In the helm quickstart define a db for your deployment that includes\nthe admin credentials for your database \n \n \n db:\n  vendor: postgresql | mysql | oracle\n  host: <yourhost>\n  port: <yourport>\n  adminUser: <youradmin>\n  adminPassword: <youradminpassword>\n  name: <yourdbname>\n \n \n \n Run the helm quickstart or create a deployment for your Entando\nenvironment manually \n \n Note: The quickstart creates a default configuration for the\ndeployment. This isn’t to suggest that it is the only\nconfiguration or that it matches with every use case. It is\nrecommended to think about your desired deployment Architecture\nand to configure for that environment using the CRDs as building\nblocks. This also isn’t to suggest that if it isn’t directly\nsupported by the quickstart template that you can’t change it.\nThe deployment is editable. Treat the helm template as a\nbootstrapping environment and edit your deployments to match\nyour needs and requirements. \n \n \n \n Open the yaml file generated from the deployment and review the\nsettings for the deployment \n \n The Entando Operator will create a secret for the database\nautomatically and use the DB initializers to create the DB for\nthe Entando app and any services that use it \n \n \n \n Deploy your app \n \n \n"},{title:"Tutorial: How to connect Entando 6 to an external Keycloak instance",frontmatter:{},regularPath:"/v6.2/tutorials/customize-the-platform/change-default-datasources-and-connections/tutorials/how-to-connect-to-external-keycloak.html",relativePath:"v6.2/tutorials/customize-the-platform/change-default-datasources-and-connections/tutorials/how-to-connect-to-external-keycloak.md",key:"v-65da4ddc",path:"/v6.2/tutorials/customize-the-platform/change-default-datasources-and-connections/tutorials/how-to-connect-to-external-keycloak.html",headers:[{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Get keycloak information",slug:"_1-get-keycloak-information"},{level:3,title:"2. Generate the secret",slug:"_2-generate-the-secret"},{level:3,title:"3. Upload the secret",slug:"_3-upload-the-secret"},{level:3,title:"4. Deploy the Entando6 application",slug:"_4-deploy-the-entando6-application"},{level:2,title:"Conclusion",slug:"conclusion"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:' Tutorial: How to connect Entando 6 to an external Keycloak instance \n Purpose \n This tutorial enables the Entando administrator to leverage an existing\nKeycloak instance. \n Requirements \n \n \n A Keycloak instance \n \n \n A realm named "entando" on that instance \n \n \n An admin user for the "entando" realm \n Steps \n 1. Get keycloak information \n Retrieve the relevant information from the Keycloak instance you want to\nuse. \n Specifically you will need: \n \n \n The username of the Keycloak admin that has admin rights to the\n"entando" realm, e.g entando-keycloak-admin \n \n \n The Keycloak admin password, e.g. password123 \n \n \n The base url for the Keycloak server, including the auth value, e.g.\n https://my-keycloak-instance.com/auth \n 2. Generate the secret \n You now need to generate a secret with name  keycloak-admin-secret \nusing the information retrieved from step 1. The Entando administrator\nwill automatically detect this secret by name, and use it to log onto\nthe provided Keycloak server. \n Here is an example of the secret you will need to construct: \n ---\napiVersion: v1\nstringData:\n    username: <the username of the Keycloak admin user for the "entando" realm>\n    password: <the password of this Keycloak admin user>\n    url: <the base url of the Keycloak service, typically ending with the path /auth>\nkind: Secret\nmetadata\n    name: keycloak-admin-secret\n    namespace: <your-app-namespace>\ntype: Opaque\n \n \n Note \n To encode your values, in bash, you can do\n echo <your-value> | base64 \n 3. Upload the secret \n Next upload the secret to the namespace where you want to deploy your\nEntando 6 instance. \n oc create -f my-secret.yaml -n <my-app-namespace>\n 4. Deploy the Entando6 application \n Now you are ready to deploy your Entando 6 application and the\nadministrator will reuse the  keycloak-admin-secret  secret to populate\nthe environment correctly. \n Conclusion \n You should now have a working Entando 6 instance using an external\nKeycloak server. \n'},{title:"Backing Up and Restoring an Entando Application",frontmatter:{},regularPath:"/v6.2/tutorials/devops/backing-up-and-restoring-your-environment.html",relativePath:"v6.2/tutorials/devops/backing-up-and-restoring-your-environment.md",key:"v-5d8b05c6",path:"/v6.2/tutorials/devops/backing-up-and-restoring-your-environment.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Create a Backup",slug:"create-a-backup"},{level:2,title:"Restore a Backup",slug:"restore-a-backup"}],lastUpdated:"12/15/2021, 2:22:26 PM",lastUpdatedTimestamp:1639596146e3,content:' Backing Up and Restoring an Entando Application \n Prerequisites \n \n \n Java 8 \n \n \n Docker installed locally\n( https://docs.docker.com/docker-for-windows/install/ ) \n \n \n maven \n \n \n Access to a docker repository (docker.io or other) \n \n \n This tutorial will show you how you can use an Entando application that\nyou have built as a launching point for creating new applications. \n Create a Backup \n This step requires using a running Entando environment to take an application backup.\nThe output of this step is a local directory with the files (database and static assets) you can use to restore the application later. \n \n \n Log into  App Builder \n \n \n Go to  Configuration -> Database \n \n \n Click on  Create A Backup  and wait for the process to complete. All of the static assets and database backups are persisted to a PVC in /entando-data on the server pod. \n \n \n Transfer the files from the server-container. The details will vary depending on your kubernetes environment. \n \n \n \n \n \n kubectl \n OpenShift \n \n \n \n \n kubectl cp <pod>:<path> <local-path> \n oc rsync <pod>:<path> <localPath> \n \n \n e.g. kubectl cp quickstart-server-deployment-7b8c699599-f84zq:/entando-data backup \n e.g. oc rsync app-entando-server-deployment-67fd5b9954-s72mb:/entando-data \n \n \n \n \n You should see 3 directories -  databases ,  protected , and  resources .\nThe  protected  directory contains the timestamped backup you triggered from the  App Builder . \n Restore a Backup \n In this lab you’ll take a previously built demo application, install the\nbackup files, build a Docker image from the updated app, and deploy it as a new application. \n \n \n Clone the application at:\n https://github.com/entando/entando-de-app  using \n git clone https://github.com/entando/entando-de-app\n \n \n \n On a command line, cd into the  entando-de-app  you just cloned: \n cd entando-de-app\n \n \n \n Take the backup file and unzip it in a location of your choice. \n \n \n This zip contains all of the assets, content, and metadata\nneeded to launch an Entando application. We are going to package\nthe static assets and database backup into a Docker image. \n \n \n Entando will automatically instantiate and populate the app from\nthe most recent backup \n \n \n \n \n Move the resources and protected folders from your Entando backup into your\n entando-de-app  application under  src/main/webapp  replacing any content that is\nalready there. \n \n \n Build a docker image from the app \n mvn clean package -Pwildfly -Pderby docker:build\n \n \n Note that the "derby" option here is only for the initialization\nphase of the DB when deploying. It isn’t the final database\nchoice \n \n \n \n View the images installed on your local docker instance \n docker images\n \n Look for the following: \n entando/entando-de-app:latest\n \n \n \n Create a repository on your docker account to house your new\napplication \n \n \n Re-tag the image you just built with your repo \n  docker tag entando/entando-de-app:latest <YOUR-USER>/<YOUR-REPO-NAME>:latest\n \n \n \n Push the Image to your Repository \n docker push <YOUR-USER>/<YOUR-REPO-NAME>:latest\n \n \n \n Now we need to generate a new application for deployment to\nKubernetes using the helm chart \n \n \n If you have an output from helm from before you can re-use it\nand just apply the changes to the config map. In this case skip to step 12. \n \n \n Or you can re-run helm and change the output \n \n \n \n \n Re-run the helm command for your environment \n \n \n Open the output yaml file from the helm command in the text editor\nof your choice \n \n For example:  vi training-alpha.yaml \n \n \n \n In that file look for the  ConfigMap \n \n \n The config map defines all of the images that are available as\npart of the deployment. They aren’t all used concurrently. \n \n \n You can also view this config map in  kubernetes/OpenShift \n \n \n \n \n Now you need to update the deployment to use your customized Wildfly\nimage. Find  entando-de-app-wildfly  in the config map \n \n Note that we are changing the de-app but you could create a\ncustom version of any of the included images \n \n \n \n Change the version to match the version you used for your image \n \n \n Change the "organization" to the name of your main image repository\norganization and if you aren’t using docker.io (DockerHub) then\nchange the registry as well. \n \n \n Save the file \n \n \n Follow the deployment steps you went through when you originally\ndeployed your Entando application to your Kubernetes instance \n \n \n Once deployed go to the  App Builder  in your app \n \n \n Click  Go To Homepage  and you should see your restored application. \n \n \n'},{title:"Tutorial: Extending the App Builder",frontmatter:{},regularPath:"/v6.2/tutorials/customize-the-platform/extend-app-builder.html",relativePath:"v6.2/tutorials/customize-the-platform/extend-app-builder.md",key:"v-46bd5ad0",path:"/v6.2/tutorials/customize-the-platform/extend-app-builder.html",headers:[{level:2,title:"Creating a Basic Application",slug:"creating-a-basic-application"},{level:2,title:"Understanding the Stand Alone Environment",slug:"understanding-the-stand-alone-environment"},{level:2,title:"Customizing the Menu",slug:"customizing-the-menu"},{level:2,title:"Customizing the menu labels",slug:"customizing-the-menu-labels"},{level:2,title:"Customizing the Routes",slug:"customizing-the-routes"},{level:2,title:"state",slug:"state"},{level:2,title:"Customizing the Reducers",slug:"customizing-the-reducers"},{level:2,title:"userList",slug:"userlist"},{level:3,title:"connecting to the store",slug:"connecting-to-the-store"},{level:2,title:"Page Models",slug:"page-models"},{level:3,title:"Connecting to the Store",slug:"connecting-to-the-store-2"},{level:2,title:"Adding the API Calls",slug:"adding-the-api-calls"},{level:2,title:"Creating the Thunk",slug:"creating-the-thunk"},{level:2,title:"changing the mapDispatchToProps in the containers",slug:"changing-the-mapdispatchtoprops-in-the-containers"},{level:2,title:"Updating the List components",slug:"updating-the-list-components"},{level:2,title:"clear the default value of the reducer",slug:"clear-the-default-value-of-the-reducer"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:" Tutorial: Extending the App Builder \n Apps for the Entando App Builder are developed as standalone\napplications which can be run using  npm start  in standalone mode. \n Each application should be deployed in npm using the  @entando \nnamespace and will export into their dist folder several items used by\nthe App Builder when integrating it into the full application. \n Creating a Basic Application \n To create a basic application, use the  entando\nfpg  running the\n npx @entando/fpg ab-app <appName>  command. \n the  appName  should only contain alphanumeric characters and\nunderscores, and should begin with a letter. \n This will create inside the working directory, a boilerplate app-builder\napp in a directory named  <appName>  argument. \n i.e. \n using the command  npm @entando/fpg ab-app testing  inside your home\ndirectory, a directory named  testing  will be created containing the\napp. \n All dependencies will already be installed allowing you to  cd  inside\nthe project directory and run  npm start  to start the app running. \n Understanding the Stand Alone Environment \n Each app for the App Builder, can run in both a stand alone mode and an\nintegrated mode. Using  npm start  will use standalone mode. \n In this environment you’ll be looking at the user interface of the app\ninside a default page. This page, which includes a default menu, will\nnot be exported and therefore can be customized. \n To better understand which elements and components are being exported to\nApp Builder, it is best to understand the anatomy of the app. \n Exports \n Each app will have a  babel.js  export file similar to: \n      import  menu  from   'ui/common/LinkMenu' ; \n     import   {  cms  as  state  }   from   'state/rootReducer' ; \n     import   {  routes ,  routesDir  }   from   'ui/App' ; \n     import  en  from   'locales/en' ; \n     import  it  from   'locales/it' ; \n\n     const  testing  =   { \n       id :   'testing' , \n      menu , \n      state , \n      routes , \n      routesDir , \n       locales :   { \n        en , \n        it , \n       } , \n     } ; \n\n     export   default  testing ; \n id: is the app id. \n This parameter is used by App Builder to differentiate all integrated\napps. \n menu: is a React component containing all the menu elements. \n These elements are used inside the standalone environment and inside the\nintegrated environment as a second level menu. The boilerplate app\ncontains a basic menu. \n      import  React  from   'react' ; \n     import   {  LinkMenuItem  }   from   '@entando/menu' ; \n     import   {  FormattedMessage  }   from   'react-intl' ; \n\n     const   LinkMenu   =   ( )   =>   ( \n       < > \n         < LinkMenuItem\n          id = \"menu-SECTION_ID\" \n          label = { < FormattedMessage id = \"testing.menu.SECTION_NAME\"  defaultMessage = \"SECTION_NAME\"   / > } \n          to = '/use/const/here/imported/from/routes' \n         / > \n       < / > \n     ) ; \n\n     export   default  LinkMenu ; \n Customizing the Menu \n For this exercise, we will create two links inside the menu. The first\nwill link to a page listing all the users inside the entando instance.\nThe second will list all the existing page templates inside the Entando\ninstance. \n For this example we’re using existing APIs from the Entando core just\nfor simplicity, you can instead call any API or data source. \n In your app project, open  src/ui/common/LinkMenu.js  and update the\nconst to the code below. \n      const   LinkMenu   =   ( )   =>   ( \n       < > \n         < LinkMenuItem\n          id = \"menu-userList\" \n          label = { < FormattedMessage id = \"testing.menu.userList\"  defaultMessage = \"User List\"   / > } \n          to = '/use/const/here/imported/from/routes' \n         / > \n         < LinkMenuItem\n          id = \"menu-pageModelList\" \n          label = { < FormattedMessage id = \"testing.menu.pageModelList\"  defaultMessage = \"Page Model List\"   / > } \n          to = '/use/const/here/imported/from/routes' \n         / > \n       < / > \n     ) ; \n \n it is important that both the  <LinkMenuItem>  id property and the\n`<FormattedMessage>`properties inside label have the correct values\nassigned, i.e.: \n the LinkMenuItem id will be  menu-userList  while the FormattedMessage\nid will be  testing.menu.userList  and the defaultMessage will be\n User List . \n locales \n The locales files are objects that contain all of the i18n locales of\nthe app. \n By default the boilerplate contains both the english and italian i18n\nfiles. \n In your app project in  src/locales/en.js  and  src/locales/it.js  you\ncan see your labels. \n      export   default   { \n       locale :   'en' , \n       messages :   { \n         'testing.title' :   '' , \n         'testing.label.errors' :   '' , \n         'testing.label.cancel' :   '' , \n         'testing.chooseAnOption' :   '' , \n         'testing.tip' :   '' , \n         'testing.new' :   '' , \n         'testing.save' :   '' , \n         'testing.saveAndApprove' :   '' , \n         'testing.unpublish' :   '' , \n         'testing.setContentAs' :   '' , \n         'testing.cancel' :   '' , \n         'testing.saveAndContinue' :   '' , \n         'testing.stickySave.status' :   '' , \n         'testing.stickySave.lastAutoSave' :   '' , \n       } , \n     } ; \n \n While running in standalone mode the boilerplate does not offer a way\nfor the user pick a locale, but both will be loaded inside app-builder\nand will be consumed as intended by it, using the correct one based on\nthe user-picked language. \n It is of course possible to change the standalone app to give the user\nthe option to choose the locale in here as well, but this is not\nsomething will be covering in this tutorial. \n Customizing the menu labels \n To customize the existing menu labels, we’ll add the new label ids\ninside both the english and Italian locale files: \n \n Note \n If you named your app something besides  testing  you’ll need to fix\nthese tags to match the name of your app. \n \n      ... \n     messages :   { \n         ... \n         'testing.menu.userList' :   'List of Users' , \n         'testing.menu.pageModelList' :   'Page Models' , \n         ... \n     } , \n     ... \n \n The key in the messages object matches the id of the\n`<FormattedMessage>`component we placed inside the menu, while its\nvalue is the actual string that will be displayed depending on the\ncurrently active language. \n Routes and RoutesDir \n Both of these elements are imported from  src/ui/App.js . The first one\nis a collection of actual  <Route>  components, and the second one is an\nobject containing each route data, i.e.: \n      export   const  routesDir  =   [ \n       { \n         path :   ROUTE_TESTING , \n         component :   < > app component < / > , \n       } , \n     ] ; \n \n The constant  ROUTE_TESTING  is imported from  src/app-init/routes.js \n Customizing the Routes \n Next we will create the two routes for the two links we have created by\ncreating first the two constants needed. \n In your IDE open  src/app-init/routes.js \n      export   const   ROUTE_TESTING   =   '/testing' ; \n     export   const   ROUTE_USER_LIST   =   '/testing/user-list' ; \n     export   const   ROUTE_PAGE_MODELS   =   '/testing/page-models' ; \n \n \n Note \n Change the value of  testing  to what you selected for the name of\nyour App extension. \n \n The value of each constant will be the path of the route. It is\nimportant that each route is a subroute of the id of the app itself,\notherwise this may cause name collision when running inside the\nintegrated environment of app-builder. \n Both routes are next imported inside  App.js : \n Update the imports with your new ROUTE tags. \n      import   { \n       ROUTE_TESTING , \n       ROUTE_USER_LIST , \n       ROUTE_PAGE_MODELS , \n     }   from   'app-init/routes' ; \n \n and then add to the  routesDir  constant: \n      export   const  routesDir  =   [ \n       { \n         path :   ROUTE_TESTING , \n         component :   < > app component < / > , \n       } , \n       { \n         path :   ROUTE_USER_LIST , \n         render :   ( )   =>   < > user list < / > , \n       } , \n       { \n         path :   ROUTE_PAGE_MODELS , \n         render :   ( )   =>   < > page models < / > , \n       } , \n     ] ; \n \n Next, import the routes constants inside  LinkMenu.js  and change\naccordingly the  to  property of the  <LinkMenuItem>  component: \n      ... \n     import   { \n       ROUTE_USER_LIST , \n       ROUTE_PAGE_MODELS , \n     }   from   'app-init/routes' ; \n\n     const   LinkMenu   =   ( )   =>   ( \n       < > \n         < LinkMenuItem\n          id = \"menu-userList\" \n          label = { < FormattedMessage id = \"tatata.menu.userList\"  defaultMessage = \"User List\"   / > } \n          to = { ROUTE_USER_LIST } \n         / > \n         < LinkMenuItem\n          id = \"menu-pageModelList\" \n          label = { < FormattedMessage id = \"tatata.menu.pageModelList\"  defaultMessage = \"Page Model List\"   / > } \n          to = { ROUTE_PAGE_MODELS } \n         / > \n       < / > \n     ) ; \n     ... \n \n Next clicks on the links in the menu will change the routes and display\nthe content defined in the  App.js  file. \n state \n The state in src/babel.js is the combined reducer of the app, the\nrootReducer.js contains the combined reducer of the app and exports it,\nbut also contains the entire reducer of the app when running in\nstandalone mode. \n      export   const  testing  =   combineReducers ( { \n       // implement here your app specific reducers \n     } ) ; \n\n     export   default   combineReducers ( { \n       apps :   combineReducers ( {  testing  } ) , \n      api , \n      currentUser , \n      form , \n      loading , \n      locale , \n      messages , \n      modal , \n      pagination , \n     } ) ; \n \n The app specific reducers are stored inside the  apps  object, this is\ndone to avoid possible name collisions with any reducer stored inside\napp-builder when running the app in integrated mode. \n Customizing the Reducers \n Next we will be creating the two reducers for the user list and page\nmodels. They will be created inside two new directories\n src/state/apps/testing/userList/  and\n src/state/apps/testing/pageModels . The  types.js  files will contain\nthe two action types that we’ll need. \n userList/types.js \n // eslint-disable-next-line import/prefer-default-export\nexport const ADD_USERS = 'apps/testing/add-users';\n \n pageModels/types.js \n // eslint-disable-next-line import/prefer-default-export\nexport const ADD_PAGE_MODELS = 'apps/testing/page-models/add-page-models';\n \n The value of both constants contain the whole namespace\n apps/testing/REDUCER  this is done to avoid any possible name collision\nwhen running the app in integrated mode. \n Next create both actions files: \n userList/actions.js \n      import   { \n       ADD_USERS , \n     }   from   'state/apps/testing/userList/types' ; \n\n     // eslint-disable-next-line import/prefer-default-export \n     export   const   addUsers   =   users   =>   ( { \n       type :   ADD_USERS , \n       payload :  users , \n     } ) ; \n \n pageModels/actions.js \n      import   { \n       ADD_PAGE_MODELS , \n     }   from   'state/apps/testing/pageModels/types' ; \n\n     // eslint-disable-next-line import/prefer-default-export \n     export   const   addPageModels   =   pageModels   =>   ( { \n       type :   ADD_PAGE_MODELS , \n       payload :  pageModels , \n     } ) ; \n \n then the selectors: \n userList/selectors.js \n      import   {  createSelector  }   from   'reselect' ; \n\n     export   const   getUserList   =   state   =>  state . apps . testing . userList ; \n     export   const  getList  =   createSelector ( getUserList ,   userList   =>  userList . list ) ; \n \n pageModels/selectors.js \n      import   {  createSelector  }   from   'reselect' ; \n\n     export   const   getPageModels   =   state   =>  state . apps . testing . pageModels ; \n     export   const  getList  =   createSelector ( getPageModels ,   pageModels   =>  pageModels . list ) ; \n \n And finally the reducers. The default state is going to contain some\nsample data for us to display. \n userList/reducer.js \n      import   {   ADD_USERS   }   from   'state/apps/testing/userList/types' ; \n\n     const  defaultState  =   { \n       list :   [ \n         { \n           username :   'admin' , \n           registration :   '2018-01-08 00:00:00' , \n           lastLogin :   '2018-01-08 00:00:00' , \n           lastPasswordChange :   '2018-01-08 00:00:00' , \n           status :   'active' , \n           passwordChangeRequired :   true , \n           profileAttributes :   { \n             fullName :   'admin' , \n             email :   'admin@entando.com' , \n           } , \n         } , \n         { \n           username :   'user1' , \n           registration :   '2018-01-08 00:00:00' , \n           lastLogin :   '2018-01-08 00:00:00' , \n           lastPasswordChange :   '2018-01-08 00:00:00' , \n           status :   'disabled' , \n           passwordChangeRequired :   true , \n           profileAttributes :   { \n             fullName :   'User Name' , \n             email :   'user1@entando.com' , \n           } , \n         } , \n       ] , \n     } ; \n\n     const   reducer   =   ( state  =  defaultState ,  action  =   { } )   =>   { \n       switch   ( action . type )   { \n         case   ADD_USERS :   { \n           return   {   ... state ,   list :  action . payload  } ; \n         } \n\n         default :   return  state ; \n       } \n     } ; \n\n     export   default  reducer ; \n \n pageModels/reducer.js \n      import   {   ADD_PAGE_MODELS   }   from   'state/apps/testing/pageModels/types' ; \n\n     const  defaultState  =   { \n       list :   [ \n         { \n           code :   'home' , \n           descr :   'Home Page' , \n           configuration :   { \n             frames :   [ \n               { \n                 pos :   0 , \n                 descr :   'Navbar' , \n                 sketch :   { \n                   x1 :   0 , \n                   y1 :   0 , \n                   x2 :   2 , \n                   y2 :   0 , \n                 } , \n               } , \n               { \n                 pos :   1 , \n                 descr :   'Navbar 2' , \n                 sketch :   { \n                   x1 :   3 , \n                   y1 :   0 , \n                   x2 :   5 , \n                   y2 :   0 , \n                 } , \n               } , \n             ] , \n           } , \n           template :   '<html></html>' , \n         } , \n         { \n           code :   'service' , \n           descr :   'Service Page' , \n           configuration :   { \n             frames :   [ \n               { \n                 pos :   0 , \n                 descr :   'Navbar' , \n                 sketch :   { \n                   x1 :   0 , \n                   y1 :   0 , \n                   x2 :   2 , \n                   y2 :   0 , \n                 } , \n               } , \n               { \n                 pos :   1 , \n                 descr :   'Navbar 2' , \n                 sketch :   { \n                   x1 :   3 , \n                   y1 :   0 , \n                   x2 :   5 , \n                   y2 :   0 , \n                 } , \n               } , \n             ] , \n           } , \n           template :   '<html></html>' , \n         } , \n       ] , \n     } ; \n\n     const   reducer   =   ( state  =  defaultState ,  action  =   { } )   =>   { \n       switch   ( action . type )   { \n         case   ADD_PAGE_MODELS :   { \n           return   {   ... state ,   list :  action . payload  } ; \n         } \n\n         default :   return  state ; \n       } \n     } ; \n\n     export   default  reducer ; \n \n Last, we can add the two reducers just created to the\n src/state/rootReducer.js \n      ... \n     import  userList  from   'state/apps/testing/userList/reducer' ; \n     import  pageModels  from   'state/apps/testing/pageModels/reducer' ; \n\n     export   const  testing  =   combineReducers ( { \n      pageModels , \n      userList , \n     } ) ; \n     ... \n \n we will now be able to see with the  reduxDevTools  in our browser. To\nview this state in your reduxDevTools go to: \n State -→ apps -→ testing -→ pageModels  and\n State -→ apps -→ testing -→ userList \n Creating the UI Components \n At this point, both routes created should be rendering a simple string.\nWe will next create the actual component that will be rendered inside\nthe page. \n userList \n Inside  src/ui/userList/  create the  List  component. Create the\n userList  directory and  List.js  file in that directory. \n      import  React  from   'react' ; \n\n     import   { \n      Grid , \n      TablePfProvider , \n     }   from   'patternfly-react' ; \n\n     const   List   =   ( )   =>   { \n       const  data  =   [ \n         { \n           username :   'admin' , \n           registration :   '2018-01-08 00:00:00' , \n         } , \n         { \n           username :   'user1' , \n           registration :   '2018-01-08 00:00:00' , \n         } , \n       ] ; \n\n       const  tr  =  data . map ( row   =>   ( \n         < tr > \n           < td > { row . username } < / td > \n           < td > { row . registration } < / td > \n         < / tr > \n       ) ) ; \n\n       return   ( \n         < Grid fluid > \n           < TablePfProvider\n            striped\n            bordered\n            hover\n           > \n             < thead > \n               < tr > \n                 < td > username < / td > \n                 < td > registration < / td > \n               < / tr > \n             < / thead > \n             < tbody > \n               { tr } \n             < / tbody > \n           < / TablePfProvider > \n         < / Grid > \n       ) ; \n     } ; \n\n     export   default  List ; \n \n Next, change the route inside  src/ui/App.js . Add the import below and\nupdate the component to reference the List component created in the\nprior step. \n      ... \n     import  List  from   'ui/userList/List' ; \n     ... \n       { \n         path :   ROUTE_USER_LIST , \n         component :  List , \n       } , \n     ... \n \n The table will now display correctly when clicking on the menu item. \n connecting to the store \n Next let’s connect the component to the store to get the data from the\nreducer. \n The first step is creating the  ListContainer.js  next to the  List \ncomponent file. \n      import   {  connect  }   from   'react-redux' ; \n     import   {  getList  }   from   'state/apps/testing/userList/selectors' ; \n\n     import  List  from   'ui/userList/List' ; \n\n     export   const   mapStateToProps   =   state   =>   ( { \n       data :   getList ( state ) , \n     } ) ; \n\n     export   default   connect ( \n      mapStateToProps , \n       null , \n     ) ( List ) ; \n \n And then update the List component to receive the property. The List\nfile should now look like this: \n      import  React  from   'react' ; \n     import  PropTypes  from   'prop-types' ; \n\n     import   { \n      Grid , \n      TablePfProvider , \n     }   from   'patternfly-react' ; \n\n     const   List   =   ( {  data  } )   =>   { \n       const  tr  =  data . map ( row   =>   ( \n         < tr > \n           < td > { row . username } < / td > \n           < td > { row . registration } < / td > \n         < / tr > \n       ) ) ; \n\n       return   ( \n         < Grid fluid > \n           < TablePfProvider\n            striped\n            bordered\n            hover\n           > \n             < thead > \n             < tr > \n               < td > username < / td > \n               < td > registration < / td > \n             < / tr > \n             < / thead > \n             < tbody > \n             { tr } \n             < / tbody > \n           < / TablePfProvider > \n         < / Grid > \n       ) ; \n     } ; \n\n     export   default  List ; \n \n Make sure that you remove the predefined  data  const since the data\nwill now be coming from the reducer, on top of defining PropTypes rules\nfor validating and giving a default for the injected property  data . \n Once complete, update the component used in the route inside  App.js .\nUpdate the import to the container and update the component in\n ROUTE_USER_LIST  to the new ListContainer. \n      ... \n     import  ListContainer  from   'ui/userList/ListContainer' ; \n     ... \n       { \n         path :   ROUTE_USER_LIST , \n         component :  ListContainer , \n       } , \n     ... \n \n Go back to your app. We will now see the data inside the table\nreflecting the content of the storage. \n Page Models \n inside  src/ui/pageModels/  we are going to create the  List  component \n      import  React  from   'react' ; \n     import  PropTypes  from   'prop-types' ; \n\n     import   { \n      Grid , \n      TablePfProvider , \n     }   from   'patternfly-react' ; \n\n     const   List   =   ( {  data  } )   =>   { \n       const  tr  =  data . map ( row   =>   ( \n         < tr > \n           < td > { row . username } < / td > \n           < td > { row . registration } < / td > \n         < / tr > \n       ) ) ; \n\n       return   ( \n         < Grid fluid > \n           < TablePfProvider\n            striped\n            bordered\n            hover\n           > \n             < thead > \n             < tr > \n               < td > username < / td > \n               < td > registration < / td > \n             < / tr > \n             < / thead > \n             < tbody > \n             { tr } \n             < / tbody > \n           < / TablePfProvider > \n         < / Grid > \n       ) ; \n     } ; \n\n    List . propTypes  =   { \n       data :  PropTypes . arrayOf ( PropTypes . shape ( { } ) ) , \n     } ; \n\n    List . defaultProps  =   { \n       data :   [ ] , \n     } ; \n\n     export   default  List ; \n \n Next change the route inside  src/ui/App.js \n      ... \n     import  ListPageModels  from   'ui/pageModels/List' ; \n     ... \n       { \n         path :   ROUTE_PAGE_MODELS , \n         component :  ListPageModels , \n       } , \n     ... \n \n The table will now be displayed correctly when clicking on the menu\nitem. \n Connecting to the Store \n Next, connect the component to the store to get the data from the\nreducer. \n The very first thing we’ll do is create the  ListContainer.js  next to\nthe  List  component file. \n      import   {  connect  }   from   'react-redux' ; \n     import   {  getList  }   from   'state/apps/testing/pageModels/selectors' ; \n\n     import  List  from   'ui/pageModels/List' ; \n\n     export   const   mapStateToProps   =   state   =>   ( { \n       data :   getList ( state ) , \n     } ) ; \n\n     export   default   connect ( \n      mapStateToProps , \n       null , \n     ) ( List ) ; \n \n And then update the List component to receive the property. The whole\nList component will have this content: \n      import  React  from   'react' ; \n     import  PropTypes  from   'prop-types' ; \n\n     import   { \n      Grid , \n      TablePfProvider , \n     }   from   'patternfly-react' ; \n\n     const   List   =   ( {  data  } )   =>   { \n       const  tr  =  data . map ( row   =>   ( \n         < tr > \n           < td > { row . code } < / td > \n           < td > { row . descr } < / td > \n         < / tr > \n       ) ) ; \n\n\n       return   ( \n         < Grid fluid > \n           < TablePfProvider\n            striped\n            bordered\n            hover\n           > \n             < thead > \n             < tr > \n               < td > code < / td > \n               < td > descr < / td > \n             < / tr > \n             < / thead > \n             < tbody > \n             { tr } \n             < / tbody > \n           < / TablePfProvider > \n         < / Grid > \n       ) ; \n     } ; \n\n    List . propTypes  =   { \n       data :  PropTypes . arrayOf ( PropTypes . shape ( { } ) ) , \n     } ; \n\n    List . defaultProps  =   { \n       data :   [ ] , \n     } ; \n     export   default  List ; \n \n Next make sure that you remove the predefined  data  const since the\ndata will be coming from the reducer, on top of defining PropTypes rules\nfor validating and giving a default for the injected property  data . \n Once complete, update the component used in the route inside  App.js \n      ... \n     import  PageModelsListContainer  from   'ui/pageModels/ListContainer' ; \n     ... \n       { \n         path :   ROUTE_PAGE_MODELS , \n         component :  PageModelsListContainer , \n       } , \n     ... \n \n You will now see the data inside the table reflecting the content of the\nstorage. \n Connecting the app to an Entando core instance \n By default the app is using mocks and not connecting to any Entando core\ninstance. \n Because the app is making use of  @entando/apimanager  we can easily\nchange this by setting up two  .env  variables inside the  .env  file in\nthe project root: \n     REACT_APP_DOMAIN=http://localhost:8080/entando-app\n    REACT_APP_USE_MOCKS=false\n \n The  REACT_APP_DOMAIN  must pointing towards the domain and container\nwhere the Entando instance is running and  must not  contain trailing\nslashes. \n Once this is done to make the change happen we will have to stop the app\nusing  ctrl + c  and re run it with  npm start . \n Now the toast stating  This application is using mocks  won’t be popping\nup anymore. \n You can make sure that the configuration is correct by looking at the\nnetwork section in the browser dev tools. By default the app\nautomatically makes an admin login against a plain Entando instance to\nauthenticate the user and to be able to consume any protected api. \n This is not an ideal scenario and it is meant to be used only for\ndebugging purposes for many reasons: \n \n \n the username and password should never be hardcoded in your app \n \n \n if authentication is required the user should be the one performing\nthe login action \n \n \n the plain default passwords in use won’t be useful against a proper\nproduction instance of Entando \n Adding the API Calls \n We are now going to add api calls for both users and page models to\nretrieve the data live instead of relying on our store’s default state. \n Inside  src/api  create the  users.js  file: \n      import   {  makeRequest ,   METHODS   }   from   '@entando/apimanager' ; \n\n     // eslint-disable-next-line import/prefer-default-export \n     export   const  getUsers  =   ( page  =   {   page :   1 ,   pageSize :   10   } ,  params  =   '' )   =>   ( \n       makeRequest ( \n         { \n           uri :   ` /api/users ${ params } ` , \n           method :   METHODS . GET , \n           mockResponse :   { } , \n           useAuthentication :   true , \n         } , \n        page , \n       ) \n     ) ; \n \n and then create the  pageModels.js  file: \n      import   {  makeRequest ,   METHODS   }   from   '@entando/apimanager' ; \n\n     // eslint-disable-next-line import/prefer-default-export \n     export   const  getPageModels  =   ( page  =   {   page :   1 ,   pageSize :   10   } ,  params  =   '' )   =>   makeRequest ( { \n       uri :   ` /api/pageModels ${ params } ` , \n       method :   METHODS . GET , \n       mockResponse :   { } , \n       useAuthentication :   true , \n     } ,  page ) ; \n Creating the Thunk \n In order to use the api call we next create a thunk action, which is a\nredux action with side effects, like an API call. \n inside the  src/state/apps/testing/userList/actions.js  file we are\ngoing to add the new action: \n      ... \n     import   {  addErrors  }   from   '@entando/messages' ; \n     import   { \n      getUsers , \n     }   from   'api/users' ; \n     ... \n\n     // thunks \n\n     export   const  fetchUsers  =   ( page  =   {   page :   1 ,   pageSize :   10   } ,  params  =   '' )   =>   dispatch   =>   ( \n       new   Promise ( ( resolve )   =>   { \n         getUsers ( page ,  params ) . then ( ( response )   =>   { \n          response . json ( ) . then ( ( json )   =>   { \n             if   ( response . ok )   { \n               dispatch ( addUsers ( json . payload ) ) ; \n             }   else   { \n               dispatch ( addErrors ( json . errors . map ( err   =>  err . message ) ) ) ; \n             } \n             resolve ( ) ; \n           } ) ; \n         } ) . catch ( ( )   =>   { } ) ; \n       } ) \n     ) ; \n \n Next do the same inside  src/state/apps/testing/pageModels/actions.js : \n      ... \n     import   {  addErrors  }   from   '@entando/messages' ; \n     import   { \n      getPageModels , \n     }   from   'api/pageModels' ; \n     ... \n\n     // thunks \n\n     export   const  fetchPageModels  =   ( page  =   {   page :   1 ,   pageSize :   10   } ,  params  =   '' )   =>   dispatch   =>   ( \n       new   Promise ( ( resolve )   =>   { \n         getPageModels ( page ,  params ) . then ( ( response )   =>   { \n          response . json ( ) . then ( ( data )   =>   { \n             if   ( response . ok )   { \n               dispatch ( addPageModels ( data . payload ) ) ; \n               resolve ( ) ; \n             }   else   { \n               dispatch ( addErrors ( data . errors . map ( err   =>  err . message ) ) ) ; \n               resolve ( ) ; \n             } \n           } ) ; \n         } ) . catch ( ( )   =>   { } ) ; \n       } ) \n     ) ; \n \n Now with two exports, it is safe to remove the\n eslint-disable-next-line  comment on line 5 of both files. \n changing the mapDispatchToProps in the containers \n Next, in order to pass the newly created thunk to both List components,\nwe’ll update the containers accordingly, as: \n src/ui/userList/ListContainer.js \n      ... \n     import   {  fetchUsers  }   from   'state/apps/testing/userList/actions' ; \n     ... \n     export   const   mapDispatchToProps   =   dispatch   =>   ( { \n       fetch :   ( )   =>   dispatch ( fetchUsers ( ) ) , \n     } ) ; \n\n     export   default   connect ( \n      mapStateToProps , \n      mapDispatchToProps , \n     ) ( List ) ; \n \n src/ui/pageModels/ListContainer.js \n      ... \n     import   {  fetchPageModels  }   from   'state/apps/testing/pageModels/actions' ; \n     ... \n     export   const   mapDispatchToProps   =   dispatch   =>   ( { \n       fetch :   ( )   =>   dispatch ( fetchPageModels ( ) ) , \n     } ) ; \n\n     export   default   connect ( \n      mapStateToProps , \n      mapDispatchToProps , \n     ) ( List ) ; \n Updating the List components \n Both List components were simple components with only a  render  method,\ntherefore could be declared as simple constants. \n Next we will fetch data during the  componentDidMount  life cycle event\nwhich will require we turn the constant into a class on top of changing\nthe PropTypes to add the new fetch method passed down to the component. \n src/ui/userList/List.js \n      import  React ,   {  Component  }   from   'react' ; \n     ... \n     class   List   extends   Component   { \n       componentDidMount ( )   { \n         const   {  fetch  }   =   this . props ; \n         fetch ( ) ; \n       } \n\n       render ( )   { \n         const   {  data  }   =   this . props ; \n         const  tr  =  data . map ( row   =>   ( \n           < tr > \n             < td > { row . username } < / td > \n             < td > { row . registration } < / td > \n           < / tr > \n         ) ) ; \n\n         return   ( \n           < Grid fluid > \n             < TablePfProvider\n              striped\n              bordered\n              hover\n             > \n               < thead > \n                 < tr > \n                   < td > username < / td > \n                   < td > registration < / td > \n                 < / tr > \n               < / thead > \n               < tbody > \n                 { tr } \n               < / tbody > \n             < / TablePfProvider > \n           < / Grid > \n         ) ; \n       } \n     } \n\n    List . propTypes  =   { \n       data :  PropTypes . arrayOf ( PropTypes . shape ( { } ) ) , \n       fetch :  PropTypes . func , \n     } ; \n\n    List . defaultProps  =   { \n       data :   [ ] , \n       fetch :   ( )   =>   { } , \n     } ; \n \n src/ui/pageModels/List.js \n      import  React ,   {  Component  }   from   'react' ; \n     ... \n     class   List   extends   Component   { \n       componentDidMount ( )   { \n         const   {  fetch  }   =   this . props ; \n         fetch ( ) ; \n       } \n\n       render ( )   { \n         const   {  data  }   =   this . props ; \n         const  tr  =  data . map ( row   =>   ( \n           < tr > \n             < td > { row . code } < / td > \n             < td > { row . descr } < / td > \n           < / tr > \n         ) ) ; \n\n         return   ( \n           < Grid fluid > \n             < TablePfProvider\n              striped\n              bordered\n              hover\n             > \n               < thead > \n                 < tr > \n                   < td > code < / td > \n                   < td > descr < / td > \n                 < / tr > \n               < / thead > \n               < tbody > \n                 { tr } \n               < / tbody > \n             < / TablePfProvider > \n           < / Grid > \n         ) ; \n       } \n     } \n\n    List . propTypes  =   { \n       data :  PropTypes . arrayOf ( PropTypes . shape ( { } ) ) , \n       fetch :  PropTypes . func , \n     } ; \n\n    List . defaultProps  =   { \n       data :   [ ] , \n       fetch :   ( )   =>   { } , \n     } ; \n clear the default value of the reducer \n Now we should be fetching data from the server, therefore we can safely\nmake the list key in the  defaultState  object an empty array: \n src/state/apps/testing/userList/reducer.js \n      ... \n     const  defaultState  =   { \n       list :   [ ] , \n     } ; \n     ... \n \n src/state/apps/testing/pageModels/reducer.js \n      ... \n     const  defaultState  =   { \n       list :   [ ] , \n     } ; \n     ... \n adding additional dependencies \n It may be necessary to set additional dependencies for your project. If\nthe need arises, it is important to remember a few rules: \n Only actual dependencies that are not already included in  app-builder \ncan be added as pure dependencies. Every other dependency must either be\na  devDependency  or  peerDependency . \n If you are not careful you may end up with duplicated dependencies that\n will  result in errors manifesting themselves when running the app\ninside App Builder. \n running the app in integrated mode within App Builder \n After running  npm install  in the App Builder, the user can run the\n npm run app-install <appId>  command to install the app. \n This command will trigger a download of the app from npm and the\ninstallation of its component within App Builder. After the installation\nprocess is complete, it will be possible to either  npm start  or\n npm build  App Builder. \n To install a dev app, like the one developed in this tutorial which have\nnot been previously published on npm, you will need to use additional\nflags and will have to run a few additional commands. \n Before running the Install command  make sure that you have\nuninstalled all existing peer and dev dependencies to avoid collision\nwith app builder. To do so, from the app builder app directory\n( testing , in this tutorial) just run in the correct order the\nfollowing commands: \n npm run babel \n npm i --only=production \n The first will create the dist directory that will be needed by App\nBuilder while the second one will uninstall anything but production\ndependencies. \n Next, from the App Builder directory, run the install command with these\nadditional flags: \n \n \n -d  specify the relative path where the app is installed. When\nusing this flag the appId should be the normalized app name, without\nthe  @entando/  prefix. \n \n \n -p  specify the package name if it is different from the appId \n \n \n to use flags you will have to use the double dash in the command: \n npm run app-install —  cms -d ../testing -p @entando/testing \n the value in the  -p  flag should always match the actual name of the\napp that is going to be installed inside App Builder . You can check\nyour app name inside the  package.json  file of your app. \n If you experience problems after running the build command delete the\n node_modules  directory before running the second command. \n"},{title:"Building a Docker Image for the Entando Core",frontmatter:{},regularPath:"/v6.2/tutorials/devops/build-core-image.html",relativePath:"v6.2/tutorials/devops/build-core-image.md",key:"v-2659ff40",path:"/v6.2/tutorials/devops/build-core-image.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Introduction",slug:"introduction"},{level:2,title:"Setup",slug:"setup"}],lastUpdated:"12/15/2021, 2:22:26 PM",lastUpdatedTimestamp:1639596146e3,content:" Building a Docker Image for the Entando Core \n Prerequisites \n \n \n Java 8 \n \n \n Docker installed locally\n( https://docs.docker.com/docker-for-windows/install/ ) \n \n \n maven \n \n \n Access to a docker repository (docker.io or other) \n Introduction \n This tutorial will take you through the basic steps to create a docker\nimage from an Entando core application. A more detailed guide with\nadditional commands and configuration can be found here: \n https://github.com/entando/entando-de-app \n Setup \n \n \n Clone the application at:\n https://github.com/entando/entando-de-app  using \n git clone https://github.com/entando/entando-de-app\n \n \n \n On a command line, cd into the entando-de-app you just cloned: \n cd entando-de-app\n \n \n \n Build a docker image from the core app \n mvn clean package -Pwildfly -Pderby docker:build\n \n \n \n View the images installed on your local docker instance \n docker images\n \n Look for \n entando/entando-de-app:latest\n \n \n \n Create a repository on your docker repository to house your new\napplication \n \n \n Re-tag the image you just built with your repo \n  docker tag entando/entando-de-app:latest <YOUR-USER>/<YOUR-REPO-NAME>:latest\n \n \n \n Push the Image to your Repository \n docker push <YOUR-USER>/<YOUR-REPO-NAME>:latest\n \n \n \n"},{title:"Business Objective",frontmatter:{},regularPath:"/v6.2/tutorials/customize-the-platform/pda-tutorial.html",relativePath:"v6.2/tutorials/customize-the-platform/pda-tutorial.md",key:"v-102cf958",path:"/v6.2/tutorials/customize-the-platform/pda-tutorial.html",headers:[{level:2,title:"Micro Frontend",slug:"micro-frontend"},{level:2,title:"Process Automation Manager (PAM)",slug:"process-automation-manager-pam"},{level:2,title:"Business Process Modeling Notation (bpmn)",slug:"business-process-modeling-notation-bpmn"},{level:2,title:"Decision Model and Notation (dmn)",slug:"decision-model-and-notation-dmn"},{level:2,title:"Back End for Front End (BFF)",slug:"back-end-for-front-end-bff"},{level:2,title:"Task List",slug:"task-list"},{level:3,title:"PAM Implementation",slug:"pam-implementation"},{level:2,title:"Task Details",slug:"task-details"},{level:3,title:"PAM Implementation",slug:"pam-implementation-2"},{level:2,title:"Task Comments",slug:"task-comments"},{level:3,title:"PAM Implementation",slug:"pam-implementation-3"},{level:2,title:"Task Forms",slug:"task-forms"},{level:3,title:"PAM Implementation",slug:"pam-implementation-4"},{level:2,title:"Attachments",slug:"attachments"},{level:3,title:"PAM Implementation",slug:"pam-implementation-5"},{level:2,title:"New Process Form",slug:"new-process-form"},{level:2,title:"Summary Card",slug:"summary-card"},{level:3,title:"PAM Implementation",slug:"pam-implementation-6"},{level:2,title:"Totals Over Time",slug:"totals-over-time"},{level:3,title:"PAM Implementation",slug:"pam-implementation-7"},{level:2,title:"Styling",slug:"styling"},{level:2,title:"Implementing a New Engine or Integrating a New Task Source",slug:"implementing-a-new-engine-or-integrating-a-new-task-source"},{level:2,title:"Page Templates and Layout",slug:"page-templates-and-layout"},{level:2,title:"Creating a new PDA MFE",slug:"creating-a-new-pda-mfe"},{level:2,title:"Communication between MFEs",slug:"communication-between-mfes"},{level:2,title:"Micro Frontend Overview",slug:"micro-frontend-overview"},{level:3,title:"Task forms",slug:"task-forms-2"},{level:2,title:"Widgets",slug:"widgets"},{level:2,title:"Building From source",slug:"building-from-source"},{level:2,title:"Code Style",slug:"code-style"},{level:2,title:"Sonar",slug:"sonar"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:' Business Objective \n The Entando Process Driven Applications plugin is built to provide a\nrich and full featured user experience to allow for the management and\ncompletion of business processes and automation. The UX is delivered a\ngeneral purpose UX layer built using micro frontends that can be\nutilized for any business process or task engine. Customers drive the UX\nlayer by utilizing a pre-developed Entando integration or by\nimplementing a set of interfaces on the server side. The backend is a\nSpring Boot microservice that provides a pluggable interface allowing\nfor the injection of any underlying process or automation toolkit. The\ninterfaces and steps for creating a new PDA backend implementation are\nprovided below. This document provides an overview of the Entando\nProcess Driven Apps (PDA) plugin. The initial section covers the\nbusiness functionality and user facing micro frontends. The second\nsection covers the architecture and the points of extension for the PDA\nplugin. The third provides a detailed technical overview for developers\nto add new functionality to a PDA implementation. \n Terminology \n Micro Frontend \n A Micro frontend architecture is an approach to developing web\napplication as a composition of small frontend apps. Instead of writing\na large monolith frontend application, the application is broken down\ninto domain specific micro frontends, which are self-contained and can\nbe developed and deployed independently. \n Process Automation Manager (PAM) \n A business process automation engine built and maintained by Red Hat \n Business Process Modeling Notation (bpmn) \n Business Process Model and Notation (BPMN) is a graphical representation\nfor specifying business processes in a business process model. \n Decision Model and Notation (dmn) \n Decision Model and Notation is a standard published by the Object\nManagement Group. It is a standard approach for describing and modeling\nrepeatable decisions within organizations to ensure that decision models\nare interchangeable across organizations. \n Back End for Front End (BFF) \n A microservice architecture allows teams to iterate quickly and to\ndevelop technology to scale rapidly. The Backend for Frontend (BFF)\narchitecture is a type of pattern built with microservices. The key\ncomponent of this pattern is an application that connects the front-end\nof your application with the backend. This BFF Code Pattern will help\nyou build that component according to IBM’s best practices. \n PDA Micro Frontends \n This section provides an overview of each of the micro frontends (MFE)\nthat are available as part of the Entando PDA plugin. In cases below\nwhere there are details specific to the PAM implementation they are\nprovided for that MFE. When extending the integration layer to other\nengines or custom implementations it will be up to the integrating team\nto define behavior and datasource for each MFE. \n Task List \n The task list MFE provides a user with a list of visible tasks that are\neither assigned to that user or that are potentially ownable by that\nuser. In the default implementation the visible tasks are limited to a\nsingle process instance. At configuration time the application designer\nis given the option to select a set of columns that will be visible in\nthe task list for that page. \n PAM Implementation \n The default PAM implementation makes the top level task fields available\nin the task list for selection. It is possible to fetch task and process\nvariables for rendering in the task list but these values are excluded\nby default due to the additional API call overhead required. \n Task Details \n The task details MFE renders detailed information about a given task.\nThe task details widget is intended to give the final user processing a\ntask the information necessary to complete the task at hand. The task\ndetails are rendered in a read only grid. See the styling section below\nfor changing and customizing the layout. \n PAM Implementation \n The PAM integration renders task variables in the task details widget. \n Task Comments \n The task comments MFE gives the user the ability to view notes attached\nto a given task and to add new notes to a task. \n PAM Implementation \n The PAM implementation reads and publishes notes to the comments\nendpoint \n Task Forms \n The task form implementation renders a form specific to a task and gives\nthe user the ability to complete that form. The form implementation is a\nwrapper around a JSON schema that describes the layout, style and\ncontent of the form. It is up to the backend implementation to transform\nto the schema and default ux layout needed to render the form. See the\ntechnical documentation below for more on the JSON schema based\nimplementation. \n PAM Implementation \n The PAM implementation of forms depends on the presence of a form\ndefinition being present on the PAM task. The Entando PAM engine\nimplementation transforms from the PAM format to the JSON schema to\nrender the form. And it transforms the API format back to the PAM format\nbased on the form definition in PAM. There are some limitations on form\ncustomization due to the format required to return data to PAM. See the\nforms section in the technical documentation for more information. \n Attachments \n The attachments MFE gives the user to view documents attached to a\ntask/case/process and to add new documents to a task/case/process. \n PAM Implementation \n The PAM implementation posts the documents to the PAM endpoints for\nstorage. Future features will include using Entando document storage for\nstoring documents and a pluggable document management interface. \n New Process Form \n The new process form renders a form that allows the final user to\nprovide the information necessary to instantiate a new business process\ninstance. The technology for generating the process form is the same as\nthe JSON schema definition used for task forms. === PAM Implementation\nThe PAM implementation depends on a form definition being attached to\nthe process definition. Entando transforms the PAM representation into a\nJSON schema form that can be rendered to the final user. \n Summary Card \n The summary card MFE provides a view into aggregate data for the process\nimplementation. The rendered information includes a total value, a trend\nvalue, and a selector for timeframe. The summary card allows the\napplication developer to select a request for rendering the requested\ninformation which maps to a call in the underlying engine to provide the\nsummarized data. \n PAM Implementation \n The PAM implementation of the summary card widget relies on the PAM\ncustom query functionality. The PAM PDA engine exposes configuration\nthat allows users/developers to define a custom query in a config file\nthat will be executed to render the summary card. This implementation\nallows the data rendered on the summary cards to be changed via\nconfiguration. In the application there is a properties file that allows\nthe implementer to provide a custom query for each of the cards. \n Totals Over Time \n The totals over time MFE provides a dual axis line/bar graph providing\ntrend information about the process environment. The MFE also provides\nthree summary values for comparison over the same time period. \n PAM Implementation \n The PAM implementation of the totals over time MFE utilizes custom\nqueries to fetch the summary data rendered in the chart. The queries\nused in the implementation are defined in configuration files in the MFE\nand can be updated to render data specific to a given implementation. \n Customizing the Process Driven Application \n Styling \n The Entando PDA MFEs are styled via a material UI theme. That theme can\nbe downloaded and updated here:\n https://github.com/entando/frontend-libraries/tree/master/packages/entando-ui \n Implementing a New Engine or Integrating a New Task Source \n Implementing a new Engine for Process Driven Applications means to\ncreate a new Java Project and implement the interfaces defined in the\npda-core-engine project. So, the new project should include the\npda-core-engine as a dependency. To see an implementation in action,\ntake a look at the pda-redhatpam-engine project, which implements the\nRed Hat PAM engine integration. After the engine is implemented, the JAR\nfile resulting from the implementation should be available in the\nclasspath for entando-process-driven-plugin, which is the project that\nis ultimately executed and exposes the Rest APIs for the frontend\napplication. One way to do that is by publishing the engine\nimplementation to a Maven repository and adding it as a dependency to\nthe entando-process-driven-plugin project. Below are the descriptions of\nthe key classes and interfaces in the pda-core-engine project that need\nto be inherited or implemented when creating a new engine\nimplementation: \n \n \n Engine: This class represents a BPM engine and exposes the services\nthat are available for that specific implementation. It is intended\nto be inherited and the subclass should provide the real\nimplementation for each service by calling the superclass\nconstructor with the service implementations as arguments. If any\nservice is not supported, a null value should be passed to the\ncorresponding constructor argument. The engine can provide\nimplementations for the the following service interfaces: \n \n \n TaskService: defines service methods for task retrieval from the\nBPM engine. \n \n \n TaskDefinitionService: defines service methods related to task\ndefinition. A task definition specifies which fields or columns\nare available for all task instances. \n \n \n TaskCommentService: defines service methods related to task\ncomment manipulation. It should be implemented if the task\ncomment is supported by the engine. \n \n \n TaskAttachmentService: defines service methods to operate on\ntask attachments. It should be implemented if the engine\nsupports file attachment on the task. \n \n \n TaskFormService: defines service methods for task form\noperations, like retrieving the form definition and submitting a\nform. The Form object can be used to render a form dynamically. \n \n \n TaskLifecycleService: defines service methods related to the\ntask lifecycle. The lifecycle operations move the task from one\nstate to another. \n \n \n TaskLifecycleBulkService: defines methods for bulk lifecycle\noperations. Like the TaskLifecycleService, methods here move the\ntask from one state to another, but this interface works with\nmultiple tasks at a time. \n \n \n ProcessService: defines service methods for process definitions\noperations. \n \n \n ProcessFormService: defines service methods for process form\noperations, like retrieving the form definition and submitting a\nform. The Form object can be used to render a form dynamically. \n \n \n GroupService: define service methods related to groups from the\nBPM engine. \n Page Templates and Layout \n Page templates are page templates that facilitate rapid development of\npages and allow adding pre-made components - widgets - just by drag &\ndropping. Templating language used in page templates is parsed by Apache\nFreeMarker template engine. To create a new page model, go to the Admin\npanel and select UX Pattern > Page Templates. Press “Add” and you will be\nredirected to the page template creation screen. Add the page template code\nand page template name. Depending on the version you are using you will\nneed to provide a XML or JSON schema. This schema is used to generate\nthe page layout in page configuration screen - it’s used to drag & drop\nwidgets on the page and helps users visualize where each widget will be\nplaced on the page. Basic schema could look like this \n {\n  "frames": [\n    {\n      "pos": 0,\n      "descr": "Widget description",\n      "mainFrame": false,\n      "defaultWidget": null,\n      "sketch": {\n        "x2": 1,\n        "y2": 0,\n        "x1": 0,\n        "y1": 0\n      }\n    }\n  ]\n}\n \n Each item in the frames array represents a widget frame (slot). \n \n \n pos - a position index (starts from zero); this value is used in\nAPIs to address specific widget on the page \n \n \n descr - widget frame description that is displayed in page\nconfiguration screen \n \n \n mainFrame - The primary frame on the page template \n \n \n defaultWidget - widget code for a default widget to use in this\nframe; page template developer can help out users and suggest the\ndefault widgets to use (e.g., header and footer widgets) \n \n \n sketch - an object with 4 coordinates on x and y axises; this allows\nthe developer to place the widgets on the visual representation of\nthe page template’s frames. \n \n \n Sketch’s x and y values go from 0 to 11 (similar to columns in\nBootstrap), so if you want to place a 2x2 frame at the top left corner\nof the page, the values would be x1: 0, x2: 1 y1: 0 y2: 1. \n After you create the JSON/XML schema for the widgets, you can start\nworking on the page template itself. It’s a HTML template that contains\nreferences to the frames you have added in schema. To add a frame in a\nspecific place of the page, just add  <@wp.show frame=0 /> , where frame\nis the pos variable from the schema. Do not forget to add\n <#assign wp=JspTaglibs["/aps-core"]>  at the top of your template, it\nwill provide access to wp variable. \n After you are done with your page template, go to Page designer > Page\ntree and create a new page by pressing “Add”. Fill the needed\ninformation and under Settings > Page Template select your newly created\npage template. Press “Save and Configure” and you will be redirected to the\npage configuration screen where you will be able to drag & drop the\navailable widgets onto the free frames. Set up your widgets (not all\nframes need to be filled) and publish the page. To see your page you can\npress “Preview” or go to\n `<YOUR_ENVIRONMENT_URL>/<LOCALE>/<PAGE_CODE>.page . If your pages\nshare common parts such as GTM scripts, consider using fragments.\nFragments are like shared code snippets - just add <@wp.fragment\ncode="<FRAGMENT_CODE>" escapeXml=false /> to your page template and\nthe code inside the fragment will be added to your page. \n Creating a new PDA MFE \n There are no limitations on the stack that could be used to create PDA\nMFEs. Custom Elements are a great way to hide implementation details\nwhile providing a neutral interface to others. To create a simple PDA\nMFE, implement your solution using technologies you are familiar with\nand wrap it in a custom element. Build your solution with a custom\nelement and upload the built files (Settings > File Browser) in\n/public/ folder. Go to  UX Pattern > Widget  section of the admin panel\nand press “Add” to add a new widget. Enter widget code, titles, select\ngroup (for free access to everybody, select “Free Access”), and fill the\nCustom UI: \n <#assign wp=JspTaglibs["/aps-core"]>\n<script src="<@wp.resourceURL />path/from/static/bundle.js"><\/script>\n<your-custom-element parameter=”value” />\n \n <#assign wp=JspTaglibs["/aps-core"]>  - provides access to wp variable\nthat is used to get resource URL. After you add the widget, go to the\npage tree, select a page where you would like to use the widget and\nconfigure it. Drag and drop the widget into a frame and publish the\npage. \n Communication between MFEs \n Communication between MFEs can be achieved using Custom Events. Each\nwidget can define events that it will emit and register to events that\nare important to it. \n const createWidgetEvent = eventType => {\n  return payload => {\n    const widgetEvent = new CustomEvent(eventType, { payload });\n    window.dispatchEvent(widgetEvent);\n  };\n};\n\n\nconst subscribeToWidgetEvent = (eventType, eventHandler) => {\n  window.addEventListener(eventType, eventHandler);\n  return () => {\n    window.removeEventListener(eventType, eventHandler);\n  };\n};\n \n Custom element then creates the events it emits and registers to the\nevents that it wants to react to \n constructor(props) {\n  super(props);\n\n  // other code\n\n  this.onClickSubmit = createWidgetEvent(‘myWidget.onSubmit’);\n}\n\nconnectedCallback() {\n\n  // other code\n\n  this.unsubscribeFromWidgetEvents = subscribeToWidgetEvent(\n    ‘otherWidget.onClickClear’,\n    () => {\n      // callback function when otherWidget fires the onClickClear custom event\n    }\n  }\n}\n Technical Documentation \n Micro Frontend Overview \n Task forms \n Widgets containing form (e.g., task completion form widget) use JSON\nschema to dynamically create forms. Widget implementation uses\nreact-jsonshema-form library that converts forms’ JSON schemas into\nReact components. Our initial implementation uses Material UI components\nvia Material UI theme library rjsf-material-ui as baseline and has\nEntando specific templates, widgets and fields (which are\nreact-jsonshema-form terms for parts of forms). In this section you will\nlearn about basic setup of the form, but if you would like to learn\nmore, please refer to react-jsonshema-form documentation. Themed JSON\nform is created using the withTheme() method from the\nreact-jsonschema-form package \n import { withTheme } from \'react-jsonschema-form\';\nimport { Theme as MuiRJSForm } from \'rjsf-material-ui\';\n\nconst JSONForm = props => {\n\n  const ThemedForm = withTheme(MuiRJSForm);\n\n  // ...\n\n  return (\n    <ThemedForm\n    schema={formSchema}\n    uiSchema={uiSchema}\n    {...customTemplates}\n    widgets={customWidgets}\n    formData={formData}\n    onSubmit={e => onSubmitForm(e)}\n    >\n  );\n};\n\nexport default JSONForm;\n \n For JSON Form to work, the form schema is mandatory. It’s a JSON\ndefinition of the form’s structure. Users can also provide form data via\nformData variable, which should follow the structure of JSON schema; and\nUI schema using uiSchema variable, which allows users to customise the\nform’s UI (components, rules, types, etc.) To test JSON schema, UI\nschema and form data, you can use react-jsonschema-form sandbox\nenvironment. Custom Entando templates, widgets, and fields provide a\npossibility to customise the layout of the form using Grid components.\nTo specify what area a field or subform should fill, users can provide\nsize parameter in UI schema’s ui:options object. Size refers to Material\nUI’s grid column widths (Material UI documentation) where the area the\nfrom can take up is divided into 12 columns and value 12 (a default\nvalue if size is not provided) means the field or subform should take up\nall 12 columns. That means that size should be a value from 1 to 12. If\ntwo fields that are next to each other have size values 8 and 4\nrespectively - they will fit into one row, first field being 2 times\nwider than the second field. User can also provide innerSize parameter\nto size the input inside the field. This helps with formatting - if user\nwants a two column layout and have smaller input fields inside these\ncolumns. Multicolumn layout can also be achieved using\ngenerateColumnedOFT(columnSize) functionality, basically providing the\ndefault columnSize to the created form. generateColumnedOFT returns an\nObjectFieldTemplate that is used as a template for all object fields\n(fields that contain properties inside of them). To help us understand\nthe mapping between JSON schema and UI schema lets define an example\nschema: \n {\n  "$schema": "http://json-schema.org/draft-07/schema#",\n  "$id": "http://entando.org/schemas/pda-form.json",\n  "title": "Mortgage Application Form",\n  "type": "object",\n  "properties": {\n    "Application": {\n      "title": "Application",\n    "type": "object",\n    "required": [],\n    "properties": {\n        "mortgageamount": {\n          "type": "integer",\n          "title": "Mortgage amount",\n          "description": "Mortgage amount"\n        },\n        "downpayment": {\n          "type": "integer",\n          "title": "Down Payment",\n          "description": "Down Payment"\n        },\n        "applicant": {\n          "title": "Applicant",\n          "type": "object",\n          "required": [],\n          "properties": {\n            "name": {\n              "type": "string",\n              "title": "Name",\n              "description": "Name",\n              "maxLength": 100\n            },\n            "annualincome": {\n              "type": "integer",\n              "title": "Annual Income",\n              "description": "Annual Income"\n            }\n          }\n        },\n        "property": {\n          "title": "Property",\n          "type": "object",\n          "required": [],\n          "properties": {\n            "age": {\n              "type": "integer",\n              "title": "Age of property",\n              "description": "Age of property"\n            },\n            "address": {\n              "type": "string",\n              "title": "Address of property",\n              "description": "Address of property",\n              "maxLength": 100\n               }\n          }\n        }\n      }\n    },\n    "inlimit": {\n      "type": "boolean",\n    "title": "Is mortgage application in limit?"\n    }\n  }\n}\n \n From this JSON (you can copy & paste it into the react-jsonschema-form\nsandbox) we can see that there is a main form with a title “Mortgage\nApplication Form”. Root “Mortgage Application Form” form has two\nproperties - one is a subform  Application  and the second one is just a\ncheckbox field (field ID is inlimit). Application subform contains 2\nfields: Mortgage amount (field ID is mortgageamount) and Down Payment\n(field ID is downpayment); and two subforms - Applicant (field ID is\napplicant) and Property (field ID is property). Applicant subform\ncontains 2 fields - Name (field ID is name) and Annual Income (field ID\nis annualincome). Property subform contains 2 fields - Age of property\n(field ID is age) and Address of property (field ID is address) By\ndefault (without providing UI schema) they are all listed one field per\nrow. To use Entando’s implementation of Grid layout, users have to\nprovide UI schema with details about each field. For example, if we\nwould like to have a layout that looks like this (fields are marked\n [ field name ] ): \n +----------------------------------------------------------------------------+\n| Mortgage Application Form                                                  |\n+----------------------------------------------------------------------------+\n| Application                                                                |\n+----------------------------------+-----------------------------------------+\n| [Mortgage amount]                | [Down Payment]                          |\n+----------------------------------+-----------------+-----------------------+\n| Applicant                                          | Property              |\n+----------------------------------+-----------------+-----------------------+\n| [Name]                           | [Annual Income] | [Age of property]     |\n+----------------------------------+-----------------+-----------------------+\n|                                                    | [Address of property] |\n+----------------------------------------------------+-----------------------+\n \n To set up the UI schema you have to define each field you want to\ncustomise by addressing using the field IDs - to add options to\nApplicant’s Name field, you will have to create an object tree going\nfrom root object through Application —> Applicant —> Name (using IDs\nit’s Application.applicant.name). UI schema for the table layout defined\nabove would look like this: \n {\n  Application: {\n    \'ui:options\': {\n      size: 12, // <-- this value is not mandatory as size is 12 columns-wide by default\n    },\n    mortgageamount: {\n      \'ui:disabled\': true, // <-- user can define fields disabled at UI schema level\n      \'ui:options\': {\n        size: 6, // <-- Mortgage amount field should take up half of the row\n      },\n    },\n    downpayment: {\n      \'ui:options\': {\n        size: 4, // <-- Down payment field should take up the other half of the row\n      },\n    },\n    applicant: {\n      \'ui:options\': {\n        size: 8, // <-- Applicant subform should take up 8 out of 12 columns\n      },\n      name: {\n        \'ui:options\': {\n          size: 8, // <-- Applicant name field should take up 8 columns in the 8 columns that Applicant subform occupies\n        },\n      },\n      annualincome: {\n        \'ui:options\': {\n          size: 4, // <-- Annual Income field taking up the remaining 4 columns\n        },\n      },\n    },\n    property: {\n      \'ui:options\': {\n        size: 4, // <-- Property subform should take up the remaining 4 out of 12 columns\n      },\n      // note that property\'s fields are not mentioned - defaulting them to 12 columns in are that is available to them\n    },\n  },\n};\n\nAs Material UI components are used for field templates, there might be a need to pass some Material UI options into the field. You can do that by adding muiProps object to the ui:options.\nFor example, if you would like to make the Down payment field resizable, you can add multiline: true to muiProps option. If you want to make the field take up multiple rows by default, add rows and rowsMax fields. The latter limits how many rows should be added until the scroll bar is shown.\ndownpayment: {\n  \'ui:options\': {\n    size: 4,\n    muiProps: {\n      multiline: true,\n      rows: 2,\n      rowsMax: 4\n    }\n  }\n}\n Widgets \n Different types of widgets can be applied by passing the type via\n"ui:widget". Property tells the form which UI widget should be used to\nrender a field. You can read about react-jsonschema-form supported\nwidgets here. \n Building From source \n Reference the component projects for instructions to build from source.\n https://github.com/entando/entando-process-driven-plugin \n https://github.com/entando/entando-process-driven-plugin/tree/master/widgets \n https://github.com/entando/pda-redhatpam-engine \n https://github.com/entando/pda-core-engine \n Code Style \n See:  https://github.com/entando/entando-code-style \n Sonar \n https://sonarcloud.io/organizations/entando/projects \n'},{title:"Connect to an External Keycloak Instance",frontmatter:{},regularPath:"/v6.2/tutorials/devops/external-keycloak/",relativePath:"v6.2/tutorials/devops/external-keycloak/README.md",key:"v-73e5ec98",path:"/v6.2/tutorials/devops/external-keycloak/",headers:[{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Get keycloak information",slug:"_1-get-keycloak-information"},{level:3,title:"2. Generate the secret",slug:"_2-generate-the-secret"},{level:3,title:"3. Upload the secret",slug:"_3-upload-the-secret"},{level:3,title:"4. Deploy the Entando6 application",slug:"_4-deploy-the-entando6-application"},{level:2,title:"Conclusion",slug:"conclusion"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:' Connect to an External Keycloak Instance \n Purpose \n This tutorial enables the Entando administrator to leverage an existing\nKeycloak instance. \n Requirements \n \n \n A Keycloak instance \n \n \n A realm named "entando" on that instance \n \n \n An admin user for the "entando" realm \n Steps \n 1. Get keycloak information \n Retrieve the relevant information from the Keycloak instance you want to\nuse. \n Specifically you will need: \n \n \n The username of the Keycloak admin that has admin rights to the\n"entando" realm, e.g entando-keycloak-admin \n \n \n The Keycloak admin password, e.g. password123 \n \n \n The base url for the Keycloak server, including the auth value, e.g.\n https://my-keycloak-instance.com/auth \n 2. Generate the secret \n You now need to generate a secret with name  keycloak-admin-secret \nusing the information retrieved from step 1. The Entando administrator\nwill automatically detect this secret by name, and use it to log onto\nthe provided Keycloak server. \n Here is an example of the secret you will need to construct: \n ---\napiVersion: v1\nstringData:\n    username: <the username of the Keycloak admin user for the "entando" realm>\n    password: <the password of this Keycloak admin user>\n    url: <the base url of the Keycloak service, typically ending with the path /auth>\nkind: Secret\nmetadata\n    name: keycloak-admin-secret\n    namespace: <your-app-namespace>\ntype: Opaque\n \n \n Note \n To encode your values, in bash, you can do\n echo <your-value> | base64 \n 3. Upload the secret \n Next upload the secret to the namespace where you want to deploy your\nEntando 6 instance. \n oc create -f my-secret.yaml -n <my-app-namespace>\n 4. Deploy the Entando6 application \n Now you are ready to deploy your Entando 6 application and the\nadministrator will reuse the  keycloak-admin-secret  secret to populate\nthe environment correctly. \n Conclusion \n You should now have a working Entando 6 instance using an external\nKeycloak server. \n'},{title:"Tutorial: Connecting to an External Database",frontmatter:{},regularPath:"/v6.2/tutorials/devops/external-database/",relativePath:"v6.2/tutorials/devops/external-database/README.md",key:"v-75704160",path:"/v6.2/tutorials/devops/external-database/",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:" Tutorial: Connecting to an External Database \n Overview \n This document provides a guide to connecting to an external database. In\nmany (not all) production configurations it is recommended to use a DBMS\noutside of the cluster where your Entando application is running to\nsimplify maintenance, duplication of resources, and to establish a\nbackup workflow that will scale with your application. \n Prerequisites \n \n \n An environment to install your Entando applicaiton \n \n \n A running PostgreSQL, MySQL, or Oracle environment \n \n \n Administrator access to the database \n \n \n Network access from your Kubernetes cluster to your database \n Tutorial \n \n In the helm quickstart define a db for your deployment that includes\nthe admin credentials for your database \n \n \n db:\n  vendor: postgresql | mysql | oracle\n  host: <yourhost>\n  port: <yourport>\n  adminUser: <youradmin>\n  adminPassword: <youradminpassword>\n  name: <yourdbname>\n \n \n \n Run the helm quickstart or create a deployment for your Entando\nenvironment manually \n \n Note: The quickstart creates a default configuration for the\ndeployment. This isn’t to suggest that it is the only\nconfiguration or that it matches with every use case. It is\nrecommended to think about your desired deployment Architecture\nand to configure for that environment using the CRDs as building\nblocks. This also isn’t to suggest that if it isn’t directly\nsupported by the quickstart template that you can’t change it.\nThe deployment is editable. Treat the helm template as a\nbootstrapping environment and edit your deployments to match\nyour needs and requirements. \n \n \n \n Open the yaml file generated from the deployment and review the\nsettings for the deployment \n \n The Entando Operator will create a secret for the database\nautomatically and use the DB initializers to create the DB for\nthe Entando app and any services that use it \n \n \n \n Deploy your app \n \n \n"},{title:"Local Development Tips and Tricks",frontmatter:{sidebarDepth:2},regularPath:"/v6.2/tutorials/devops/local-tips-and-tricks.html",relativePath:"v6.2/tutorials/devops/local-tips-and-tricks.md",key:"v-0f16da74",path:"/v6.2/tutorials/devops/local-tips-and-tricks.html",headers:[{level:2,title:"Kubernetes",slug:"kubernetes"},{level:2,title:"Network issues",slug:"network-issues"},{level:3,title:".nip.io isn't allowed",slug:"nip-io-isn-t-allowed"},{level:3,title:"The IP address changed after the initial install",slug:"the-ip-address-changed-after-the-initial-install"},{level:2,title:"Windows development",slug:"windows-development"},{level:3,title:"Hyper-V IP changes",slug:"hyper-v-ip-changes"},{level:3,title:"JHipster",slug:"jhipster"},{level:3,title:"Multipass with VirtualBox",slug:"multipass-with-virtualbox"}],lastUpdated:"9/30/2020, 11:01:17 AM",lastUpdatedTimestamp:1601478077e3,content:" Local Development Tips and Tricks \n We've collected a list of tips and tricks for optimizing your local development environment.\nWe invite you to ask questions, collaborate with the community, and share your own favorite\npractices over on the  Entando forum . \n Kubernetes \n Per the  Getting Started  guide, we've recommended using Multipass as a way to quickly spin up an Ubuntu VM to host a local Kubernetes cluster for test purposes. There are many times when a local environment is useful but most teams utilize a shared Kubernetes cluster managed by an operations team and installed either on premise or with a cloud provider for full integration testing, CI/CD, DevOps, etc. \n Network issues \n A local Entando 6.2 quickstart installation (e.g. what you'll get if you follow the  Getting Started  guide) uses a set of local domain names to enable accessing Entando services. Your IP address will vary but they will look something like this: \n quickstart-entando.192.168.99.1.nip.io\nquickstart-kc-entando.192.168.99.1.nip.io\nquickstart-eci-entando.192.168.99.1.nip.io\n \n The base domain configured via the ENTANDO_DEFAULT_ROUTING_SUFFIX (e.g. in your entando.yaml) is based on a fixed IP address and that address is configured during the initial installation. That setting is used to generate ingress routes to map incoming URLs to individual services. In production environments there's generally a dedicated network layer to manage IPs/routing (both on premise and cloud) but those options are often not readily available in a local setup. Here are a couple common issues that can prevent Entando from starting in a local environment: \n  .nip.io isn't allowed \n \n This could be because of firewall settings or corporate security policies. The simplest workaround is to manually edit your /etc/hosts file and map the necessary domains to the IP of your local virtual machine. \n \n  192.168.99.1 quickstart-kc-entando.192.168.99.1.nip.io\n 192.168.99.1 quickstart-eci-entando.192.168.99.1.nip.io\n 192.168.99.1 quickstart-entando.192.168.99.1.nip.io\n \n \n If you add microservices to your installation, you may need to add additional mappings for the new ingresses. \n See  this section below  for detailed steps on Windows. \n  The IP address changed after the initial install \n \n The workaround noted above (e.g. update your /etc/hosts file) can also be used here. Simply update the IP address in the first column to use the current IP of your virtual machine. \n On Windows this can happen simply because your laptop restarted. See  Windows Hyper-V IP Changes  below. \n Windows development \n Hyper-V IP changes \n Q:  My Entando installation stops working when I restart Windows. How can I fix this? \n A:  The basic issue is that Windows Hyper-V makes it difficult to set\na static IP for a VM. (See this  forum post  for details.) As discussed  above , Entando's ingress routes rely on an fixed IP address and will break if the IP address changes after initial installation. Here are a few options to solve this issue, short of modifying your router or network switch settings: \n Option 1: Manually update your hosts file \n The simplest option to re-enable external access to your cluster is to update your hosts file after each Windows restart. \n You need two pieces of information for this workaround and you'll need administrator access to do this. \n \n Determine the original IP used for your VM. This is included in the  ENTANDO_DEFAULT_ROUTING_SUFFIX  or you can see it included in the ingress names. Run   kubectl -n entando get ingress  and you should see something like this: \n \n NAME                          CLASS    HOSTS                                           \nquickstart-kc-ingress         <none>   quickstart-kc-entando.192.168.235.100.nip.io  \nquickstart-eci-ingress        <none>   quickstart-eci-entando.192.168.235.100.nip.io  \nquickstart-ingress            <none>   quickstart-entando.192.168.235.100.nip.io    \n \n \n Determine the current IP using  hostname -I  in the VM or by running  multipass list  from Windows: \n \n $ multipass list\nName                    State             IPv4             Image\nprimary                 Running           172.31.118.12   Ubuntu 18.04 LTS\n \n \n As a Windows administrator, edit your hosts file  (C:\\Windows\\System32\\drivers\\etc\\hosts)  to map any needed URLs from the old IP to the new IP. This will bypass .nip.io lookups. \n \n 172.31.118.12 quickstart-kc-entando.192.168.235.100.nip.io\n172.31.118.12 quickstart-eci-entando.192.168.235.100.nip.io\n172.31.118.12 quickstart-entando.192.168.235.100.nip.io\n \n \n You should now be able to access your Entando URLs via the new IP. If your Entando installation stalled during startup, it should continue starting up as soon as the external address is functional again. \n Option 2: Add a Windows route \n This option is a little more involved the first time but it means repairing your network settings can be done very easily later. In this case you'll pick a static IP, configure a Windows route to map it to the Hyper-V interface, and claim the IP in the Ubuntu VM via a netplan entry. \n You'll need to run all of these steps before installing Entando the first time but then just steps #1 and #2 after subsequent Windows restarts. \n \n \n Determine an IP that is unused on your local network. You can use ping or other tools for this but in the following steps we assume that your selected IP is 192.168.99.1. \n \n \n Determine the interface address to Hyper-V, e.g. 32 below. Use cmd  route print  and look for the Interface entry for Hyper-V: \n \n \n Interface List\n 32...00 15 5d 86 45 20 ......Hyper-V Virtual Ethernet Adapter\n \n \n Using elevated privileges, add a persistent route to map your IP to the Hyper-V interface: \n \n route -p add [YOUR-IP] mask 255.255.255.255 0.0.0.0 IF [HYPER-V-INTERFACE]\nroute -p add 192.168.99.1 mask 255.255.255.255 0.0.0.0 IF 32\n \n \n \n Verify the route was added by using  route print 192.168.99.1 . This command is useful after restart to check if the route needs to be created again. \n \n \n Next, configure your VM to claim the same address. Shell into the VM using  winpty multipass shell [YOUR-VM-NAME] . \n \n \n Change to the root user to make the following steps simpler:  sudo -i \n \n \n Determine your network adapter via  ip link , e.g. eth0. You just need the name. It's often second in the list after the loopback adapter. \n \n \n ubuntu@primary:~$  ip   link \n 1 : lo:  < LOOPBACK,UP,LOWER_UP >  mtu  65536  qdisc noqueue state UNKNOWN mode DEFAULT group default qlen  1000 \n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n 2 : eth0:  < BROADCAST,MULTICAST,UP,LOWER_UP >  mtu  1500  qdisc mq state UP mode DEFAULT group default qlen  1000 \n    link/ether 00:15:5d:00:1a:0c brd ff:ff:ff:ff:ff:ff\n \n \n \n cd /etc/netplan \n \n \n Create a netplan entry starting with 0 so it's loaded first:  vi 0-entando.yaml \n \n \n network : \n   version :   2 \n   renderer :  networkd\n   ethernets : \n     [ YOUR - NETWORK - ADAPTER ] : \n       dhcp4 :  no\n       addresses :  \n         -   [ YOUR - IP ] /24\n \n Example: \n network : \n   version :   2 \n   renderer :  networkd\n   ethernets : \n     eth0 : \n       dhcp4 :  no\n       addresses :  \n         -  192.168.99.1/24\n \n \n \n Apply the changes via  netplan apply \n \n \n Verify connectivity via  ping 192.168.99.1  from the VM. You should get a response rather than a timeout. \n \n \n (Optional) Run a python server to verify you can access the VM from the host at  http://192.168.99.1:8000.  It may take a minute or so before the server is ready. \n \n \n python3 -m http.server 8000\n \n \n You should now be able to install Entando using the static IP. If your Entando installation stalled during startup and was previously configured using the static IP, it should continue starting up as soon as the external address is functional again. \n Option 3: Reinstall Entando \n We're including this option because it works and requires no additional configuration. If you plan to regularly work with Entando we recommend developing against a centralized and shared Kubernetes instance rather than running a full stack locally. If you need a cluster locally we recommend using option 1 or 2. \n JHipster \n Q:  How can I run JHipster on Windows? \n A:  JHipster requires a TTY interface for its menus to function correctly. Here are a few options to satisfy that requirement on Windows: \n \n Run  jhipster  under cmd or Powershell \n Using Git Bash, run  winpty jhipster.cmd \n Use Ubuntu bash via WSL (1 or 2) or within the Multipass VM \n Multipass with VirtualBox \n Multipass supports the use of VirtualBox on Windows as an alternative to using Hyper-V, say if you're using Windows Home. See the Multipass documentation on how to configure it to work with VirtualBox. \n In order to get Entando working correctly with this setup you will need to add a port forwarding rule so you can access Entando from your host system. \n \n \n Create your VM within Multipass. \n \n \n Go to the Oracle VM VirtualBox Manager and edit the  Network  settings for the VM. \n \n \n Go to the  Advanced  options and click  Port Forwarding Rules \n \n \n Add a new rule. \n \n Name : your choice \n Protocol : TCP \n Host IP : leave this blank \n Host Port : 80 \n Guest IP : leave this blank \n Guest Port : 80 \n Click OK \n \n \n \n At this point any requests to port 80 on your localhost should be forwarded to the VM. \n \n \n You can now identify the IP of your host and use that to configure the  ENTANDO_DEFAULT_ROUTING_SUFFIX  in your yaml file, e.g.  192.168.64.25.nip.io . You should not use the non-routable address (e.g. 10.0.2.15) identified from within the guest VM itself, but rather use the IP of the host. \n \n \n"},{title:"Entando 6 Azure Kubernetes Installation Instructions",frontmatter:{sidebarDepth:2},regularPath:"/v6.2/tutorials/devops/installation/azure-kubernetes-service/azure-install.html",relativePath:"v6.2/tutorials/devops/installation/azure-kubernetes-service/azure-install.md",key:"v-a13cc134",path:"/v6.2/tutorials/devops/installation/azure-kubernetes-service/azure-install.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"Cluster Setup",slug:"cluster-setup"},{level:3,title:"Setup and Connect to the Cluster",slug:"setup-and-connect-to-the-cluster"},{level:3,title:"Deploy NGINX Ingress Controller",slug:"deploy-nginx-ingress-controller"},{level:3,title:"Verify the NGINX Ingress Install",slug:"verify-the-nginx-ingress-install"},{level:3,title:"Install the Entando Custom Resource Definitions (CRDs)",slug:"install-the-entando-custom-resource-definitions-crds"},{level:2,title:"Deploy Your Entando Application",slug:"deploy-your-entando-application"},{level:2,title:"Appendix A - Example values.yaml file for Helm Quickstart",slug:"appendix-a-example-values-yaml-file-for-helm-quickstart"},{level:2,title:"Appendix B - Troubleshooting",slug:"appendix-b-troubleshooting"}],lastUpdated:"11/24/2020, 1:24:50 PM",lastUpdatedTimestamp:160624229e4,content:' Entando 6 Azure Kubernetes Installation Instructions \n Prerequisites \n \n Azure account\n \n \n \n Note: If you\'re using an Azure free account, you may need to upgrade your account first to enable pay-as-you-go billing. The Azure free account default quota includes just 1-4 vCPU which is not sufficient for this tutorial. There may be a delay before the quotas are updated when you upgrade your account. \n \n \n \n \n If you\'re not using Azure Cloud Shell:\n \n Azure command line tool \n Helm2 client \n Overview \n The steps below walk you through installing the Entando platform in an Azure Kubernetes Services (AKS) cluster. Generally the steps are: \n \n Create an AKS cluster with 5 nodes (to allow expansion for microservices) \n Install nginx as an ingress controller in the cluster \n Install Entando \n \n If you\'re already comfortable setting up an AKS cluster and installing nginx then you may be able to skip to  setting up Entando . \n Cluster Setup \n Setup and Connect to the Cluster \n \n Login to Azure ( https://portal.azure.com/ ) \n Select the  Kubernetes services  icon\n \n If not listed click  More services  on the right and search for Kubernetes \n \n \n Click  Add  in upper left corner \n Select  Kubernetes cluster . You\'ll start with the  Basics  tab. \n Select a  Resource group  or create one with the  Create new  link if it you don’t have one, e.g.  resource-group-1 \n Enter a name of your choice in Kubernetes cluster name, e.g.  cluster-1 \n Pick your  Region  if it wasn\'t automatically selected for you. \n In the  Availability zones  dropdown pick  one and only one  availability zone\n \n Generally, you could pick more than one but it will result in a failure in a quickstart environment. If you chose more than one availability zone you will have to provision storage, manage node affinity, and ensure correct network configuration to ensure your application deploys. We recommend only doing this for production clusters. \n \n \n Select the default  Kubernetes version  if it\'s not already selected, e.g. 1.16.13 \n Keep the default  Node size , e.g.  Standard DS2 v2 \n Change the  Node count  to  5 \n Click  Next: Node Pools  to move to the next tab. \n Keep the default values here\n \n If you\'re familiar with AKS your can change as desired based on your objectives/knowledge \n \n \n Click  Next: Authentication \n For  Authentication method  select  System-assigned managed identity \n \n You can pick a  Service principal  instead and Azure will automatically generate one for you. If you use an existing principal it is up to you to configure it and ensure you have the access you need. \n \n \n Click  Next: Networking \n Enter a value for DNS name prefix, e.g.  cluster-1-dns \n Click  Review + Create \n \n Note: There are many other configuration options available for an AKS cluster. Generally, you can change these based on your experience and comfort level with the AKS platform. Entando uses base Kubernetes APIs so as long as you follow the Entando configuration instructions below you can tune your cluster infrastructure to meet your goals \n \n \n Select  Create \n Wait for your cluster to initialize.\n \n This may take a few minutes \n Deploy NGINX Ingress Controller \n \n Navigate to your cluster by clicking  Go to Resource  from the results page or by the top navigation  Home - Kubernetes service  and clicking on your cluster. \n Select  Connect \n Select  Bash \n Run the first two commands (e.g.  az account set...  and  az aks get-credentials...  to connect to your cluster. This should only be needed the first time you run the Azure Cloud Shell.\n \n The Cloud Shell times out after 20 minutes of inactivity. \n The following instructions assume you\'ll use the Azure Cloud Shell but you can also run the commands in a local environment if you have  kubectl \n \n \n Deploy nginx with the commands below. See  nginx instructions  for more details. \n \n kubectl create namespace ingress-basic\n \n helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx\nhelm repo add stable https://kubernetes-charts.storage.googleapis.com/\nhelm repo update\n \n helm install nginx-ingress ingress-nginx/ingress-nginx \\\n    --namespace ingress-basic \\\n    --set controller.replicaCount=2 \\\n    --set controller.nodeSelector."beta\\.kubernetes\\.io/os"=linux \\\n  --set defaultBackend.nodeSelector."beta\\.kubernetes\\.io/os"=linux\n \n \n Get the external IP address for your ingress controller. Record the value of EXTERNAL-IP for  nginx-ingress-controller  from the command below. \n \n kubectl get service -n ingress-basic\n Verify the NGINX Ingress Install \n We recommend setting up a test application so you can easily verify the ingress is working in your cluster. See  this page  for those steps. You can use either Azure Cloud Shell or your local  kubectl . \n Install the Entando Custom Resource Definitions (CRDs) \n Once per cluster you need to deploy the  Entando Custom Resources . \n \n Download the Custom Resource Definitions (CRDs) and unpack them \n \n curl -L -C - https://raw.githubusercontent.com/entando/entando-releases/v6.2.0/dist/qs/custom-resources.tar.gz | tar -xz\n \n \n Install the Entando CRDs: \n \n kubectl create -f dist/crd\n Deploy Your Entando Application \n You can now deploy your application to Azure Kubernetes Service. \n \n Download and unpack the entando-helm-quickstart release files with the following command or by selecting a specific release  here . See the included README file for more information on subsequent steps. \n \n curl -sfL https://github.com/entando-k8s/entando-helm-quickstart/archive/v6.2.0.tar.gz | tar xvz\n \n \n Change into the new directory \n \n cd entando-helm-quickstart-6.2.0\n \n \n \n Edit the  values.yaml \n \n Set  supportOpenshift: false \n Set  ENTANDO_DEFAULT_ROUTING_SUFFIX  to the EXTERNAL-IP of your ingress controller and add nip.io to the end\n \n For example:  ENTANDO_DEFAULT_ROUTING_SUFFIX: 52.188.177.248.nip.io \n \n \n Configure nginx as the ingress controller and enable file system groups for persistent volume access:\n \n ENTANDO_INGRESS_CLASS: "nginx" \n ENTANDO_REQUIRES_FILESYSTEM_GROUP_OVERRIDE: "true" \n \n \n See  Appendix A  for an example values.yaml \n \n \n \n Create the Entando namespace: \n \n \n kubectl create namespace entando\n \n \n Run helm to generate the template file: \n \n helm template my-aks-app --namespace=entando ./ > my-aks-app.yaml\n \n \n Deploy Entando via \n \n kubectl create -f my-aks-app.yaml\n \n \n Watch Entando startup. The application will be available when the quickstart-server-deployment pod shows 3/3 in the READY column and RUNNING in the STATUS column. \n \n kubectl get pods -n entando --watch\n \n \n Check for the Entando ingresses using \n \n kubectl describe ingress -n entando\n \n \n Access your app on the url for the ingress of the app builder, e.g.  http://quickstart-entando.EXTERNAL-IP.nip.io/entando-de-app \n Appendix A - Example values.yaml file for Helm Quickstart \n In the example below the application will deploy with embedded databases and will use  nginx \nas the ingress controller. Replace  <YOUR-IP>  with the EXTERNAL-IP address of your nginx controller \n app:\n name: quickstart\n dbms: none\noperator:\n supportOpenshift: false\n env:\n   ENTANDO_DOCKER_IMAGE_VERSION_FALLBACK: 6.0.0\n   #ENTANDO_DOCKER_REGISTRY_OVERRIDE: docker.io # Remove comment if you want to always use a specific docker registry\n   #ENTANDO_DOCKER_IMAGE_ORG_OVERRIDE: entando # Remove the comment if you want to always use a specific docker organization\n   ENTANDO_DEFAULT_ROUTING_SUFFIX: <YOUR-IP>.nip.io\n   ENTANDO_POD_READINESS_TIMEOUT_SECONDS: "1000"\n   ENTANDO_POD_COMPLETION_TIMEOUT_SECONDS: "1000"\n   ENTANDO_DISABLE_KEYCLOAK_SSL_REQUIREMENT: "true"\n   ENTANDO_K8S_OPERATOR_IMPOSE_DEFAULT_LIMITS: "false"\n   ENTANDO_INGRESS_CLASS: "nginx"\n   ENTANDO_REQUIRES_FILESYSTEM_GROUP_OVERRIDE: "true"\n tls:\n   caCrt:\n   tlsCrt:\n   tlsKey:\ndeployPDA: false\n Appendix B - Troubleshooting \n If you get an error like:  0/5 nodes are available: 5 node(s) had volume node affinity conflict.  or if your deployment hangs in a situation like this from  kubectl get pods -n entando \n NAME                                                 READY   STATUS      RESTARTS   AGE\nmy-aks-app-operator-644697776f-sxtq2                 1/1     Running     0          13m\nquickstart-composite-app-deployer-2guz0n42pc         1/1     Running     0          13m\nquickstart-deployer-jj4njqk4bg                       1/1     Running     0          10m\nquickstart-eci-deployer-t0xktqsonk                   0/1     Completed   0          11m\nquickstart-eci-k8s-svc-deployment-78f64c8d89-7c578   1/1     Running     0          11m\nquickstart-kc-deployer-16gzv3clsj                    0/1     Completed   0          13m\nquickstart-kc-server-deployment-7c9bc65744-g52nx     1/1     Running     0          13m\nquickstart-server-deployment-55fcfc6b68-szvkl        0/3     Pending     0          10m\n \n Double check your availability zones. By default an Azure cluster will include nodes from multiple zones but it will not provision storage\nfor all of those nodes so you can\'t deploy your application. \n You can confirm this error in AKS by \n \n In your cluster select  Workloads  in the left nav \n Click on the deployment for your server application. This is  quickstart-server-deployment  by default \n Click on the deployment name inside that application. There will be one \n Click on the tab labeled  Conditions \n If you see an error that says  0/5 nodes are available: 5 node(s) had volume node affinity conflict.  Then you need to reconfigure\nyour cluster to have nodes in one zone or work with your Azure operations team to provision storage to match node affinity. \n \n'},{title:"Installation on Google Kubernetes Engine (GKE)",frontmatter:{sidebarDepth:2},regularPath:"/v6.2/tutorials/devops/installation/google-cloud-platform/",relativePath:"v6.2/tutorials/devops/installation/google-cloud-platform/README.md",key:"v-07622a2a",path:"/v6.2/tutorials/devops/installation/google-cloud-platform/",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Cluster Setup",slug:"cluster-setup"},{level:3,title:"Setup and Connect to the Cluster",slug:"setup-and-connect-to-the-cluster"},{level:3,title:"Install the NGINX Ingress Controller",slug:"install-the-nginx-ingress-controller"},{level:3,title:"Verify the NGINX Ingress install",slug:"verify-the-nginx-ingress-install"},{level:3,title:"Install the Entando Custom Resource Definitions (CRDs)",slug:"install-the-entando-custom-resource-definitions-crds"},{level:2,title:"Deploy Your Entando Application",slug:"deploy-your-entando-application"},{level:3,title:"Setup and Deploy",slug:"setup-and-deploy"},{level:3,title:"Quickstart with Embedded Databases",slug:"quickstart-with-embedded-databases"},{level:3,title:"External Database",slug:"external-database"},{level:2,title:"Appendix A - Cluster Sizing",slug:"appendix-a-cluster-sizing"},{level:3,title:"Updating the Nodes in Your Cluster",slug:"updating-the-nodes-in-your-cluster"},{level:2,title:"Appendix B - Example values.yaml file for Helm Quickstart",slug:"appendix-b-example-values-yaml-file-for-helm-quickstart"}],lastUpdated:"4/23/2021, 4:16:15 AM",lastUpdatedTimestamp:1619165775e3,content:' Installation on Google Kubernetes Engine (GKE) \n Prerequisites \n \n Google Cloud account:  http://cloud.google.com/ \n Install these tools locally if you\'re not using the Google Cloud Shell steps below:\n \n Google Cloud SDK  including gcloud \n kubectl  command line tool \n Cluster Setup \n These steps only need to be completed once per cluster. \n Setup and Connect to the Cluster \n \n Login to your Google Cloud account:  https://cloud.google.com/ \n Go to  Kubernetes Engine -> Clusters  and click  Create Cluster \n Select the  Configure  button under the  Standard  option \n Enter a name and select a  Location type \n \n The  Location type  settings are up to you. The defaults are fine for an initial test. \n \n \n Select  1.18.16-gke.502  for the  Master version \n On the left menu select  default-pool \n Under  Size  set the  Number of nodes  entry to 5.  (See  Appendix A  for details.) \n Click  Create \n Wait for the cluster to initialize. This will take a few minutes. There will be a green check mark when complete. \n Click  Connect  for your new cluster. \n Click  Run in Cloud Shell \n \n Alternatively, copy the provided command and execute it in your local environment to connect your local  kubectl  to your GKE cluster. \n \n \n Run  kubectl get namespaces  to verify your connection: \n \n a_user@cs-6000-devshell-vm-c34ef644-5584-4c5d-aa14-6e41af4a5c9a:~$ kubectl get namespaces\nNAME              STATUS   AGE\ndefault           Active   6m11s\nkube-node-lease   Active   6m12s\nkube-public       Active   6m12s\nkube-system       Active   6m13s\n Install the NGINX Ingress Controller \n Entando isn’t compatible out of the box  with the default ingress controller provided in GKE.\nSee here for more if you’re interested in GKE ingress:  https://cloud.google.com/kubernetes-engine/docs/concepts/ingress \n We’re going to install the NGINX ingress controller to manage the ingresses for Entando services\ndeployed by the operator. This will be a simpler and more adaptable configuration for most users and\nenvironments. Users who really need the GKE ingress controller (rare) could integrate it following\nthe instructions provided by GKE and then customize the service definition created by the Entando\noperator. \n These are the minimal instructions to prepare NGINX ingress using the Google Cloud Shell. To install it\nusing your local  kubectl  or to vary other settings please see the more detailed documents here:\n https://cloud.google.com/community/tutorials/nginx-ingress-gke  and  https://kubernetes.github.io/ingress-nginx/deploy/#gce-gke . \n \n Initialize your user as a cluster-admin: \n \n kubectl create clusterrolebinding cluster-admin-binding --clusterrole cluster-admin \\\n--user $(gcloud config get-value account)\n \n \n Install the ingress controller pods: \n \n kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/provider/cloud/deploy.yaml\n \n \n To check if the ingress controller pods have started, run the following command: \n \n    kubectl get pods -n ingress-nginx \\\n     -l app.kubernetes.io/name=ingress-nginx --watch\n \n \n Wait until the ingress-nginx-controller status changes to  Running : \n \n NAME                                        READY   STATUS      RESTARTS   AGE\ningress-nginx-admission-create-27tgt        0/1     Completed   0          65s\ningress-nginx-admission-patch-7wmgl         0/1     Completed   1          65s\ningress-nginx-controller-7656c59dc4-7xgmc   1/1     Running     0          75s\n \n \n Get the external IP address for your ingress controller. Record the value of EXTERNAL-IP for  nginx-ingress-controller  from the command below. \n \n kubectl get service -l app=nginx-ingress --namespace ingress-nginx\n Verify the NGINX Ingress install \n We recommend setting up a test application so you can easily verify the ingress is working. \n \n From the  Cloud Shell,  create a simple application by running the following command: \n \n kubectl run hello-app --generator=run-pod/v1 --image=gcr.io/google-samples/hello-app:1.0 --port=8080\n \n \n Expose the  hello-app  Pod as a Service: \n \n kubectl expose pod hello-app\n \n \n Create an  ingress-resource.yaml  file with this content: \n \n apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: ingress-resource\n  annotations:\n    kubernetes.io/ingress.class: nginx\n    nginx.ingress.kubernetes.io/ssl-redirect: "false"\nspec:\n  rules:\n  - http:\n      paths:\n      - path: /hello\n        backend:\n          serviceName: hello-app\n          servicePort: 8080\n \n \n Now create the Ingress Resource using  kubectl apply -f ingress-resource.yaml \n Verify that the Ingress Resource has been created using  kubectl get ingress ingress-resource .\nIt may take a few minutes for the  Address  to be populated. \n Verify you can access the web application by going to the  EXTERNAL-IP/hello  address, using the\n Address  from the previous nginx-ingress-controller. You should see the following: \n \n Hello, world!\nVersion: 1.0.0\nHostname: hello-app\n \n Note the external IP address of your ingress controller since you’ll need it for the application configuration.\nThe Entando deployment exposes an environment variable to set the ingress controller to be used as part of the deployment. That variable is  ENTANDO_INGRESS_CLASS  and should be set to  nginx  in deployments to GKE (this is documented in the application instructions below as well) \n Install the Entando Custom Resource Definitions (CRDs) \n Once per cluster you need to deploy the  Entando Custom Resources . \n \n Download the Custom Resource Definitions (CRDs) and unpack them: \n \n curl -L -C - https://raw.githubusercontent.com/entando/entando-releases/v6.2.0/dist/qs/custom-resources.tar.gz | tar -xz\n \n \n Install the Entando CRDs:  kubectl create -f dist/crd \n Deploy Your Entando Application \n You can now deploy your Entando applications to GKE. \n Setup and Deploy \n \n Download and unpack the entando-helm-quickstart release you want to use from here:\n https://github.com/entando-k8s/entando-helm-quickstart/releases \n \n e.g.  curl -sfL https://github.com/entando-k8s/entando-helm-quickstart/archive/v6.2.0.tar.gz | tar xvz \n See the included README file for more information on the following steps. \n \n \n Edit  values.yaml in the root directory:\n \n Set  supportOpenshift: false \n Set  ENTANDO_DEFAULT_ROUTING_SUFFIX  to the IP value of your  nginx  controller plus .nip.io\n \n For example:  ENTANDO_DEFAULT_ROUTING_SUFFIX: 35.223.161.214.nip.io \n We’re using  https://nip.io  because we need wildcard dns address resolution however nip.io is not required. If your enterprise has a different internal dns resolution scheme for development instances you can use that or other alternative dns services like xip.io. \n \n \n If not already present, set these values to utilize nginx as the ingress controller and file system groups for persistent volume access:\n \n ENTANDO_INGRESS_CLASS: "nginx" \n ENTANDO_REQUIRES_FILESYSTEM_GROUP_OVERRIDE: "true" \n \n \n See  Appendix B  for an example values.yaml \n \n \n Create the Entando namespace:  kubectl create namespace entando \n Update helm dependencies:  helm dependency update \n Run helm to generate the template file:  helm template my-app --namespace=entando ./ > my-app.yaml \n Deploy Entando via  kubectl create -f my-app.yaml \n Watch Entando startup  kubectl get pods -n entando --watch \n Check for the Entando ingresses using  kubectl describe ingress -n entando . This is a snippet: \n \n quickstart-entando.34.71.130.61.nip.io\n                                          /entando-de-app     quickstart-server-service:8080 (10.44.2.3:8080)\n                                          /digital-exchange   quickstart-server-service:8083 (10.44.2.3:8083)\n                                          /app-builder/       quickstart-server-service:8081 (10.44.2.3:8081)\n \n \n Access Entando at the listed endpoints, e.g. Entando App Builder at  quickstart-entando.34.71.130.61.nip.io/app-builder/ \n Quickstart with Embedded Databases \n The lightest weight and fastest to deploy option for evaluation and getting started uses embedded databases for the application and Keycloak.\nTo deploy quickstart with embedded databases at the top of values.yaml add  dbms: none  under the app section in the file. See Appendix B for an example. \n External Database \n You can also use an external database instance for your application.\nThis is recommended for projects that will be developed for delivery to customers or stakeholders.\nAny dbms that is reachable from the cluster can be used. \n Example: Deploy Postgres to a Namespace on Your Cluster \n These instructions will deploy a postgres instance to a namespace in your kubernetes cluster. \n https://github.com/GoogleCloudPlatform/postgresql-docker/blob/master/9/README.md#run-a-postgresql-server-kubernetes \n \n Note: If deployed this way the address you use for the database in the helm template must be a full address rather than an IP address alone. Use the database IP plus nip.io for a dev instances \n \n Once deployed you can use the  external database instructions  to\nconnect your Entando application to your instance., \n Connect CloudSQL to GKE \n \n This link describes creating a PG instances using the GCP Cloud SQL\n \n https://cloud.google.com/sql/docs/postgres/create-instance \n \n \n Connecting from GKE to Cloud SQL\n \n https://cloud.google.com/sql/docs/postgres/connect-kubernetes-engine \n Appendix A - Cluster Sizing \n In the cluster setup instructions you set the number of nodes in your cluster to 5. This setting\nassumes the default node type with a single VCPU per instance and 3.8 GB of RAM. The kubernetes\nsystem and nginx will request approximately 1 CPU in total. The Entando application will deploy\non the remaining 4. This configuration is suitable for a development team but may need to be\nexpanded as microservices are added to the architecture. \n If you’re running other applications (like a postgres instance) in your cluster you may need\nmore nodes. \n Updating the Nodes in Your Cluster \n \n Select Kubernetes Engine from the left nav in GCP \n Select Clusters \n Hit the Edit button (pencil on the right) \n Scroll to bottom \n Click the link labeled default-pool \n Edit button at the top \n Change the nodes to the number you\'d like to include \n Save \n Wait until updated on clusters page (green checkmark on cluster) \n Appendix B - Example values.yaml file for Helm Quickstart \n In the example below the application will deploy with embedded databases and will use  nginx \nas the ingress controller. Replace  <YOUR-NGINX-IP>  with the ip address where your  nginx \ninstance is exposed on your cluster. \n app:\n name: quickstart\n dbms: none\noperator:\n supportOpenshift: false\n env:\n   ENTANDO_DOCKER_IMAGE_VERSION_FALLBACK: 6.0.0\n   #ENTANDO_DOCKER_REGISTRY_OVERRIDE: docker.io # Remove comment if you want to always use a specific docker registry\n   #ENTANDO_DOCKER_IMAGE_ORG_OVERRIDE: entando # Remove the comment if you want to always use a specific docker organization\n   ENTANDO_DEFAULT_ROUTING_SUFFIX: <YOUR-NGINX-IP>.nip.io\n   ENTANDO_POD_READINESS_TIMEOUT_SECONDS: "1000"\n   ENTANDO_POD_COMPLETION_TIMEOUT_SECONDS: "1000"\n   ENTANDO_DISABLE_KEYCLOAK_SSL_REQUIREMENT: "true"\n   ENTANDO_REQUIRES_FILESYSTEM_GROUP_OVERRIDE: "true"\n   ENTANDO_INGRESS_CLASS: "nginx"\n   ENTANDO_K8S_OPERATOR_IMPOSE_DEFAULT_LIMITS: "false"\n tls:\n   caCrt:\n   tlsCrt:\n   tlsKey:\ndeployPDA: false\n\n \n '},{title:"Tutorial: Selecting the default databases",frontmatter:{},regularPath:"/v6.2/tutorials/devops/default-database.html",relativePath:"v6.2/tutorials/devops/default-database.md",key:"v-6fa3d88a",path:"/v6.2/tutorials/devops/default-database.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:" Tutorial: Selecting the default databases \n Overview \n This document provides a guide to changing an Entando environment by selecting the default databases used.\nSee  External Database  to connect to a database outside of the cluster. \n Prerequisites \n \n An environment to install your Entando applicaiton \n Network access from your Kubernetes cluster to your database \n Tutorial \n If needed you can set the desired component to use a specific DBMS by updating the Helm-generated yaml file (e.g. 'entando.yaml' from  Getting Started  as follows: \n \n open the chosen file and search for  EntandoCompositeApp  custom resource \n identify the component to update in the related list \n update the  spec.dbms  property with the desired value (you can specify different DBMS for different components) \n \n Repeat previous steps for all components you need to change used DBMS on. \n Valid values for  spec.dbms  property are:  none ,  postgresql ,  mysql ,  oracle . \n none  value will result in using an embedded database with in-file persistence strategy. \n Please note that using embedded databases into distributed systems forces to have only 1 replica per pod.\nThis happens because the volume claimed by each replica points to the same files,\nso the first container locking the files will prevent next replicas to obtain access to the DB files.\nNote that this affects also deployments rolling updates \n If you need to update your deployment, there is a known workaround consisting in setting the replicas number to 0, waiting for pod shutdown completion, update the deployment yaml file, then updating again to 1 the replicas value. In this way, the newly created containers will be able to startup correctly and access the embedded database files on the filesystem. \n These considerations lead us to discourage embedded database use into production environments. \n"},{title:"Installation on Amazon Elastic Kubernetes Service (EKS)",frontmatter:{sidebarDepth:2},regularPath:"/v6.2/tutorials/devops/installation/elastic-kubernetes-service/eks-install.html",relativePath:"v6.2/tutorials/devops/installation/elastic-kubernetes-service/eks-install.md",key:"v-536a5526",path:"/v6.2/tutorials/devops/installation/elastic-kubernetes-service/eks-install.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"Cluster Setup",slug:"cluster-setup"},{level:3,title:"Setup and Connect to the Cluster",slug:"setup-and-connect-to-the-cluster"},{level:3,title:"Install the NGINX Ingress Controller",slug:"install-the-nginx-ingress-controller"},{level:3,title:"Verify the NGINX Ingress Install",slug:"verify-the-nginx-ingress-install"},{level:3,title:"Install the Entando Custom Resource Definitions (CRDs)",slug:"install-the-entando-custom-resource-definitions-crds"},{level:2,title:"Deploy Your Entando Application",slug:"deploy-your-entando-application"},{level:2,title:"Appendix A - Troubleshooting",slug:"appendix-a-troubleshooting"},{level:2,title:"Appendix B - Example values.yaml file for Helm Quickstart",slug:"appendix-b-example-values-yaml-file-for-helm-quickstart"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:' Installation on Amazon Elastic Kubernetes Service (EKS) \n Prerequisites \n \n AWS CLI \n AWS account \n kubectl \n A domain or the ability to purchase one. Can use route 53 for this inside AWS if doing it all inline \n helm2 client \n Overview \n The steps below walk you though installing the Entando platform in an EKS cluster. Generally the steps are: \n \n Configure an IAM role to allow kubernetes to manage the cluster \n Create an EKS cluster with 5 nodes (to allow expansion for microservices) \n Install nginx as an ingress controller in the cluster \n Register a domain (if you don\'t already have one) and configure it for wildcard subdomains. \n Install Entando \n \n If you\'re already comfortable setting up an EKS cluster and installing nginx then you may be able to skip to  setting up Entando . \n Cluster Setup \n These steps will use the AWS console to create the cluster. If you’re already familiar with creating an EKS cluster and assigning nodes to it via the AWS cli then you can use the cli process for cluster creation as well. \n Setup and Connect to the Cluster \n \n \n Login to AWS as a non-super admin user \n \n If you don’t have a user besides the super admin it is recommended that you create one. Clusters created using the super admin for your account will have some restrictions that may complicate your installation. \n Your user will need access to EKS and at least the ability to create a cluster. You may need additional policies for Route53 and other services depending on your exact configuration. \n \n \n \n Create an IAM role for the cluster so that AWS can provision assets. See  https://docs.aws.amazon.com/eks/latest/userguide/worker_node_IAM_role.html  for more details. \n \n Select  IAM  from services \n Select  Create role \n Select  AWS Service  box at the top for the type of trusted entity \n Click  EKS  from the main list \n Click  EKS - Cluster  under  Select your use case \n Click  Next:Permissions \n A Policy of  AmazonEKSClusterPolicy  should already be present \n Click  Next: Tags \n (Optional) Add tags if you want \n Click  Next: Review \n Name your role (you’ll need this later), e.g.  my-eks-role \n \n \n \n Refine the role to enable Nodegroup management and to add ELB access so that the cluster can deploy a load balancer for nginx. \n \n Go to  IAM -> Roles -> your role . \n Under permissions click  Attach policies \n Add a policy of  AmazonEKSWorkerNodePolicy \n Add a policy of  AmazonEKS_CNI_Policy \n Add a policy of  AmazonEC2ContainerRegistryReadOnly \n Add a policy of  ElasticLoadBalancingFullAccess \n \n \n \n Go to  Services  and select  Elastic Kubernetes Service \n \n \n Create an EKS Cluster \n \n Add a cluster name (e.g.  cluster-1 ) and click  Create EKS cluster \n For  Cluster Service Role , select the role you created above, e.g.  my-eks-role . If you choose a different role it must have ELB permissions so the cluster can create a load balancer in  Networking  (Step 2). \n Click  Next \n Use the defaults for  Networking  (Step 2) and click  Next \n Use the defaults for  Configure Logging  (Step 3) and click  Next . \n Review your settings and then click  Create . Cluster provisioning usually takes between 10 and 15 minutes. \n See  https://docs.aws.amazon.com/eks/latest/userguide/create-cluster.html  for more information on cluster creation. \n \n \n \n Add a node group to the cluster \n \n Go to  Services  ->  Elastic Kubernetes Service  ->  Clusters  -> Click on your cluster name. \n Go to the  Compute  tab \n Click  Add Node Group \n Name : give your group a name, e.g.  node-1 \n Node IAM Role : Select the cluster role you created above. If the role doesn\'t appear, verify that you added the extra policies to the role. \n Subnets  - VPC subnets should already be setup and selected. \n Select  Allow remote access to nodes .  Follow the links to create a new SSH key pair if you don\'t already have one. \n Click  Next \n AMI type:  Amazon Linux 2 \n Instance type:  t3.medium \n Click  Next \n Set  Maximum size  to 5. This will be over-resourced for a  Getting Started  experience but will leave capacity for adding microservices to your cluster without modifying the Nodegroup. \n Click  Next \n Review your settings and then click  Create \n \n \n \n Connect  kubectl  to the cluster \n \n Note:  If this is a brand new setup you will need to login using the user you used to create your cluster in the console in the steps above. Make sure the users match.\n \n aws-configure  (and then provide the Access key, etc.) \n \n \n aws eks --region region-code update-kubeconfig --name cluster_name \n More details and troubleshooting  https://docs.aws.amazon.com/eks/latest/userguide/create-kubeconfig.html \n Your current context should now be configured for your AWS cluster: \n \n \n \n     $  kubectl config current-context\n    arn:aws:eks:us-east-2:483173223614:cluster/cluster-1\n Install the NGINX Ingress Controller \n \n Add the NGINX controller for ingress. This depends on your role having permissions for ELB.\n \n For basic nginx ingress install run this command \n \n \n \n     kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.34.1/deploy/static/provider/aws/deploy.yaml\n \n \n See  https://kubernetes.github.io/ingress-nginx/deploy/#aws  as well as  this  for more detailed install steps. \n \n \n Get the ELB external URL for your nginx install\n \n Run:  kubectl get services -n ingress-nginx \n Get the value of the external address (EXTERNAL-IP) for the ingress-nginx-controller: \n \n \n \n NAME                                 TYPE           CLUSTER-IP       EXTERNAL-IP                        \ningress-nginx-controller             LoadBalancer   10.100.102.83    ad234bd11a1ff4dadb44639a6bbf707e-0e0a483d966405ee.elb.us-east-2.amazonaws.com\n \n \n Determine the domain to use for your cluster. The goal here is to provide a way to route wildcard DNS traffic to the different parts of the apps and this can’t be done directly on the name for the ELB.\n \n Option 1 . Use a domain you already have available. You\'ll need to route traffic on that domain to the external cluster address noted in step 9.\n \n For an existing domain you can add a wildcard subdomain via a CNAME, e.g.  CNAME *.mysubdomain.domain.com <EXTERNAL-ADDRESS> . THe details will vary depending on your DNS registry. \n \n \n Option 2 . Register a domain in route 53.\n \n Add wildcard dns resolution in route 53 to the ELB address attached to nginx above. \n Note: The value in your A record will automatically include dualstack. This allows the ELB to serve both IPV4 and IPV6 traffic \n \n \n If you register a new domain use  nslookup  or  dig  to make sure the DNS changes have propagated. This can take hours. \n Verify the NGINX Ingress Install \n We recommend setting up a test application so you can easily verify the ingress is working in your cluster. See  this page  for those steps. You can use your local  kubectl . \n Install the Entando Custom Resource Definitions (CRDs) \n Once per cluster you need to deploy the  Entando Custom Resources . \n \n Download the Custom Resource Definitions (CRDs) and unpack them \n \n curl -L -C - https://raw.githubusercontent.com/entando/entando-releases/v6.2.0/dist/qs/custom-resources.tar.gz | tar -xz\n \n \n Install the Entando CRDs:  sudo kubectl create -f dist/crd \n Deploy Your Entando Application \n You can now deploy your application to Amazon EKS. \n \n Download and unpack the  entando-helm-quickstart release  here:\n https://github.com/entando-k8s/entando-helm-quickstart/releases \n \n See the included README file for more information on the following steps. \n \n \n \n curl -sfL https://github.com/entando-k8s/entando-helm-quickstart/archive/v6.2.0.tar.gz | tar xvz\n \n \n \n Edit  values.yaml  in the root directory: \n \n Set  supportOpenshift: false \n Set  ENTANDO_DEFAULT_ROUTING_SUFFIX  to the URL of your external domain:\n \n For example:  ENTANDO_DEFAULT_ROUTING_SUFFIX: entando-aws-test.org \n This assumes you have enabled wildcard dns address resolution  above . \n \n \n Configure nginx as the ingress controller and enable file system groups for persistent volume access:\n \n ENTANDO_INGRESS_CLASS: "nginx" \n ENTANDO_REQUIRES_FILESYSTEM_GROUP_OVERRIDE: "true" \n \n \n See  Appendix B  for an example values.yaml \n \n \n \n Create the Entando namespace:  kubectl create namespace entando \n \n \n Run helm to generate the template file: \n \n \n helm template my-eks-app --namespace=entando ./ > my-eks-app.yaml\n \n \n Deploy Entando via  kubectl create -f my-eks-app.yaml \n Watch Entando startup  kubectl get pods -n entando --watch \n Check for the Entando ingresses using  kubectl describe ingress -n entando \n Access your app on the url for the ingress of the app builder, e.g.  http://quickstart-entando.mysubdomain.domain.com/entando-de-app \n Appendix A - Troubleshooting \n IAM And Roles \n \n https://docs.aws.amazon.com/eks/latest/userguide/install-aws-iam-authenticator.html \n https://stackoverflow.com/questions/56863539/getting-error-an-error-occurred-accessdenied-when-calling-the-assumerole-oper \n \n NGINX \n \n https://docs.nginx.com/nginx/deployment-guides/amazon-web-services/ingress-controller-elastic-kubernetes-services/ \n Issue with permissions for NGINX ingress: \n \n  Warning  SyncLoadBalancerFailed   38m                 service-controller  (combined from similar events): Error syncing load balancer: failed to ensure load balancer: error creating\n Appendix B - Example values.yaml file for Helm Quickstart \n In the example below the application will deploy with embedded databases and will use  nginx \nas the ingress controller. Replace  <YOUR-DOMAIN>  with the domain you\'ve configured for your cluster. \n app:\n name: quickstart\n dbms: none\noperator:\n supportOpenshift: false\n env:\n   ENTANDO_DOCKER_IMAGE_VERSION_FALLBACK: 6.0.0\n   #ENTANDO_DOCKER_REGISTRY_OVERRIDE: docker.io # Remove comment if you want to always use a specific docker registry\n   #ENTANDO_DOCKER_IMAGE_ORG_OVERRIDE: entando # Remove the comment if you want to always use a specific docker organization\n   ENTANDO_DEFAULT_ROUTING_SUFFIX: <YOUR-DOMAIN>\n   ENTANDO_POD_READINESS_TIMEOUT_SECONDS: "1000"\n   ENTANDO_POD_COMPLETION_TIMEOUT_SECONDS: "1000"\n   ENTANDO_DISABLE_KEYCLOAK_SSL_REQUIREMENT: "true"\n   ENTANDO_K8S_OPERATOR_IMPOSE_DEFAULT_LIMITS: "false"\n   ENTANDO_REQUIRES_FILESYSTEM_GROUP_OVERRIDE: "true"\n   ENTANDO_INGRESS_CLASS: "nginx"\n tls:\n   caCrt:\n   tlsCrt:\n   tlsKey:\ndeployPDA: false\n\n \n '},{title:"Deprecated: Creating an Entando Component Repository (ECR) bundle using npm registry",frontmatter:{},regularPath:"/v6.2/tutorials/ecr/tutorials/create-ecr-bundle-from-npm.html",relativePath:"v6.2/tutorials/ecr/tutorials/create-ecr-bundle-from-npm.md",key:"v-43efab4d",path:"/v6.2/tutorials/ecr/tutorials/create-ecr-bundle-from-npm.html",headers:[{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Create a bundle folder",slug:"_1-create-a-bundle-folder"},{level:3,title:"2. Add a descriptor.yaml file",slug:"_2-add-a-descriptor-yaml-file"},{level:3,title:"3. Add a simple component to the bundle",slug:"_3-add-a-simple-component-to-the-bundle"},{level:3,title:"4. Make the bundle an NPM module to be hostable on an NPM registry.",slug:"_4-make-the-bundle-an-npm-module-to-be-hostable-on-an-npm-registry"},{level:3,title:"5. Publish the bundle on an NPM registry",slug:"_5-publish-the-bundle-on-an-npm-registry"},{level:3,title:"6. Create the EntandoDeBundle custom resource for Kubernetes",slug:"_6-create-the-entandodebundle-custom-resource-for-kubernetes"},{level:3,title:"7. Upload the bundle to Kubernetes",slug:"_7-upload-the-bundle-to-kubernetes"},{level:2,title:"Conclusion",slug:"conclusion"},{level:2,title:"Resources",slug:"resources"}],lastUpdated:"12/15/2020, 3:24:13 PM",lastUpdatedTimestamp:1608063853e3,content:' Deprecated: Creating an Entando Component Repository (ECR) bundle using npm registry \n Important \n This method is deprecated in favor of git which is the default repository mechanism for bundles as of Entando 6.2.\nSee  https://github.com/entando-k8s/entando-component-manager  for the necessary settings to use npm instead of git.\nSupport for npm registry will be discontinued in the future. \n Purpose \n Generate a simple Entando Component Repository (ECR) bundle shareable in an Entando 6 environment using npm registry \n Requirements \n You can create the bundle using you favorite text/code editor. To share the bundle you will need: \n \n Node / NPM \n An NPM registry where to upload the bundle \n A K8S cluster where to upload the bundle (e.g. minikube, microk8s, minishift) configured correctly for Entando 6 \n A namespace in the cluster reachable from the operator and entando-k8s-service \n The  entando-bundle-cli  command-line tool to generate the necessary metadata to share the bundle in a Kubernetes cluster \n Steps \n 1. Create a bundle folder \n To start, let’s create a new folder to host your bundle. \n mkdir example-bundle && cd example-bundle\n 2. Add a descriptor.yaml file \n For a bundle to be readable by the ECR it will need at least a  descriptor.yaml  file in the folder. Let’s create it with some minimal information. \n vim descriptor.yaml\n \n Here is some content for your base descriptor. \n code: example-bundle\ndescription: This is an example of an Entando 6 bundle\n\ncomponents:\n 3. Add a simple component to the bundle \n This bundle will contains only a simple widget. \n Let’s first create the widget metadata in a dedicated folder. \n mkdir widgets\n\nvim widgets/example-widget.yaml\n \n Now let’s populate the  example-widget.yaml  metadata with some content: \n code: example-widget\ntitles:\n  en: Example Widget\n  it: Widget d\'esempio\ngroup: free\ncustomUi: <h2>Hi from Example Widget</h2>\n \n Finally, add a reference to this widget in the bundle  descriptor.yaml  file. \n code: example-bundle\ndescription: This is an example of a Entando 6 bundle\n\ncomponents:\n    widgets:\n        - widgets/example-widget.yaml\n 4. Make the bundle an NPM module to be hostable on an NPM registry. \n From the bundle root, initialize a  package.json  file \n npm init\n \n Follow the instructions on screen. Here is an example of a possible  package.json  file: \n {\n  "name": "example-bundle",\n  "version": "1.0.0",\n  "description": "An example of an Entando6 bundle",\n  "license": "LGPL-2.1",\n  "main": "descriptor.yaml",\n  "keywords": [\n    "entando6",\n    "digital-exchange",\n    "entando-de-bundle"\n  ]\n}\n \n \n Note \n Try to keep the name of the published bundle the same as the bundle code in the descriptor.yaml file to avoid confusion. \n 5. Publish the bundle on an NPM registry \n Now your bundle is ready to be published on an NPM registry. \n From the root of the bundle (where the package.json and descriptor.yaml files are) you can issue an  npm publish  command. \n \n Important \n It would be ideal to have a private npm registry to upload this into.\nCheck the  resources section  for more details; \n \n npm publish --registry=<your-registry>\n 6. Create the EntandoDeBundle custom resource for Kubernetes \n Assuming the "entando-bundle-cli" command-line utility is already installed and available globally on your system, you can now convert the module into an EntandoDeBundle K8S custom resource. We assume you have a namespace in a Kubernetes cluster which is readable from the Entando Operator and you have the permissions to create resources there. Let’s call this namespace  accessible-ns \n You can also provide a thumbnail for your bundle using  --thumbnail-url=<your-thumbnail-url . \n entando-bundle from-npm @entando/example-bundle --name=example-bundle --namespace=accessible-ns --dry-run > example-bundle.yaml\n 7. Upload the bundle to Kubernetes \n Now you simply need to upload the bundle into Kubernetes. \n kubectl create -f example-bundle.yaml\n Conclusion \n You should now have the bundle available in your cluster and accessible from the App Builder. \n Resources \n \n \n Setup a local npm registry for testing\npurposes \n \n \n Entando Bundle CLI\nproject \n \n \n'},{title:"Deprecated: Create a local NPM registry for testing",frontmatter:{},regularPath:"/v6.2/tutorials/ecr/how-to-create-local-npm-registry.html",relativePath:"v6.2/tutorials/ecr/how-to-create-local-npm-registry.md",key:"v-ab0e5bc0",path:"/v6.2/tutorials/ecr/how-to-create-local-npm-registry.html",headers:[{level:2,title:"Start local nexus as a docker container",slug:"start-local-nexus-as-a-docker-container"},{level:2,title:"Setup a private npm registry",slug:"setup-a-private-npm-registry"},{level:2,title:"Setup npm-realm and user for publishing",slug:"setup-npm-realm-and-user-for-publishing"},{level:2,title:"Create the role",slug:"create-the-role"},{level:2,title:"Create the user",slug:"create-the-user"},{level:2,title:"Enable npm realm to support npm adduser or npm login",slug:"enable-npm-realm-to-support-npm-adduser-or-npm-login"},{level:2,title:"Configure NPM",slug:"configure-npm"},{level:2,title:"Config npm to use the local repository",slug:"config-npm-to-use-the-local-repository"},{level:2,title:"Login to the registry",slug:"login-to-the-registry"},{level:2,title:"Good to go",slug:"good-to-go"},{level:2,title:"Set the publish repository at package.json level",slug:"set-the-publish-repository-at-package-json-level"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:' Deprecated: Create a local NPM registry for testing \n Important \n This method is deprecated in favor of git which is the default repository mechanism for bundles as of Entando 6.2.\nSee  https://github.com/entando-k8s/entando-component-manager  for the necessary settings to use npm instead of git.\nSupport for npm registry will be discontinued in the future. \n \n As a registry you can use whatever technology you prefer. Some examples\nare the  NPM official registry ,\n Verdaccio  or\n Nexus \n For development purposes, let’s start a local Nexus repository and set\nit up as NPM registry \n Start local nexus as a docker container \n Start by creating a volume to host all the data you will build in nexus.\nThis is useful to save the content even if you will remove the docker\ncontainer. You can follow two different approaches here: 1. You create a\ndocker volume and mount it (that’s the sonatype recommanded approach) 2.\nYou create a folder, change the modification to 777 and use that as a\nvolume \n By following the first approach, here are the commands you will need to\nissue in order to run Nexus as a docker container using the docker\ncommand \n docker volume create --name nexus-data\ndocker run -d -p 8081:8081 --name nexus -v nexus-data:/nexus-data sonatype/nexus3\n \n With the second approach, create a directory (e.g.  nexus-data ) and set\nthe own to UID 200 \n mkdir nexus-data && chown -R 200:200 nexus-data\ndocker run -d -p 8081:8081 --name nexus -v "$(pwd)/nexus-data":/nexus-data sonatype/nexus3\n \n Nexus should be available at your localhost at port 8081 \n Now you need to sign-in as an admin to configure Nexus and make it\nusable as a private npm repository. To do so, you need to get the admin\ncredential from inside the container. \n docker exec -it nexus cat /nexus-data/admin.password\n \n Now you can use the password to access your private nexus instance as an\nadmin and change the admin password to something easier for you to work\nwith. \n Setup a private npm registry \n \n NOTE : Nexus allows you to setup both a private registry and a\nproxy to an external registry. For development purposes, having only a\nprivate registry could make sense in order to retrieve only local\nmodules and not modules available on remote registries, though feel\nfree to setup also a proxy if you want to get access to npm modules\noutside of the private registry. Check out the\n documentation \non nexus website for further details. \n \n To setup a local repository: 1. Go to the\n Server administration and configuration  page 2. Go to repositories 3.\nCreate a new repository 4. Choose the  npm (hosted)  5. Provide a name\nand save \n \n NOTE : If you want you can also create a group repository to\nsupport search from multiple sources (local/proxies) at the same time. \n Setup npm-realm and user for publishing \n In order to be able to login and publish into a repository you need to \n \n Create a role to enable user publishing 2. Create a user and assign\nroles to them 3. Enable the NPM realm to support  npm adduser  or\n npm login  commands \n Create the role \n \n \n Go to  Security > Roles > Create role > Nexus Role \n \n \n Choose a role ID and name \n \n \n In the privileges, add the one required for publishing, e.g.\n nx-repository-view-npm-<your-repo>-* \n \n \n Save \n Create the user \n \n \n Go to  Security > Users > Create local user \n \n \n Add the relevant informations for your user, set the user  Active \nand add the role you created in the previous step \n Enable npm realm to support  npm adduser  or  npm login \n \n \n Go to  Security > Realms \n \n \n Add  the npm Bearer Token Realm  to the active column \n Configure NPM \n Config npm to use the local repository \n In order to use the private repository as default repository you need to\nconfigure npm accordingly (or use the  --registry=  option with all your\ncommands) \n npm config set registry http://localhost:8081/repository/<repo-name>/\n \n \n Note A : The trailing slash at the end of the repository is\nrequired for the repository to work \n \n \n Note B : This repository will be used for all the npm methods, so\nbare in mind that changing the global repository will potentially\nbreak other projects. If you want to avoid this, continue to use the\n --registry  option. \n Login to the registry \n You should be able to login to the registry using the login command \n npm login --registry=http://localhost:8081/repository/<repo-name>/\n Good to go \n You can now publish your own npm modules to the private registry using\nthe publish command \n npm publish --registry=http://localhost:8081/repository/<repo-name>/\n Set the publish repository at package.json level \n In your npm module you can also add to the  package.json  an entry to\nmake the private repository the default for publishing. Add this to your\npackage.json file \n   "publishConfig": {\n    "registry": "http://localhost:8081/repository/<repo-name>/"\n  }\n \n '},{title:"Installation on OpenShift",frontmatter:{sidebarDepth:2},regularPath:"/v6.2/tutorials/devops/installation/open-shift/openshift-install.html",relativePath:"v6.2/tutorials/devops/installation/open-shift/openshift-install.md",key:"v-6e9a7bb4",path:"/v6.2/tutorials/devops/installation/open-shift/openshift-install.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Local Installation",slug:"local-installation"},{level:3,title:"Install the Entando Custom Resource Definitions (CRDs)",slug:"install-the-entando-custom-resource-definitions-crds"},{level:3,title:"Get your Cluster Default Ingress",slug:"get-your-cluster-default-ingress"},{level:3,title:"Setup and Deploy",slug:"setup-and-deploy"},{level:2,title:"Appendix A - Troubleshooting and Common Errors",slug:"appendix-a-troubleshooting-and-common-errors"},{level:3,title:"Permission Errors",slug:"permission-errors"},{level:3,title:"Forbidden Error installing Entando Custom Resource Definitions in Minishift or CRC",slug:"forbidden-error-installing-entando-custom-resource-definitions-in-minishift-or-crc"},{level:3,title:"Application is not available when accessing app builder",slug:"application-is-not-available-when-accessing-app-builder"},{level:3,title:"Network Issues",slug:"network-issues"},{level:2,title:"Appendix B - Example values.yaml file for Helm Quickstart",slug:"appendix-b-example-values-yaml-file-for-helm-quickstart"}],lastUpdated:"11/12/2020, 8:49:01 AM",lastUpdatedTimestamp:1605188941e3,content:' Installation on OpenShift \n Prerequisites \n \n An OpenShift installation (3.11 or 4.x) \n oc  command line tool \n A helm 3 client \n Local Installation \n If you want to run OpenShift in your local development environment you can run Minishift (OpenShift 3.11) or Code Ready Containers (OpenShift 4). Use the local development version that matches the cluster where you intend to deploy your application. \n For Minishift:  https://docs.okd.io/3.11/minishift/getting-started/installing.html \n For CRC:  https://developers.redhat.com/products/codeready-containers/download \n Once you\'ve completed the installation above capture the local IP address of your development instance using  minishift ip  or  crc ip . You\'ll need it when configuring your Entando application. \n Login to your OpenShift environment from the command line with  oc login  using the URL and credentials for your cluster. \n Install the Entando Custom Resource Definitions (CRDs) \n Once per cluster you need to deploy the  Entando Custom Resources . This is the only step in this guide that requires cluster level access. If you are running on Minishift or CRC make sure you are connected using the administrator login provided when you started your local instance. \n \n Download the Custom Resource Definitions (CRDs) and unpack them: \n \n curl -L -C - https://raw.githubusercontent.com/entando/entando-releases/v6.2.0/dist/qs/custom-resources.tar.gz | tar -xz\n \n \n Install the Entando CRDs: \n \n oc create -f dist/crd\n Get your Cluster Default Ingress \n If you\'re deploying on a managed cluster get the default hostname from your cluster administrator. Entando uses wildcard addressing to connect different parts of your Entando application and the default route for applications exposed on your cluster is needed. You\'ll set this value in step 3 below. \n Setup and Deploy \n \n Download and unpack the entando-helm-quickstart release you want to use from here:\n https://github.com/entando-k8s/entando-helm-quickstart/releases \n \n See the included README file for more information on the following steps. \n \n \n \n curl -sfL https://github.com/entando-k8s/entando-helm-quickstart/archive/v6.2.0.tar.gz | tar xvz\n \n \n Change into the new directory \n \n cd entando-helm-quickstart-6.2.0\n \n \n Edit  values.yaml in the root directory:\n \n Set  supportOpenshift: true \n If you\'re deploying to a managed cluster:\n \n Set  ENTANDO_DEFAULT_ROUTING_SUFFIX  to the default URL of applications deployed in your OpenShift cluster. If you\'re unsure of this value, please check with your cluster administrator for this URL. \n Entando will create applications using that default URL and relies on wildcard DNS resolution. \n \n \n If you\'re using Minishift or CRC:\n \n Set  ENTANDO_DEFAULT_ROUTING_SUFFIX  to the value from  minishift ip  or  crc ip  plus  nip.io . For example,  ENTANDO_DEFAULT_ROUTING_SUFFIX: 192.168.64.10.nip.io \n \n \n See  Appendix B  for an example values.yaml \n \n \n Create the Entando namespace: \n \n oc new-project entando\n \n \n Update helm dependencies: \n \n helm dependency update\n \n \n Run helm to generate the template file: \n \n helm template my-app --namespace=entando ./ > my-app.yaml\n \n \n If you\'re using Helm 2 instead of Helm 3, then replace  helm template my-app  with  helm template --name=my-app \n \n \n Deploy Entando via \n \n oc create -f my-app.yaml\n \n \n If you see this error  no matches for kind "Deployment" in version "extensions/v1beta1" , then you\'ll need to edit my-app.yaml and set  apiVersion: "apps/v1"  for the Deployment. \n \n \n Watch Entando startup \n \n oc get pods -n entando --watch\n \n \n This step is complete when the  quickstart-server  pod shows 3/3 running. For example, \n \n quickstart-server-deployment-6c89fb49f7-gpmqc   3/3   Running   0     72s\n \n \n The full pod name will differ but by default will start with  quickstart-server-deployment . \n \n \n Check for the Entando ingresses using  oc describe ingress -n entando . This is a snippet: \n \n Name:             quickstart-ingress\nNamespace:        entando\nAddress:          \nDefault backend:  default-http-backend:80 (<none>)\nRules:\n  Host                                 Path  Backends\n  ----                                 ----  --------\n  quickstart-entando.192.168.64.10.nip.io  \n                                       /entando-de-app     quickstart-server-service:8080 (<none>)\n                                       /digital-exchange   quickstart-server-service:8083 (<none>)\n                                       /app-builder/       quickstart-server-service:8081 (<none>)\n \n The host path in the configuration above plus  /app-builder/  (trailing slash is important) will allow you to log into your environment. For example,\n http://quickstart-entando.192.168.64.10.nip.io/app-builder/ \n Appendix A - Troubleshooting and Common Errors \n Permission Errors \n If you get OpenShift permission errors deploying your Entando application into your OpenShift namespace make sure your user has the  escalate  and  bind  verbs on Roles in the namespace you\'re deploying to. Ultimately you need this command to  oc auth can-i escalate role  to return  yes . That access is only required in the namespace where you are deploying your Entando application. No cluster level access is required. \n Check with your cluster administrator if you need help assigning these roles. Generally this requires the creation of a role with those permissions, preferably a ClusterRole, and then depending on how administrators manage security your Entando installer needs to be given that role in the target namespace. So let\'s assume the clusterRole we create is  entando-installer  and the user\'s name is john, on OpenShift creating the rolebinding would be:\n oc policy add-role-to-user entando-installer john -n <your-namespace> \n Before installing, we suggest running  oc auth can-i escalate role  with your given user in the targeted namespace. If it says "yes" you should be able to install. \n Forbidden Error installing Entando Custom Resource Definitions in Minishift or CRC \n If you get an error like the one below installing the CRDs in your local instance you need to login using the administrator role. \n /opt/ocInstallLocal$ oc create -f dist/crd/\nError from server (Forbidden): error when creating "dist/crd/EntandoAppCRD.yaml": customresourcedefinitions.apiextensions.k8s.io is forbidden: User "developer" cannot create resource "customresourcedefinitions" in API group "apiextensions.k8s.io" at the cluster scope\n \n The administrator credentials are printed when you started your local cluster in a message like this one: \n To access the cluster, first set up your environment by following \'crc oc-env\' instructions\nINFO Then you can access it by running \'oc login -u developer -p developer https://api.crc.testing:6443\'\nINFO To login as an admin, username is \'kubeadmin\' and password is xxxx-xxxx-xxxx-xxxx\n Application is not available when accessing app builder \n If you get the message "Application is not available" when accessing the app-builder make sure to include a trailing slash in the URL. For example,\nhttp://quickstart-entando.192.168.64.10.nip.io/app-builder/ \n Network Issues \n If you see errors when images are being retrieved (resulting in errors like ErrImagePull or ImagePullBackOff), you may want to start crc using  crc start -n "8.8.8.8  or configure the nameserver using  crc config set nameserver 8.8.8.8  before running  crc start . This will allow the cluster to perform DNS lookups via Google\'s public DNS server. \n If you\'re on Windows, you should also check out the notes  here  since Minishift and CRC rely on Windows Hyper-V by default. This can result in network issues when the host computer is restarted. \n Appendix B - Example values.yaml file for Helm Quickstart \n The example below includes configuration for deployment on a locally installed instance: \n app:\n  name: quickstart\n  dbms: none\n#externalDatabase:\n host: some.db.host\n port: 32432\n databaseName: sampledb\n username:\n password:\noperator:\n  supportOpenshift: true\n  env:\n    ENTANDO_DOCKER_IMAGE_VERSION_FALLBACK: 6.0.0\n    #ENTANDO_DOCKER_REGISTRY_OVERRIDE: docker.io # Remove comment if you want to always use a specific docker registry\n    #ENTANDO_DOCKER_IMAGE_ORG_OVERRIDE: entando # Remove the comment if you want to always use a specific docker organization\n    ENTANDO_DEFAULT_ROUTING_SUFFIX: 192.168.64.10.nip.io\n    ENTANDO_POD_READINESS_TIMEOUT_SECONDS: "1000"\n    ENTANDO_POD_COMPLETION_TIMEOUT_SECONDS: "1000"\n    ENTANDO_DISABLE_KEYCLOAK_SSL_REQUIREMENT: "true"\n    ENTANDO_K8S_OPERATOR_IMPOSE_DEFAULT_LIMITS: "false"\n    ENTANDO_K8S_OPERATOR_FORCE_DB_PASSWORD_RESET: "true"\n  tls:\n    caCrt:\n    tlsCrt:\n    tlsKey:\ndeployPDA: false\n \n '},{title:"How to setup a Nexus instance on a Kubernetes cluster",frontmatter:{},regularPath:"/v6.2/tutorials/ecr/how-to-setup-nexus-on-kubernetes-cluster.html",relativePath:"v6.2/tutorials/ecr/how-to-setup-nexus-on-kubernetes-cluster.md",key:"v-701e8b40",path:"/v6.2/tutorials/ecr/how-to-setup-nexus-on-kubernetes-cluster.html",headers:[{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Create a namespace for nexus",slug:"_1-create-a-namespace-for-nexus"},{level:3,title:"2. Create the deployment file.",slug:"_2-create-the-deployment-file"},{level:3,title:"3. Create the deployment",slug:"_3-create-the-deployment"},{level:3,title:"4. Create a service for nexus",slug:"_4-create-a-service-for-nexus"},{level:3,title:"5. Access nexus",slug:"_5-access-nexus"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:' How to setup a Nexus instance on a Kubernetes cluster \n Requirements \n \n \n A kubernetes cluster (that could be minikube, minishift, microk8s,\netc.) \n \n \n A dedicated namespace for nexus (we are going to use  nexus  as\ntarget namespace) \n Steps \n 1. Create a namespace for nexus \n We are going to deploy our nexus instance on a namespace called  nexus \n kubectl create namespace nexus\n 2. Create the deployment file. \n Let’s create a  Deployment.yaml  file to describe our nexus\ndeployment. \n Here things get a little bit different between nexus 2.x and nexus 3.x.\nIn both cases though we are going to use a volume mount for nexus-data,\nremember that this is going to be removed when the pod is removed. In\nproduction you should probably use some kind of persistent data. \n Nexus 2.x \n Here we are passing a few customizable ENV variable and adding a volume\nmount for nexus data. \n Deployment.yaml. \n     apiVersion: apps/v1\n    kind: Deployment\n    metadata:\n      name: nexus\n      namespace: nexus\n    spec:\n      replicas: 1\n      template:\n        metadata:\n          labels:\n            app: nexus-server\n        spec:\n          containers:\n            - name: nexus\n              image: sonatype/nexus:latest\n              env:\n              - name: MAX_HEAP\n                value: "800m"\n              - name: MIN_HEAP\n                value: "300m"\n              resources:\n                limits:\n                  memory: "4Gi"\n                  cpu: "1000m"\n                requests:\n                  memory: "2Gi"\n                  cpu: "500m"\n              ports:\n                - containerPort: 8081\n              volumeMounts:\n                - name: nexus-data\n                  mountPath: /sonatype-work\n          volumes:\n            - name: nexus-data\n              emptyDir: {}\n Nexus 3.x \n For Nexus 3.x we dont use any custom env variables. You can check the\nofficial docker repo for the supported env variables. \n Deployment.yaml. \n     apiVersion: extensions/v1beta1\n    kind: Deployment\n    metadata:\n      name: nexus\n      namespace: nexus\n    spec:\n      replicas: 1\n      selector:\n        matchLabels:\n            app: nexus-server\n      template:\n        metadata:\n          labels:\n            app: nexus-server\n        spec:\n          containers:\n            - name: nexus\n              image: sonatype/nexus3:latest\n              resources:\n                limits:\n                  memory: "4Gi"\n                  cpu: "1000m"\n                requests:\n                  memory: "2Gi"\n                  cpu: "500m"\n              ports:\n                - containerPort: 8081\n              volumeMounts:\n                - name: nexus-data\n                  mountPath: /nexus-data\n          volumes:\n            - name: nexus-data\n              emptyDir: {}\n 3. Create the deployment \n Now let’s create the deployment \n kubectl create -f Deployment.yaml\n \n You can check the deployment pod status with \n kubectl get pod -n nexus\n 4. Create a service for nexus \n Now you need to create a  Service.yaml  file that will to expose the\nnexus endpoint using NodePort. \n \n Note \n If you are on a cloud, you can expose the service using a load\nbalancer using the service type Loadbalancer. Also, the Prometheus\nannotations will help in service endpoint monitoring by Prometheus. \n \n Service.yaml. \n apiVersion: v1\nkind: Service\nmetadata:\n  name: nexus-service\n  namespace: devops-tools\n  annotations:\n      prometheus.io/scrape: \'true\'\n      prometheus.io/path:   /\n      prometheus.io/port:   \'8081\'\nspec:\n  selector:\n    app: nexus-server\n  type: NodePort\n  ports:\n    - port: 8081\n      targetPort: 8081\n      nodePort: 32000\n \n Now you can create the service \n kubectl create -f Service.yaml\n \n Check the service configuration using kubectl. \n kubectl describe service nexus-service -n devops-tools\n 5. Access nexus \n Now you will be able to access nexus on any of the Kubernetes node IP on\nport 32000/nexus as we have exposed the node port. For example, \n \n \n \n \n \n \n \n Service \n Url \n \n \n Nexus 2 \n http://35.144.130.153:32000/nexus \n \n \n Nexus 3 \n http://35.144.130.153:32000 \n \n \n \n \n Note \n For Nexus 2.x and Nexus 3 < 3.17 the default username and password\nwill be admin & admin123, while for Nexus 3 >= 3.17 you need to get\nthe password from within the container with\n cat /nexus-data/admin.password \n \n'},{title:"Creating an Entando Component Repository (ECR) bundle using git repository",frontmatter:{},regularPath:"/v6.2/tutorials/ecr/tutorials/create-ecr-bundle-from-git.html",relativePath:"v6.2/tutorials/ecr/tutorials/create-ecr-bundle-from-git.md",key:"v-3d12ebad",path:"/v6.2/tutorials/ecr/tutorials/create-ecr-bundle-from-git.html",headers:[{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Create a bundle folder",slug:"_1-create-a-bundle-folder"},{level:3,title:"2. Add a descriptor.yaml file",slug:"_2-add-a-descriptor-yaml-file"},{level:3,title:"3. Add a simple component to the bundle",slug:"_3-add-a-simple-component-to-the-bundle"},{level:3,title:"4. Initialize git and add remote repository",slug:"_4-initialize-git-and-add-remote-repository"},{level:3,title:"5. Publish a git tag",slug:"_5-publish-a-git-tag"},{level:3,title:"6. Create the EntandoDeBundle custom resource for Kubernetes",slug:"_6-create-the-entandodebundle-custom-resource-for-kubernetes"},{level:3,title:"7. Upload the bundle to Kubernetes.",slug:"_7-upload-the-bundle-to-kubernetes"},{level:2,title:"Conclusion",slug:"conclusion"},{level:2,title:"Resources",slug:"resources"}],lastUpdated:"12/15/2020, 3:24:13 PM",lastUpdatedTimestamp:1608063853e3,content:' Creating an Entando Component Repository (ECR) bundle using git repository \n Purpose \n Generate a simple Entando Component Repository (ECR) bundle shareable in an Entando 6 environment using git repository \n Requirements \n You can create the bundle using you favorite code editor. To share the bundle you will need: \n \n NodeJS,  npm , and  git \n A K8S cluster where to upload the bundle (e.g. minikube, microk8s, minishift) configured correctly for Entando 6 \n A namespace in the cluster reachable from the operator and entando-k8s-service \n The  entando-bundle-cli  command-line tool to generate the necessary metadata to share the bundle in a Kubernetes cluster \n Steps \n 1. Create a bundle folder \n To start, let’s create a new folder to host your bundle. \n mkdir example-bundle && cd example-bundle\n 2. Add a descriptor.yaml file \n For a bundle to be readable by the ECR it will need at least a  descriptor.yaml  file in the folder. Let’s create it with some minimal information. \n vim descriptor.yaml\n \n Here is some content for your base descriptor. \n code: example-bundle\ndescription: This is an example of an Entando 6 bundle\n\ncomponents:\n 3. Add a simple component to the bundle \n This bundle will contains only a simple widget. \n Let’s first create the widget metadata in a dedicated folder. \n mkdir widgets\n\nvim widgets/example-widget.yaml\n \n Now let’s populate the  example-widget.yaml  metadata with some content: \n code: example-widget\ntitles:\n  en: Example Widget\n  it: Widget d\'esempio\ngroup: free\ncustomUi: <h2>Hi from Example Widget</h2>\n \n Finally, add a reference to this widget in the bundle  descriptor.yaml  file. \n code: example-bundle\ndescription: This is an example of a Entando 6 bundle\n\ncomponents:\n    widgets:\n        - widgets/example-widget.yaml\n 4. Initialize git and add remote repository \n From the bundle root, run \n git init\ngit add .\ngit commit -m "Init Git repository"\n \n This will initialize an empty Git repository and commit files. \n Add remote repository as origin and push the bundle. \n git remote add origin https://your/remote/repository.git\ngit push -u origin master\n \n \n Important \n descriptor.yaml  file has to be at the root of repository. \n 5. Publish a git tag \n Your bundle has to have a tag. To add it, run \n git tag -a "v0.0.1" -m "My first tag"\ngit push --tags\n 6. Create the EntandoDeBundle custom resource for Kubernetes \n Assuming the "entando-bundle-cli" command-line utility is already installed and available globally on your system, you can now convert the module into an EntandoDeBundle K8S custom resource. We assume you have a namespace in a Kubernetes cluster which is readable from the Entando Operator and you have the permissions to create resources there. Let’s call this namespace  accessible-ns \n You can also provide a thumbnail for your bundle using  --thumbnail-url=<your-thumbnail-url . \n Run the  entando-bundle from-git  command providing your remote git repository link (created in step 4) as  --repository  option: \n entando-bundle from-git --name=example-bundle --namespace=accessible-ns --repository=https://your/remote/repository.git --dry-run > example-bundle.yaml\n 7. Upload the bundle to Kubernetes. \n Now you simply need to upload the bundle into Kubernetes. \n kubectl create -f example-bundle.yaml\n Conclusion \n You should now have the bundle available in your cluster and accessible from the App Builder. \n Resources \n \n Entando Bundle CLI\nproject \n \n'},{title:"Use Blueprint Generated Plugin and Micro Frontends Without a Bundle",frontmatter:{},regularPath:"/v6.2/tutorials/ecr/tutorials/ecr-deploy-use-plugin-and-mfe-without-bundle.html",relativePath:"v6.2/tutorials/ecr/tutorials/ecr-deploy-use-plugin-and-mfe-without-bundle.md",key:"v-ebd258e6",path:"/v6.2/tutorials/ecr/tutorials/ecr-deploy-use-plugin-and-mfe-without-bundle.html",headers:[{level:2,title:"Objective",slug:"objective"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:2,title:"1. Generate a docker image for your microservice",slug:"_1-generate-a-docker-image-for-your-microservice"},{level:2,title:"2. Publish the Docker image to Docker registry (DockerHub or equivalent)",slug:"_2-publish-the-docker-image-to-docker-registry-dockerhub-or-equivalent"},{level:2,title:"3. Deploy the plugin into your Entando cluster",slug:"_3-deploy-the-plugin-into-your-entando-cluster"},{level:2,title:"4. Wait for your plugin to be in Running state and link the plugin with the app using an EntandoAppPluginLink custom resource",slug:"_4-wait-for-your-plugin-to-be-in-running-state-and-link-the-plugin-with-the-app-using-an-entandoapppluginlink-custom-resource"},{level:2,title:"5. Upload the micro frontends to your Entando App",slug:"_5-upload-the-micro-frontends-to-your-entando-app"},{level:2,title:"6. Use the microfrontend and microservice",slug:"_6-use-the-microfrontend-and-microservice"}],lastUpdated:"12/8/2021, 3:22:31 PM",lastUpdatedTimestamp:1638994951e3,content:' Use Blueprint Generated Plugin and Micro Frontends Without a Bundle \n Objective \n In this tutorial you will learn how to use the plugin and microfrontend generated using the Entando Blueprint\nin a running cluster without the need to include the components in a bundle. \n If you haven\'t already generated a plugin and micro frontends with the component generator go here first  Generate a Plugin \n Requirements \n \n \n An Entando Plugin built with the Entando Component Generator and populated with micro frontends \n \n \n Node and NPM are installed on your machine (use LTS version) \n \n \n Docker is installed on your machine and you are able to upload images to docker-hub or an image repository of your\nchoice \n \n \n An installed instance of the Entando platform running Kubernetes. See  Getting Started \n Steps \n 1. Generate a docker image for your microservice \n JHipster uses the JIB Maven plugin to generate a docker image for your\nmicroservice. \n The name of the output image generated with JIB will be composed by: \n \n The organization you chose during the setup wizard (by default that\'s set to  entando ) \n The name of the application \n Version  0.0.1-SNAPSHOT \n \n You can build the docker image with this command \n ./mvnw -Pprod clean package jib:dockerBuild\n \n If for example during setup wizard you chose a custom organization  myorg  and the set the application name to  jhipster  the resulting docker image is going to be  myorg/jhipster:0.0.1-SNAPSHOT \n \n Note \n The output image name can be changed in the  pom.xml  file by configuring\nthe  plugins.plugin.jib-maven-plugin.configuration.to.image  tag \n \n  <plugin>\n   <groupId>com.google.cloud.tools</groupId>\n   <artifactId>jib-maven-plugin</artifactId>\n   <configuration>\n     \x3c!-- ... --\x3e\n     <to>\n       <image>\x3c!-- use a custom value here --\x3e</image>\n     </to>\n     \x3c!-- ... --\x3e\n   </configuration>\n </plugin>\n \n \n Note \n Output image name can also be set by customizing the  ./mvnw  command using the  -Djib.to.image \nparameter. For example, if you want to build an image with organization  myneworg , name  myapp  and version  latest  you can do \n \n  ./mvnw -Pprod clean package jib:dockerBuild -Djib.to.image=myneworg/myapp:latest\n \n \n Warning \n If you change the target image of the docker build, remember to update\nthe plugin metadata in the bundle accordingly. \n 2. Publish the Docker image to Docker registry (DockerHub or equivalent) \n Let’s now publish the docker image for the microservice to make it\navailable later during bundle installation in the cluster. \n docker push <name-of-the-image:tag>\n 3. Deploy the plugin into your Entando cluster \n You can now deploy the plugin custom resource generated by the Entando Blueprint in the  bundle/plugins  folder. \n \n Warning \n As stated in step 1, if you changed the target image of your docker build, the plugin custom resource\nin the  bundle/plugins  folder needs to be updated to point to the correct image \n \n From the jhipster project root \n cd  bundle/plugins\n\nkubectl create -f  < plugin-file.yaml >  -n entando\n 4. Wait for your plugin to be in  Running  state and link the plugin with the app using an  EntandoAppPluginLink  custom resource \n Once the plugin server deployment is up and running, you can create an  EntandoAppPluginLink custom resource \nto make the plugin API available from the EntandoApp domain. \n Here an example of a EntandoAppPluginLink custom resource. Some assumptions with this custom resource: \n \n The EntandoPlugin generated with the blueprint is  my-demo-plugin \n The EntandoApp exposing the  my-demo-plugin  APIs is  my-entando-app \n Both are deployed on the  entando  namespace. \n The link itself is named  my-entando-app-to-my-demo-plugin-link \n The name of the link yaml is  my-link.yaml \n \n \n Warning \n Remember to change the fields to match your setup. \n \n apiVersion: entando.org/v1\nkind: EntandoAppPluginLink\nmetadata:\n  name: my-entando-app-to-my-demo-plugin-link\n  namespace: entando\nspec:\n  entandoAppName: my-entando-app\n  entandoAppNamespace: entando\n  entandoPluginName: my-demo-plugin\n  entandoPluginNamespace: entando\n \n Now add this link to your environment \n kubectl create -f my-link.yaml -n entando\n \n A new link deployer will start and will work behind the scenes to add your plugin  ingressPath  (this is part of the\nplugin  spec ) to the EntandoApp ingress \n 5. Upload the micro frontends to your Entando App \n Now that the plugin and the app are linked together, you can proceed to generate the Micro Frontend from the App Builder\nand upload the static resources like  js  and  css  files. \n \n From AppBuilder go to  Configuration -> File Browser  and create a new folder inside the  public  folder and make the name of the folder the same as the name of the bundle (the value is in the  code  field available in the  /bundle/descriptor.yaml  file of the blueprint project) or using a custom name, e.g.  demo-widget \n \n \n Warning \n If you choose to use a custom folder, remember to update the references in the customUI of the widget later \n \n \n Upload all the resources available in the  /bundle/resources  folder\nof the blueprint project into the folder you created above in the App Builder file browser. \n \n \n Warning \n You can decide to recreate the folder structure to be the same as the one in  /bundle/resources  or not, but you need to update the\nreferences in the customUI / configUI of the widget later if you choose a different folder structure. \n \n \n \n Create the widget. In the App Builder go to  UX Patterns -> Widgets . \n \n \n Select  Add \n \n \n Set whatever title you want \n \n \n For the customUI copy the one created in one of the widgets you generated from the blueprint.\nAs an example, the customUI for the  detailWidget  of the conference entity is available in\n /bundle/ui/widgets/conference/detailsWidget/conference-details-widget.ftl \n \n \n \n Warning \n Remember to update all the references in the customUI to use the custom folder structure you defined \n \n \n Update the service url to match the location where you deployed the ingress for your microservice if you used a path different than the default. For example, \n \n Update the service-url value with the relative path of your service if you\'re deploying a bundle\n\t\tEx. <car-table service-url="/newBp/api"  />\n\tOr use the full path if you\'re deploying the BE and FE individually\n\t\tEx. <car-table service-url="http://newbp-plugin-entando.192.168.64.7.nip.io/newBp/api"/>\n \n \n Note \n As of Entando 6.3 your Entando application will include a keycloak_auth fragment by default that will inject the token\nand connection to Keycloak that your microfrontends need to invoke protected APIs. You can see this token at  UX Patterns -> Fragments  in the\nApp Builder and search for keycloak-auth. \n \n \n If you\'re creating a new page from scratch or your page is missing the Keycloak fragment you can add it with this freemarker snippet \n \n <@wp.fragment code="keycloak-auth" escapeXml=false />\n 6. Use the microfrontend and microservice \n You can now use your micro frontends and your microservice in your Entando App. \n'},{title:"Communicate Between Micro Frontends",frontmatter:{sidebarDepth:2},regularPath:"/v6.2/tutorials/micro-frontends/communication.html",relativePath:"v6.2/tutorials/micro-frontends/communication.md",key:"v-23fbd1b8",path:"/v6.2/tutorials/micro-frontends/communication.html",headers:[{level:2,title:"Publisher",slug:"publisher"},{level:3,title:"Create Custom Event",slug:"create-custom-event"},{level:3,title:"Update React App to Dispatch Event",slug:"update-react-app-to-dispatch-event"},{level:3,title:"Test Event Dispatcher",slug:"test-event-dispatcher"},{level:2,title:"Subscriber",slug:"subscriber"},{level:3,title:"Add Event Listener",slug:"add-event-listener"},{level:3,title:"Display Custom Event",slug:"display-custom-event"},{level:3,title:"Test Event Listener",slug:"test-event-listener"},{level:2,title:"Add Widgets to App Builder",slug:"add-widgets-to-app-builder"},{level:3,title:"Create Environment File",slug:"create-environment-file"},{level:3,title:"Run npm build",slug:"run-npm-build"},{level:3,title:"Create Public Folder",slug:"create-public-folder"},{level:3,title:"Add Widgets",slug:"add-widgets"},{level:3,title:"Add Page Template",slug:"add-page-template"},{level:3,title:"View on Homepage",slug:"view-on-homepage"},{level:2,title:"Angular to React",slug:"angular-to-react"},{level:3,title:"Create Angular Publisher",slug:"create-angular-publisher"},{level:3,title:"Add to App Builder",slug:"add-to-app-builder"}],lastUpdated:"8/11/2020, 4:23:51 PM",lastUpdatedTimestamp:1597177431e3,content:" Communicate Between Micro Frontends \n Recommended Learning \n \n Tutorial:  Create a React Micro Frontend \n Tutorial:  Create an Angular Micro Frontend \n \n \n Entando supports communication between micro frontends using  Custom Events , an established web standard. In this tutorial, we'll build: \n \n A React micro frontend that publishes an event \n A React micro frontend that listens to an event \n An Angular micro frontend that publishes an event to a React micro frontend \n Publisher \n Create a simple app to publish an event. \n npx create-react-app publisher-widget --use-npm\n \n Start the app. \n cd  publisher-widget\n \n npm  start\n Create Custom Event \n Next, add event firing logic. \n Add a new file  publisher-widget/src/PublisherWidgetElement.js . \n import  React  from   'react' ; \n import  ReactDOM  from   'react-dom' ; \n import  App  from   './App' ; \n\n const   EVENTS   =   { \n   greeting :   'greeting' , \n } ; \n\n class   PublisherWidgetElement   extends   HTMLElement   { \n\n   constructor ( )   { \n     super ( ) ; \n     this . onGreet   =   name   =>   this . publishWidgetEvent ( EVENTS . greeting ,   {  name  } ) ; \n   } \n\n   connectedCallback ( )   { \n     this . mountPoint  =  document . createElement ( 'div' ) ; \n     this . appendChild ( this . mountPoint ) ; \n     this . render ( ) ; \n   } \n\n   publishWidgetEvent ( eventId ,  detail )   { \n     const  widgetEvent  =   new   CustomEvent ( eventId ,   {  detail  } ) ; \n    window . dispatchEvent ( widgetEvent ) ; \n   } \n\n   render ( )   { \n    ReactDOM . render ( < App onGreet = { this . onGreet }   / > ,   this . mountPoint ) ; \n   } \n } \n\ncustomElements . define ( 'publisher-widget' ,  PublisherWidgetElement ) ; \n\n export   default  PublisherWidgetElement ; \n \n \n In the  CustomEvent  constructor,  detail  is the specific name to use in the event payload, as per the  DOM specification . \n Import Custom Element \n Update  publisher-widget/src/index.js . \n import   './index.css' ; \n import   './PublisherWidgetElement' ; \n Test Custom Element \n Update  publisher-widget/public/index.html , and view it in the browser. \n    < body > \n     < noscript > You need to enable JavaScript to run this app. </ noscript > \n     < publisher-widget   /> \n    ...\n   </ body > \n Update React App to Dispatch Event \n Update  publisher-widget/src/App.js . \n import  React  from   'react' ; \n import   './App.css' ; \n\n class   App   extends   React . Component   { \n   constructor ( props )   { \n     super ( props ) ; \n     this . state  =   {   name :   '' } ; \n   } \n\n   handleNameChange ( value )   { \n     this . setState ( prevState   =>   ( { \n       ... prevState , \n       name :  value , \n     } ) ) ; \n   } \n\n   render ( )   { \n     const   {  name  }   =   this . state ; \n     const   {  onGreet  }   =   this . props ; \n     return   ( \n       < div > \n         < h1 > Send a greeting < / h1 > \n         < label htmlFor = \"name\" > Name < / label > \n         < input id = \"name\"  onChange = { e   =>   this . handleNameChange ( e . target . value ) }  value = { name }   / > \n         < button onClick = { ( )   =>   onGreet ( name ) } > Say hello ! < / button > \n       < / div > \n     ) ; \n   } \n } \n\n export   default  App ; \n Test Event Dispatcher \n In the JavaScript console of your browser, enter: \n window . addEventListener ( 'greeting' ,   ( evt )   =>  console . log ( 'Hello' ,  evt . detail . name ) ) \n \n Write something in the text field. Click the \"Say hello!\" button and take a look at the JS console. It will show the event message. \n Congratulations! \n You’ve now published a custom event. \n Subscriber \n Next, let’s create the subscriber. \n npx create-react-app subscriber-widget --use-npm\n \n Start the app. \n cd  subscriber-widget\n \n npm  start\n Add Event Listener \n Add a new file  subscriber-widget/src/SubscriberWidgetElement.js . \n import  React  from   'react' ; \n import  ReactDOM  from   'react-dom' ; \n import  App  from   './App' ; \n\n const   EVENTS   =   { \n   greeting :   'greeting' , \n } ; \n\n class   SubscriberWidgetElement   extends   HTMLElement   { \n\n   constructor ( )   { \n     super ( ) ; \n     this . name  =   null ; \n     this . subscribeToWidgetEvent ( EVENTS . greeting ,   ( evt )   =>   this . onGreeting ( evt . detail . name ) ) ; \n   } \n\n   connectedCallback ( )   { \n     this . mountPoint  =  document . createElement ( 'div' ) ; \n     this . appendChild ( this . mountPoint ) ; \n     this . render ( ) ; \n   } \n\n   subscribeToWidgetEvent ( eventType ,  eventHandler )   { \n    window . addEventListener ( eventType ,  eventHandler ) ; \n   } \n\n   onGreeting ( name )   { \n     this . name  =  name ; \n     this . render ( ) ; \n   } \n\n   render ( )   { \n    ReactDOM . render ( < App name = { this . name }   / > ,   this . mountPoint ) ; \n   } \n } \n\ncustomElements . define ( 'subscriber-widget' ,  SubscriberWidgetElement ) ; \n\n export   default  SubscriberWidgetElement ; \n Import Custom Element \n Update  subscriber-widget/src/index.js . \n import   './index.css' ; \n import   './SubscriberWidgetElement' ; \n Test Micro Frontend \n Update  subscriber-widget/public/index.html , and view it in the browser. \n    < body > \n     < noscript > You need to enable JavaScript to run this app. </ noscript > \n     < subscriber-widget > \n    ...\n   </ body > \n Display Custom Event \n Update  subscriber-widget/src/App.js . \n import  React  from   'react' ; \n import   './App.css' ; \n\n function   App ( {  name  } )   { \n   return  name  ?   ( < h2 > Just got a greeting from  { name } < / h2 > ) \n     :   ( < h2 > Waiting  for  a greeting ... < / h2 > ) ; \n } \n\n export   default  App ; \n Test Event Listener \n In the JavaScript console of your browser, enter: \n const  widgetEvent  =   new   CustomEvent ( 'greeting' ,   { \n   detail :   { \n     name :   'Pippo' \n   } , \n } ) ; \nwindow . dispatchEvent ( widgetEvent ) ; \n \n The custom event should now display in the  subscriber-widget . \n Congratulations! \n You’ve now created a micro frontend that listens to custom events. \n Add Widgets to App Builder \n Now let's add the publisher and subscriber micro frontends in Entando. \n \n Note: These are the same steps as the  Create a React Micro Frontend  tutorial. \n Create Environment File \n Publisher Widget \n \n \n Create an  .env  file in the project root for the  publisher-widget . \n \n \n Open the  .env  file, and enter the  PUBLIC_URL  where the micro frontend will be hosted. \n \n \n Example: \n PUBLIC_URL=http://quickstart-entando.192.168.64.34.nip.io/entando-de-app/cmsresources/publisher-widget\n \n Notes \n \n Replace  quickstart-entando.192.168.64.34.nip.io  with the ingress you use to access Entando from your local browser. \n /entando-de-app/cmsresources/  is your Resource URL. \n publisher-widget  is the public folder we'll create to host the publisher micro frontend. \n Subscriber Widget \n \n \n Create an  .env  file in the project root for the  subscriber-widget . \n \n \n Open the  .env  file, and enter the  PUBLIC_URL  where the micro frontend will be hosted. \n \n \n \n Use  subscriber-widget  for the name of the public folder we'll create to host the subscriber micro frontend. \n \n Example: \n PUBLIC_URL=http://quickstart-entando.192.168.64.34.nip.io/entando-de-app/cmsresources/subscriber-widget\n Run npm build \n Publisher Widget \n \n \n Open a command line, and navigate to the project root of the  publisher-widget . \n \n \n Run build. \n \n \n npm  run build\n \n \n Rename the following generated files in the  build  directory. \n \n \n \n \n Example of Generated Build File \n Rename to \n Function \n \n \n \n \n build/static/js/2.f14073bd.chunk.js \n static/js/vendor.js \n Third-party libraries \n \n \n build/static/js/runtime-main.8a835b7b.js \n static/js/runtime.js \n Bootstrapping logic \n \n \n build/static/js/main.4a514a6d.chunk.js \n static/js/main.js \n App \n \n \n build/static/css/main.5f361e03.chunk.css \n static/css/main.css \n Stylesheet \n Subscriber Widget \n \n Repeat steps 1-3 for the  subscriber-widget . \n Create Public Folder \n Publisher Widget \n \n \n Navigate to  Entando App Builder  in your browser. \n \n \n Go to  Configuration  →   File Browser   →  public \n \n \n Click  Create Folder . \n \n \n Enter  publisher-widget . \n \n \n Click  Save . \n \n \n Click  public  →  publisher-widget . \n \n \n Create the same folder structure as your generated build directory \n \n \n \n publisher-widget/static/css \n publisher-widget/static/js \n \n \n Upload the files we renamed in the corresponding  js  and  css  folders. \n \n \n publisher-widget/static/css/main.css \n publisher-widget/static/js/main.js \n publisher-widget/static/js/runtime.js \n publisher-widget/static/js/vendor.js \n Subscriber Widget \n \n Repeat steps 1-8 for the  subscriber-widget . \n Add Widgets \n Publisher Widget \n \n \n Go to  Entando App Builder  in your browser. \n \n \n Go to  Components  →  Micro Frontends & Widgets  at the top nav. \n \n \n Click  Add . \n \n \n Enter the following: \n \n \n \n Code: publisher_widget  → note: dashes are not allowed \n Title: Publisher Widget  → for both English and Italian languages \n Group: Free Access \n Custom UI: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < link   rel = \" stylesheet \"   type = \" text/css \"   href = \" < @wp . resourceURL  /> publisher-widget/static/css/main.css \" > \n < script   async   src = \" < @wp . resourceURL  /> publisher-widget/static/js/runtime.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> publisher-widget/static/js/vendor.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> publisher-widget/static/js/main.js \" > </ script > \n < publisher-widget   /> \n \n \n Click  Save . \n Subscriber Widget \n Repeat steps 1-5 for the subscriber widget. \n \n Code: subscriber_widget  → note: dashes are not allowed \n Title: Subscriber Widget  → for both English and Italian languages \n Group: Free Access \n Custom UI: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < link   rel = \" stylesheet \"   type = \" text/css \"   href = \" < @wp . resourceURL  /> subscriber-widget/static/css/main.css \" > \n < script   async   src = \" < @wp . resourceURL  /> subscriber-widget/static/js/runtime.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> subscriber-widget/static/js/vendor.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> subscriber-widget/static/js/main.js \" > </ script > \n < subscriber-widget   /> \n Add Page Template \n \n \n Go to  Components  →  Pages  →  Page Templates  →  Add . \n \n \n Enter the following: \n \n \n \n Code: two_widget  → note: dashes are not allowed \n Name: Two Widget \n JSON Configuration: \n \n { \n   \"frames\" :   [ \n     { \n       \"pos\" :   0 , \n       \"descr\" :   \"Sample Frame\" , \n       \"mainFrame\" :   false , \n       \"defaultWidget\" :   null , \n       \"sketch\" :   null \n     } , \n     { \n       \"pos\" :   1 , \n       \"descr\" :   \"Sample Frame Two\" , \n       \"mainFrame\" :   false , \n       \"defaultWidget\" :   null , \n       \"sketch\" :   null \n     } \n   ] \n } \n \n \n Template: \n \n < #assign  wp = JspTaglibs [ \"/aps-core\" ] > \n <! DOCTYPE   HTML   PUBLIC   \"-//W3C//DTD HTML 4.0 Transitional//EN\" > \n < html > \n   < head > \n       < title > < @wp . currentPage param = \"title\"   /> </ title > \n   </ head > \n   < body > \n     < h1 > < @wp . currentPage param = \"title\"   /> </ h1 > \n     < div > < @wp . show frame = 0   /> </ div > \n     < div > < @wp . show frame = 1   /> </ div > \n   </ body > \n </ html > \n \n \n Click  Save . \n View on Homepage \n \n \n Go to  Pages  →  Management \n \n \n For the  Home  page  (folder icon) , in the  Actions  column, click the  ⋮  icon \n \n \n Click  Edit . \n \n \n In the  Settings  section, select: \n \n \n \n Page Template: Two Widget \n \n \n \n Click  Save and Configure . \n \n \n In the  WIDGETS  sidebar on the right: \n \n \n \n Drag  Publisher Widget  and  Subscriber Widget  into  Sample Frame  and  Sample Frame Two . \n \n \n \n Click  Publish . \n \n \n To view the home page, scroll to the top of the page, and click  Go to Homepage . \n \n \n Enter a greeting in the input field. Press the submit button. The subscriber widget will update with the greeting. Done! \n \n \n Congratulations! \n You can now communicate between micro frontends with  Custom Events . \n Angular to React \n We can also communicate between micro frontends using different JavaScript frameworks. \n In this next example, we’ll create an Angular micro frontend to publish an event, and we'll use the React micro frontend we created in the previous section to receive the event. \n Create Angular Publisher \n ng new angular-publisher-widget\n \n Choose the following options: \n ? Would you like to  add  Angular routing? No\n? Which stylesheet  format  would you like to use? CSS\n \n Serve the application. \n cd  angular-publisher-widget\n \n ng serve\n Convert to Custom Element \n Next, let's convert our Angular app into a custom element. We'll use  Angular elements  to transform components into custom elements. \n ng  add  @angular/elements\n \n Replace the contents of  angular-widget/src/app/app.module.ts . \n \n In this file, we bootstrap the custom element using the  ngDoBootstrap  method. \n \n import   {  BrowserModule  }   from   '@angular/platform-browser' ; \n import   {  NgModule ,  Injector  }   from   '@angular/core' ; \n import   {  createCustomElement  }   from   '@angular/elements' ; \n import   {  AppComponent  }   from   './app.component' ; \n import   {  ReactiveFormsModule  }   from   '@angular/forms' ; \n\n@ NgModule ( { \n   declarations :   [ \n    AppComponent\n   ] , \n   imports :   [ \n    BrowserModule , \n    ReactiveFormsModule\n   ] , \n   providers :   [ ] , \n   entryComponents :   [ AppComponent ] \n } ) \n export   class   AppModule   { \n   constructor ( private   injector :  Injector )   { } \n\n   ngDoBootstrap ( )   { \n     const  el  =   createCustomElement ( AppComponent ,   {   injector :   this . injector  } ) ; \n    customElements . define ( 'angular-publisher-widget' ,  el ) ; \n   } \n } \n Create Custom Event \n Replace the contents of  angular-widget/src/app/app.component.ts . \n \n Here, we're adding code to dispatch the custom event. \n \n import   {  Component  }   from   '@angular/core' ; \n import   {  FormControl ,  FormGroup  }   from   '@angular/forms' ; \n\n const   EVENTS   =   { \n   greeting :   'greeting' , \n } ; \n\n@ Component ( { \n   selector :   'app-root' , \n   templateUrl :   './app.component.html' , \n   styleUrls :   [ './app.component.css' ] \n } ) \n export   class   AppComponent   { \n  greetingForm  =   new   FormGroup ( { \n     name :   new   FormControl ( '' ) , \n   } ) ; \n\n   publishWidgetEvent ( eventId ,  detail )   { \n     const  widgetEvent  =   new   CustomEvent ( eventId ,   {  detail  } ) ; \n    window . dispatchEvent ( widgetEvent ) ; \n   } \n\n   onSubmit ( )   { \n     const  name  =   this . greetingForm . get ( 'name' ) . value ; \n     this . publishWidgetEvent ( EVENTS . greeting ,   {  name  } ) ; \n   } \n } \n Add HTML Form \n Replace the contents of  angular-widget/src/app/app.component.html . \n \n In the app component html, we're adding a simple form to call our component class  app.component.ts . \n \n < h1 > Send a greeting </ h1 > \n < form   [formGroup] = \" greetingForm \"   (ngSubmit) = \" onSubmit() \" > \n   < label > \n    Name\n     < input   type = \" text \"   formControlName = \" name \" > \n   </ label > \n   < button   type = \" submit \" > Say hello! </ button > \n </ form > \n View Micro Frontend \n Open  angular-publisher-widget/src/index.html . \n In the  <body> , replace  <app-root></app-root>  with your custom element  <angular-publisher-widget /> . \n < body > \n   < angular-publisher-widget   /> \n </ body > \n \n You can check to see if your micro frontend is working in your browser (e.g., localhost:4200) \n Add to App Builder \n Now we're ready to host our micro frontend in Entando. \n Build It \n From the project root, type: \n ng build --prod --outputHashing = none\n \n This will generate a  dist  directory. \n Create Public Folder \n \n \n Navigate to  Entando App Builder  in your browser. \n \n \n Click  Configuration  →   File Browser   →  public . \n \n \n Create a folder named  angular-publisher-widget . \n \n \n Click  Upload Files . \n \n \n From your generated  dist  folder, upload: \n \n \n \n main-es2015.js \n polyfills-es2015.js \n runtime-es2015.js \n Add Widget \n \n \n Go to  Components > Micro frontends & Widgets  in the Entando App Builder. \n \n \n Click  Add  at the lower right. \n \n \n Enter the following: \n \n \n \n Code: angular_publisher_widget  → note: dashes are not allowed \n Title: Angular Publisher Widget  → for both English and Italian languages \n Group: Free Access \n Custom UI: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < script   async   src = \" < @wp . resourceURL  /> angular-widget/main-es2015.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> angular-widget/polyfills-es2015.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> angular-widget/runtime-es2015.js \" > </ script > \n\n < angular-publisher-widget   /> \n \n \n Click  Save . \n View on Homepage \n \n \n Go to  Pages  →  Management \n \n \n Next to the  Home  page  (folder icon) , in the  Actions  column, click the  ⋮  icon \n \n \n In the Search field in right-hand sidebar, enter  Angular Publisher Widget . \n \n \n Drag and drop  Angular Publisher Widget  into the  Sample Frame  in the main body of the page. \n \n \n \n Replace  Publisher Widget . \n \n \n \n Click  Publish . \n \n \n In the top navigation, on the right, click  Go to Homepage . \n \n \n Enter a greeting in the input field. Press the submit button. The subscriber widget will update with the greeting. Done! \n \n \n \n Note: If you don't see an input field, refresh the page. \n \n Congratulations! \n You've now created an Angular micro frontend that can communicate with a React micro frontend. \n \n"},{title:"Create an Angular Micro Frontend",frontmatter:{sidebarDepth:2},regularPath:"/v6.2/tutorials/micro-frontends/angular.html",relativePath:"v6.2/tutorials/micro-frontends/angular.md",key:"v-6847b620",path:"/v6.2/tutorials/micro-frontends/angular.html",headers:[{level:2,title:"Create Angular App",slug:"create-angular-app"},{level:3,title:"Convert to Custom Element",slug:"convert-to-custom-element"},{level:3,title:"Test Micro Frontend",slug:"test-micro-frontend"},{level:2,title:"Build It",slug:"build-it"},{level:2,title:"Host Micro Frontend",slug:"host-micro-frontend"},{level:3,title:"Create Public Folder",slug:"create-public-folder"},{level:3,title:"Add Widget",slug:"add-widget"},{level:3,title:"See It in Action",slug:"see-it-in-action"}],lastUpdated:"9/30/2020, 7:30:41 AM",lastUpdatedTimestamp:1601465441e3,content:" Create an Angular Micro Frontend \n Prerequisites \n \n A working instance of Entando. \n \n \n Tested Versions \n node v13.8.0 → We suggest using  nvm  to handle node installations. \n Create Angular App \n Install Angular CLI. \n npm   install  -g @angular/cli\n \n Generate a new angular application. \n ng new angular-widget\n \n Choose the following options: \n ? Would you like to  add  Angular routing? No\n? Which stylesheet  format  would you like to use? CSS\n \n Serve the application. \n cd  angular-widget\n \n ng serve\n \n This is the expected output: \n angular-widget\n├── e2e\n│   └── src\n│       ├── app.e2e-spec.ts\n│       └── app.po.ts\n│\n├── node_modules\n├── src\n│   ├── app\n│   │   ├── app.component.css\n│   │   ├── app.component.html\n│   │   ├── app.component.spec.ts\n│   │   ├── app.component.ts\n│   │   └── app.module.ts\n│   │\n│   ├── assets\n│   │   └── .gitkeep\n│   │\n│   ├── environment\n│   │   ├── environment.prod.ts\n│   │   └── environment.ts\n│   │\n│   ├── favicon.ico\n│   ├── index.html\n│   ├── main.ts\n│   ├── polyfills.ts\n│   ├── styles.css\n│   └── test.ts\n│\n├── .editorconfig\n├── .gitignore\n├── angular.json\n├── browserlist\n├── karma.conf.js\n├── package.json\n├── README.md\n├── tsconfig.app.json\n├── tsconfig.json\n├── tsconfig.spec.json\n└── tslint.json\n Convert to Custom Element \n Next, let's convert our Angular app into a custom element. We'll use  Angular elements  to transform components into custom elements. \n ng  add  @angular/elements\n \n WARNING \n Install the Angular elements package using  ng add , not with  npm install  as it runs additional steps behind the scenes like adding the  document-register-element  polyfill. \n \n TIP \n Angular elements are Angular components packaged as custom elements (also called Web Components), a web standard for defining new HTML elements in a framework-agnostic way. \n \n Open  angular-widget/src/app/app.module.ts . \n \n Here's what the initial file looks like: \n \n import   {  BrowserModule  }   from   '@angular/platform-browser' ; \n import   {  NgModule  }   from   '@angular/core' ; \n\n import   {  AppComponent  }   from   './app.component' ; \n\n@ NgModule ( { \n   declarations :   [ \n    AppComponent\n   ] , \n   imports :   [ \n    BrowserModule\n   ] , \n   providers :   [ ] , \n   bootstrap :   [ AppComponent ] \n } ) \n export   class   AppModule   {   } \n \n Replace the entire file with: \n import   {  BrowserModule  }   from   '@angular/platform-browser' ; \n import   {  NgModule ,  Injector  }   from   '@angular/core' ; \n import   {  createCustomElement  }   from   '@angular/elements' ; \n import   {  AppComponent  }   from   './app.component' ; \n\n@ NgModule ( { \n   declarations :   [ \n    AppComponent\n   ] , \n   imports :   [ \n    BrowserModule\n   ] , \n   providers :   [ ] , \n   entryComponents :   [ AppComponent ] \n } ) \n export   class   AppModule   { \n   constructor ( private   injector :  Injector )   { } \n\n   ngDoBootstrap ( )   { \n     const  el  =   createCustomElement ( AppComponent ,   {   injector :   this . injector  } ) ; \n    customElements . define ( 'angular-widget' ,  el ) ; \n   } \n } \n \n \n In the initial file,  AppModule  is bootstrapped directly during application launch. \n In the updated file, we booststrap our custom element using the  ngDoBootstrap()  method . \n \n Custom Elements \n \n Must contain a hyphen  -  in the name. : \n Cannot be a single word. \n Should follow  kebab-case  for naming convention. \n Test Micro Frontend \n Now, let's check our custom element to see if it's working. \n Open  angular-widget/src/index.html . \n In the  <body> , replace  <app-root></app-root>  with your custom element  <angular-widget /> . \n <! doctype   html > \n < html   lang = \" en \" > \n < head > \n   < meta   charset = \" utf-8 \" > \n   < title > AngularWidget </ title > \n   < base   href = \" / \" > \n   < meta   name = \" viewport \"   content = \" width=device-width, initial-scale=1 \" > \n   < link   rel = \" icon \"   type = \" image/x-icon \"   href = \" favicon.ico \" > \n </ head > \n < body > \n   < angular-widget   /> \n </ body > \n </ html > \n \n Congratulations! \n You’re now running  Angular  in a micro frontend. \n Build It \n From the project root, type: \n ng build --prod --outputHashing = none\n \n This will generate an  angular-widget/dist  directory. \n If we assume browser support for  ES6 (ECMAScript 2015) , we can focus on the following JavaScript files to publish our app: \n \n main-es2015.js \n polyfills-es2015.js \n runtime-es2015.js \n \n Generated Build Files \n --outputHashing=none  generates files without hashes so we can deploy new versions of the micro frontend without having to reconfigure our widget in Entando to point to the newly built files. \n \n If you want to use file names with content hashes to avoid potential caching issues in your browser, you can update the  Custom UI  field of your widget after building new versions of your micro frontend. Widget configuration is covered in the next section. \n Host Micro Frontend \n Now we're ready to host our micro frontend in Entando. \n Create Public Folder \n \n \n Navigate to  Entando App Builder  in your browser. \n \n \n Click  Administration  at the lower left hand side of the screen. \n \n \n Click the  File Browser  tab. \n \n \n Click the  public  folder. \n \n \n Click  Create Folder . \n \n \n Enter  angular-widget \n \n \n Click  Save . \n \n \n Click  angular-widget . \n \n \n Click 'Upload Files`. \n \n \n Upload the following files from  angular-widget/dist/angular-widget : \n \n \n \n main-es2015.js \n polyfills-es2015.js \n runtime-es2015.js \n \n Additional Deployment Options \n \n Install the micro frontend from a bundle in the  Entando Component Repository . \n Add the micro frontend to  Entando App Builder . \n Load the micro frontend from an API. \n Add Widget \n \n Go to  Components > Micro frontends & Widgets  in the Entando App Builder. \n Click  Add  at the lower right. \n \n \n \n Enter the following: \n \n \n Code: angular_widget  → note: dashes are not allowed \n Title: Angular Widget  → for both English and Italian languages \n Group: Free Access \n Custom UI: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < script   async   src = \" < @wp . resourceURL  /> angular-widget/main-es2015.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> angular-widget/polyfills-es2015.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> angular-widget/runtime-es2015.js \" > </ script > \n\n < angular-widget   /> \n \n \n Click  Save . \n \n TIP \n <#assign wp=JspTaglibs[ \"/aps-core\"]>  gives you access to the  @wp  object where you can use environment variables like  resourceURL . \n See It in Action \n Let's see the Angular micro frontend in action on our page. \n Add Page \n Note \n If you've already configured your home page: \n \n   Next to the  Home  folder, under  Actions , click  Configure . \n   Skip to the  Add Widget  section. \n \n \n Let's add our widget to the  Home  page. \n \n \n Go to  Pages  →  Management \n \n \n Next to the  Home  folder, under  Actions , click  Edit . \n \n \n Next to  Page Template  select  Service Page . \n \n \n Click  Save and Configure . \n Add Widget \n \n \n In the Search field in right-hand sidebar, enter  Angular Widget . \n \n \n Drag and drop  Angular Widget  into the  Sample Frame  in the main body of the page. \n \n \n Click  Publish . \n \n \n At the upper right, click  Go to Homepage . \n \n \n \n Congratulations! \n You now have an Angular micro frontend running in Entando. \n \n"},{title:"Microfrontends",frontmatter:{sidebarDepth:2},regularPath:"/v6.2/tutorials/micro-frontends/",relativePath:"v6.2/tutorials/micro-frontends/README.md",key:"v-27be8b6a",path:"/v6.2/tutorials/micro-frontends/",headers:[{level:2,title:"Introduction",slug:"introduction"},{level:2,title:"Tutorials",slug:"tutorials"}],lastUpdated:"8/11/2020, 4:23:51 PM",lastUpdatedTimestamp:1597177431e3,content:" Microfrontends \n Introduction \n \n The idea behind Micro Frontends is to think about a website or web app as  a composition of features  which are owned by  independent teams . Each team has a  distinct area of business  or  mission  it cares about and specialises in. A team is  cross functional  and develops its features  end-to-end , from database to user interface. \n —  Michael Geers,  micro-frontends.org \n \n Think of micro frontends as the implementation of a microservices architecture applied to the full web application that extends all the way to the frontend. \n Entando implements micro frontends based on  Web Components , a set of technologies that allow developers to create reusable custom elements supported by all major internet browsers. \n Web Components can work with vanilla JavaScript as well as with the most popular web frameworks (e.g., React, Angular, and Vue). \n Entando's microservice and micro frontend architecture allows developers to work with their favorite technology stack, and makes it easier for companies to integrate disparate applications. \n Tutorials \n \n \n Create a React Micro Frontend \n \n \n Create an Angular Micro Frontend \n \n \n Add an App Builder configuration screen to a\nwidget \n \n \n Display widget configuration \n \n \n The Entando Blueprint generated widgets \n \n \n Communicate Between Micro Frontends \n \n \n Widget authentication with Keycloak \n \n \n"},{title:"Authentication",frontmatter:{},regularPath:"/v6.2/tutorials/micro-frontends/authentication.html",relativePath:"v6.2/tutorials/micro-frontends/authentication.md",key:"v-4486ad80",path:"/v6.2/tutorials/micro-frontends/authentication.html",lastUpdated:"8/11/2020, 4:23:51 PM",lastUpdatedTimestamp:1597177431e3,content:" Authentication \n Keycloak is used for authentication. \n To set up keycloak server, please refer to Keycloak\n documentation . \n As all MFE widgets use the same Keycloak instance, it should be\ninitialized on a container of all widgets. \n Using Details widget generated using Entando JHipster blueprint as an\nexample, let’s get familiar with authentication implementation. \n As mentioned before, widget auth implementation assumes that Keycloak is\ninitialized outside of the widget. In Details example, it is done in\nindex.html where Keycloak server’s keycloak.js is used. \n <head>\n    <script src=\"keycloak.js\"><\/script>\n    <script>\n        var keycloak = new Keycloak();\n        keycloak\n          .init({ onLoad: 'check-sso' })\n          .success(onInit);\n    <\/script>\n</head>\n \n \n Note \n keycloak.js is provided by your Keycloak server at\n <SERVER_URL:PORT>/auth/js/keycloak.js \n \n Keycloak is initialized by passing Keycloak server path, realm and\nclient ID and calling  init({/* options */})  function. \n const keycloak = Keycloak({\n  url: 'http://localhost:9080/auth',\n  realm: 'jhipster',\n  clientId: 'jhipster-entando-react-client',\n});\n\nkeycloak\n  .init({ onLoad: 'check-sso' })\n  .success(onInit);\n \n Depending on Keycloak version you are using,  init()  function can\nreturn a Promise (newer versions support  promiseType: 'native' \noption). \n keycloak\n  .init({ onLoad: 'check-sso', promiseType: 'native' })\n  .then(authenticated => {\n    alert(authenticated ? 'Authenticated' : 'Not authenticated');\n  })\n  .catch(() => {\n    alert('Failed to initialize');\n  });\n \n All the Keycloak events are made custom events - this way widgets could\nreact to them if a need arises. \n function createKcDispatcher(payload) {\n  return () => window.dispatchEvent(new CustomEvent('keycloak', { detail: payload }));\n}\n\nkeycloak.onReady = createKcDispatcher({ eventType: 'onReady' });\nkeycloak.onAuthSuccess = createKcDispatcher({ eventType: 'onAuthSuccess' });\nkeycloak.onAuthError = createKcDispatcher({ eventType: 'onAuthError' });\nkeycloak.onAuthRefreshSuccess = createKcDispatcher({ eventType: 'onAuthRefreshSuccess' });\nkeycloak.onAuthRefreshError = createKcDispatcher({ eventType: 'onAuthRefreshError' });\nkeycloak.onAuthLogout = createKcDispatcher({ eventType: 'onAuthLogout' });\nkeycloak.onTokenExpired = createKcDispatcher({ eventType: 'onTokenExpired' });\nconst onInit = createKcDispatcher({ eventType: 'onInit' });\n \n Keycloak object is then stored into  window.entando  object for widgets\nto have access to. \n window.entando = {\n  ...(window.entando || {}),\n  keycloak,\n};\n \n On the widget side inside the custom element creation logic Keycloak\nobject is accessed and passed into the component via Keycloak context \n const getKeycloakInstance = () =>\n  (window &&\n    window.entando &&\n    window.entando.keycloak &&\n    { ...window.entando.keycloak, initialized: true }\n  ) || { initialized: false };\n\n\n// ...\n\nconstructor(...args) {\n  // ...\n  this.keycloak = getKeycloakInstance();\n}\n\nconnectedCallback() {\n  // ...\n  ReactDOM.render(\n    <KeycloakContext.Provider value={this.keycloak}>\n      <ConferenceDetailsContainer />\n    </KeycloakContext.Provider>,\n    this.mountPoint\n  );\n}\n \n And on the component side you can show different content depending on\nthe authentication status \n At  auth/KeycloakViews.js \n export const AuthenticatedView = ({ children, keycloak }) => {\n  const authenticated = keycloak.initialized && keycloak.authenticated;\n  return authenticated ? children : null;\n};\n\nexport const UnauthenticatedView = ({ children, keycloak }) => {\n  const authenticated = keycloak.initialized && keycloak.authenticated;\n  return !authenticated ? children : null;\n};\n \n At  components/ConferenceDetailsContainer.js \n render() {\n  const { conference, loading } = this.state;\n  const { t, keycloak } = this.props;\n\n  return (\n    <ThemeProvider theme={this.theme}>\n      <UnauthenticatedView keycloak={keycloak}>\n        {t('common.notAuthenticated')}\n      </UnauthenticatedView>\n      <AuthenticatedView keycloak={keycloak}>\n        {loading && t('common.loading')}\n        {!loading && <ConferenceDetails conference={conference} />}\n      </AuthenticatedView>\n    </ThemeProvider>\n  );\n}\n \n \n Note \n Keycloak object is accessible via props because of  withKeycloak  HOC:\n export default withKeycloak(ConferenceDetailsContainer); \n \n"},{title:"Tutorial: Blueprint generated widgets' overview",frontmatter:{},regularPath:"/v6.2/tutorials/micro-frontends/generate-micro-frontends-from-a-database-entity/",relativePath:"v6.2/tutorials/micro-frontends/generate-micro-frontends-from-a-database-entity/README.md",key:"v-7bef863e",path:"/v6.2/tutorials/micro-frontends/generate-micro-frontends-from-a-database-entity/",headers:[{level:2,title:"Common parts",slug:"common-parts"},{level:3,title:"Authentication",slug:"authentication"},{level:3,title:"Custom events",slug:"custom-events"},{level:3,title:"Tests and mocks",slug:"tests-and-mocks"},{level:3,title:"PropTypes",slug:"proptypes"},{level:3,title:"Fetching data",slug:"fetching-data"},{level:2,title:"Form widget",slug:"form-widget"}],lastUpdated:"8/10/2020, 11:11:30 AM",lastUpdatedTimestamp:159707229e4,content:' Tutorial: Blueprint generated widgets\' overview \n When you  create an entity using Entando blueprint , it generates a few\npremade widgets. In this section we will review them. \n We will be using  Conference  as an entity name for the examples below. \n Common parts \n Each widget contains a README file that should help you with the setup. \n All generated widgets are web components created using Custom Elements\nAPI. \n Each widget is displayed using the custom element tag - e.g., inside the\nDetails widget folder  conference/detailsWidget/public/index.html  you\ncan find\n conference-details id="1" override-edit-handler hide-edit-button /> .\nThis element  <conference-details />  is defined in the component entry\npoint at\n conference/detailsWidget/src/custom-elements/ConferenceDetailsElement.js . \n \n Note \n custom element names ( conference-details ) require a dash in them to\nbe used, e.g., (kebab-case) - they can not be single words. \n \n For more information about web components, custom elements and micro\nfrontends, please refer to "Create a react micro frontend widget"\nsection. \n Authentication \n If widget requires authentication, component is wrapped in\n KeycloakContext.Provider  and Keycloak object is fetched from\n window.entando.keycloak  variable. Entando is using Keycloak as our\nauthentication provider, but you can add any providers you like. \n ReactDOM.render(\n  <KeycloakContext.Provider value={this.keycloak}>\n    <StylesProvider jss={this.jss}>\n      <ThemeProvider theme={this.muiTheme}>{FormContainer}</ThemeProvider>\n    </StylesProvider>\n  </KeycloakContext.Provider>,\n  this.mountPoint\n);\n \n For more information about authentication implementation, please refer\nto the "Authentication" section. \n Custom events \n All widgets rely on custom events for communication which is why custom\nevent creation and removal is in each widget, as well as event listener\ncreation. Note that when an event listener is created, it should be when\nthe element is no longer needed. It should be created in the custom\nelement’s  disconnectedCallback()  function. \n To add more events to listen to the widgets, add the event types to\n INPUT_EVENT_TYPES  object at\n detailsWidget/src/custom-elements/widgetEventTypes.js  which will add\nit to the listener list (or remove the event by removing the element). \n For more information about custom events and widget communication,\nplease refer to the section on "Widget communication". \n Tests and mocks \n Each widget has tests written for it. Entando uses\n react-testing-library , but developers are free to upgrade and use any\ntool. Tests are kept at  detailsWidget/src/components/  and mocks for\nthem are at  detailsWidget/src/components/ . \n PropTypes \n PropTypes for data used across several components are shared - you can\nsee and modify them at  detailsWidget/src/components/ . This way you can\navoid repeating same propTypes in each component and just import shared\nones \n import React from \'react\';\nimport conferenceType from \'components/__types__/conference\';\n\nconst ConferenceDetails = props => {\n  // ...\n};\n\nConferenceDetails.propTypes = {\n  conference: conferenceType,\n  t: PropTypes.func.isRequired,\n};\n\nexport default ConferenceDetails;\n Fetching data \n For data fetching from widgets use Fetch API. You can find functions for\nfetching data at  detailsWidget/src/api  in different files for\ndifferent contexts. \n Form widget \n For displaying forms within a widget use\n Formik  which helps with form state\nmanagement. For data validation use\n Yup . \n'},{title:"Create a React Micro Frontend",frontmatter:{sidebarDepth:2},regularPath:"/v6.2/tutorials/micro-frontends/react.html",relativePath:"v6.2/tutorials/micro-frontends/react.md",key:"v-67b9aca6",path:"/v6.2/tutorials/micro-frontends/react.html",headers:[{level:2,title:"Create React App",slug:"create-react-app"},{level:3,title:"Wrap with Custom Element",slug:"wrap-with-custom-element"},{level:3,title:"Import Custom Element",slug:"import-custom-element"},{level:3,title:"Test Micro Frontend",slug:"test-micro-frontend"},{level:2,title:"Get Resource URL",slug:"get-resource-url"},{level:2,title:"Build It",slug:"build-it"},{level:3,title:"npm build",slug:"npm-build"},{level:2,title:"Host Micro Frontend",slug:"host-micro-frontend"},{level:3,title:"Create Public Folder",slug:"create-public-folder"},{level:3,title:"Update Custom UI Field",slug:"update-custom-ui-field"},{level:3,title:"View in Homepage",slug:"view-in-homepage"}],lastUpdated:"9/3/2020, 3:46:44 PM",lastUpdatedTimestamp:1599162404e3,content:" Create a React Micro Frontend \n Prerequisites \n \n A working instance of Entando. \n \n \n Tested Versions \n node v13.8.0 → We suggest using  nvm  to handle node installations. \n Create React App \n We'll use  Create React App  to create a simple app in seconds. \n npx create-react-app my-widget --use-npm\n \n This is the expected output: \n my-widget\n├── README.md\n├── node_modules\n├── package.json\n├── .gitignore\n├── public\n│   ├── favicon.ico\n│   ├── index.html\n│   ├── logo192.png\n│   ├── logo512.png\n│   ├── manifest.json\n│   └── robots.txt\n└── src\n    ├── App.css\n    ├── App.js\n    ├── App.test.js\n    ├── index.css\n    ├── index.js\n    ├── logo.svg\n    ├── serviceWorker.js\n    └── setupTests.js\n \n Start the app. \n cd  my-widget\n npm  start\n Wrap with Custom Element \n Add a new file  src/WidgetElement.js  with the custom element that will wrap the entire React app. \n import  React  from   'react' ; \n import  ReactDOM  from   'react-dom' ; \n import  App  from   './App' ; \n\n class   WidgetElement   extends   HTMLElement   { \n     connectedCallback ( )   { \n         this . mountPoint  =  document . createElement ( 'div' ) ; \n         this . appendChild ( this . mountPoint ) ; \n        ReactDOM . render ( < App  / > ,   this . mountPoint ) ; \n     } \n } \n\ncustomElements . define ( 'my-widget' ,  WidgetElement ) ; \n\n export   default  WidgetElement ; \n \n TIP \n connectedCallback  is a lifecycle hook that  runs each time the element is added to the DOM. \n \n The React  root  node is programatically generated in the  connectedCallback  method when our custom element is added to the DOM. \n Custom Elements \n \n Must contain a hyphen  -  in the name. : \n Cannot be a single word. \n Should follow  kebab-case  for naming convention. \n Import Custom Element \n Open  src/index.js . Here's what the initial file looks like: \n import  React  from   'react' ; \n import  ReactDOM  from   'react-dom' ; \n import   './index.css' ; \n import  App  from   './App' ; \n import   *   as  serviceWorker  from   './serviceWorker' ; \n\nReactDOM . render ( < App  / > ,  document . getElementById ( 'root' ) ) ; \n\n // If you want your app to work offline and load faster, you can change \n // unregister() to register() below. Note this comes with some pitfalls. \n // Learn more about service workers: https://bit.ly/CRA-PWA \nserviceWorker . unregister ( ) ; \n \n Replace the entire file with these two lines. \n import   './index.css' ; \n import   './WidgetElement' ; \n Test Micro Frontend \n \n \n Open  public/index.html . \n \n \n Replace  <div id=\"root\"></div>  with the custom element  <my-widget /> . \n \n \n    < body > \n     < noscript > You need to enable JavaScript to run this app. </ noscript > \n     < my-widget   /> \n    ...\n   </ body > \n \n Congratulations! \n You’re now running  React  in a containerized micro frontend. \n Get Resource URL \n Let's add our micro frontend to Entando by adding our JavaScript and CSS files to the  public  folder. \n TIP \n Entando makes files publicly available through the  public  folder. \n Add Widget \n Initially, we'll add a widget to get the resource URL for the  public  folder. Later on, we'll use the same widget to add our micro frontend to Entando. \n \n \n Go to  Components > Micro frontends & Widgets  in the Entando App Builder. \n \n \n Click  Add  at the lower right. \n \n \n \n \n Enter the following: \n \n \n Code: my_widget  → note: dashes are not allowed \n Title: My Widget  → for both English and Italian languages \n Group: Free Access \n Custom UI: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < @wp . resourceURL  /> \n \n TIP \n <#assign wp=JspTaglibs[ \"/aps-core\"]>  gives you access to the  @wp  object where you can use environment variables like  resourceURL . \n \n \n Click  Save . \n Add Page \n Next, let's add our widget to a page so we can view the  Resource URL . \n If you're getting started with a new install of Entando, let's add our widget to the  Home  page: \n \n \n For Experienced Entando users: \n Add a new page → Add your widget to the page \n \n \n \n \n Go to  Pages  →  Management \n \n \n Next to the  Home  folder, under  Actions , click  Edit . \n \n \n Next to  Page Template  select  Service Page . \n \n \n Click  Save and Configure . \n \n \n In the Search field in right-hand sidebar, enter  My Widget . \n \n \n Drag and drop  My Widget  into the  Sample Frame  in the main body of the page. \n \n \n Click  Publish . \n \n \n At the upper right, click  Go to Homepage . \n \n \n \n This will take you to a blank home page with your widget. \n \n \n Copy the  Resource URL . \n \n /entando-de-app/cmsresources/\n Build It \n Now that we have the resource URL where we'll host our  Create React App , we're ready to build. \n \n \n Create an  .env  file in the project root of your  Create React App . \n \n \n Add the  PUBLIC_URL  where we'll be hosting our files. \n \n \n Example: \n PUBLIC_URL=http://quickstart-entando.192.168.64.34.nip.io/entando-de-app/cmsresources/my-widget\n \n \n Replace  quickstart-entando.192.168.64.34.nip.io/app-builder  with the URL for your Entando App Builder instance. →  How to find your Entando App Builder URL. \n \n Notes \n \n quickstart-entando.192.168.64.34.nip.io  represents your  Entando App Builder  instance. \n /entando-de-app/cmsresources/  is your Resource URL \n my-widget  is the public folder we'll create to host our files \n \n \n TIP \n When you run  npm run build ,  Create React App  will substitute  %PUBLIC_URL%  with a correct absolute path so your project works even if you use client-side routing or host it at a non-root URL. \n npm build \n \n \n Open a command line, and navigate to the project root of your  Create React App . \n \n \n Run the command: \n \n \n npm  run build\n \n \n Rename the following generated files in the  build  directory. \n \n \n \n \n Example of Generated Build File \n Rename to \n Function \n \n \n \n \n build/static/js/2.f14073bd.chunk.js \n static/js/vendor.js \n Third-party libraries \n \n \n build/static/js/runtime-main.8a835b7b.js \n static/js/runtime.js \n Bootstrapping logic \n \n \n build/static/js/main.4a514a6d.chunk.js \n static/js/main.js \n App \n \n \n build/static/css/main.5f361e03.chunk.css \n static/css/main.css \n Stylesheet \n \n \n \n Generated Build Files \n We rename the JavaScript and CSS files so we can deploy new versions of the micro frontend without having to update the  Custom UI  field of our widget to reference the new files. \n \n If you want to use the original  file names with the content hashes to avoid potential caching issues in your browser , update the  Custom UI  field of your widget when deploying new versions of your micro frontend. The  Custom UI  settings will be covered in the next section. \n Additional Deployment Options \n \n Install the micro frontend from a bundle in the  Entando Component Repository . \n Add the micro frontend to  Entando App Builder . \n Load the micro frontend from an API. \n Host Micro Frontend \n Now we're ready to host our micro frontend in Entando. \n Create Public Folder \n \n \n Navigate to  Entando App Builder  in your browser. \n \n \n Click  Administration  at the lower left hand side of the screen. \n \n \n Click the  File Browser  tab. \n \n \n Click the  public  folder. \n \n \n Click  Create Folder . \n \n \n Enter  my-widget . \n \n \n Click  Save . \n \n \n Click  public  →  my-widget . \n \n \n Create the same folder structure as your generated build directory \n \n \n \n my-widget/static/css \n my-widget/static/js \n \n \n Upload the files we renamed in the corresponding  js  and  css  folders. \n \n \n my-widget/static/css/main.css \n my-widget/static/js/main.js \n my-widget/static/js/runtime.js \n my-widget/static/js/vendor.js \n \n Note: You can drag and drop the files in your browser. \n \n Upload the  React  logo. \n \n \n my-widget/static/media/logo.5d5d9eef.svg  → You don't need to rename this file. \n Update Custom UI Field \n \n \n Go to  Components  →  Micro frontends & Widgets . \n \n \n Under the  My Widgets  category → next to  My Widget  → under  Action  → select  Edit . \n \n \n Update  Custom UI  field: \n \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < link   rel = \" stylesheet \"   type = \" text/css \"   href = \" < @wp . resourceURL  /> my-widget/static/css/main.css \" > \n < script   async   src = \" < @wp . resourceURL  /> my-widget/static/js/runtime.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> my-widget/static/js/vendor.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> my-widget/static/js/main.js \" > </ script > \n < my-widget   /> \n \n \n Click  Save . \n View in Homepage \n Let's see the React micro frontend in action on our page. \n \n \n In the  Entando App Builder  dashboard, click  Go to Homepage  at the upper right. \n \n \n Go to the page that you created, and click refresh. \n \n \n \n Congratulations! \n You now have a React micro frontend running in Entando. \n \n"},{title:"Add a Configuration Screen in App Builder",frontmatter:{},regularPath:"/v6.2/tutorials/micro-frontends/widget-configuration.html",relativePath:"v6.2/tutorials/micro-frontends/widget-configuration.md",key:"v-07879720",path:"/v6.2/tutorials/micro-frontends/widget-configuration.html",headers:[{level:2,title:"Create React App",slug:"create-react-app"},{level:2,title:"Add Input Field",slug:"add-input-field"},{level:2,title:"Custom Element",slug:"custom-element"},{level:2,title:"Configuration Screen",slug:"configuration-screen"},{level:2,title:"Add Attribute",slug:"add-attribute"},{level:2,title:"Display Input",slug:"display-input"},{level:2,title:"Build It",slug:"build-it"},{level:2,title:"Update Widget in App Builder",slug:"update-widget-in-app-builder"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:' Add a Configuration Screen in App Builder \n Entando 6 widgets can be customized through an App Builder configuration\nscreen so the citizen developers can avoid writing ad-hoc additional\ncode. \n In Entando 6, the configuration screen is also a micro frontend, which\ncan also be defined as a web component. That means you can develop and\ntest it in isolation, without a running Entando instance. \n Create React App \n Let’s start with the boilerplate provided by  Create React\nApp , probably the most popular one. \n npx create-react-app my-widget-config --use-npm \n my-widget-config\n├── README.md\n├── node_modules\n├── package.json\n├── .gitignore\n├── public\n│   ├── favicon.ico\n│   ├── index.html\n│   ├── logo192.png\n│   ├── logo512.png\n│   ├── manifest.json\n│   └── robots.txt\n└── src\n    ├── App.css\n    ├── App.js\n    ├── App.test.js\n    ├── index.css\n    ├── index.js\n    ├── logo.svg\n    ├── serviceWorker.js\n    └── setupTests.js\n \n Then, type  cd my-widget-config  and  npm start  to start the app. \n Add Input Field \n Let’s start with a simple form: only an input with a label. So, let’s\nedit  App.js \n import React from \'react\';\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { name: \'\'};\n  }\n\n  handleNameChange(value) {\n    this.setState(prevState => ({\n      ...prevState,\n      name: value,\n    }));\n  }\n\n  render() {\n    const { name } = this.state;\n    return (\n      <div>\n        <h1>Sample Entando 6 Widget Configuration</h1>\n        <label htmlFor="name">Name</label>\n        <input id="name" onChange={e => this.handleNameChange(e.target.value)} value={name} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n \n You are free to use your favorite form handling library e.g.,\n Formik ,\n redux-form  (that requirese redux) or others. \n In regards to styling, since this is going to be an App Builder screen,\nwe strongly suggest using  PatternFly\nv3  ( patternfly  and  patternfly-react \npackages) to keep UX coherence. \n Custom Element \n Now, let’s add the web component that will wrap the entire React app.\nLet’s name it  WidgetElement \n import React from \'react\';\nimport ReactDOM from \'react-dom\';\nimport App from \'./App\';\n\nclass WidgetElement extends HTMLElement {\n  constructor() {\n    super();\n    this.reactRootRef = React.createRef();\n    this.mountPoint = null;\n  }\n\n  get config() {\n    return this.reactRootRef.current ? this.reactRootRef.current.state : {};\n  }\n\n  set config(value) {\n    return this.reactRootRef.current.setState(value);\n  }\n\n  connectedCallback() {\n    this.mountPoint = document.createElement(\'div\');\n    this.appendChild(this.mountPoint);\n    ReactDOM.render(<App ref={this.reactRootRef} />, this.mountPoint);\n  }\n}\n\ncustomElements.define(\'my-widget-config\', WidgetElement);\n\nexport default WidgetElement;\n \n Its responsibility is rendering the react app and syncing the react app\nstate in a  config  property, that  must  be named that way. The key to\nApp builder communication is that it works in three steps: \n \n \n App Builder reads  config  property when the widget config screen is\nrendered \n \n \n config  property is mutated when a user configures the widget \n \n \n When a user saves the config, App Builder retrieves it (again, from\nthe  config  property) and persists it through Entando APIs \n \n \n This means the widget developer can focus on the configuration screens\nwithout having to call Entando APIs to read or write configuration. \n One more JS file to update:  index.js . Starting from this \n import React from \'react\';\nimport ReactDOM from \'react-dom\';\nimport \'./index.css\';\nimport App from \'./App\';\nimport * as serviceWorker from \'./serviceWorker\';\n\nReactDOM.render(<App />, document.getElementById(\'root\'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n \n You only have to import  WidgetElement  plus the css, if needed.\nSomething like \n import \'./index.css\';\nimport \'./WidgetElement\';\n \n We assume we don’t need a service worker for the widget, so we can\ndelete serviceWorker.js. \n To ensure our web component is working we have to edit\n public/index.html . Remove  <div id="root"></div>  from the  body  (we\nprogrammatically generated the react root in the  connectedCallback \nmethod of  WidgetElement ) and add our new web component tag\n <my-widget /> . \n <!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" />\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\n    <title>React App</title>\n  </head>\n  <body>\n    <my-widget-config />\n  </body>\n</html>\n \n \n Note \n the web component tag name ( my-widget-config  in this tutorial)\n must  match the first parameter of the  customElements.define \nmethod. \n \n The page should auto reload and…​congrats, you’re running an Entando 6\nwidget in isolation. \n Configuration Screen \n Next, we’ll build our widget before embedding it into the Entando 6\ninstance. From the react project root, type \n npm run build \n and a  build/static  directory will be generated. Copy it into the\nEntando 6 instance under\n src\\main\\webapp\\cmsresources\\my-widget-config , then rename \n \n \n a file like  js/runtime~main.c7dcdf0b.js  to  js/runtime.js \n(bootstrapping logic) \n \n \n a file like  js/2.230b21ef.chunk.js  to  js/vendor.js  (third-party\nlibraries) \n \n \n a file like  js/main.1fd3965a.chunk.js  to  js/main.js  (app) \n \n \n Now go to  Components  →  Micro frontends & Widgets  and find the original widget we\'re creating the configuration screen for. Edit the widget and update the\n configUI  field. \n {\n  "customElement": "my-widget-config",\n  "resources": [\n    "my-widget-config/static/js/runtime.js",\n    "my-widget-config/static/js/vendor.js",\n    "my-widget-config/static/js/main.js"\n  ]\n}\n \n \n Note \n \n \n It is possible to keep the original names in order to avoid\npotential caching issues, but then you will have to update the\n Config UI  field in the App Builder widget screen each time a new\nversion of the widget is deployed. \n \n \n configUI  is a JSON object, so pay attention to save a\nwell-formed one (the integrated JSON editor will help you) \n \n \n value for  customElement  must match the name of custom tag in\n index.html  and the one passed as parameter to\n customElements.define  in  WidgetElement \n \n \n \n Last step: configure a page in App Builder, drag our widget into the\npage template slot and you’ll see the configuration screen we just built. \n Display Widget Configuration \n So, we already created a react micro frontend widget and configuration\nscreen to customize a  name  field. \n In this tutorial we will display that field in our micro frontend\nwidget. \n Add Attribute \n Edit  WidgetElement  to add attribute handling to the custom element,\nand make re-render our app when an attribute changes. Now, the  name \nattribute is being read from the custom element and passed as a prop to\nthe react root component ( App ). \n import React from \'react\';\nimport ReactDOM from \'react-dom\';\nimport App from \'./App\';\n\nconst ATTRIBUTES = {\n  name: \'name\',\n};\n\nclass WidgetElement extends HTMLElement {\n\n  static get observedAttributes() {\n    return Object.values(ATTRIBUTES);\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (!Object.values(ATTRIBUTES).includes(name)) {\n      throw new Error(`Untracked changed attribute: ${name}`);\n    }\n    if (this.mountPoint && newValue !== oldValue) {\n      this.render();\n    }\n  }\n\n  connectedCallback() {\n    this.mountPoint = document.createElement(\'div\');\n    this.appendChild(this.mountPoint);\n    this.render();\n  }\n\n  render() {\n    const name = this.getAttribute(ATTRIBUTES.name);\n    ReactDOM.render(<App name={name} />, this.mountPoint);\n  }\n}\n\ncustomElements.define(\'my-widget\', WidgetElement);\n\nexport default WidgetElement;\n \n \n Note \n attributeChangedCallback  is also a custom elements lifecycle hook\nmethod. \n Display Input \n Edit the  App  component now, to make it display the  name  prop. \n import React from \'react\';\nimport \'./App.css\';\n\nfunction App({name}) {\n  return (\n    <div className="App">\n      <header className="App-header">\n        <p>\n          Hello, {name}!\n        </p>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n \n Now, to ensure our custom element is working we can edit\n public/index.html  and set a value for the  name  attribute of the\ncustom element. \n <!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" />\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\n    <title>React App</title>\n  </head>\n  <body>\n    <my-widget name="Marco"/>\n  </body>\n</html>\n \n After page reload, you should be able to display a simple "Hello,\nMarco!" message. \n Build It \n From the react project root, type: \n npm run build \n and the  build/static  directory will be (re)generated. Copy it again\ninto the Entando 6 instance under\n src\\main\\webapp\\resources\\static\\my-widget , then rename \n \n \n a file like  js/runtime~main.c7dcdf0b.js  to  js/runtime.js \n(bootstrapping logic) \n \n \n a file like  js/2.230b21ef.chunk.js  to  js/vendor.js  (third-party\nlibraries) \n \n \n a file like  js/main.1fd3965a.chunk.js  to  js/main.js  (app) \n \n \n a file like  css/main.d1b05096.chunk.js  to  css/main.css \n(stylesheet) \n \n \n \n Note \n you could keep the original names in order to avoid potential caching\nissues, but then you will have to update the  Custom UI  field in the\nApp Builder widget screen every time a new version of the widget is\ndeployed. \n \n If the application server you’re running does not have hot deploy\nenabled, restart it. \n Update Widget in App Builder \n Open the  Entando App Builder , go to  Components  →  Micro frontends & Widgets , find the widget  My Widget  and click to edit it. \n Update the  Custom UI  field from: \n <#assign wp=JspTaglibs[ "/aps-core"]>\n<link rel="stylesheet" type="text/css" href="<@wp.resourceURL />static/my-widget/static/css/main.css">\n<script async src="<@wp.resourceURL />static/my-widget/static/js/runtime.js"><\/script>\n<script async src="<@wp.resourceURL />static/my-widget/static/js/vendor.js"><\/script>\n<script async src="<@wp.resourceURL />static/my-widget/static/js/main.js"><\/script>\n<my-widget />\n \n to \n <#assign wp=JspTaglibs[ "/aps-core"]>\n<link rel="stylesheet" type="text/css" href="<@wp.resourceURL />static/my-widget/static/css/main.css">\n<script async src="<@wp.resourceURL />static/my-widget/static/js/runtime.js"><\/script>\n<script async src="<@wp.resourceURL />static/my-widget/static/js/vendor.js"><\/script>\n<script async src="<@wp.resourceURL />static/my-widget/static/js/main.js"><\/script>\n<@wp.currentWidget param="config" configParam="name" var="configName" />\n<my-widget name="${configName}" />\n \n We basically added a JSTL tag to extract a field (under  configParam )\nfrom the config field of the current widget and put it in a  configName \nvariable, that we pass to the custom element. \n Save the widget and reload the page that contains the widget: you’ll see\n Hello, Marco!  as expected. \n'},{title:"Entando Platform",frontmatter:{sidebarDepth:0},regularPath:"/v6.3.2/docs/",relativePath:"v6.3.2/docs/README.md",key:"v-8c1a0244",path:"/v6.3.2/docs/",headers:[{level:2,title:"Entando Architecture",slug:"entando-architecture"},{level:2,title:"Why Kubernetes?",slug:"why-kubernetes"}],lastUpdated:"11/12/2021, 4:26:29 PM",lastUpdatedTimestamp:1636752389e3,content:" Entando Platform \n Entando is the leading open source  Application Composition Platform  for Kubernetes. It enables parallel teams to accelerate development and innovation of business capabilities on a modern, cloud-native, and Kubernetes-native stack. \n With native support for Javascript app development, a micro frontend and microservices architecture, deployment of apps in containers that can be individually scaled up and down, and automated management of containers with Kubernetes, we simplify the move for enterprises looking to modernize across on-prem and cloud infrastructures. \n Entando Architecture \n \n The Entando platform includes the following major elements: \n \n Entando App Engine : assemble micro frontends & microservices and compose them on a page. \n Entando App Builder : the user interface to build and design applications. \n Entando Component Generator : provide advanced data modeling capabilities and automatically generate the corresponding microservices and micro frontends. \n Entando Component Repository : a shared, internal repository to encourage code reuse across the enterprise. \n Entando Identity Management : token-based authentication across multiple domains and connect service providers with identity providers. \n Entando WCMS : a web content management system that supports headless CMS. \n (optional)  Entando Business Automation Bundle : workflow and task automation including out of the box integration with Red Hat Process Automation Manager (PAM). \n Why Kubernetes? \n Instead of you doing the work to ensure your apps and services stay up and running, Kubernetes does the work for you. For each app or service, you can set resource limits, the number of pods you want backing each service, upgrade strategy, and auto-scaling. Kubernetes actively manages your cluster to match your defined resource utilization and ensures your site doesn't go down. \n How Google Runs Containers in Production \n Each week, Google deploys over 2 billion containers in production to run all of its services like Gmail, YouTube, and Search. Kubernetes is Google's open source solution to automate the management of containers at scale. \n \n Over 50% of Fortune 500 companies use Kubernetes with product offerings from Amazon Elastic Kubernetes Service (EKS), Google Cloud Platform (GKE), IBM (Red Hat) OpenShift, Microsoft Azure (AKS), and VMWare Pivotal (PKS). \n"},{title:"Contributing to Entando",frontmatter:{},regularPath:"/v6.3.2/docs/community/contributing.html",relativePath:"v6.3.2/docs/community/contributing.md",key:"v-4ce7f388",path:"/v6.3.2/docs/community/contributing.html",headers:[{level:2,title:"Contributing to the Source",slug:"contributing-to-the-source"},{level:2,title:"Code Style and Formatting",slug:"code-style-and-formatting"},{level:3,title:"Java",slug:"java"},{level:3,title:"Javascript",slug:"javascript"},{level:3,title:"Find the Code",slug:"find-the-code"},{level:2,title:"Get Help",slug:"get-help"},{level:2,title:"Licenses",slug:"licenses"}],lastUpdated:"1/31/2022, 9:28:12 AM",lastUpdatedTimestamp:1643639292e3,content:" Contributing to Entando \n There are many ways to contribute to Entando including participating in the  Entando Forum , opening issues on GitHub,  updating documentation , building bundles using the  Entando Component Repository , and contributing directly to the source. \n Contributing to the Source \n Entando welcomes contributions to our source code repositories. This is a brief overview of how to create a pull request for an Entando repository. \n If you're new to forks in the git world checkout this guide  Working with Forks \n \n Find the repository you want to edit on the Entando GitHub\n \n https://github.com/entando \n https://github.com/entando-k8s \n \n \n Create a fork of the repository you want to update \n Make your changes or updates on your fork. We recommend making your changes on a branch so that you can update your commits as needed before creating your PR \n Submit a PR against the main (or master) branch of the repository you're working against. If you're fixing a specific issue reference that issue number in the notes and linked issues \n Watch the automated builds to make sure everything passes \n The Entando team will merge your changes! \n Code Style and Formatting \n Most Entando repositories enforce code style rules. References and setup for the main\nsource types are provided below. \n Java \n Java rules are based on checkstyle and PMD can be found at in the  entando-code-style  project. There are configuration files for Intellij, Eclipse, and Netbeans for automated formatting. \n Javascript \n Code style and formatting rules for all Entando javascript projects are enforced by linters in every project. For a reference example see: .sass-lint.yml and .eslintrc.js in the  App builder \n In the future these rules will be replaced by Prettier. \n Find the Code \n Entando source can be found on GitHub in the following organizations. \n \n https://github.com/entando \n https://github.com/entando-k8s \n \n For an overview of the key projects in both GitHub organizations and their role in the architecture see  Entando Deployment Structure \n Get Help \n If you have questions, need help, or want to find out more about contributing join us at \n \n Entando Forum \n Community Slack \n Licenses \n The Entando Platform is 100% open source and most Entando repositories are licensed under the LGPL V3.0. The entando-docs repository is one exception with a  CC BY 4.0 license . See the LICENSE file in the root directory of a given repository for its specific license information. \n Entando libraries licensed with LGPL V3.0 that are used to build applications may be linked to proprietary applications. If linked statically, the application code must also be released as LGPL. If the application is linked dynamically to Entando, the proprietary code does not need to be released. \n A commercial open source license is provided for the Entando Platform for customers with Gold and Platinum subscriptions. This license permits freely extending or modifying Entando without requiring contribution of confidential IP back to the open source community. \n"},{title:"Entando Contributor Covenant Code of Conduct",frontmatter:{},regularPath:"/v6.3.2/docs/community/code-of-conduct.html",relativePath:"v6.3.2/docs/community/code-of-conduct.md",key:"v-765adacc",path:"/v6.3.2/docs/community/code-of-conduct.html",headers:[{level:2,title:"Our Pledge",slug:"our-pledge"},{level:2,title:"Our Standards",slug:"our-standards"},{level:2,title:"Enforcement Responsibilities",slug:"enforcement-responsibilities"},{level:2,title:"Scope",slug:"scope"},{level:2,title:"Enforcement",slug:"enforcement"},{level:2,title:"Enforcement Guidelines",slug:"enforcement-guidelines"},{level:3,title:"1. Correction",slug:"_1-correction"},{level:3,title:"2. Warning",slug:"_2-warning"},{level:3,title:"3. Temporary Ban",slug:"_3-temporary-ban"},{level:3,title:"4. Permanent Ban",slug:"_4-permanent-ban"},{level:2,title:"Attribution",slug:"attribution"}],lastUpdated:"5/19/2021, 9:29:46 AM",lastUpdatedTimestamp:1621430986e3,content:" Entando Contributor Covenant Code of Conduct \n Our Pledge \n We as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, religion, or sexual identity\nand orientation. \n We pledge to act and interact in ways that contribute to an open, welcoming,\ndiverse, inclusive, and healthy community. \n Our Standards \n Examples of behavior that contributes to a positive environment for our\ncommunity include: \n \n Demonstrating empathy and kindness toward other people \n Being respectful of differing opinions, viewpoints, and experiences \n Giving and gracefully accepting constructive feedback \n Accepting responsibility and apologizing to those affected by our mistakes,\nand learning from the experience \n Focusing on what is best not just for us as individuals, but for the\noverall community \n \n Examples of unacceptable behavior include: \n \n The use of sexualized language or imagery, and sexual attention or\nadvances of any kind \n Trolling, insulting or derogatory comments, and personal or political attacks \n Public or private harassment \n Publishing others' private information, such as a physical or email\naddress, without their explicit permission \n Other conduct which could reasonably be considered inappropriate in a\nprofessional setting \n Enforcement Responsibilities \n Community leaders are responsible for clarifying and enforcing our standards of\nacceptable behavior and will take appropriate and fair corrective action in\nresponse to any behavior that they deem inappropriate, threatening, offensive,\nor harmful. \n Community leaders have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions that are\nnot aligned to this Code of Conduct, and will communicate reasons for moderation\ndecisions when appropriate. \n Scope \n This Code of Conduct applies within all community spaces, and also applies when\nan individual is officially representing the community in public spaces.\nExamples of representing our community include using an official e-mail address,\nposting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event. \n Enforcement \n Instances of abusive, harassing, or otherwise unacceptable behavior may be\nreported to the community leaders responsible for enforcement at\ncommunity@entando.com. \n All complaints will be reviewed and investigated promptly and fairly. \n All community leaders are obligated to respect the privacy and security of the\nreporter of any incident. \n Enforcement Guidelines \n Community leaders will follow these Community Impact Guidelines in determining\nthe consequences for any action they deem in violation of this Code of Conduct: \n 1. Correction \n Community Impact : Use of inappropriate language or other behavior deemed\nunprofessional or unwelcome in the community. \n Consequence : A private, written warning from community leaders, providing\nclarity around the nature of the violation and an explanation of why the\nbehavior was inappropriate. A public apology may be requested. \n 2. Warning \n Community Impact : A violation through a single incident or series\nof actions. \n Consequence : A warning with consequences for continued behavior. No\ninteraction with the people involved, including unsolicited interaction with\nthose enforcing the Code of Conduct, for a specified period of time. This\nincludes avoiding interactions in community spaces as well as external channels\nlike social media. Violating these terms may lead to a temporary or\npermanent ban. \n 3. Temporary Ban \n Community Impact : A serious violation of community standards, including\nsustained inappropriate behavior. \n Consequence : A temporary ban from any sort of interaction or public\ncommunication with the community for a specified period of time. No public or\nprivate interaction with the people involved, including unsolicited interaction\nwith those enforcing the Code of Conduct, is allowed during this period.\nViolating these terms may lead to a permanent ban. \n 4. Permanent Ban \n Community Impact : Demonstrating a pattern of violation of community\nstandards, including sustained inappropriate behavior,  harassment of an\nindividual, or aggression toward or disparagement of classes of individuals. \n Consequence : A permanent ban from any sort of public interaction within\nthe community. \n Attribution \n This Code of Conduct is adapted from the  Contributor Covenant ,\nversion 2.0, available at\nhttps://www.contributor-covenant.org/version/2/0/code_of_conduct.html. \n Community Impact Guidelines were inspired by  Mozilla's code of conduct\nenforcement ladder . \n For answers to common questions about this code of conduct, see the FAQ at\nhttps://www.contributor-covenant.org/faq. Translations are available at\nhttps://www.contributor-covenant.org/translations. \n"},{title:"Entando Component Manager",frontmatter:{sidebarDepth:2},regularPath:"/v6.3.2/docs/compose/ecm-overview.html",relativePath:"v6.3.2/docs/compose/ecm-overview.md",key:"v-5ea0ec18",path:"/v6.3.2/docs/compose/ecm-overview.html",headers:[{level:3,title:"Key Features:",slug:"key-features"}],lastUpdated:"2/22/2022, 1:55:15 PM",lastUpdatedTimestamp:1645556115e3,content:" Entando Component Manager \n ​​An Entando Application is composed of the  Entando App Builder ,  Entando App Engine , and Entando Component Manager. The Entando Component Manager (ECM) provides functionality to build and organize micro frontends and widgets from within the App Builder. It also manages the connections between an application and the installed plugins. \n The Component Manager is a service that links the  Entando Component Repository  (ECR) of the App Builder to the core application instance. It appears as  quickstart-cm-deployment  in the Kubernetes pod list: \n \n The ECM communicates with the Kubernetes service to populate the ECR with the bundles available as  Custom Resources  in the Entando namespace. These bundles can be installed in the application and managed from within the ECR. \n \n In the flow pictured above: \n \n A user visits the ECR page in the App Builder \n The ECR makes a REST call to the  digital-exchange  endpoint \n The Component Manager receives the  digital-exchange  request \n The Component Manager calls the  k8s-service  to return the list of available  EntandoDeBundles  in the namespace \n \n A similar process occurs when bundles are installed or uninstalled. The  Entando Operator  performs actions based on lifecycle events for affected Entando Custom Resources. \n Key Features: \n \n \n Manages the installation and removal of project bundles \n \n \n Makes components available in the App Builder through the Component Repository \n \n \n Handles versioning of component bundles for sharing and collaborating \n \n \n"},{title:"Entando App Builder",frontmatter:{sidebarDepth:2},regularPath:"/v6.3.2/docs/compose/app-builder.html",relativePath:"v6.3.2/docs/compose/app-builder.md",key:"v-6e997a68",path:"/v6.3.2/docs/compose/app-builder.html",headers:[{level:3,title:"Key Features:",slug:"key-features"},{level:3,title:"Next Steps:",slug:"next-steps"}],lastUpdated:"2/22/2022, 1:55:15 PM",lastUpdatedTimestamp:1645556115e3,content:" Entando App Builder \n The Entando App Builder plays a key role in the composition of Entando Applications. It is a feature-rich, low-code user interface to customize and manage components. It also offers a Dashboard and a modular CMS to streamline the design and build process. \n \n The App Builder allows you to create pages and content, configure widgets and plugins, and interact with the  Entando Component Repository  (ECR). It also interfaces with the  Entando Hub , where you can share components and collaborate. \n Pages are designed and embedded with functionality via drag-and-drop: \n \n In the default deployment, the App Builder is a React JS application served by Node. In a quickstart environment, the App Builder is deployed as a container. It is the frontend of the core application and uses REST APIs to communicate with the core instance and  Entando Component Manager (ECM) . The App Builder can query the ECM to fetch information on Entando Bundles available to the ECR. \n Key Features: \n \n \n Install component bundles from the Entando Component Repository \n \n \n Deploy standalone packaged business capabilities \n \n \n Preview page design and functionality \n \n \n Append or update applications \n \n \n Deliver standardized UX design with page and content templates \n \n \n Use micro frontends to build pages from modular, editable content \n Next Steps: \n \n \n To begin,  install Entando \n \n \n Welcome Wizard \n \n \n Create a new page \n \n \n Try out components or packaged business capabilities from the  Entando Hub \n \n \n"},{title:"Welcome Wizard",frontmatter:{redirectFrom:"/v6.3.2/docs/getting-started/welcome-wizard.html"},regularPath:"/v6.3.2/docs/compose/welcome-wizard.html",relativePath:"v6.3.2/docs/compose/welcome-wizard.md",key:"v-6602b914",path:"/v6.3.2/docs/compose/welcome-wizard.html",lastUpdated:"2/8/2022, 9:40:35 AM",lastUpdatedTimestamp:1644331235e3,content:" Welcome Wizard \n The Welcome Wizard is displayed when you first log in to the Application Builder. You can also start it later by going to the top navigation bar in the Application Builder, click on the information icon, and click  Begin Welcome Wizard . You can disable it from the wizard popup by selecting  Don't show next time  and then  Close , or by going to  My Profile → Preferences  and setting the  Welcome Wizard  preference to  Off . \n \n The Wizard will guide you through the key steps in designing and publishing a page in your application: \n \n Create a Page by setting its title, code, location, group, and template. \n Design the Page by placing a set of pre-configured widgets on the page. \n Preview the Page \n Publish the Page \n \n For more information see the following tutorials: \n \n Page Management \n Widgets and Fragments \n Content Creation \n Digital Assets \n \n"},{title:"Entando Component Repository",frontmatter:{redirectFrom:"/v6.3.2/docs/ecr/ecr-overview.html"},regularPath:"/v6.3.2/docs/compose/ecr-overview.html",relativePath:"v6.3.2/docs/compose/ecr-overview.md",key:"v-389f9c04",path:"/v6.3.2/docs/compose/ecr-overview.html",headers:[{level:2,title:"Glossary",slug:"glossary"},{level:3,title:"Component",slug:"component"},{level:3,title:"ECR Bundle",slug:"ecr-bundle"},{level:3,title:"EntandoDeBundle custom resource",slug:"entandodebundle-custom-resource"},{level:3,title:"Entando-component-manager",slug:"entando-component-manager"},{level:3,title:"Entando-K8S-service",slug:"entando-k8s-service"},{level:2,title:"Architecture",slug:"architecture"},{level:2,title:"Example flow",slug:"example-flow"}],lastUpdated:"2/8/2022, 9:40:35 AM",lastUpdatedTimestamp:1644331235e3,content:" Entando Component Repository \n The Entando Component Repository (ECR) is meant to be a repository to\nshare reusable components among different Entando instances. \n The following glossary relates to the ECR and related concepts: \n Glossary \n Component \n An Entando component - simply referred to as component - is a piece of\nreusable code/resource to be used in an Entando widget, page or\napplication. Examples of components are widgets, microfrontends,\ncontent-types, labels, plugins, and static resources \n ECR Bundle \n An ECR bundle - is a package containing one or more components and a\n'descriptor.yaml' file providing information about the bundle. The\nbundle is published on an Git registry and is shared with an Entando\napplication using the EntandoDeBundle custom resource. \n EntandoDeBundle custom resource \n The EntandoDeBundle custom resource is a Kubernetes custom resource\nreadable by the Entando6 operator. It’s used to provide information\nabout an ECR bundle and make the bundle available in kubernetes for the\nentando-component-manager. \n Entando-component-manager \n The entando-component-manager - a.k.a component-manager is part of the\nEntando6 app and dialogs both with the Kubernetes cluster via the\nentando-k8s-service and with the entando-core. The\nentando-component-manager reads the bundles from the cluster and exposes\nthem via an API accessible from AppBuilder. The component-manager is\nalso responsible of the installation/removal of components from\nentando-core \n Entando-K8S-service \n The Entando-K8S-Service is part of the Entando infrastructure and is\nresponsible for the low-level communication with the K8S cluster API. \n Architecture \n \n From an architectural point of view, the ECR is composed of \n \n The EntandoDeBundles which contain the metadata associated with a bundle \n The Entando-k8s-service which reads the bundles from the\ncluster/namspace(s) and serves them via a consumable API \n The Component-manager which creates the connection between the EntandoApp\nand the K8S-service. \n Example flow \n \n \n The user lands on the ECR page in app-builder and wants to see the\nlist of bundles shared with that EntandoApp \n \n \n AppBuilder asks the component-manager for the list of available\nbundles \n \n \n Component-manager queries the k8s-service to get the available\nbundles \n \n \n The k8s-service queries the cluster/namespace(s) it is able to read\nfrom for available bundles and returns the list to the\ncomponent-manager \n \n \n Component-manager returns a list to App-Builder \n \n \n The user is able to see the available bundles and is able to install\none or more of them \n \n \n"},{title:"Web Accessibility in Entando",frontmatter:{redirectFrom:"/v6.3.2/docs/concepts/accessibility.html"},regularPath:"/v6.3.2/docs/consume/accessibility.html",relativePath:"v6.3.2/docs/consume/accessibility.md",key:"v-6af9f52c",path:"/v6.3.2/docs/consume/accessibility.html",headers:[{level:2,title:"Requirements and Standards",slug:"requirements-and-standards"},{level:2,title:"Tools",slug:"tools"}],lastUpdated:"2/8/2022, 9:40:35 AM",lastUpdatedTimestamp:1644331235e3,content:" Web Accessibility in Entando \n \n The power of the Web is in its universality.\nAccess by everyone regardless of disability is an essential aspect. \n \n - Tim Berners-Lee, W3C Director and inventor of the World Wide Web \n Web accessibility means that websites, tools, and technologies are designed and developed so that people with\ndisabilities can use them. Accessibility is essential for developers and organizations that want to create high-quality\nwebsites and web tools, and not exclude people from using their products and services.\nSee  w3.org  for an introduction to this topic. \n Requirements and Standards \n Many projects and programs will have specific requirements in the area of accessibility, particularly for applications\nor sites with a broad reach or specific governance considerations. Entando's approach to accessibility is to provide the\ntools and techniques that allow a development team to meet their own specific accessibility requirements. \n Development teams will need someone to become familiar with the relevant accessibility standards and help make design\ndecisions on how they will be applied to a specific project. Those standards vary by region so please check the\nlegislation in your area or consult an accessibility specialist. Useful resources include: \n \n W3C Web Accessibility Initiative (WAI) \n Web Content Accessibility Guidelines (WCAG) \n USA:  Section 508 of the Rehabilitation Act \n \n At the end of the day it's up to a development team to make sure their implementation is compliant with a specific\nguideline or standard. Typically a team will make use of Entando Page Templates, Content Templates, and custom micro\nfrontends in order to accomplish this goal. \n Tools \n Accessibility requirements are ideally known at the start of a project so the design language and tools can be adopted\nearly in the project. Using them consistently will ease implementation of the accessibility elements needed to meet the\ndesired compliance level. Retrofitting a project for accessibility can be done but is typically more involved. Example\ndesign systems used by Entando clients include: \n \n Material-UI  - a React framework used to build a custom design system and/or one based on\nMaterial Design. \n Carbon Design System  - IBM's open source design system \n Bootstrap Italia  - a Bootstrap 4-based frontend theme that implements\nthe Italian Design Guidelines for public websites. \n \n Asessing web accessibility is important throughout the life of a project. There are many tools available in this area. A\nuseful list can be found  on the W3C site  with filters by guideline, region,\nlanguage, etc. Entando clients have made good use of the following: \n \n a11y.css \n Access Assistant \n Continuum Explorer Pro \n Wave (web accessibility evaluation tool) \n \n"},{title:"Entando Identity Management -- Keycloak",frontmatter:{redirectFrom:"/v6.3.2/docs/reference/identity-management.html"},regularPath:"/v6.3.2/docs/consume/identity-management.html",relativePath:"v6.3.2/docs/consume/identity-management.md",key:"v-b827ee28",path:"/v6.3.2/docs/consume/identity-management.html",headers:[{level:2,title:"Logging into your Keycloak Instance",slug:"logging-into-your-keycloak-instance"},{level:2,title:"Authentication",slug:"authentication"},{level:2,title:"Authorization",slug:"authorization"},{level:3,title:"Role Assignment for Plugins/Microservices",slug:"role-assignment-for-plugins-microservices"},{level:3,title:"Core",slug:"core"},{level:2,title:"Social Login",slug:"social-login"},{level:2,title:"One Time Passwords",slug:"one-time-passwords"},{level:2,title:"Themes, Look and Feel",slug:"themes-look-and-feel"}],lastUpdated:"4/19/2022, 2:47:38 PM",lastUpdatedTimestamp:1650394058e3,content:' Entando Identity Management -- Keycloak \n Entando Identity Management is based on open source Keycloak. Entando Applications rely on a Keycloak instance that is either  externally installed  or specific to an application. The architecture and requirements to customize your Keycloak instance are described below. \n Logging into your Keycloak Instance \n Keycloak is protected by a Secret deployed to your Entando Kubernetes instance. You can query Kubernetes for the Secret\'s default admin credentials, substituting your environment\'s namespace and Secret name: \n ent kubectl get secret quickstart-kc-admin-secret -n entando -o go-template="{{println}}Username: {{.data.username | base64decode}}{{println}}Password: {{.data.password | base64decode}}{{println}}{{println}}"\n \n To find the Secret name, run \n kubectl get secrets -n <namespace>\n \n and search for the Secret that ends in  kc-admin-secret . \n Authentication \n Beginning with Entando 6, all authentication is powered by Keycloak. This ensures that a micro frontend can call a microservice with a token available to the client. \n \n Entando implements Keycloak as a central point of authentication to provide a single, unified view of identity. This architecture increases portability. Keycloak acts as an abstraction layer to the underlying Identity Provider (IDP), allowing Entando to integrate into other IDPs without modifying the source. \n Authorization \n Role Assignment for Plugins/Microservices \n Keycloak authorizes microservices using clients and roles. Authorizations are stored in a JSON Web Token and available to services when invoked. \n Below are the steps to grant a user one or more roles for a specific client. This controls permissions when configuring the microservice. Note: when a microservice is installed in Entando, a corresponding client (and set of roles) is created per its plugin definition. \n \n Login to your Keycloak instance \n Select  Users  from the menu on the left \n Use the search box to find the appropriate user, e.g. "admin" \n Click on the user ID \n \n \n \n Click on the  Role Mappings  tab \n Use the  Client Roles  drop-down menu to specify the microservice client \n Select from the client\'s  Available Roles \n \n \n \n Use the  Add Selected  button to move the desired roles to  Assigned Roles . These will subsequently appear under  Effective Roles . \n Core \n When a user is authenticated to the  entando-core  via Keycloak, a copy of that user is added to the  entando-core  user management database to enable WCMS functionality. Within the App Builder, WCMS roles and groups can be assigned to a user for access to App Builder functions or  portal-ui  content in the runtime application. \n The code that copies the user into the  entando-core  can be customized per implementation to automatically create groups and roles. See the  entando-keycloak-plugin  for details of the code that copies users and data to the WCMS database. The README in that project includes properties that are available to your Entando Application. \n See  KeycloakAuthorizationManager.java  for an example of adding attributes programatically. In particular, refer to the  processNewUser  method. \n Social Login \n Keycloak allows Entando to provide social login as an out-of-the-box capability.  Keycloak Social Identity Providers  documents how to enable and configure social logins in your Entando Applications. \n One Time Passwords \n Keycloak enables One Time Passwords (OTP) login to Entando Applications. See  Keycloak OTP Policies  to configure and enable OTP in your application. \n Themes, Look and Feel \n Developers can customize the look and feel of the login page, as well as the identity management system that ships with Entando. The  Keycloak Theme Documentation  provides instructions for creating your own theme. Alternatively, you can modify the  Entando Theme . \n'},{title:"Entando Custom Resources for Kubernetes",frontmatter:{redirectFrom:"/v6.3.2/docs/concepts/custom-resources.html"},regularPath:"/v6.3.2/docs/consume/custom-resources.html",relativePath:"v6.3.2/docs/consume/custom-resources.md",key:"v-4cd51ca4",path:"/v6.3.2/docs/consume/custom-resources.html",headers:[{level:2,title:"Objective",slug:"objective"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"The Core Entando Custom Resources",slug:"the-core-entando-custom-resources"},{level:2,title:"The ResourceRequirements specification",slug:"the-resourcerequirements-specification"},{level:2,title:"EntandoKeycloakServer",slug:"entandokeycloakserver"},{level:3,title:"Overview",slug:"overview-2"},{level:3,title:"Example",slug:"example"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties"},{level:2,title:"EntandoClusterInfrastructure",slug:"entandoclusterinfrastructure"},{level:3,title:"Overview",slug:"overview-3"},{level:3,title:"Example",slug:"example-2"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-2"},{level:2,title:"EntandoApp",slug:"entandoapp"},{level:3,title:"Overview",slug:"overview-4"},{level:3,title:"Example",slug:"example-3"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-3"},{level:2,title:"EntandoPlugin",slug:"entandoplugin"},{level:3,title:"Overview",slug:"overview-5"},{level:3,title:"Example",slug:"example-4"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-4"},{level:2,title:"EntandoAppPluginLink",slug:"entandoapppluginlink"},{level:3,title:"Overview",slug:"overview-6"},{level:3,title:"Example",slug:"example-5"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-5"},{level:2,title:"EntandoDatabaseService",slug:"entandodatabaseservice"},{level:3,title:"Example",slug:"example-6"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-6"},{level:2,title:"EntandoCompositeApp",slug:"entandocompositeapp"},{level:3,title:"Overview",slug:"overview-7"},{level:3,title:"Example",slug:"example-7"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-7"}],lastUpdated:"2/8/2022, 9:40:35 AM",lastUpdatedTimestamp:1644331235e3,content:' Entando Custom Resources for Kubernetes \n Objective \n This is an overview of Entando Kubernetes Custom Resources and their semantics in Entando 6. \n Prerequisites \n \n Basic knowledge of Kubernetes and how to deploy Docker images to it \n Basic knowledge of Helm and how Helm Charts use YAML templates for parameterized deployments to Kubernetes \n Overview \n Amongst its many features, Kubernetes comes with a REST API for dozens of different resource types.\nGenerally these APIs offer full Create/Retrieve/Update/Delete (CRUD) access to each of the resource types. We\ntypically format these resources in YAML or JSON and use commandline tools such as\n kubectl  or  oc  to manage them. Each of these resources has a clearly defined structure\nthat is well documented in the  Kubernetes API  .\nKubernetes  also allows clients to subscribe to events generated as these resources get updated. These subscriptions\nare called \'watches\' and allow clients to be notified whenever the state of a resource changes. It also\nenforces a strong role based access control (RBAC) on all resources, with granular permissions at the level of operation (Create/Retrieve/Update/Delete/Watch) per resource. \n The basic architecture for Kubernetes worked so well for its developers that it was made available to third  party developers. Kubernetes now offers a mechanism for third parties to provide their own custom\nresource types that still leverqage CRUD support, event subscriptions and RBAC out of the box.\nThis mechanism is referred to as Custom Resources. \n Custom Resources are most commonly used with Kubernetes Operators. Operators are Docker images that have been\ndeployed to Kubernetes Deployments. Generally, they observe a set of custom resources and perform some operations against\nthe Kubernetes API to reflect the state changes in the Custom Resource. We can say that Custom Resources are associated\nwith specific semantics in how they are translated in the cluster. \n A new Custom Resource can be introduced into Kubernetes by registering a Custom Resource Definition (CRD). This is\njust another yaml or json resource that defines the structure of the custom resource to be installed using the OpenAPI\nJSON Schema format. When talking about Custom Resources, it is very important to distinguish between Custom Resource\nDefinitions and Custom Resources. CRD\'s are static type definitions provided by an Operator\nprovider such as Entando. For those familiar with programming languages, CRD\'s are like class definitions, whereas\nCustom Resources are actual instances of that class. \n Entando introduces two groups of Custom Resources. \n \n Core Custom Resources required\nfor a basic installation of Entando in a Kubernetes cluster. These directly result in other\nKubernetes resources being deployed in the cluster. \n Custom Resources specific\nto the Entando Component Repository that serve primarily as metadata for other Entando components. \n The Core Entando Custom Resources \n The Entando Operator observes all the Core Entando Custom Resources in one or more namespaces. If a Core\nEntando Custom Resource is created, updated or deleted, the Entando Operator will trigger a new run-to-completion Pod\nthat will translate that state change into a state change in the actual Kubernetes Cluster. Often, this will\nresult in the Deployment of one or more Docker images, along with one or more Services, and sometimes an Ingress. We refer to the Docker Images that implement these run-to-completion Pods as Entando Kubernetes Controllers. \n The Entando Operator itself is also implemented as a Docker Image. You can have a closer look at how it works in the\n entando-k8s-controller-coordinator  project on Github.\nApart from the typical Maven, Java and Docker files, you will also notice the\n entando-k8s-controller-coordinator Helm Chart .\nThis Helm Chart is basically the entry point for installations of Entando 6 on Kubernetes. More detailed instructions\non how to install the Entando 6 Operator are available in our\n installation instructions . \n The ResourceRequirements specification \n All of the Entando Custom Resources that result in physical Kubernetes Deployments can be configured with specific\nresource requirements. These settings can be provided under the  spec  object of the custom resource. It currently\nsupports the following attributes: \n \n spec.resourceRequirements.storageRequest  - the initial storage requested from the persistence provider. Please keep\nin mind that resizable storage is not supported by all storage providers, and this may be the final size of the storage\nallocated. \n spec.resourceRequirements.storageLimit  - the maximum amount of storage required by the deployment. \n spec.resourceRequirements.memoryRequest  - the initial memory requested from the node the deployment\'s primary container is running on. \n spec.resourceRequirements.memoryLimit  - the maximum amount of memory the deployment\'s primary container will use. If\nit exceeds this amount, the container may be terminated by Kubernetes. \n spec.resourceRequirements.cpuRequest  - the initial CPU allocation from the node the deployment\'s primary container is running on. \n spec.resourceRequirements.cpuLimit  - the maximum CPU allocation for the deployment\'s primary container. \n spec.resourceRequirements.fileUploadLimit   - the maximum upload file size supported by the deployment. \n \n All of these attributes require a number and a unit of measurement, e.g. "64Mi". Please consult the\n official Kubernetes documentation \nfor more information on how to configure these attributes. \n EntandoKeycloakServer \n The EntandoKeycloakServer Custom Resource is used to deploy and configure a Red Hat Keycloak Server instance on the\ncluster. After deploying this Keycloak instance, the Entando Operator will create a Kubernetes Secret that provides\nthe necessary information for subsequent deployment operations to access the Keycloak instance as the Admin user. This\nallows the rest of the Entando Kubernetes Controllers to create a Keycloak OpenID Connect (OIDC) client for every HTTP service that\ngets deployed. If you already have a Keycloak instance that you want to use, you can skip this custom resource entirely\nand simply create the `keycloak-admin-secret\' in the operator\'s namespace as specified in\n this tutorial . \n Overview \n \n Entando Cluster Citizen:  Keycloak \n Custom Resource Definition:  EntandoKeycloakServer \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-keycloak-controller \n Github Repo:  entando-k8s/entando-k8s-keycloak-controller \n \n \n Deployment Details:\n \n Docker image:  entando/entando-keycloak \n Github Repo:  entando/entando-keycloak \n \n \n Possible Database Images:\n \n MySQL:  docker.io/centos/mysql-57-centos7 \n PostgreSQL:  docker.io/centos/postgresql-96-centos7 \n Example \n ---\nkind: "EntandoKeycloakServer"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-keycloak"\n  namespace: "keycloak-namespace"\nspec:\n  dbms: "postgresql"\n  imageName: "entando/entando-keycloak"\n  ingressHostName: "test-keycloak.ampie.dynu.net"\n  isDefault: true\n  environmentVariables: \n    - name: KEYCLOAK_WELCOME_THEME\n      value: my-custom-theme\n  tlsSecretName: my-tls-secret\n  replicas: 1\n Explanation of properties \n \n spec.dbms  is used to select the database management of choice. The Entando Operator will use this value to deploy a dedicated Database instance in this namespace\nfor Keycloak to use. If this value matches the  spec.dbms  property\nof a previously  configured  EntandoDatabaseService ,\nthe Keycloak image will be configured to use this service.\nIf left empty or given a value of \'none\', Keycloak will deploy using its own internal\nH2 database. \n spec.imageName  is used to provide a customized image. By default, the operator will use the  entando/entando-keycloak \ndiscussed above. When using the default image, please refer to the\n relevant section \nin the README of the Entando Operator to determine how the Docker registry and version for this image is calculated.\nWhen you need to customize the theme or add extensions to Keycloak, you can create your own custom image and provide\nthe value in this property. Make sure you use the default image ( entando/entando-keycloak )\nas a base image. You can then add your customizations and build your own. Please use a fully qualified\nDocker image name here. \n spec.ingressHostName  is the hostname of the Kubernetes Ingress to be created for Keycloak. Please ensure that this is\naccessible using the default routing suffix of your Entando Operator Deployment or a DNS name previously\nregistered with your DNS provider. \n spec.isDefault  is \'true\' by default and this should suffice for most conditions. This will result in the standard\n keycloak-admin-secret  being replaced by a Secret connecting you to this newly created Keycloak instance.\nTheoretically one could use multiple Keycloak instances in a cluster, in which case this property should be false. \n spec.environmentVariables  is a Map of environment variables to pass to the Keycloak Docker image. For example, this could\nbe used to select a specific theme for Keycloak with the variable KEYCLOAK_WELCOME_THEME. These parameters\nare applied to the container\'s environment variables after all variables have been calculated. It can therefore\nalso be used as a mechanism to override any of the default environment variables that need customization. \n spec.tlsSecretName  is the name of a standard Kubernetes\n TLS Secret  that will be used for the\nresulting Ingress. This is only required if the\n globally configured TLS Secret \nfor the Operator is absent or has not been created with a wildcard hostname that supports this Keycloak instance\'s hostname. \n spec.replicas  - the number of replicas to be made available on the Deployment of this Keycloak Server. \n spec.resourceRequirements  - the minimum and maximum  resource allocation  for the Keycloak Server container. \n EntandoClusterInfrastructure \n The EntandoClusterInfrastructure custom resource can be used to create the shared services that Entando requires in a cluster.\nAt the time of writing this document, there is one service, the Entando K8S Service, but this\nmay change in the future. Deployments resulting from this custom resource are configured to use the default Keycloak\nServer specified in the  keycloak-admin-secret  using the  entando  realm. An Ingress is also created as part of this\ndeployment. At this point, there is no way to customize the image in question. \n Overview \n \n Entando Cluster Citizen:  Entando Kubernetes Service \n Custom Resource Definition:  EntandoClusterInfrastructure \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-cluster-infrastructure-controller \n Github Repo:  entando-k8s/entando-k8s-keycloak-controller \n \n \n Deployment Details:\n \n Docker image:  entando/entando-k8s-service \n Github Repo:  entando-k8s/entando-k8s-service \n \n \n Possible Database Images: none \n Example \n ---\nkind: "EntandoClusterInfrastructure"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-eci"\n  namespace: "eci-namespace"\nspec:\n  keycloakSecretToUse: some-keycloak-secret\n  ingressHostName: "test-keycloak.ampie.dynu.net"\n  isDefault: true\n  environmentVariables: \n    - name: ENTANDO_NAMESPACES_TO_OBSERVE\n      value: my-namespace\n  tlsSecretName: my-tls-secret\n  replicas: 1\n Explanation of properties \n \n spec.keycloakSecretToUse  is used to determine which Kubernetes Secret to use when connecting to the correct\nKeycloak instance. If not specified, the default Secret  keycloak-admin-secret  will be used. This is useful only\nif you have more than one Keycloak server in your cluster. \n spec.ingressHostName  is the hostname of the Kubernetes Ingress to be created for the Entando K8S Service. Please\nensure that this is accessible using the default routing suffix of your Entando Operator Deployment or a DNS\nname previously registered with your DNS provider. \n spec.isDefault  is \'true\' by default and this should suffice for most conditions. This will result in the standard\n entando-cluster-infrastructure-secret  being replaced by a Secret connecting you to this newly created\nEntando K8S Service.  Theoretically one could use multiple Entando K8S Services in a cluster, in which\ncase this property should be false for new Entando K8S Services that should not override the default Secret. \n spec.environmentVariables  is a Map of environment variables to pass to the Entando K8S Service Docker image. For example, this could\nbe used to override the ENTANDO_NAMESPACES_TO_OBSERVE variable that configures the set of Kubernetes namespaces that this\nservice should read the EntandoDeBundles from. Also note that all of the\n Spring variables in entando-k8s-service project \ncan also be overridden here by specifying the equivalent SNAKE_CASE names of the dot-delimited Spring properties.\nThese parameters are applied to the container\'s environment variables after all variables have been calculated.\nIt can therefore also be used as a mechanism to override any of the default environment variables that need customization. \n spec.tlsSecretName  is the name of a standard Kubernetes\n TLS Secret  that will be used for the\nresulting Ingress. This is only required if the\n globally configured TLS Secret \nfor the Operator is absent or has not been created with a wildcard hostname that supports this Keycloak instance\'s hostname. \n spec.replicas  - the number of replicas to be made available on the Deployment of this Entando K8S Service. \n spec.resourceRequirements  - the minimum and maximum  resource allocation  for the Entando Kubernetes Service container. \n EntandoApp \n An EntandoApp is a Deployment of a Docker image that hosts an Entando and Java based web application. Entando offers two\nstandard images that can be used, but generally we expect our customers to provide their images here. An EntandoApp\nDeployment packages three images into a single Pod: the Entando App Image in question, AppBuilder and Component Manager. \n Overview \n \n Custom Resource Definition:  EntandoApp \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-app-controller \n Github Repo:  entando/entando-k8s-app-controller \n \n \n Deployment Details - Entando App:\n \n Docker image:  entando/entando-de-app-wildfly   or    entando/entando-de-app-eap \n Github Repo:  entando-k8s/entando-de-app \n Entando Cluster Citizen:  Entando App \n \n \n Deployment Details - AppBuilder:\n \n Docker image:  entando/app-builder \n Github Repo:  entando/app-builder \n \n \n Deployment Details - ComponentManager:\n \n Docker image:  entando/entando-component-manager \n Github Repo:  entando-k8s/entando-component-manager \n Entando Cluster Citizen:  Component Manager \n \n \n Possible Database Images:\n \n MySQL:  docker.io/centos/mysql-57-centos7 \n PostgreSQL:  docker.io/centos/postgresql-96-centos7 \n Example \n ---\nkind: "EntandoApp"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-app"\n  namespace: "my-namespace"\nspec:\n  standardServerImage: wildfly\n  customServerImage: your-org/your-image:4.3.2\n  dbms: "postgresql"\n  ingressPath: my-app\n  keycloakSecretToUse: some-kc-secret\n  clusterInfrastructureToUse: some-eci-secret  \n  ingressHostName: "test-app.my-routing-suffix.com"\n  environmentVariables: \n    - name: ENTANDO_VAR1\n      value: my-var1\n  tlsSecretName: my-tls-secret\n  replicas: 1\n  ecrGitSshSecretName: my-secret\n Explanation of properties \n \n \n spec.standardServerImage  can be either wildfly  or  eap . This instructs the Entando Operator to use one of the\ntwo standard Entando App images. \n \n wildfly  will deploy the  entando/entando-de-app-wildfly  image \n eap  will deploy the  entando/entando-de-app-eap  image \n \n This property and the  spec.customServerImage  are  assumed to be mutually exclusive. Only provide a value to\none of the two. Please refer to the\n relevant section \nin the README of the Entando Operator to determine how the Docker registry and version of these images are calculated. \n \n \n spec.customServerImage  can be used to deploy the Docker image containing your own custom Entando App. Please\nfollow the instructions on how to  build your own image . \nThis property and the  spec.standardServerImage  are  assumed to be mutually exclusive. Only provide a\nvalue to one of the two. \n \n \n spec.dbms  is used to select the database management of choice. If left empty, a default value of  postgresql \nis assumed. The value  none  is not supported. The Entando Operator will use this value to deploy a dedicated Database instance in this namespace\nfor the EntandoApp to use. If this value matches the  spec.dbms  property\nof a previously configured  EntandoDatabaseService ,\nthe Entando App will be configured to use this service. \n \n \n spec.ingressPath  specifies the web context of the Entando App to be deployed. This is required to create a single\npath entry in the Ingress that is used to expose the Entando App. The default behaviour of Wildfly and\nJBoss EAP is to use the name of the WAR file that is deployed, but it is possible to override this in the EntandoApp\nproject using a  jboss-web.xml  file .\nIn the absence of this file, the web context would be the\nMaven artifactId of the Entando App project. It is also possible to modify this by changing the  <finalName>  element\nin the Maven  pom.xml . \n \n \n spec.clusterInfrastructureToUse  is the name of the Kubernetes Secret that provides the connection details to the\nEntandoClusterInfrastructure containining the Entando Component Repository for this App to use. This is only\nrequired if more than one EntandoClusterInfrastructure is available and this value can be omitted entirely under\nmost conditions. \n \n \n spec.keycloakSecretToUse  is used to determine which Kubernetes Secret to use when connecting to the correct\nKeycloak instance. If not specified, the default Secret  keycloak-admin-secret  will be used. This is only useful\nif you have more than one Keycloak server in your cluster. \n \n \n spec.ingressHostName  is the hostname of the Kubernetes Ingress to be created for the Entando App. Please\nensure that this is accessible using the default routing suffix of your Entando Operator Deployment or a DNS\nname previously registered with your DNS provider. Keep in mind that EntandoPlugins linked to this app will\nalso be made available on this host. \n \n \n spec.environmentVariables  is a Map of environment variables to pass to the EntandoApp Docker image. For example, this could\nbe used to provide connection details for custom datasources or message queues as discussed in the\n custom datasources tutorial . Also note that all of the\n Spring variables in an Entando project \ncan also be overridden here by specifying the equivalent SNAKE_CASE names of the dot-delimited Spring properties.\nThese parameters are applied to the container\'s environment variables after all variables have been calculated.\nIt can therefore also be used as a mechanism to override any of the default environment variables that need customization.\nKeep in mind that these parameters will be passed to each of the three containers in this Pod as environment\nvariables, and that care needs to be taken to avoid conflicting variable names. \n \n \n spec.tlsSecretName  is the name of a standard Kubernetes\n TLS Secret  that will be used for the\nresulting Ingress. This is only required if the\n globally configured TLS Secret \nfor the Operator is absent or has not been created with a wildcard hostname that supports this Keycloak instance\'s hostname. \n \n \n spec.replicas  - the number of replicas to be made available on the Deployment of this Entando App. \n \n \n spec.resourceRequirements  - the minimum and maximum  resource allocation  for the Entando App Engine container. \n \n \n spec.ecrGitSshSecretName  - a secret containing a private key file named  rsa_id  that matches a public key configured in the Git server. \n EntandoPlugin \n An Entando Plugin is a microservice that can be made available to one or more EntandoApps in the cluster. Please follow\nour instructions on using our blueprint to  build your own EntandoPlugin . The\nDeployment resulting from an EntandoPlugin is also a multi-container Pod deployment and will include the\nplugin Docker image specified and the EntandoPluginSidecar Docker Image. \n Overview \n \n Custom Resource Definition:  EntandoPlugin \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-plugin-controller \n Github Repo:  entando/entando-k8s-plugin-controller \n \n \n Deployment Details - plugin:\n \n Docker image: as provided by user \n Entando Cluster Citizen:  Plugin \n \n \n Deployment Details - EntandoPluginSidecar:\n \n Docker image:  entando/entando-plugin-sidecar \n Github Repo:  entando/entando-plugin-sidecar \n \n \n Possible Database Images:\n \n MySQL:  docker.io/centos/mysql-57-centos7 \n PostgreSQL:  docker.io/centos/postgresql-96-centos7 \n Example \n ---\nkind: "EntandoPlugin"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-plugin"\n  namespace: "my-namespace"\nspec:\n  image: your-org/your-image:4.3.2\n  securityLevel: lenient\n  ingressPath: /my-plugin\n  healthCheckPath: /actuator/health\n  dbms: "postgresql"\n  keycloakSecretToUse: some-kc-secret\n  clusterInfrastructureToUse: some-eci-secret  \n  ingressHostName: "test-app.my-routing-suffix.com"\n  roles:\n    - code: admin\n      name: Administrators\n    - code: user\n      name: Users\n  permissions: \n    - clientId: some-keycloak-client \n      role: some-admin\n    - clientId: another-keycloak-client \n      role: another-admin\n  environmentVariables: \n    - name: ENTANDO_VAR1\n      value: my-var1\n  tlsSecretName: my-tls-secret\n  replicas: 1\n Explanation of properties \n \n spec.image  is the Docker image you can provide for the plugin you want to deploy. Please follow\nour instructions on using our blueprint to  build your own EntandoPlugin .\nIf you start with the Entando Blueprint, the resulting Spring Boot application will make use of the environment variables set by the Entando Operator. \n spec.dbms  is used to select the database management of choice. The Entando Operator will use this value to deploy a dedicated Database instance in this namespace\nfor the Entando Plugin to use. If left empty or if the value is  none , it\nis assumed that the plugin in question does not require a database. If this value matches\nthe  spec.dbms  property  of a previously  configured\n EntandoDatabaseService ,\nthe Entando Plugin will be configured to use this service. \n spec.ingressPath  specifies the web context where the Entando Plugin will be made available when linked to EntandoApps.\nPlease ensure this is in sync with the  server.servlet.context-path  property set in your Spring Boot application. \n spec.clusterInfrastructureToUse  is the name of the Kubernetes Secret that provides the connection details to the\nEntandoClusterInfrastructure this Plugin will use. This is only\nrequired if more than one EntandoClusterInfrastructure is available and this value can be omitted entirely under\nmost conditions. \n spec.keycloakSecretToUse  is used to determine which Kubernetes Secret to use when connecting to the correct\nKeycloak instance. If not specified, the default Secret  keycloak-admin-secret  will be used. This is only useful\nif you have more than one Keycloak server in your cluster. \n spec.ingressHostName  is the hostname of the Kubernetes Ingress to be created for the Entando Plugin. Please\nensure that this is accessible using the default routing suffix of your Entando Operator Deployment or a DNS\nname previously registered with your DNS provider. This hostname will not be used from your Widgets that you\nimplemented for this plugin, as these widgets will use the hostname of the EntandoApp they are used from.\nThis hostname is useful for embedded web user interfaces in this plugin, such as admin user interfaces\nor diagnostic user interface. \n spec.roles  specifies the set of roles that this plugin expects. At deployment time, the Entando Operator ensures\nthat each of these roles are created on Keycloak for the Keycloak client representing this EntandoPlugin. It is\nup to the Plugin provider to ensure that Spring Security has been set up to enforce the access rules implied\nby the individual roles. Each role has a unique  code  and a more human readable   name  as a property. \n spec.permissions  specifies the set of permissions this plugin requires on other services with known Keycloak Clients.\nAt deployment time, the Entando Operator will use the service account user of this EntandoPlugin\'s Keycloak Client\nand create the necessary role bindings on the specified client id of the service to be used.\nEach permission specifies the  clientId  in Keycloak of the target service, and the  role  that this EntandoPlugin\nshould be bound to in that Keycloak client. \n spec.environmentVariables  is a Map of environment variables to pass to the EntandoPlugin Docker image.\nIt is entirely up to the plugin provider to determine the semantics of each variable. We strongly suggest for the\nplugin provider to use the standard Spring Property Resolver syntax for Spring variables, as this would allow\nany of these variables to be overridden here by specifying the equivalent SNAKE_CASE names of the dot-delimited\nSpring properties.\nThese parameters are applied to the container\'s environment variables after all variables have been calculated.\nIt can therefore also be used as a mechanism to override any of the default environment variables that need customization.\nKeep in mind that these parameters will be passed to both containers in this Pod as environment\nvariables, and that care needs to be taken to avoid conflicting variable names. \n spec.tlsSecretName  is the name of a standard Kubernetes\n TLS Secret  that will be used for the\nresulting Ingress. This is only required if the\n globally configured TLS Secret \nfor the Operator is absent or has not been created with a wildcard hostname that supports this Keycloak instance\'s hostname. \n spec.replicas  - the number of replicas to be made available on the Deployment of this Entando Plugin. \n spec.resourceRequirements  - the minimum and maximum  resource allocation  for the Entando Plugin container. \n EntandoAppPluginLink \n The EntandoAppPluginLink custom resource is created when an AppBuilder user links an EntandoPlugin to the current\nEntandoApp or deploys an EntandoPlugin for use in the current EntandoApp. The Entando Operator processes the resulting\nEntandoAppPluginLink and creates a path for the Plugin on the Ingress that exposes the EntandoApp in question. This path\nis determined by the  spec.ingressPath  property on the EntandoPlugin custom resource itself. If the EntandoPlugin\nresides in a namespace other than the namespace of the EntandoApp, the EntandoOperator creates a Kubernetes\nService in the namespace of the EntandoApp that simply delegates to the Service in the namespace of the EntandoPlugin. \n Overview \n \n Custom Resource Definition:  EntandoAppPluginLink \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-app-plugin-link-controller \n Github Repo:  entando/entando-k8s-app-plugin-link-controller \n Example \n ---\nkind: "EntandoAppPluginLink"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-link"\n  namespace: "my-namespace"\nspec:\n  entandoAppName: my-app\n  entandoAppNamespace: my-namespace\n  entandoPluginName: my-app\n  entandoPluginNamespace: my-namespace\n Explanation of properties \n \n spec.entandoAppName  specifies the name of the EntandoApp that requires the plugin, found in  EntandoApp.metadata.name \n spec.entandoAppNamespace  specifies the namespace of the EntandoApp that requires the plugin, found in  EntandoApp.metadata.namespace \n spec.entandoPluginName  specifies the name of the EntandoApp that requires the plugin, found in  EntandoPlugin.metadata.name \n spec.entandoPluginNamespace  specifies the namespace of the EntandoApp that requires the plugin, found in  EntandoPlugin.metadata.namespace \n EntandoDatabaseService \n By default, the Entando Operator deploys one of either the MySQL or PostgreSQL database Docker images for every custom\nresource that requires a database. Many customers may, however, have existing infrastructure for their databases which\nthey may want to leverage. The EntandoDatabaseService custom resource allows customers to deploy a Service that points\nto an external database. When deploying one of the Entando Custom Resources that require a database, the Entando\nOperator will look for EntandoDatabases in the same namespace. If it finds one with the same  spec.dbms  setting\nas the database required by the custom resource, it will create a dedicated schema/username/password combination\nfor the custom resource and point the deployment emanating from Custom Resources to this external database. \n \n Custom Resource Definition:  EntandoDatabaseService \n Example \n ---\nkind: "EntandoDatabaseService"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-database-service"\n  namespace: "my-namespace"\nspec:\n  dbms: "osracle"\n  host: 10.0.12.41\n  port: 1521\n  databaseName: mydb \n  tablespace: \n  secretName: some-secret\n  jdbcParameters:\n    maxStatements: 300 \n    loginTimeout: 180\n Explanation of properties \n \n spec.dbms  is used to select the database management of choice if this value matches the  spec.dbms  property\nof the Entando custom resource that will use it. Valid values are  oracle ,  postgresql  and  mysql . \n spec.host  can either be a valid IPv4 address or a hostname. Where an IP address is provided, the Entando Operator\nwill create a Kubernetes Service with an associated EndPoints resource to allow for routing to this address. Where\na hostname is provided, the Entando Operator will simply create a Kubernetes Service of type  cname . \n spec.port  is the port that the external database service is running on. This value is optional in which case we will\nuse the default port for the DBMS vendor in question. \n spec.databaseName  is the name of the database that the Entando Operator should be creating schemas in. This property\nis only for use with PostgreSQL and Oracle, as MySQL doesn\'t distinguish between schemas and databases. \n spec.tablespace  is only required for Oracle so that Schemas can be created in different tablespaces. \n spec.secretName  should be the name ( Secret.metadata.name ) of a Kubernetes Secret in the same namespace that has\na  username  key and a  password  key to provide the Entando Operator with the necessary access and permissions\nto create Schemas and users on the database in question. \n spec.jdbcParameters  is a map of name/value pairs that will be appended to the JDBC connection string to allow for\nfurther customization of the actual connection to the database. \n EntandoCompositeApp \n The EntandoCompositeApp Custom Resource can be used to package a collection of Entando Core Custom Resources in a\nsingle YAML file for sequential deployment. Keep in mind that one can already use standard YAML syntax to package\na set of Kubernetes resources in a single file, separating each resource with a triple dash ( --- ). The purpose\nof this custom resource is therefore specifically to ensure that the deployment of the previous \'component\' has\ncompleted, and that  the resulting Pod is up and running before commencing deploying on the \'component\'. \n The primary use case of this custom resource is to package a full Entando App and all its supporting service and\nplugins for easy installation as is often required for demos and POCs. Creating this kind of dependency for typical\nproduction deployments is not advised, as it will inevitably result in a violation of pipeline isolation. The\nmore commonly recommended approach is for your Entando Apps and Plugins to be fully deployable in isolation. Use this\ncustom resource with care. \n Overview \n \n Custom Resource Definition:  EntandoCompositeApp \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-composite-app-controller \n Github Repo:  entando/entando-k8s-composite-app-controller \n Example \n ---\nkind: "EntandoCompositeApp"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-composite-app"\n  namespace: "my-namespace"\nspec:\n  components:\n    - kind: "EntandoKeycloakServer"\n         metadata:\n           name: "my-kc"\n         spec:\n           dbms: postgresql\n           isDefault: true\n           replicas: 1\n       - kind: "EntandoClusterInfrastructure"\n         metadata:\n           name: "my-eci"\n         spec:\n           dbms: postgresql\n           replicas: 1\n           isDefault: true\n       - kind: "EntandoApp"\n         metadata:\n           name: "my-app"\n         spec:\n           dbms: postgresql\n           replicas: 1\n           standardServerImage: wildfly\n           ingressPath: /entando-de-app\n       - kind: "EntandoPlugin"\n         metadata:\n           name: "my-pda"\n         spec:\n           image: "docker.io/entando/entando-process-driven-plugin:latest"\n           replicas: 1\n           dbms: "mysql"\n Explanation of properties \n \n spec.components  specifies the list of Entando Core Custom Resources to be deployed  in sequence . Please note\nthat only the Entando Custom Resources discussed in this section can be used in this list. Custom resources\nrelated to the Entando Component Repository never result in actual deployments on the Kubernetes cluster and\ntherefore do not need to be specified in any sequence. You can use the normal triple dash YAML notation to\ninclude them in the same YAML file. \n \n'},{title:"The Entando Operator",frontmatter:{redirectFrom:"/v6.3.2/docs/concepts/operator-intro.html"},regularPath:"/v6.3.2/docs/consume/operator-intro.html",relativePath:"v6.3.2/docs/consume/operator-intro.md",key:"v-cca1d5a0",path:"/v6.3.2/docs/consume/operator-intro.html",headers:[{level:2,title:"Installation Scope Options",slug:"installation-scope-options"},{level:3,title:"When to use Cluster Scoped Deployments",slug:"when-to-use-cluster-scoped-deployments"},{level:3,title:"When to use Namespace Scoped Deployments",slug:"when-to-use-namespace-scoped-deployments"},{level:2,title:"TLS Secret Creation",slug:"tls-secret-creation"},{level:2,title:"Database Deployment",slug:"database-deployment"},{level:2,title:"Ingress Path Generation",slug:"ingress-path-generation"}],lastUpdated:"2/8/2022, 9:40:35 AM",lastUpdatedTimestamp:1644331235e3,content:" The Entando Operator \n The Entando Operator processes the custom resources in Kubernetes that represent the different  components of an Entando application .\nThe goal of the operator is to provide automation and a set of default configuration options to simplify and accelerate the deployment of an Entando application. \n The sections below provide details and assumptions that the operator makes when deploying Entando Custom Resources. If you're using OpenShift these\nsections will provide details on how to configure your deployment via the Operator Hub. \n For details on the individual custom resources and their configuration check out the  custom resources documentation . \n Installation Scope Options \n The Entando Operator can be installed in one of two modes. Either cluster scoped or namespace scoped. In a cluster scoped deployment the operator will have\nvisibility across the cluster and will manage all of the Entando applications in the Kubernetes cluster. In a namespace scoped deployment the operator\nwill only have visibility to the namespace where it is deployed and will manage only the components in that namespace. \n When installing the operator via OpenShift look for the  Installation Mode  option to select the scoping for the operator. \n When to use Cluster Scoped Deployments \n When choosing how to deploy your operator there are no right or wrong answers. Think about the deployment that best fits your goals and team. Here are some items to think about. \n \n Cluster scoped deployments are common in production clusters and in environments with strong operational support and controls. \n A cluster scoped deployment can saves resources When you want to optimize resource consumption and share Kubernetes infrastructure. \n When you are planning to centralize and share other infrastructure resources like Keycloak and databases a cluster scoped deployment can fit into the same management processes.\n \n Sharing infrastructure resources is a recommended approach for medium or large teams and the operator can be treated like other infrastructure services. \n \n \n In some cases security requirements will require that the permissions required for the operator are managed separately from the deployed applications. A cluster scoped deployment isolates the operator permissions in a separate namespace. \n Cluster scoped deployments can simplify the deployment of an Entando app by developers or end users because they have fewer resources to manage \n When to use Namespace Scoped Deployments \n When choosing how to deploy your operator there are no right or wrong answers. Think about the deployment that best fits your goals and team. Here are some items to think about. \n \n Namespace scoped deployments are common in dev clusters. Or in clusters where application naemspaces come and go frequently \n Namespace scoped deployments are useful in scenarios where you plan to, or could have, many different versions of Entando \n Namespace scoped deployments give your teams complete team autonomy and the ability to create and destroy applications \n When teams are small and self managing from an operational perspective a namespace scoped deployment is a simpler architecture \n If you plan to have a small number of applications deployed in the cluster a namespace scoped deployment can be easier to manage \n \n Click here for tutorials and instructions for deploying via operator hub \n TLS Secret Creation \n When configuring and deploying Entando via the operator you will be asked to provide a secret for some of the components in the architecture. A few things to be aware of when creating and configuring a secret: \n \n The secret is assumed to be in the same namespace as the component being created. \n This secret is expected to have a private key, and a certificate for the hostname (or a wildcard cert) that the service\nwill be exposed on. \n Refer to the 'ingressHostname' property in the custom resource for more information on how the hostname is\ndetermined. \n If a secret isn't provided the Entando Operator will evaluate the value of the  ENTANDO_PATH_TO_TLS_KEYPAIR  which is\nexpected to contain two files: tls.key and tls.crt.\n \n If a key pair is found in the folder specified, it will revert to the keypair found. \n If a key pair is not found the Entando Operator will evaluate the value of the  ENTANDO_USE_AUTO_CERT_GENERATION .\nIf that property is set to  true  the Entando Operator will assume that the cluster has been configured with a valid CA and leave it to\nthe Ingress controller to generate its own certificates. \n \n \n \n Click here for tutorials on creating secrets and setting up TLS in your Entando Apps. \n Database Deployment \n Some Entando components include the ability to select a database management system (DBMS) when deploying the component. \n \n \n The DBMS field in Entando Custom Resources can be one of mysql, oracle, postgresql or embedded. \n \n IMPORTANT!  -- If embedded is selected for a component only 1 replica for the component can be created. \n IMPORTANT!  -- Oracle instances are not supported for automatic deployment in a container. You must create an Oracle instance or use an existing instance and configure it as an  external database  for your Entando app \n \n \n \n If an EntandoDatabaseService has been deployed in the component's namespace, and the DBMS specified on this EntandoDatabaseService\nis the same as the DBMS specified on this EntandoApp, the Entando Operator will create dedicated\nschemas (in the case of PostgreSQL or Oracle), or databases in the case of MySQL. \n \n If a matching EntandoDatabaseService does not exist in this namespace, the Entando Operator\nwill automatically deploy the appropriate container to host the DBMS specified. This last option is not\nyet supported for Oracle. \n \n \n \n For an EntandoApp three schemas/database will be created: the Entando Port DB, tne Entando Serv DB and a database for\nthe Entando Component Manager. \n \n If the Port and Serv schemas/databases are empty, the Entando Operator  will use the underlying Entando App to populate these databases with the data backup available in the standard backup path in the WAR deployment. \n In scenarios where the EntandoApp needs to connect to an existing database that is fully managed\nby the customer, it is best to setup the standard database connection variables using the\n spec.environmentVariables  property and set this property to 'none'. This will skip any database\npreparations steps in the deployment. \n \n \n \n When deploying a component the operator will evaluate the spec and if it supports the standard  spec.dbms \nproperty, the value of this property will be given to the component's  spec.dbms . Please consult\nthe documentation for each component's CRD to determine how each Entando resource uses the dbms (if any). \n Ingress Path Generation \n When deploying an Entando Custom Resource that uses an Ingress path: \n \n The  ingressHostName  property defines the host path that will be used to access this\nservice from outside the cluster. The Entando Operator will\ncreate an ingress reflecting this hostname, and expose the resource at its default path.\n \n IMPORTANT!  -- If omitted, the Entando Operator will automatically generate a hostname\nusing the value of the ENTANDO_DEFAULT_ROUTING_SUFFIX environment variable that the Entando Operator was\nconfigured with. It will prefix the name and namespace of the EntandoKeycloakServer to this default routing suffix. \n \n \n \n"},{title:"Accessing Entando APIs",frontmatter:{sidebarDepth:2,redirectFrom:"/v6.3.2/docs/reference/entando-apis.html"},regularPath:"/v6.3.2/docs/consume/entando-apis.html",relativePath:"v6.3.2/docs/consume/entando-apis.md",key:"v-a482b5a0",path:"/v6.3.2/docs/consume/entando-apis.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:3,title:"Enable or disable the Swagger UI in a running container",slug:"enable-or-disable-the-swagger-ui-in-a-running-container"},{level:2,title:"How to find your client secret",slug:"how-to-find-your-client-secret"},{level:2,title:"Setup in local environment",slug:"setup-in-local-environment"},{level:3,title:"Configure Keycloak",slug:"configure-keycloak"},{level:3,title:"Start the Entando Application",slug:"start-the-entando-application"},{level:2,title:"APIs Overview",slug:"apis-overview"},{level:3,title:"API structure",slug:"api-structure"},{level:3,title:"Models",slug:"models"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"2/8/2022, 9:40:35 AM",lastUpdatedTimestamp:1644331235e3,content:" Accessing Entando APIs \n Overview \n Entando includes the Swagger UI in a quickstart environment and is reachable at  /entando-de-app/api/swagger-ui.html : \n http://[your-host-name]/entando-de-app/api/swagger-ui.html\n Enable or disable the Swagger UI in a running container \n The Swagger UI can be enabled or disabled in a running container by modifying the SPRING_PROFILES_ACTIVE environment variable for the entando-de-app container. \n \n Edit the deployment. The name may be different outside of a quickstart environment. \n \n sudo kubectl -n entando edit deployment/quickstart-server-deployment\n \n \n \n (Optional) Scale the deployment  spec.replicas  to 0 before updating the deployment. This is necessary if you're using an in-memory database, e.g. the default quickstart configuration, and will prevent database errors that can happen on an immediate restart after the profile is changed. Save the deployment to apply the change. \n \n \n Find the entando-de-app env variables section under  spec.template.spec.containers.env[image: entando-de-app] \n \n \n 4a. To enable the swagger UI, add the SPRING_PROFILES_ACTIVE environment variable, if it's missing, or add  swagger  to its comma-delimited list. \n         - name: SPRING_PROFILES_ACTIVE\n          value: default,swagger\n \n 4b. To disable the swagger UI, remove  swagger  from the value. \n \n \n (Optional) Reset the deployment  spec.replicas  back to 1. \n \n \n Save the deployment to apply the change. \n How to find your client secret \n You'll need your client credentials to execute the Entando APIs. \n \n \n Login into your Keycloak instance \n \n \n Go to  Administration → Clients \n \n \n Select the desired client (e.g. in a quickstart environment this is  quickstart-server ) \n \n \n Click on the  Credentials  tab to get the secret \n Setup in local environment \n You may prefer to run a local standalone Entando application for some tasks. You'll need Java 11, maven, and Keycloak for authentication. See  these instructions  to setup a standalone Keycloak. \n Configure Keycloak \n Configure your Keycloak client in order to support Swagger UI. A quickstart environment has this pre-configured. \n \n \n Login to your Keycloak instance \n \n \n Access the Administration console \n \n \n Click on  Clients  on the left bar and select your client (e.g.  quickstart-server ) \n \n \n Update the following values under  Settings : \n \n Set  Valid Redirect URIs  to  http://localhost:[your port]/entando-de-app/*  or  *  to allow all redirect URIs. \n Set  Web Origins  to  http://localhost:[your port]  or  *  to accept all origins. \n Start the Entando Application \n \n \n Clone the Entando reference application: \n git clone https://github.com/entando/entando-de-app\n \n \n \n Start the application with the following options: \n \n Enable the Swagger profile via  -Dspring.profiles.active=swagger \n Enable the Keycloak profile via  -Pkeycloak \n Configure the application connection to Keycloak itself. For simplicity this uses the same client credentials you'll use to try out the APIs.\n \n Set  -Dkeycloak.auth.url  to your Keycloak endpoint (including  /auth ), e.g.  -Dkeycloak.auth.url=http://my-keycloak-server/auth \n Set  -Dkeycloak.client.id  to your client id, e.g.  -Dkeycloak.client.id=quickstart-server \n Set  -Dkeycloak.client.secret  to your client secret, e.g.  -Dkeycloak.client.secret=my-secret . See  How to find your client secret  above. \n \n \n (Optional) Set -Djetty.port=8085  if the default port 8080 is already in use. \n (Optional) To skip the docker steps (or if you don't have docker installed/running), add  -DskipDocker=true \n \n Here's a full example: \n mvn clean package jetty:run-war -Pjetty-local -Pderby -Pkeycloak -Dspring.profiles.active=swagger -Djetty.port=8085 -Dorg.slf4j.simpleLogger.log.org.eclipse.jetty.annotations.AnnotationParser=error -Dkeycloak.auth.url=http://my-keycloak-host/auth -Dkeycloak.client.id=quickstart-server -Dkeycloak.client.secret=my-client-secret -DskipDocker=true\n \n \n \n Wait for the application to start. \n [INFO] Started ServerConnector@1355c8be{HTTP/1.1, (http/1.1)}{0.0.0.0:8085}\n[INFO] Started @66257ms\n[INFO] Started Jetty Server\n \n \n \n Navigate to the Swagger UI in a browser at  /entando-de-app/api/swagger-ui.html \n  http://localhost:[your port]/entando-de-app/api/swagger-ui.html\n APIs Overview \n The Entando core exposes REST APIs for every action that can be taken in\nthe App Builder environment. For example, you can use\nthese APIs to create pages, create page templates or to add widgets to\npages. The APIs can be used to support automation, testing, or\nintegrations with external systems. \n API structure \n All of the APIs share a common top level structure. Each response will\ncontain a top level entry for  errors ,  metadata , and  payload . \n The  errors  will always contain code and a message string indicating an\nerror condition in the request. The  metadata  section is used for\npaging, sorting, filtering and data that is distinct from the body. The\nbody of each response is included in the  payload  section of the\nresponse and varies according to each API. \n Models \n All of the model classes returned by the Entando core are annotated so that the model definition is included in the Swagger documentation. At the bottom of the Swagger page all of the model classes returned by the API endpoints can be found. \n Tutorial \n \n \n Access your application Swagger UI as discussed above \n \n \n Click on the  Authorize  button in the upper right corner \n \n \n Enter the client id and client secret in the open window and click  Authorize \n \n \n If you are redirected to the Entando login page, log in with your credentials (default are  admin / adminadmin ) \n \n \n You will be redirected to the Swagger UI page, now authenticated \n \n \n Use the  Try it out  button on the APIs \n \n \n Scroll to  widget-controller \n \n \n Select the blue GET row \n \n \n Select  Try it out \n \n \n Look at the results in the window. You should see a Server response with Code 200 and full response body. \n \n \n \n \n"},{title:"Customizing the Entando Component Generator",frontmatter:{redirectFrom:"/v6.3.2/docs/component-generator/component-gen-customize.html"},regularPath:"/v6.3.2/docs/create/component-gen-customize.html",relativePath:"v6.3.2/docs/create/component-gen-customize.md",key:"v-42f24850",path:"/v6.3.2/docs/create/component-gen-customize.html",lastUpdated:"2/16/2022, 9:07:34 AM",lastUpdatedTimestamp:1645020454e3,content:" Customizing the Entando Component Generator \n The Entando Component Generator is an instance of a JHipster blueprint that can be extended to match your team's needs and requirements. If you're interested in extending the blueprint or creating your own blueprint, contact us on the  Entando Forum  or  Community Slack  and we'll help you get started. \n The source for the Entando blueprint can be found  here . \n To learn more about creating blueprints and to see other blueprints available from JHipster checkout the  blueprint documentation  or visit  JHipster  for an overview. \n"},{title:"Entando Component Generator",frontmatter:{redirectFrom:"/v6.3.2/docs/component-generator/component-gen-overview.html"},regularPath:"/v6.3.2/docs/create/component-gen-overview.html",relativePath:"v6.3.2/docs/create/component-gen-overview.md",key:"v-a0fbe934",path:"/v6.3.2/docs/create/component-gen-overview.html",headers:[{level:2,title:"Objectives",slug:"objectives"},{level:2,title:"Generated Component Flow",slug:"generated-component-flow"}],lastUpdated:"2/8/2022, 9:40:35 AM",lastUpdatedTimestamp:1644331235e3,content:" Entando Component Generator \n The Entando Component Generator powered by JHipster is a tool that gives developers the ability to quickly generate Entando components that can be used to extend an Entando Application. \n The component generator takes advantage of the concept of  JHipster blueprints  to provide powerful templating and standard generation patterns. \n Objectives \n The component generator has two main objectives \n \n \n Accelerate development \n \n Automate the creation of microservices and micro frontends with code that runs without changes. Start from running software. \n Code is meant to be developed on and changed by developers. Ready for customization. \n Using standard tools, technologies, and patterns that can be consumed by developers who are not familiar with the underlying blueprint \n \n \n \n Standardize microservice creation and technology choices \n \n Encode business standards for networking, monitoring, build tools, and distribution into a blueprint to ensure that developers are starting from a technical point that matches your teams requirements \n Ensure code follows standards and practices of your teams including code formatting, testing tools, static analysis tools, package structures, and other rules specific to your organization \n Enable teams to quickly recognize and adopt code from system integrators and other third parties because the patterns and standards are encoded in the starting point of your applications \n Generated Component Flow \n This section provides an overview of the component generation process. If you want to jump into the code and a tutorial start here:  Entando Component Generator Tutorial \n \n \n \n Create components \n \n The Component Generator will create a Spring Boot microservice and optionally will create React micro frontends for entities that you add to your project \n The microservice and generated micro frontends are runnable out of the box and preconfigured to connect to  Entando Identity Management \n The code is meant to be edited and enhanced by developers. JHipster provides interactive updates and merges if you need to re-run the generator or add new functionality via JHipster \n The microservice includes liquibase and integrated data mocking if you want to generate data in your API calls \n \n \n \n Define bundle and deploy assets \n \n The Entando blueprint includes scripts and tools to automatically generate a bundle ready for deployment to the ECR. The bundle will include your microservice, generated microfrontends, and any microfrontends that you have created manually under the  ui  folder \n The generated Spring Boot microservice can be built and deployed to a Docker registry using the provided maven Jib plugin \n Generated bundles can be pushed to a git repository of the users choice \n \n \n \n Deploy bundles to  Entando Component Repository (ECR) \n \n Once your Docker images are pushed to your registry and your bundle is available in Git you can generate an Entando bundle descriptor and push the bundles to the ECR \n The bundles can be versioned and updated using tags in the git repository \n \n \n \n Install in Entando Apps \n \n Once the bundles are in the ECR they are available for deployment in any Entando application that has access to the ECR in the cluster \n \n \n \n"},{title:"Entando Blueprint Features",frontmatter:{redirectFrom:"/v6.3.2/tutorials/micro-frontends/generate-micro-frontends-from-a-database-entity/"},regularPath:"/v6.3.2/docs/create/blueprint-features.html",relativePath:"v6.3.2/docs/create/blueprint-features.md",key:"v-004ce474",path:"/v6.3.2/docs/create/blueprint-features.html",headers:[{level:2,title:"The Features:",slug:"the-features"},{level:2,title:"Premade Widgets",slug:"premade-widgets"},{level:3,title:"Authentication",slug:"authentication"},{level:3,title:"Custom events",slug:"custom-events"},{level:3,title:"Tests and mocks",slug:"tests-and-mocks"},{level:3,title:"PropTypes",slug:"proptypes"},{level:3,title:"Fetching data",slug:"fetching-data"},{level:2,title:"Form widget",slug:"form-widget"}],lastUpdated:"2/8/2022, 9:40:35 AM",lastUpdatedTimestamp:1644331235e3,content:" Entando Blueprint Features \n The Entando Blueprint makes it easier and faster to customize your application by generating controllers, repositories, services, and micro frontends for your entity. It means generating those project files in minutes, simply by answering questions that define the parameters of your application. \n The Entando Blueprint uses JHipster technology based on Embedded JavaScript (EJS), a templating language that provides powerful constructs for large scale file generation. \n The Features: \n \n Backend with Spring Boot\n \n Data modeling \n JHipster Design Language (JDL) support \n Keycloak integration \n Liquibase integration for schema upgrade \n Preconfigured Cross-Origin Resource Sharing (CORS) settings \n Profiles (dev, prod) \n Swagger/OpenAPI frontend \n \n \n Frontend with React\n \n .env profiles \n Localization \n Keycloak integration \n \n \n \n For more information: \n \n Install  JHipster Entando Blueprint \n Try implementing an Entando Blueprint--  Create microservices and micro frontents \n Premade Widgets \n When you create an entity using the Entando Blueprint, it generates a few\npremade widgets. Each will be reviewed below. \n \n Authentication \n Custom events \n Tests and mocks \n PropTypes \n Fetching data \n Form widget \n \n We will be using  Conference  as an entity name for the example below. \n What the widgets have in  common : \n \n \n Each widget contains a README file that helps with the setup. \n \n \n All generated widgets are web components created using Custom Elements\nAPI. \n \n \n Each widget is displayed using the custom element tag. For example, inside the\ndetails widget folder  conference/detailsWidget/public/index.html , you\ncan find\n conference-details id=\"1\" override-edit-handler hide-edit-button /> .\nThe element  <conference-details />  is defined in the component entry\npoint at\n conference/detailsWidget/src/custom-elements/ConferenceDetailsElement.js . \n \n \n \n Note \n Custom element names require a hyphen like  conference-details  (kebab-case)--they cannot be single words. \n \n For more information about web components, custom elements and micro\nfrontends, refer to  Create a React micro frontend widget . \n Authentication \n If a widget requires authentication, the component is wrapped in\n KeycloakContext.Provider  and the Keycloak object is fetched from the\n window.entando.keycloak  variable. Entando uses Keycloak as the\nauthentication provider, but you can add any provider as needed. \n ReactDOM.render(\n  <KeycloakContext.Provider value={this.keycloak}>\n    <StylesProvider jss={this.jss}>\n      <ThemeProvider theme={this.muiTheme}>{FormContainer}</ThemeProvider>\n    </StylesProvider>\n  </KeycloakContext.Provider>,\n  this.mountPoint\n);\n \n For more information about the authentication process, please refer\nto the  Authentication section . \n Custom events \n All widgets rely on custom events for communication.  That is why each widget contains custom event creation and removal, along with the event listener creation.  Note that when an event listener is created, it should be when\nthe element is no longer needed. It should be created in the custom\nelement’s  disconnectedCallback()  function. \n To add more event listeners, add the event types to\n INPUT_EVENT_TYPES  object at\n detailsWidget/src/custom-elements/widgetEventTypes.js , which adds\nit to the listener list. To remove the event, simply remove the element from the list. \n For more information about custom events and widget communication,\nplease refer to the section on  Widget communication . \n Tests and mocks \n Each widget has tests written for it. Entando uses\n react-testing-library , but developers are free to upgrade and use any\ntool desired. Tests and mocks are at  detailsWidget/src/components/ . \n PropTypes \n PropTypes for data used across several components are shared. You can\nsee and modify them at  detailsWidget/src/components/ . This way you can\navoid repeating the same propTypes in each component by importing them. \n import React from 'react';\nimport conferenceType from 'components/__types__/conference';\n\nconst ConferenceDetails = props => {\n  // ...\n};\n\nConferenceDetails.propTypes = {\n  conference: conferenceType,\n  t: PropTypes.func.isRequired,\n};\n\nexport default ConferenceDetails;\n Fetching data \n For data fetching from widgets, use Fetch API. You can find the functions for\nfetching data at  detailsWidget/src/api , in different files for\ndifferent contexts. \n Form widget \n For displaying forms within a widget, use\n Formik  which helps with form state\nmanagement. For data validation, use\n Yup . \n"},{title:"Component Generation Technologies",frontmatter:{redirectFrom:"/v6.3.2/docs/component-generator/component-gen-tech.html"},regularPath:"/v6.3.2/docs/create/component-gen-tech.html",relativePath:"v6.3.2/docs/create/component-gen-tech.md",key:"v-35511046",path:"/v6.3.2/docs/create/component-gen-tech.html",lastUpdated:"2/8/2022, 9:40:35 AM",lastUpdatedTimestamp:1644331235e3,content:" Component Generation Technologies \n When generating a microservice using the Entando Component Generator there are a number of technical choices that need to be made \n \n Microservice code\n \n The Component Generator currently only supports the generation of Spring Boot microservices but will support the generation of Quarkus based services soon. \n If you're interested in using Quarkus in your Entando app, contact us on the  Forum  or  Community Slack  and we'll help you get started. \n If you're considering non-Java based microservices,  here is a definition of an Entando plugin , including information on the runtime contract required to use them. \n \n \n Database type\n \n Entando recommends standardizing your choice of database to simplify operational maintenance but you do have the ability to use different databases for different microservices if you choose. \n Supported choices are none, MySQL, and Postgres. Enterprise customers can choose Oracle but should contact Entando Support for details. \n \n \n Development databases\n \n You can choose to utilize a full RDBMS or developers can utilize lightweight in memory or on disk databases with h2. \n \n \n Caching implementation\n \n When generating a microservice you will be presented with the type of cache to inject into the services. It is recommended that this is a standard choice for all of the microservices in your application but can be customized on a per service basis if desired. \n \n \n Build system\n \n Determines the java build tool to use when building your services \n Supports maven or gradle \n \n \n Other technologies\n \n Users of the component generator can also decide to use other technologies from JHipster or from the JHipster marketplace. \n There are many powerful technologies in the marketplace but it is up to the developer to integrate any choices from the marketplace into their Entando application. Entando doesn't provide any direct support for marketplace tech choices. \n \n \n Micro frontends\n \n Users can optionally choose to generate micro frontends for entities generated via the blueprint. \n The Entando Component Generator only provides micro frontends in React from the generation flow but developers can create and bundle micro frontends using other technologies as well. \n \n \n \n If you want to try out these choices follow the tutorial on  creating Entando microservices and micro frontends using the component generator . \n"},{title:"Filtering bundles",frontmatter:{redirectFrom:"/v6.3.2/docs/ecr/ecr-bundle-filters.html"},regularPath:"/v6.3.2/docs/curate/ecr-bundle-filters.html",relativePath:"v6.3.2/docs/curate/ecr-bundle-filters.md",key:"v-73954b74",path:"/v6.3.2/docs/curate/ecr-bundle-filters.html",headers:[{level:2,title:"Filtering bundles by component",slug:"filtering-bundles-by-component"},{level:3,title:"Supported labels keys are:",slug:"supported-labels-keys-are"},{level:3,title:"Example",slug:"example"},{level:2,title:"Filtering bundles by status",slug:"filtering-bundles-by-status"},{level:2,title:"Filtering bundles by textual search",slug:"filtering-bundles-by-textual-search"},{level:2,title:"Mixing search criteria",slug:"mixing-search-criteria"}],lastUpdated:"2/8/2022, 9:40:35 AM",lastUpdatedTimestamp:1644331235e3,content:' Filtering bundles \n ECR bundles are filterable by component, by status or by textual research. \n Filtering bundles by component \n ECR bundles are filterable by component from App Builder user interface. \n \n Behind the scenes, filtering is done using the label-based filtering provided out of the box from Kubernetes. \n To enable filtering of a bundle, the custom-resource representing the bundle on the Entando Cluster needs to contain the correct labels. An important note on the values to add the  labels  field, even if to correctly define a label in a k8s resource both the key and the value are required, from an Entando point of view only the key part of the label is used for filtering. The value could be set to anything, but our reccomendation is to use  "true"  for clarity and simplicity. \n Supported labels keys are: \n \n \n \n \n \n \n \n Label entry \n Description \n \n \n \n \n widget: "true" \n The bundle contains one or more microfrontends (widgets)  \n \n \n plugin: "true" \n The bundle contains one or more microservices (plugins) \n \n \n fragment: "true" \n The bundle contains one or more fragments \n \n \n pageTemplate: "true" \n The bundle contains one or more page templates \n \n \n contentType: "true" \n The bundle contains one or more content types \n \n \n contentTemplate: "true" \n The bundle contains one or more content templates \n Example \n Here is an example of the metadata for a ecr bundle containg micro-frontends, some microservices and page templates \n apiVersion: entando.org/v1\nkind: EntandoDeBundle\nmetadata:\n  name: demo-bundle\n  labels:\n    widget: "true"\n    plugin: "true"\n    pageTemplate: "true"\nspec:\n  details:\n  ...\n Filtering bundles by status \n ECR bundles are filterable by status from App Builder user interface. \n \n You can choose to see the full list of the bundles available in Kubernetes cluster by selecting the  Explore  tab, or the list of the currently installed bundles by clicking on the  Installed  tab. \n Filtering bundles by textual search \n You can search for bundles containing some keywords by executing a textual search. \n \n You can open the menu on the left to select which field to target. \n If you are creating a new bundle, keep in mind the textual search is performed against data extracted from the bundle CRD file. \n Mixing search criteria \n You can mix all previous search criteria to refine the scope of your search as you want.\nFor example, you could search for all available bundles ( Explore  tab) that contain  Page Templates  components\n(using the checkboxes) and the word  Login  in their name (using the textual search). \n'},{title:"How to customize bundle info shown in Entando App Builder",frontmatter:{redirectFrom:"/v6.3.2/docs/ecr/ecr-bundle-presentation-config.html"},regularPath:"/v6.3.2/docs/curate/ecr-bundle-presentation-config.html",relativePath:"v6.3.2/docs/curate/ecr-bundle-presentation-config.md",key:"v-f24b9bf4",path:"/v6.3.2/docs/curate/ecr-bundle-presentation-config.html",lastUpdated:"2/8/2022, 9:40:35 AM",lastUpdatedTimestamp:1644331235e3,content:" How to customize bundle info shown in Entando App Builder \n \n In the image above you can see an example of a bundle as is displayed in the ECR user interface inside the Entando App Builder. \n The corresponding custom-resource file on Kubernetes is similar to this: \n apiVersion: entando.org/v1\nkind: EntandoDeBundle\nmetadata:\n  name: simple-entando-bundle\nspec:\n  details:\n    name: \"Entando Bundle\"\n    description: An example of an Entando bundle\n    dist-tags:\n      latest: v0.0.1\n    time:\n      created: '2020-05-20T15:59:21.946Z'\n      modified: '2020-05-20T15:59:21.946Z'\n      v0.0.1: '2020-05-20T15:59:21.946Z'\n    versions:\n      - v0.0.1\n    keywords:\n      - entando6\n    author: Entando\n    thumbnail: >-\n      data:image/jpeg;base64,....\n  tags:\n....\n \n In order to change the UI elements, you need to update the custom-resource in accordance with this table \n \n \n \n Field \n UI Element \n \n \n \n \n spec.details.name \n Set the bundle title \n \n \n spec.details.description \n Set the bundle description (only visible in the list presentation format) \n \n \n spec.details.thumbnail \n Set the bundle thumbnail, expressed as a base64 encoded string \n \n \n spec.details.dist-tags.latest \n Set what's the latest version of the bundle \n \n \n \n"},{title:"Bundle and Component Descriptors",frontmatter:{sidebarDepth:2,redirectFrom:"/v6.3.2/docs/ecr/ecr-bundle-details.html"},regularPath:"/v6.3.2/docs/curate/ecr-bundle-details.html",relativePath:"v6.3.2/docs/curate/ecr-bundle-details.md",key:"v-64e64a66",path:"/v6.3.2/docs/curate/ecr-bundle-details.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:3,title:"Bundle Conventions",slug:"bundle-conventions"},{level:3,title:"Bundle Descriptor",slug:"bundle-descriptor"},{level:2,title:"Plugin",slug:"plugin"},{level:3,title:"Kubernetes Pod Names",slug:"kubernetes-pod-names"},{level:3,title:"Permissions",slug:"permissions"},{level:2,title:"Widget",slug:"widget"},{level:2,title:"Fragment",slug:"fragment"},{level:2,title:"Page Template",slug:"page-template"},{level:2,title:"Page",slug:"page"},{level:2,title:"CMS Asset",slug:"cms-asset"},{level:2,title:"Content Template",slug:"content-template"},{level:2,title:"Content Type",slug:"content-type"},{level:2,title:"Content",slug:"content"},{level:2,title:"Categories",slug:"categories"},{level:2,title:"Groups",slug:"groups"},{level:2,title:"Labels",slug:"labels"},{level:2,title:"Languages",slug:"languages"},{level:2,title:"Static Resources",slug:"static-resources"}],lastUpdated:"2/28/2022, 1:53:09 PM",lastUpdatedTimestamp:1646074389e3,content:' Bundle and Component Descriptors \n Overview \n The Entando Component Manager reads the  descriptor.yaml  file from the root of the bundle package and uses it to install any components and resources included in the bundle. \n The different component types are shown below: \n \n Here is the basic bundle structure: \n .\n├ descriptor.yaml\n├ resources/\n│ └ ...\n└ ... (folders reported in descriptor.yaml file)\n Bundle Conventions \n \n \n The bundle descriptor file must be named  descriptor.yaml  or the bundle will not be recognized. \n \n \n Static resources should be placed in a  resources  folder. They are not explicitly referenced in the  descriptor.yaml  file itself. \n Bundle Descriptor \n The bundle descriptor YAML file aggregates all included components and has the structure shown below. Note that the Page Template feature is  pageModels  and the Content Template feature is  contentModels . \n \n Warning \n The bundle descriptor file must be named  descriptor.yaml \n \n descriptor.yaml \n code: survey_bundle # The bundle ID\ndescription: This is the survey bundle # The description of the bundle\n\ncomponents: # All components are listed here.\nOptional. Use if the component requires deployment\n  plugins:\n    - folder/you/want/my_plugin_descriptor.yaml\n    - folder/you/want/another_plugin_descriptor.yaml\nTo create Widgets, add references to the descriptor files \n  widgets:\n    - widgets/my_widget_descriptor.yaml\n    - widgets/another_widget_descriptor.yaml\nTo create Fragments, add references to the descriptor files \n  fragments:\n    - fragments/my_fragment.yaml\nTo create Page Templates, add references to the descriptor files \n  pageModels:\n    - pageModels/my_page_model_descriptor.yaml\n    - pageModels/another_page_model_descriptor.yaml\nTo create and publish Pages, add references to the descriptor files \n  pages:\n    - page/my_page_descriptor.yaml\n    - page/another_page_descriptor.yaml\nTo create a CMS Asset, add a reference to the descriptor file in the same location as the image or file you want to upload\n  assets:\n    - assets/my-asset/my_asset_descriptor.yaml\n    - assets/my-asset/my_image.jpg\nTo create Content Types, add references to the descriptor files\n  contentTypes:\n    - contentTypes/my_content_type_descriptor.yaml\nTo create Content Templates, add references to the descriptor files\n  contentModels:\n    - contentModels/my_content_model_descriptor.yaml\n    - contentModels/another_content_model_descriptor.yaml\nTo create and publish Contents, add references to the descriptor files\n  contents:\n    - contents/my_content_descriptor.yaml\n    - contents/another_content_descriptor.yaml\nTo create Categories, add references to the descriptor files\n  categories:\n    - categories/my_categories.yaml\nTo create Groups, add references to the descriptor files\n  groups:\n    - groups/my_groups.yaml\nTo create Labels, add references to the descriptor files\n  labels:\n    - labels/my_labels.yaml\nTo enable Languages, add references to the descriptor files\n  languages:\n    - languages/languages.yaml\n Plugin \n Here is an example of a plugin descriptor: \n Plugin descriptor.yaml \n image: "entando/my-image:1.0.0" # The Docker image used to create the plugin\ndeploymentBaseName: "myplugin" # The base name to assign to pods that have to be created in Kubernetes\ndbms: "postgresql" # The DBMS the plugin will use\nroles: # The roles the plugin will expose in Keycloak\n  - "task-list"\n  - "task-get"\n  - "connection-list"\n  - "connection-get"\n  - "connection-create"\n  - "connection-delete"\n  - "connection-edit"\nhealthCheckPath: "/actuator/health" # The health check path that Kubernetes will use to check the status of the plugin deployment\ningressPath: "/myhostname.io/entando-plugin" # the ingress path to assign to the plugin deployment\npermissions: # a list of Keycloak clientIds / roles to bind to one another\n  - clientId: realm-management\n    role: manage-users\n  - clientId: realm-management\n    role: view-users\n \n TIP \n Entando uses the  healthCheckPath  to monitor the health of the plugin. A plugin in an Entando Bundle can use any technology, as long as it provides a health check service configured via the  healthCheckPath . This path must be specified in the descriptor file and return an HTTP 200 or success status. This can be implemented by a Java service included with the Entando Blueprint in the Spring Boot application. You can also  use a Node.js service as shown here . \n Kubernetes Pod Names \n Each plugin is deployed into Kubernetes using composite names. The first string is created by reading the descriptor file. The second string is appended autonomously by Kubernetes and 31 characters long. Each Kubernetes pod name length must not exceed 63 characters or the deployment will fail. \n DeploymentBaseName \n Previously, the first segment of the pod name was generated by concatenating and manipulating the  image  field value. However, this approach could result in a pod name longer than 63 characters.\nTo solve this problem, another (optional) property is available:  deploymentBaseName , which accepts a string of up to 32 characters. If present, its value will be used as the first part of the pod name instead of the variant of the  image  value. \n If the  deploymentBaseName  property is not present in the previous descriptor example, a possible pod name is  entando-my-image-1-0-0-server-deployment-6f86f459wj9k . If the  deploymentBaseName  property is present, a possible pod name is  myplugin-server-deployment-6f86f459wj9k . \n If you are using the  deploymentBaseName  property and want to install more versions of the same plugin at the same time, you need to specify different values for  deploymentBaseName  (perhaps including the plugin version). \n Permissions \n The  permissions  property specifies a list of coupled  clientIds  and roles that will be bound in Keycloak. To find them, open the Keycloak console and navigate to  clients  →  awesomeplugin-server  →  Service Account Roles . \n Widget \n Here is an example of a Widget descriptor: \n Widget descriptor.yaml \n code: another_todomvc_widget # The Widget identification\n\ntitles: # Widget\'s Titles\n  en: TODO MVC Widget # Title in English\n  it: TODO MVC Widget # Title in Italian\n\ngroup: free # The owner group of the Widget\nOptional. The UI Path, where the widget.ftl file will have the customUi content\ncustomUiPath: widget.ftl\nOptional. The Custom UI\ncustomUi: >-\n    <h1>My custom Widget UI</h1>\nOptional. The ConfigUI\nconfigUi:\n  customElement: todomvc-config # The name of the custom element used to render the configUI\n  resources:\n    - <bundleid>/static/js/main.js # The resources necessary for the custom element to render the configUI, like the code\n Fragment \n Here is an example of a Fragment descriptor: \n Fragment descriptor.yaml \n code: my_fragment # The unique ID\nOptional. The Fragment content\nguiCode: >-\n  "<div>Here the content</div>"\nOptional. A path to a FreeMarker file containing the Fragment content\nguiCodePath: fragment.ftl\n Page Template \n Here is an example of a Page Template descriptor: \n Page Template descriptor.yaml \n code: todomvc_page_template # The Page Template identification\ndescription: TODO MVC basic page template # The Page Template description\n\ntitles: # Page Template\'s Titles\n  en: TODO MVC PageTemplate # Title in English\n  it: TODO MVC PageTemplate # Title in Italian\nThe Page Template configuration\nconfiguration:\n  frames: # All frames\n    - pos: 0 # Frame position\n      description: Header # Frame description\n      sketch: # Frame sketch configuration\n        x1: 0\n        y1: 0\n        x2: 11\n        y2: 1\n      defaultWidget:\n        code: my-widget # the Widget code to apply when using the button "apply default widgets" in the page configuration UI\nA simplified way to define a Frame\n    - pos: 1\n      description: Breadcrumb\n      sketch: { x1: 0, y1: 0, x2: 11, y2: 1 }\nOptional. Define the Page Template in a separate file or inside the descriptor file with `template`\ntemplatePath: page.ftl\nOptional. Define the Page Template as below or in a separate file with `templatePath`\ntemplate: >-\n  <#assign wp=JspTaglibs[\\"/aps-core\\"]>\n  <!DOCTYPE HTML PUBLIC \\"-//W3C//DTD HTML 4.0 Transitional//EN\\">\n  <html>\n      <head>\n          <title><@wp.currentPage param=\\"title\\" /></title>\n      </head>\n      <body>\n          <h1><@wp.currentPage param=\\"title\\" /></h1>\n          <a href=\\"<@wp.url page=\\"homepage\\"/>\\">Home</a><br>\n          <div>\n              <h1>Bundle 1 Page Template</h1>\n              <@wp.show frame=0 />\n          </div>\n      </body>\n  </html>\n Page \n This descriptor enables a page to be created and published via a bundle. Page status can be  published  or  draft . The Widget section can be used to fully configure a page layout. \n Groups in a page descriptor are configured by  ownerGroup  and  joinGroups . The  ownerGroup  property specifies the group of users who can manage the entity in the AppBuilder. The  joinGroups  property specifies who can view or access the page. For example, setting  ownerGroup  to "free" means anyone with access to the AppBuilder can manage the page, whereas setting  joinGroup  to "free" means any end user can view the page in the application. \n Page descriptor.yaml \n code: dashboard\nparentCode: homepage\ntitles:\n  en: My dashboard\n  it: La mia Dashboard\npageModel: dashboard\nownerGroup: free\njoinGroups: []\ndisplayedInMenu: true\nseo: false\ncharset: utf-8\nECR will publish the page according to this property\nstatus: published|draft\nPage Configuration\nwidgets:\n  - code: Brand-Logo\n    config: null\n    pos: 0\n  - code: Login_buttons\n    config: null\n    pos: 2\n  - code: seeds_card\n    config:\n      cardname: creditcard\n    pos: 6\n  - code: list_item\n    config:\n      icon: managealerts\n      count: \'0\'\n      title: Alerts\n    pos: 7\n  - code: list_item\n    config:\n      icon: viewstatements\n      count: \'0\'\n      title: View Statements\n    pos: 11\n  - code: seedscard-transaction-table\n    config: null\n    pos: 13\n CMS Asset \n This descriptor contains the metadata required for uploading and updating a CMS Asset. \n Asset descriptor.yaml \n correlationCode: \'my-reference-code\'\ntype: image\nThis file should be placed in the same folder as the descriptor.yaml\nname: 113f4437cac3b3f3d4db7229f12287a4_d3.png\ndescription: 113f4437cac3b3f3d4db7229f12287a4_d3.png\ngroup: free\ncategories: []\n Content Template \n Here is an example of a Content Template descriptor: \n Content-template descriptor.yaml \n id: 8880003\ncontentType: CNG\ndescription: Demo Content Template\nOptional. Define the Content Template Shape in a separate file or inside the descriptor file with `contentShape`\ncontentShapePath:\nOptional. Define the Content Template Shape as below or in a separate file with `contentShapePath`\ncontentShape: >-\n  <article>\n    <h1>$content.Title.text</h1>\n    <h2>Demo content template</h2>\n    #if ( $content.MainBody.text != "" )\n    $content.MainBody.text\n    #end\n  </article>\n\n\nwidgets:\n  - code: Brand-Logo\n    config: null\n    pos: 0\n  - code: Login_buttons\n    config: null\n    pos: 2\n  - code: seeds_card\n    config:\n      cardname: creditcard\n    pos: 6\n  - code: list_item\n    config:\n      icon: managealerts\n      count: \'0\'\n      title: Alerts\n    pos: 7\n  - code: list_item\n    config:\n      icon: viewstatements\n      count: \'0\'\n      title: View Statements\n    pos: 11\n  - code: seedscard-transaction-table\n    config: null\n    pos: 13\n Content Type \n For more details on Content Type properties, refer to the  Content Type documentation . \n Content-type descriptor.yaml \n code: CNG\nname: Demo\nstatus: 0\n\nattributes:\n  - code: title\n    type: Text\n    name: Title\n    roles:\n      - code: jacms:title\n        descr: The main title of a Content\n    disablingCodes: []\n    mandatory: true\n    listFilter: false\n    indexable: false\n\n    enumeratorStaticItems: string\n    enumeratorStaticItemsSeparator: string\n    enumeratorExtractorBean: string\n\n    validationRules:\n      minLength: 0\n      maxLength: 100\n      regex: string\n      rangeStartString: string\n      rangeEndString: string\n      rangeStartStringAttribute: string\n      rangeEndStringAttribute: string\n      equalString: string\n      equalStringAttribute: string\n      rangeStartDate: string\n      rangeEndDate: string\n      rangeStartDateAttribute: string\n      rangeEndDateAttribute: string\n      equalDate: string\n      equalDateAttribute: string\n      rangeStartNumber: 0\n      rangeStartNumberAttribute: string\n      rangeEndNumber: 0\n      rangeEndNumberAttribute: string\n      equalNumber: 0\n      equalNumberAttribute:\n      ognlValidation:\n        applyOnlyToFilledAttr: false\n        errorMessage: Something\n        keyForErrorMessage: some\n        keyForHelpMessage: thing\n        ognlExpression: string\n Content \n This descriptor enables content to be created and optionally published via a bundle, according to the  status  property. The content ID is optional and enables linking from other components, like Content Widget. It can be autogenerated or explicitly declared. \n Groups in a content descriptor are configured by the owner group  mainGroup  and the join group  groups . The owner group consists of users who can manage the content within AppBuilder, while the join group consists of users who can view the content. \n Content descriptor.yaml \n id: NWS650\ntypeCode: NWS\ndescription: Dealing with a financial emergency\nmainGroup: free\ngroups:\n  - free\nstatus: PUBLIC\nattributes:\n  - code: date\n    value: \'2020-04-23 00:00:00\' # the date should be in ISO-8601 format\n  - code: title\n    values:\n      en: Dealing with a financial emergency\n  - code: subtitle\n    values:\n      en: |\n        <p>How to tackle financial stress</p>\n  - code: body\n    values:\n      en: |\n        <p>For many Americans, financial concerns are their number-one stress point. Here are 6 ways to help reduce your money stress and get motivated to take control of your finances.</p>\n  - code: img\n    values:\n      en:\n        correlationCode: \'651\'\n        name: bank_750xx684385064_d0.jpg\n  - code: links\n    elements:\n      - code: links\n        value:\n          symbolicDestination: \'#!U;http://www.mysite.com/!#\'\n          destType: 1\n          urlDest: \'http://www.mysite.com/\'\n          pageDest: null\n          contentDest: null\n          resourceDest: null\n        values:\n          en: mio sito\n      - code: links\n        value:\n          symbolicDestination: \'#!U;http://www.mysite.com/!#\'\n          destType: 1\n          urlDest: \'http://www.mysite.com/\'\n        values:\n          en: mio sito 2\n  - code: attaches\n    elements:\n      - code: attaches\n        values:\n          en:\n            correlationCode: \'205\'\n            name: Entando_Admin_Console_Overview_4.3.3_EN.pdf\n Categories \n This descriptor contains a list of Categories: \n Category descriptor.yaml \n - code: new-category # Identifies the Category\n  parentCode: home # The parent Category; home is the base category\n  titles:\n    it: "Una nuova categoria" # Category name in Italian\n    en: "New category" # Category name in English\n Groups \n This descriptor contains a list of Groups: \n Group descriptor.yaml \n - code: my_group # Identifies the Group\n  name: "My group" # The name of the Group\n Labels \n This descriptor contains a list of Labels: \n Label descriptor.yaml \n - key: MY-FIRST-LABEL # Identifies the Label\n  titles: # The titles on the Label\n    it: Mio Titolo # The title in Italian\n    en: My Title # The title in English\n Languages \n This descriptor contains a list of Languages to enable during the installation process: \n Language descriptor.yaml \n - code: en\n  description: English\n- code: it\n  description: Italian\n Static Resources \n In order to upload static files, you will need to create a folder called  resources . All files inside this folder will be uploaded into Entando with the same folder structure. \n resources/\n├ css/\n│ └ styles.css\n├ js/\n│ └ script.js\n├ images/\n│ ├ favicon.ico\n│ └ logo.png\n└ page.html\n \n Using the structure above, the resultant files in the Entando architecture will be: \n yourbundleid/\n├ css/\n│ └ styles.css\n├ js/\n│ └ script.js\n├ images/\n│ ├ favicon.ico\n│ └ logo.png\n└ page.html\n \n \n Important \n The  code  property  yourbundleid  is inside  descriptor.yaml . \n \n To use static files in a Widget or Page Template, use the FTL tag  <@wp.resourceURL /> : \n <img src="<@wp.resourceURL />yourbundleid/images/logo.png">\n<link rel="stylesheet" href="<@wp.resourceURL />yourbundleid/css/styles.css">\n<link rel="shortcut icon" href="<@wp.resourceURL />yourbundleid/images/favicon.ico" type="image/x-icon"/>\n<script type="application/javascript" src="<@wp.resourceURL />yourbundleid/js/script.js"><\/script>\n \n '},{title:"How Microservices get Connected to Entando Apps",frontmatter:{redirectFrom:"/v6.3.2/docs/ecr/ecr-how-microservices-connect-to-apps.html"},regularPath:"/v6.3.2/docs/curate/ecr-how-microservices-connect-to-apps.html",relativePath:"v6.3.2/docs/curate/ecr-how-microservices-connect-to-apps.md",key:"v-e60aa460",path:"/v6.3.2/docs/curate/ecr-how-microservices-connect-to-apps.html",headers:[{level:2,title:"How a Microservice from a Bundle gets Deployed with the ECR?",slug:"how-a-microservice-from-a-bundle-gets-deployed-with-the-ecr"},{level:2,title:"Other Options",slug:"other-options"},{level:2,title:"Kubernetes naming conventions",slug:"kubernetes-naming-conventions"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:" How Microservices get Connected to Entando Apps \n In this document we will describe some of the assumptions and details related to the process of connecting a microservice part of a bundle to an Entando App. \n In order to fully understand the concepts explained in this piece of the documentation, please make sure you have familiarity with these concepts: \n \n Entando custom resources \n Entando ingresses \n How a Microservice from a Bundle gets Deployed with the ECR? \n When a bundle containing a microservice is installed using the ECR, behind the scenes some actions take place. \n \n To begin, an  EntandoPlugin custom resource  is generated starting from the PluginDescriptor. Some fields will be automatically generated from the provided image. \n \n \n From the  image  field in the PluginDescriptor, we will extract the  organization ,  name  and  version  of the image. \n organization ,  name  and  version  are then converted to valid characters and composed to form the plugin name ( metadata.name ), the labels ( metadata.labels ) and the ingressPath ( spec.ingressPath ) of the custom resource. \n \n NOTE : Two PluginDescriptors having images with the same organization, name and version will generate a custom resource with the same  metadata.name  and  spec.ingressPath . \n \n Next, a check for a microservice with the same name is performed to verify if a new deployment is required for the microservice. \n If a microservice with the same name is not available in the namespace where the Entando App has been deployed, a new EntandoPlugin custom resource is created and deployed in the namespace using the details defined in the bundle. \n At the same time, an EntandoAppPluginLink custom resource is deployed in the namespace in order to expose the microservice ingress path on the EntandoApp ingress. \n If both the EntandoPlugin custom resource and the EntandoAppPluginLink are deployed correctly, the APIs of the microservice will be available from the same domain of the EntandoApp, making it possible reach those APIs from the EntandoApp using relative urls. \n \n This is the standard flow when no other micorservice with a given name is already available in the EntandoApp namespace. \n If there is an existing microservice with the same name as the one generated from the PluginDescriptor, the ECR will connect the EntandoApp to\nthe existing microservice by generating and deploying the required EntandoAppPluginLink per step 3 above.\nThis way, plugins can be reused by many applications at the same time. \n Other Options \n The naming convention recommendations above are accurate for creating bundles and for self contained applications where the Entando operator is managing the lifecycle of your microservices. If you have a substantial API infrastructure or you intend to deploy a large number of versioned microservices you can also utilize Entando with API management infrastructure like API gateways. If you are using an API gateway or other API abstraction layer you will need to manually manage the ingress for your micro frontends in your application to point to the API gateway deployment. \n In cases where conflicts occur bundles can easily be renamed by updating metdata. \n Kubernetes naming conventions \n Here some rules about naming conventions extracted from the  Kubernetes documentation on object names and ids \n \n Most resource types require a name that can be used as a DNS subdomain name as defined in RFC 1123. This means the name must: \n \n contain no more than 253 characters \n contain only lowercase alphanumeric characters, '-' or '.' \n start with an alphanumeric character \n end with an alphanumeric character \n \n \n"},{title:"Troubleshooting ECR",frontmatter:{redirectFrom:"/v6.3.2/docs/ecr/ecr-troubleshooting-guide.html"},regularPath:"/v6.3.2/docs/curate/ecr-troubleshooting-guide.html",relativePath:"v6.3.2/docs/curate/ecr-troubleshooting-guide.md",key:"v-11e12530",path:"/v6.3.2/docs/curate/ecr-troubleshooting-guide.html",headers:[{level:2,title:"A bundle installation/removal has failed, how to access the logs?",slug:"a-bundle-installation-removal-has-failed-how-to-access-the-logs"},{level:3,title:"Overview",slug:"overview"},{level:3,title:"Solution",slug:"solution"},{level:2,title:"My bundle has an issue, how should I publish a new version of the bundle?",slug:"my-bundle-has-an-issue-how-should-i-publish-a-new-version-of-the-bundle"},{level:3,title:"Overview",slug:"overview-2"},{level:3,title:"Solution",slug:"solution-2"},{level:2,title:"Bundle installation fails because a file has not been found in the bundle",slug:"bundle-installation-fails-because-a-file-has-not-been-found-in-the-bundle"},{level:3,title:"Overview",slug:"overview-3"},{level:3,title:"Solution",slug:"solution-3"},{level:2,title:"Bundle installation failed due to plugin(s) images not reachable",slug:"bundle-installation-failed-due-to-plugin-s-images-not-reachable"},{level:3,title:"Overview",slug:"overview-4"},{level:3,title:"Solution",slug:"solution-4"},{level:2,title:"I can't uninstall a bundle because some components are in use",slug:"i-can-t-uninstall-a-bundle-because-some-components-are-in-use"},{level:3,title:"Overview",slug:"overview-5"},{level:3,title:"Solution",slug:"solution-5"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:" Troubleshooting ECR \n A bundle installation/removal has failed, how to access the logs? \n Overview \n Currently the Entando component manager logs are available in kubernetes via dashboard (openshift) or cli tools (k9s or kubectl).\nIf in you Entando cluster you have more than one Entando App custom resource, you will need to know what's the correct component-manager to check using the corresponding Entando App name and namespace where the app has been deployed. \n Solution \n Using  kubectl  and assuming for simplicity that you have only one Entando App named  quickstart  and your Entando cluster is only composed of one namespace, also named  quickstart ,\nyou can get the component-manager logs using the command \n kubectl logs -f deployment/quickstart-server-deployment --namespace quickstart -c de-container\n \n Note : the  -f  flag is optional and could be used to follow the logs for debugging purposes \n My bundle has an issue, how should I publish a new version of the bundle? \n Overview \n Sometimes a bundle could have some issues: typos in the  descriptor.yaml  file, wrong references of components or to not available docker images are just a few of the possible errors. \n Solution \n \n If the bundle is shared using a git repository, you can make the required changes to your project and publish the new version to git and generate a new tag for it. \n Once the new tag is published, update the bundle costum-resource avaialble in you Entando Cluster by adding the new tag to the  tags  objects  and replacing the latest  dist-tags  to point to this new version. \n Proceed with the new installation \n \n If you're actively working on your bundle and you simply want to verify things are working correctly, instead of generating a new tag for each release of the bundle you can try to keep overriding a specific tag using the git command  git tag -f . We suggest you to follow this practice only during development and not in production. \n Bundle installation fails because a file has not been found in the bundle \n Overview \n When a component that is referenced in the  descriptor.yaml  is missing in the bundle or not correctly referenced, the bundle installation fails and in the logs is reported which file has not been found. \n ERROR - File with name {filename} not found in the bundle\n Solution \n When such a problem happens, verify that the component referenced in the descriptor file are actually present in the bundle and that the reference is properly typed. \n Publish a new version of your bundle as described in the\n \"My bundle has an issue\"  section \n Bundle installation failed due to plugin(s) images not reachable \n Overview \n Plugin included in a bundle are referenced using their docker image. Sometime the image is not available - maybe has not yet be published or is in a private docker registry - and plugin installation can't happen and the entire bundle installation process can't finish successfully \n Solution \n Verify that the docker image you are referencing is correct and publicly available. \n \"My bundle has an issue\"  section \n I can't uninstall a bundle because some components are in use \n Overview \n When removing an installed bundle, the Entando component manager verfies that the bundle components\nare not in use by any other component. Removing such components would cause an error during removal\nas in certain case the deleting a component in use is not permitted. \n Solution \n In order to prevent such errors, the user is alerted and required to manually decouple the bundle\ncomponents before beign able to completely remove the bundle from the system. \n"},{title:"Bundle versions and updates - FAQ",frontmatter:{redirectFrom:"/v6.3.2/docs/ecr/ecr-bundle-versions-faq.html"},regularPath:"/v6.3.2/docs/curate/ecr-bundle-versions-faq.html",relativePath:"v6.3.2/docs/curate/ecr-bundle-versions-faq.md",key:"v-2f6dd8e4",path:"/v6.3.2/docs/curate/ecr-bundle-versions-faq.html",headers:[{level:2,title:"Does the ECR support versioning?",slug:"does-the-ecr-support-versioning"},{level:2,title:"How is a bundle version defined?",slug:"how-is-a-bundle-version-defined"},{level:2,title:"What format should I use to version my bundle?",slug:"what-format-should-i-use-to-version-my-bundle"},{level:2,title:"As a bundle developer, how should I create a new version of a bundle?",slug:"as-a-bundle-developer-how-should-i-create-a-new-version-of-a-bundle"},{level:2,title:"How to prevent a particular bundle version from being visible in the ECR?",slug:"how-to-prevent-a-particular-bundle-version-from-being-visible-in-the-ecr"},{level:2,title:"My bundle contains a microservice generated with the Entando Component Generator, does the version of the microservice have to be the same as the bundle version?",slug:"my-bundle-contains-a-microservice-generated-with-the-entando-component-generator-does-the-version-of-the-microservice-have-to-be-the-same-as-the-bundle-version"},{level:2,title:"How bundle versions are installed from the ECR",slug:"how-bundle-versions-are-installed-from-the-ecr"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:" Bundle versions and updates - FAQ \n Does the ECR support versioning? \n A bundle, as discussed in the  overview , is a package containing one or more components.\nAs in many other packaging systems, the ECR supports bundle versioning, allowing developers to create and release improvements of their package over time. \n How is a bundle version defined? \n In the ECR, the bundle custom resource comes with a set of  tags , each one representing a version of the bundle.\nHere an example for a CMS quickstart bundle \n apiVersion: entando.org/v1\nkind: EntandoDeBundle\nmetadata:\n    name: cms-quickstart-bundle\nspec:\n  details:\n    name: Entando Example CMS Bundle\n    description: Example Bundle containing CMS components for the Quickstart experience\n  tags:\n    - integrity: ''\n      shasum: ''\n      tarball: 'https://github.com/entando/entando-cms-quickstart-bundle.git'\n      version: v0.0.1\n    - integrity: ''\n      shasum: ''\n      tarball: 'https://github.com/entando/entando-cms-quickstart-bundle.git'\n      version: v0.0.2\n \n As you can see from the code above, the bundle  cms-quickstart-bundle  has 2 versions available.\nEach version in the  tags  object must correspond a tag in the git repository provided in the  tarball  field. \n What format should I use to version my bundle? \n The ECR requires versions to follow the  semantic versioning 2.0.0 , with the possibility to prepend a  v  to the version itself. Some valid bundle versions are: \n \n 1.0 \n v0.1.0-alpha \n 1.0.1-SNAPSHOT \n 22.109.10234-RC.1 \n As a bundle developer, how should I create a new version of a bundle? \n If you're a bundle developer and you want to release a new version of your bundle, you can simply update the content of your bundle and commit the changes to the bundle git repository.\nOnce all the required changes are committed, you can create a new tag in the git repository using the  git tag  command and publish it to the remote repository using the  git push --tags  command \n For example, let's assume my bundle already has a version  1.0.0  and I want to publish the version  2.0.0  of my bundle, here the commands I need to use to create and publish the new tag: \n     git tag -a \"2.0.0\" -m \"My new version\"\n    git push --tags\n How to prevent a particular bundle version from being visible in the ECR? \n If, for some reason, you don't want a particular version to be available for the installation, you can proceed as follows: \n \n You can edit the bundle directly using the command  kubectl edit entandodebundles.entando.org -n <namespace-of-the-bundle> <name-of-the-bundle> \n \n or if you still have the original file you can also: \n \n remove the undesired version from the tag list in your bundle Kubernetes file ( integrity ,  shasum ,  tarball  and  version ) \n delete your bundle from your cluster using a command like this  kubectl delete -f your-bundle-file.yml [-n your-cluster-namespace] \n upload your bundle again to Kubernetes using a command like this  kubectl create -f your-bundle-file.yml [-n your-cluster-namespace] \n My bundle contains a microservice generated with the Entando Component Generator, does the version of the microservice have to be the same as the bundle version? \n The version of the microservice - or to be more precise the docker image associated with the microservice - isn't bound to the version of the bundle containing the microservice itself. \n This gives the bundle developer complete control over the bundle release process, especially in those situations where the bundle contains more components and even more microservices. \n How bundle versions are installed from the ECR \n When the user decides to install a version of the bundle, the ECR checks the provided tag in the git repository and clones locally just the content of the repository for that tag. \n For this reason it's important that for each provided tag in the custom-resource a corresponding tag is available in the git repository, otherwise the ECR will not be able to donwload the bundle and will throw an error. Note that the ECR can only see published tags, so make sure that all the time you create a new tag in your git repository you publish it to the remote repository too. \n"},{title:"Bundle uninstall",frontmatter:{redirectFrom:"/v6.3.2/docs/ecr/ecr-uninstall-flow.html"},regularPath:"/v6.3.2/docs/curate/ecr-uninstall-flow.html",relativePath:"v6.3.2/docs/curate/ecr-uninstall-flow.md",key:"v-cb52bfb4",path:"/v6.3.2/docs/curate/ecr-uninstall-flow.html",headers:[{level:2,title:"Uninstall process",slug:"uninstall-process"},{level:2,title:"Troubleshooting",slug:"troubleshooting"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:" Bundle uninstall \n Uninstall process \n To uninstall a bundle that was previously installed on an Entando App Engine, from Entando App builder UI go to\nthe  Component Repository  tab and select the bundle you want to uninstall \n \n An initial check is made to verify none of the bundle components are in use.\nIf any of the components are in use, a popup will alert you.\nNote that you can't force the removal of a bundle if its components are in use. \n Once the removal process starts: \n \n Bundle resources are deleted from the Entando App Engine \n Components included in the bundle are removed from the Entando App Engine \n Plugins are unlinked \n Troubleshooting \n If any error happens during the uninstall process and you don't know what to do,\ncheck out the  Troubleshooting guide  or the  Entando Forum \n"},{title:"Entando Solution Templates",frontmatter:{sidebarDepth:2},regularPath:"/v6.3.2/docs/getting-started/landing-page.html",relativePath:"v6.3.2/docs/getting-started/landing-page.md",key:"v-ceedd9b8",path:"/v6.3.2/docs/getting-started/landing-page.html",headers:[{level:2,title:"Entando Customer Portal",slug:"entando-customer-portal"},{level:2,title:"Entando Hub",slug:"entando-hub"},{level:2,title:"Entando Process Driven Applications Plugin",slug:"entando-process-driven-applications-plugin"},{level:2,title:"Entando Standard Banking Demo",slug:"entando-standard-banking-demo"}],lastUpdated:"2/10/2022, 7:25:11 AM",lastUpdatedTimestamp:1644495911e3,content:" Entando Solution Templates \n The Entando Application Composition Platform offers several Solution Templates to demonstrate various business capabilities and integrations: \n \n Entando Customer Portal \n Entando Hub \n Entando Process Driven Applications Plugin \n Entando Standard Banking Demo \n \n Each open source Solution Template was built with Entando and can be used as-is, reviewed for common development practices, or leveraged as a useful starting point for a related application. \n The following Solution Templates and other sets of components are available in the  public Entando Hub  for installation in a user environment, where turnkey functionality can be customized and extended. \n Entando Customer Portal \n The  Entando Customer Portal  streamlines development of a customer-facing, self-service subscription management application. The platform integrates Keycloak role based access control and Jira Service Management as a ticket tracking system. \n Entando Hub \n The  Entando Hub  empowers a team to share and collaborate on proprietary or Entando open source components. Capabilities, versions and metadata can be transparently analyzed, managed and published. \n Entando Process Driven Applications Plugin \n The  Entando Process Driven Applications Plugin  provides a comprehensive and versatile automation scheme for Business Process Management. It comprises a custom UX layer, a Spring Boot Backend for Frontend microservice interface, and integration with the  Red Hat Process Automation Manager . \n Entando Standard Banking Demo \n The  Entando Standard Banking Demo  showcases the benefits and possibilities of a composable application built from modular components. The example banking environment integrates a transaction table, sign up form, alert icon, and summary cards to demonstrate MFE communication and capabilities. Prominent features include Keycloak role based access control, coexistence of React and Angular MFEs, and pluggable Spring Boot microservices. \n \n"},{title:"Getting Started with Entando",frontmatter:{sidebarDepth:2},regularPath:"/v6.3.2/docs/getting-started/",relativePath:"v6.3.2/docs/getting-started/README.md",key:"v-65dad879",path:"/v6.3.2/docs/getting-started/",headers:[{level:2,title:"Try Entando",slug:"try-entando"},{level:2,title:"Learn about Entando",slug:"learn-about-entando"},{level:2,title:"Automatic Install",slug:"automatic-install"},{level:2,title:"Manual Install",slug:"manual-install"},{level:3,title:"Install Kubernetes",slug:"install-kubernetes"},{level:3,title:"Prepare Kubernetes",slug:"prepare-kubernetes"},{level:3,title:"Deploy Entando",slug:"deploy-entando"},{level:2,title:"Log in to Entando",slug:"log-in-to-entando"},{level:2,title:"Next Steps",slug:"next-steps"}],lastUpdated:"1/31/2022, 9:28:12 AM",lastUpdatedTimestamp:1643639292e3,content:" Getting Started with Entando \n WARNING \n Mac:  Entando 6 is not currently compatible with the Apple M1 ARM64 architecture found in some newer Macs. \n Try Entando \n Set up Entando using two simple steps or install manually for your specific needs. Then try the platform with a simple widget or walk through the  Welcome Wizard  in our App Builder. For a more in-depth experience, check out our  Standard Banking Demo . \n \n Automatic Install : The fastest way to locally install and start up Entando in Kubernetes. \n Manual Install : Useful if you want a shared cluster or a custom local instance. \n \n Once you're setup, check out: \n \n Build a simple Bundle and create an App \n Welcome Wizard \n Install our Standard Banking Demo \n Learn about Entando \n Learn about what Entando can do top down or explore the elements that make developing applications on Kubernetes faster and easier. \n \n Introduction to Entando  \n Learning Paths \n Concepts Overview \n Automatic Install \n Automatically install Entando via the Entando command-line interface (CLI) and prepare a local developer environment with default settings.\nThe following steps launch an Ubuntu VM via Multipass, install Kubernetes, then deploy Entando to it. \n \n Install  Multipass \n \n https : //multipass.run/#install \n \n \n Install Entando into Kubernetes on Ubuntu using the  Entando CLI \n \n curl  -sfL https://get.entando.org  |   bash \n \n \n The progress of the install will be displayed on the console. Installation can take 10+ minutes depending on how long the Docker images take to download. The sequence of steps performed by the CLI is identical to the manual steps below; to understand what the CLI does, review the manual steps. \n The URL to access the  Entando App Builder  will print to the console once the install completes. \n Login with username: admin  and password:  adminadmin . Refer to  Log in to Entando  for more information and next steps. \n Manual Install \n Configure a shared cluster or customize a local developer environment. This is a learn-as-you-go approach. It will give you a working knowledge of Kubernetes as you get Entando up and running in a local environment. The process is as follows: \n \n Install Kubernetes \n Prepare Kubernetes Environment \n Deploy Entando \n \n Note: For advanced or long-time Entando users, check out our  Quick Reference  install guide for just the steps. \n We've tested a variety of Kubernetes implementations, including Minikube, Minishift, CodeReady Containers, K3s, and Microk8s, to find the optimal combination of low cpu/memory usage, fast startup times, and minimal configuration. After downloading the necessary files, you'll have your own instance of Kubernetes up and running in <60 seconds. \n What's Needed to Run Kubernetes? \n Kubernetes is a container orchestrator designed to manage a server cluster. It requires at least one master node running a Linux OS. A lightweight ubuntu VM can be created in seconds with Multipass. Choosing a Type 1 hypervisor eliminates a guest OS, maximizing speed and performance. \n Install Kubernetes \n Enable Hypervisor \n Why a Hypervisor? \n Hypervisors allow you to create and run virtual machines. Virtualization software that run on top of your operating system like VirtualBox or VMWare Workstation are Type 2 hypervisors. Type 1 hypervisors run on bare metal. \n \n Let's install a Type 1 hypervisor for optimal performance. \n Mac:  Install  hyperkit \n brew  install  hyperkit\n \n Windows:   Install Hyper-V \n \n What if my machine doesn't support hyperkit or Hyper-V? \n Use a Type 2 hypervisor that runs on top of your operating system \n \n Install Virtual Box:\n Mac \n Windows \n Launch Ubuntu VM \n Why Multipass? \n Multipass is a cross-platform tool developed by the publishers of Ubuntu to create lightweight Ubuntu VMs in seconds. \n \n \n \n Install  Multipass \n \n \n Launch VM \n \n \n multipass launch --name ubuntu-lts --cpus  4  --mem 8G --disk 20G\n \n \n Open VM shell \n \n multipass shell ubuntu-lts\n Run Kubernetes \n Why K3s? \n K3s is a certified Kubernetes distribution designed for production workloads in resource-constrained environments. \n It's packaged as a single <50MB binary that reduces the dependencies and steps needed to install, run, and auto-update a production Kubernetes cluster. \n \n \n Install  K3s \n \n curl  -sfL https://get.k3s.io  |   sh  -\n \n \n Check for  Ready   STATUS \n \n sudo  kubectl get  node \n \n \n What's running out of the box? \n sudo  kubectl get pods -A\n \n \n \n Congratulations! \n You now have a local instance of Kubernetes up and running. \n \n Now that Kubernetes is running, you can set up kubectl to send commands directly to K3s from the host machine, rather than from within the VM. See the instructions  here . \n Prepare Kubernetes \n To install Entando, we'll add  Custom Resources , create a  Namespace , download a  Helm  chart, and configure external access to our cluster. \n Create Namespace \n What are Namespaces? \n Kubernetes supports multiple virtual clusters backed by the same physical cluster. These virtual clusters are called  namespaces . \n You can use namespaces to allocate resources and set cpu/memory limits for individual projects or teams. They can also encapsulate projects from one another. \n \n sudo  kubectl create namespace entando\n Add Custom Resources \n Why Custom Resources? \n Standard resources in Kubernetes include things like  Pods , which are groups of one or more containers,  Services , the way to call or access pods, and  Ingresses , to enable external access to Services. \n Custom resources  let you store and retrieve structured data. Combining a custom resource with a custom controller allows you to define a desired state to automate the running of your applications or services in a Kubernetes cluster. \n \n Examples of custom resources in Entando are: \n \n Entando App Engine \n Entando Identity Management System \n \n From your Ubuntu shell \n \n Download and install custom resource definitions \n \n sudo  kubectl apply -f https://raw.githubusercontent.com/entando/entando-releases/v6.3.2/dist/ge-1-1-6/namespace-scoped-deployment/cluster-resources.yaml\n \n \n Install namespace scoped resources \n \n sudo  kubectl apply -n entando -f https://raw.githubusercontent.com/entando/entando-releases/v6.3.2/dist/ge-1-1-6/namespace-scoped-deployment/orig/namespace-resources.yaml\n Download Helm Chart \n What is Helm? \n Helm is a package manager for Kubernetes that helps you define, install, and upgrade Kubernetes applications.\nThis  Getting Started  guide uses a Helm-generated file with a number of default values to help get you started faster,\ne.g. use embedded databases, exclude OpenShift support, etc. If you want to change any of those defaults, please see  https://github.com/entando-k8s/entando-helm-quickstart . \n \n \n Install Helm \n \n sudo  snap  install  helm --classic\n \n \n Download the Entando Helm template \n \n curl  -sfL https://github.com/entando-k8s/entando-helm-quickstart/archive/v6.3.2.tar.gz  |   tar  xvz\n Configure Access to Your Cluster \n What about Networking? \n Entando sets up  Ingresses  in Kubernetes to expose HTTP routes from outside the cluster to services within the cluster. We'll use this to access Entando from a local browser. \n If you run into network issues during startup, or if you are using Windows for your local development instance, please see  the tips . Symptoms can include Entando failing to completely start the first time or a working Entando instance failing to restart later. \n \n To set up external access to your cluster, you'll need to replace the value of\n entando.default.routing.suffix  with your Ubuntu IP. \n \n Get the IP address of your Ubuntu VM \n \n hostname  -I  |   awk   '{print $1}' \n \n \n Save that value for the deployment steps below \n Deploy Entando \n To speed up the  Getting Started  environment, embedded databases are used by default for these components.\nSee  this tutorial  for more information on how to change your\ndatabase connection. \n \n Enter the Helm quickstart directory \n \n cd  entando-helm-quickstart-6.3.2\n \n \n Edit the file in  sample-configmaps/entando-operator-config.yaml  by uncommenting the value for  entando.default.routing.suffix:  and setting the value to the IP address of your Ubuntu VM plus  .nip.io . For example,  entando.default.routing.suffix: 192.168.64.21.nip.io . Pay attention to yaml spacing. \n \n Reduced network speed or Docker Hub traffic controls may cause the Entando install to timeout. Use the ConfigMap settings below to increase the thresholds for image downloads. \n entando.pod.completion.timeout.seconds:  \"1200\" \nentando.pod.readiness.timeout.seconds:  \"1200\" \n \n \n Deploy your config map \n \n sudo  kubectl apply -f sample-configmaps/entando-operator-config.yaml  -n entando\n \n \n Run Helm and deploy your Entando application \n \n sudo  helm template quickstart ./  |   sudo  kubectl apply -n entando -f -\n \n \n \n Use the  get pods --watch  command to observe Entando starting up \n \n sudo  kubectl -n entando get pods --watch\n \n What does a successful startup look like? \n \n First, you'll see the Entando operator:  ContainerCreating  >  Running \n Next, the Entando composite app deployer:  Pending  >  ContainerCreating  >  Running \n Then, Keycloak:  kc-deployer  >  kc-db-deployment \n \n Jobs / Deployments \n \n Jobs, like  kc-db-preparation-job , run once and are  Completed :  0/1 \n Database deployments, like  kc-db-deployment , should end up as  Running :  1/1 \n The Keycloak server deployment,  kc-server-deployment , should end up as  Running :  1/1 \n The deployment is done when the  quickstart-composite-app-deployer  pod has a status of  Completed \n \n Lifecycle Events \n \n Each line represents an event:  Pending ,  ContainerCreating ,  Running  or  Completed \n Restarts should ideally be  0 ; otherwise, there was a problem with your cluster, and Kubernetes is trying to self-heal \n \n ubuntu@test-vm : ~ $   sudo  kubectl get pods -n entando --watch \n NAME                                   READY   STATUS              RESTARTS   AGE\nNAME                                     READY   STATUS              RESTARTS   AGE\nentando-operator-5cdf787869-t5xrg        1/1     Running             0          65s\nquickstart-composite-app-deployer-0547   1/1     Running             0          8s\nquickstart-kc-deployer-7879              0/1     ContainerCreating   0          2s\nquickstart-kc-deployer-7879              1/1     Running             0          2s\nquickstart-kc-server-deployment-5f9d7897c6-7jnq5   0/1     Pending             0          0s\nquickstart-kc-server-deployment-5f9d7897c6-7jnq5   0/1     Pending             0          3s\nquickstart-kc-server-deployment-5f9d7897c6-7jnq5   0/1     ContainerCreating   0          3s\nquickstart-kc-server-deployment-5f9d7897c6-7jnq5   0/1     Running             0          5s\nquickstart-kc-server-deployment-5f9d7897c6-7jnq5   0/1     Running             0          99s\nquickstart-kc-server-deployment-5f9d7897c6-7jnq5   1/1     Running             0          107s\nquickstart-kc-deployer-7879                        0/1     Completed           0          2m16s\nquickstart-kc-deployer-7879                        0/1     Terminating         0          2m16s\nquickstart-kc-deployer-7879                        0/1     Terminating         0          2m16s\nquickstart-eci-deployer-7439                       0/1     Pending             0          0s\nquickstart-eci-deployer-7439                       0/1     Pending             0          0s\nquickstart-eci-deployer-7439                       0/1     ContainerCreating   0          0s\nquickstart-eci-deployer-7439                       1/1     Running             0          2s\nquickstart-eci-k8s-svc-deployment-699b47595d-wxmmb   0/1     Pending             0          0s\nquickstart-eci-k8s-svc-deployment-699b47595d-wxmmb   0/1     Pending             0          0s\nquickstart-eci-k8s-svc-deployment-699b47595d-wxmmb   0/1     ContainerCreating   0          0s\nquickstart-eci-k8s-svc-deployment-699b47595d-wxmmb   0/1     Running             0          2s\nquickstart-eci-k8s-svc-deployment-699b47595d-wxmmb   0/1     Running             0          35s\nquickstart-eci-k8s-svc-deployment-699b47595d-wxmmb   1/1     Running             0          43s\nquickstart-eci-deployer-7439                         0/1     Completed           0          51s\nquickstart-eci-deployer-7439                         0/1     Terminating         0          52s\nquickstart-eci-deployer-7439                         0/1     Terminating         0          52s\nquickstart-deployer-2922                             0/1     Pending             0          0s\nquickstart-deployer-2922                             0/1     Pending             0          0s\nquickstart-deployer-2922                             0/1     ContainerCreating   0          0s\nquickstart-deployer-2922                             1/1     Running             0          1s\nquickstart-server-deployment-75bb794647-bt6xk        0/1     Pending             0          0s\nquickstart-server-deployment-75bb794647-bt6xk        0/1     Pending             0          3s\nquickstart-server-deployment-75bb794647-bt6xk        0/1     ContainerCreating   0          3s\nquickstart-server-deployment-75bb794647-bt6xk        0/1     Running             0          4s\nquickstart-server-deployment-75bb794647-bt6xk        0/1     Running             0          2m19s\nquickstart-server-deployment-75bb794647-bt6xk        1/1     Running             0          2m21s\nquickstart-ab-deployment-7d78b79c-q7r6z              0/1     Pending             0          0s\nquickstart-ab-deployment-7d78b79c-q7r6z              0/1     Pending             0          0s\nquickstart-ab-deployment-7d78b79c-q7r6z              0/1     ContainerCreating   0          0s\nquickstart-ab-deployment-7d78b79c-q7r6z              0/1     Running             0          1s\nquickstart-ab-deployment-7d78b79c-q7r6z              0/1     Running             0          12s\nquickstart-ab-deployment-7d78b79c-q7r6z              1/1     Running             0          15s\nquickstart-cm-deployment-86bc545b6f-vtg2c            0/1     Pending             0          0s\nquickstart-cm-deployment-86bc545b6f-vtg2c            0/1     Pending             0          3s\nquickstart-cm-deployment-86bc545b6f-vtg2c            0/1     ContainerCreating   0          3s\nquickstart-cm-deployment-86bc545b6f-vtg2c            0/1     Running             0          5s\nquickstart-cm-deployment-86bc545b6f-vtg2c            0/1     Running             0          98s\nquickstart-cm-deployment-86bc545b6f-vtg2c            1/1     Running             0          99s\nquickstart-deployer-2922                             0/1     Completed           0          4m28s\nquickstart-deployer-2922                             0/1     Terminating         0          4m29s\nquickstart-deployer-2922                             0/1     Terminating         0          4m29s\nquickstart-composite-app-deployer-0547               0/1     Completed           0          7m44s\nquickstart-composite-app-deployer-0547               0/1     Terminating         0          8m13s\nquickstart-composite-app-deployer-0547               0/1     Terminating         0          8m13s\n \n \n \n Press  Ctrl-C  to exit the watch command once everything is up and running. \n \n What pods come out of the box? \n sudo  kubectl get pods -n entando\n \n NAME                                                 READY   STATUS    RESTARTS   AGE\nentando-operator-5cdf787869-t5xrg                    1/1     Running   0          10m\nquickstart-kc-server-deployment-5f9d7897c6-7jnq5     1/1     Running   0          9m20s\nquickstart-eci-k8s-svc-deployment-699b47595d-wxmmb   1/1     Running   0          7m2s\nquickstart-server-deployment-75bb794647-bt6xk        1/1     Running   0          6m10s\nquickstart-ab-deployment-7d78b79c-q7r6z              1/1     Running   0          3m48s\nquickstart-cm-deployment-86bc545b6f-vtg2c            1/1     Running   0          3m30s\n\n \n \n \n Get the URL to access Entando from your local browser \n sudo  kubectl get ingress -n entando -o  jsonpath = '{.items[2].spec.rules[*].host}{.items[2].spec.rules[*].http.paths[1].path}{\"\\n\"}' \n \n \n Example URL \n \n quickstart-entando.192.168.64.33.nip.io/app-builder/\n Log in to Entando \n Now that we've installed Entando, let's log in to the  Entando App Builder \n \n \n Username:  admin \n Password:  adminadmin \n \n After login, change your password to activate your account. \n \n Note: If the login process hangs for more than 5 seconds, refresh the browser. \n \n \n The App Builder is where we'll compose our micro frontends alongside CMS pages and content. \n Congratulations! \n We now have Entando up and running on Kubernetes in our local environment. \n Next Steps \n Choose one of the following actions to continue your journey with Entando! \n \n \n Build Your First Application:  Use the  Welcome Wizard  to build your first application via guided prompts. \n \n \n Try a Tutorial:  Take advantage of the  Learning Paths , which organize a few of the most popular tutorials by user type. \n \n \n Dig Deeper into Entando Concepts:  Review the  Docs  sections to more deeply understand the Entando building blocks. \n \n \n Learn about the Quickstart Environment:  See the  Quickstart Tips  for more information on how to manage your Getting Started or quickstart environment. \n \n \n \n"},{title:"Development Process on Entando",frontmatter:{sidebarDepth:2},regularPath:"/v6.3.2/docs/getting-started/development-concepts.html",relativePath:"v6.3.2/docs/getting-started/development-concepts.md",key:"v-e669d918",path:"/v6.3.2/docs/getting-started/development-concepts.html",headers:[{level:2,title:"Create Components",slug:"create-components"},{level:2,title:"Curate and Share Components",slug:"curate-and-share-components"},{level:2,title:"Compose an Application",slug:"compose-an-application"},{level:2,title:"Consume Applications",slug:"consume-applications"}],lastUpdated:"2/11/2022, 2:19:48 PM",lastUpdatedTimestamp:1644607188e3,content:" Development Process on Entando \n With the Entando Platform, the development of an application is organized into four distinct stages: Create, Curate, Compose, and Consume. In the simplest terms, you  create  functional building blocks,  curate  them into a catalog,  compose  the blocks onto a page or a website, which is then  consumed  in an application. \n Entando provides a distributed and composable environment in which components can be independently built, scaled and iterated. This process enables parallel teams to accelerate development and innovation on a cloud- and Kubernetes-native stack. \n Create Components \n The first step in building a modern application on Entando is to design and create each independent component or functional block. Developers can use the  Entando Component Generator  and  Blueprint  to automate the building and packaging of project files, with the flexibility to customize. The modular design of apps built on Entando means new business capabilities can be integrated into your application without reworking existing systems. \n \n \n \n Documentation \n Tutorials \n \n \n \n \n Entando Component Generator \n Micro Frontends \n \n \n Entando Blueprint Feature \n Microservices \n \n \n Component Generation Technologies \n Build and Publish Project Bundles \n Curate and Share Components \n On the Entando Platform, Curate and Share means development teams can bundle and share components within a central catalog. Multiple teams or groups can collaborate on single components or a whole packaged business capability (PBC) across organizations and applications. They can test and assess components for readiness, manage and publish versions and share metadata for continuous upgrades. \n \n \n \n Documentation \n Tutorials \n \n \n \n \n Bundle and Component Descriptors \n Install Bundles from a Private Git Repository \n \n \n Filtering Bundles \n Install Bundle Plugins from a Private Image Repo \n \n \n Customize Bundle Info in App Builder \n \n \n \n Bundle Version and Updates FAQ \n \n \n \n Bundle Uninstall \n Compose an Application \n The Compose stage on Entando is centered around the  Entando App Builder , a low-code composition user interface. In the App Builder, application owners can assemble new components or upgrade existing ones with templates, widgets and fully functional PBCs. The  Entando Component Manager  and  Entando Component Repository  are integrated into the App Builder, making the composing process flexible and agile by managing all your components there. \n \n \n \n Documentation \n Tutorials \n \n \n \n \n Welcome Wizard \n Page Management \n \n \n Entando Component Repository \n Widgets and Fragments \n \n \n Entando App Builder \n Content Creation \n \n \n Entando Component Manager \n Content Templates \n \n \n \n Digital Assets \n Consume Applications \n In the development lifecycle of an application, Consume is the execution stage where end users interact with the app to complete certain tasks. On Entando, the modular design of the components and services means each can be scaled individually or as a whole, according to those interactions. Likewise, content can be added or changed, engine rules adapted and upgrades made seamlessly. As a result, the development cycle is a continuous process with minimal disruptions and faster time to market. \n \n \n \n Documentation \n Tutorials \n \n \n \n \n Accessibility \n External Identity Management System \n \n \n Entando Operator \n Add REST API \n \n \n Entando APIs \n Invoke Entando core APIs \n \n \n Custom Resources \n Change Default Datasource \n \n \n Entando Identity Management System \n \n \n \n \n"},{title:"Quick Reference",frontmatter:{},regularPath:"/v6.3.2/docs/getting-started/quick-reference.html",relativePath:"v6.3.2/docs/getting-started/quick-reference.md",key:"v-199e73e8",path:"/v6.3.2/docs/getting-started/quick-reference.html",headers:[{level:2,title:"Quick Reference",slug:"quick-reference"}],lastUpdated:"5/27/2021, 4:26:21 AM",lastUpdatedTimestamp:1622103981e3,content:" Quick Reference \n Just the steps, for advanced users. \n \n Install  Multipass \n Launch VM \n multipass launch --name ubuntu-lts --cpus  4  --mem 8G --disk 20G\n \n Open Ubuntu shell \n multipass shell ubuntu-lts\n \n Install k3s \n curl  -sfL https://get.k3s.io  |   sh  -\n \n Check for node ready \n sudo  kubectl get  node \n \n Create namespace \n sudo  kubectl create namespace entando\n \n Deploy custom resource definitions \n sudo  kubectl apply -f https://raw.githubusercontent.com/entando/entando-releases/v6.3.2/dist/ge-1-1-6/namespace-scoped-deployment/cluster-resources.yaml\n \n Deploy namespace scoped assets \n sudo  kubectl apply -n entando -f https://raw.githubusercontent.com/entando/entando-releases/v6.3.2/dist/ge-1-1-6/namespace-scoped-deployment/orig/namespace-resources.yaml\n \n Download Helm chart (or  generate your own ) \n curl  -sfL https://github.com/entando-k8s/entando-helm-quickstart/archive/v6.3.2.tar.gz  |   tar  xvz\n \n Configure external access to your cluster with your VM IP \n hostname  -I  |   awk   '{print $1}' \n \n Edit the file in  sample-configmaps/entando-operator-config.yaml  and uncomment the value for  entando.default.routing.suffix:  and set the value to the IP address of your Ubuntu VM plus  .nip.io . For example,  entando.default.routing.suffix: 192.168.64.21.nip.io . Pay attention to yaml spacing \n Deploy Entando \n sudo  kubectl apply -f sample-configmaps/entando-operator-config.yaml -n entando\n \n sudo  helm template quickstart ./  |   sudo  kubectl apply -n entando -f -\n \n Check for  quickstart-composite-app-deployer  with a status of completed using the command below \n sudo  kubectl get pods -n entando --watch\n \n Get URL to access Entando App Builder from your browser \n sudo  kubectl get ingress -n entando -o  jsonpath = '{.items[2].spec.rules[*].host}{.items[2].spec.rules[*].http.paths[1].path}{\"\\n\"}' \n \n "},{title:"Concepts Overview",frontmatter:{redirectFrom:"/v6.3.2/docs/concepts/concepts-overview.html"},regularPath:"/v6.3.2/docs/getting-started/concepts-overview.html",relativePath:"v6.3.2/docs/getting-started/concepts-overview.md",key:"v-686eeb8c",path:"/v6.3.2/docs/getting-started/concepts-overview.html",headers:[{level:2,title:"Entando App Engine",slug:"entando-app-engine"},{level:2,title:"Entando App Builder",slug:"entando-app-builder"},{level:2,title:"Entando Component Generator",slug:"entando-component-generator"},{level:2,title:"Entando Component Repository",slug:"entando-component-repository"},{level:2,title:"Entando Identity Management",slug:"entando-identity-management"},{level:2,title:"Entando WCMS",slug:"entando-wcms"},{level:2,title:"Entando Cluster Citizens",slug:"entando-cluster-citizens"},{level:3,title:"Architecture Diagram",slug:"architecture-diagram"},{level:3,title:"Members of the Cluster",slug:"members-of-the-cluster"},{level:2,title:"Entando Ingresses",slug:"entando-ingresses"},{level:3,title:"What is an Ingress?",slug:"what-is-an-ingress"},{level:3,title:"How Ingresses are used in an Entando Cluster",slug:"how-ingresses-are-used-in-an-entando-cluster"},{level:3,title:"Default Ingress HTTP Routes",slug:"default-ingress-http-routes"},{level:3,title:"Exposing Plugins in the EntandoApp Domain",slug:"exposing-plugins-in-the-entandoapp-domain"},{level:3,title:"How to check Ingresses in my Cluster",slug:"how-to-check-ingresses-in-my-cluster"},{level:3,title:"Learn More",slug:"learn-more"}],lastUpdated:"3/30/2022, 4:33:36 PM",lastUpdatedTimestamp:1648672416e3,content:' Concepts Overview \n A portal, website, web app, or mobile app built with Entando is called an Entando application.\nAn Entando application is an assembly of out of the box and/or custom built components running on the\nEntando Platform. Components can be widgets, micro frontends, microservices, page templates, WCMS content or WCMS content types. \n Entando App Engine \n The Entando App Engine is the heart of the Entando Platform by providing the primary out-of-the-box services for\ndeveloping applications. Key features: \n \n Expose the APIs the Entando App Builder uses to provide the page and content management interface for your application. \n Handle the work of assembling micro frontends and microservices and combining them on specific pages as defined by the Entando App Builder. \n Provide the data access layer to persist the page and application design. \n Manage the cluster infrastructure. \n \n See also:  APIs tutorial \n Entando App Builder \n The  Entando App Builder  is the feature-rich management interface used to design and build pages for Entando applications. \n See also:  Widget Tutorial \n Entando Component Generator \n The Entando Component Generator is Entando\'s implementation of  JHipster  that allows users to\nquickly and efficiently generate the skeleton of an Entando Component. The Entando Component Generator provides advanced\ndata modeling capabilities including object relational mapping and automatic generation of micro frontends and microservices.\nThe generated skeleton serves as a starting point to help a development team swiftly meet the needs of the business. \n See also:  Generate Microservices and Micro Frontends  \n Entando Component Repository \n The  Entando Component Repository  (ECR) is used to store and retrieve shareable components so they can be used in multiple\nEntando applications across the enterprise. \n Entando Identity Management \n Entando Identity Management  is the  Keycloak -based token-based authentication mechanism used by the\nEntando platform. It provides the ability to add Single Sign On capabilities across multiple domains and to connect service\nproviders with identity providers. \n See also:  Entando Authentication \n Entando WCMS \n The Entando Web Content Management System (WCMS) is a lightweight content and digital asset management system with support\nfor headless operation. It allows management of widgets and html fragments so they can be placed within an Entando application. \n See also:  Content Types  or  Content Templates \n Entando Cluster Citizens \n The purpose of this guide is to give an overview of the members of an Entando cluster and their role. \n Architecture Diagram \n Let’s start with a picture of an Entando 6 cluster and how the various\nmembers interact with each other. \n Members of the Cluster \n An Entando 6 cluster is composed of various citizens which interact with\neach other. Most of these citizens have a Custom Resource Definition\nfile associated with them and are deployable on Kubernetes using the\nEntando operator and controllers. \n Entando App \n An Entando application is composed of three parts: \n \n \n Entando App Builder : the user interface to customize and build an Entando application, as well as interact with the Entando Component Repository. \n \n \n Entando App Engine : the backend APIs providing access to Entando\nservices. \n \n \n Entando Component Manager : the service providing the Entando\nComponent Repository functionality, e.g. listing the available\nbundles, install/uninstall a bundle, etc. \n \n \n The interaction between these three components (and the rest of the\nEntando cluster) use the authorization/authentication features provided\nby Keycloak. \n Entando Component Manager \n As briefly introduced before, the  Entando Component Manager  is able to\nlist the EntandoDeBundles accessible from the EntandoApp and provide the\ninstall/uninstall services to install a bundle on an Entando App. All of\nthese services are made possible by the communication with the Entando\nKubernetes service, the only service of the Entando ecosystem (other\nthan the operator itself) able to interact with the cluster and some of\nthe Entando Custom Resources. \n Entando Kubernetes Service \n The Entando Kubernetes Service is part of the Entando cluster\ninfrastructure custom resource, and provides an access point to some of\nthe custom resources defined by Entando, in particular: \n \n \n Entando applications \n \n \n Entando plugins \n \n \n Entando links \n \n \n Entando Component Repository bundles \n \n \n Some of the main services provided by the Entando Kubernetes Service\nare: \n \n \n Provide a list of the available EntandoDeBundles to the\ncomponent-manager \n \n \n Deploy a plugin during the installation of a bundle or discovery of\nan already available plugin and expose that to an app \n \n \n Create a link between an EntandoApp and an EntandoPlugin to expose\nthe plugin’s APIs to the EntandoApp and the micro frontends (MFEs) \n Entando Component Repository Bundles \n An EntandoDeBundle - or Component Repository bundle - is a package with\na set of Entando components and resources. The Entando component manager\nis able to read these kind of packages and install the components to\nextend the functionalities of an EntandoApp. For more details on the\nEntandoDeBundle and the Entando Component Repository, check the\n component repository overview \ndocumentation \n Entando Plugin \n An Entando plugin is a microservice that exposes APIs reusable by one or\nmore Entando apps. Usually the plugin services are exposed to the\nEntando developer and the end users via micro frontends. Check the\n micro frontends  tutorials for more details or explore  Entando JHipster Blueprint  which makes customizing easier. You can also quickly  generate an Entando plugin here . The generated project\nwill be ready to work in an Entando environment providing the\nintegration with Keycloak, generating a set of default micro frontends\nand exposing the plugin’s logic via an EntandoDeBundle (check the\nreferences for details). \n Keycloak \n Keycloak in Entando 6 is responsible for authorization and\nauthentication All the members of an Entando 6 cluster interact with\nkeycloak to verify user/service authorization to perform any specific\ntask. Check out the references below for more details on keycloak. \n Entando Ingresses \n What is an Ingress? \n An Ingress is a Kubernetes resource which purpose is to expose HTTP and HTTPS routes from outside the cluster to services within the cluster. Traffic routing is controlled by rules defined on the Ingress resource. \n How Ingresses are used in an Entando Cluster \n When deploying an Entando Cluster, ingresses are generated for the resources that requires to be exposed to the outside world. The process of creating an ingress, setup the correct routes and the certificates is done by the via the Entando Operator and the entando custom resource controllers. \n Keycloak Ingress \n An dedicated ingress is created for keycloak to expose the authentication and authorization functionalities. Having a dedicated ingress is required to guarantee that both token issuing and token validation work correctly, even when the services using the keycloak instance are on different namespaces. \n Cluster Infrastructure Ingress \n Another ingress is created for the cluster infrastructure services in order to expose the api endpoint to interact with the cluster correctly \n EntandoApp Ingress \n Another ingress is automatically created to expose App builder, App engine and the Entando component manager, a service part of the ECR.\nThe three containers are served under the same domain, and this is beneficial as they are able to interact without cross-origin issues. \n The Entando App ingress is also used when linking an Entando Plugin with and Entando App, operation that usually happens when a bundle containing an Entando Plugin is installed via the ECR in an Entando App. Check out the dedicated section for details. \n Entando Plugin Ingress \n Also Entando Plugins are automatically exposed via an ingress when deployed in an Entando Cluster. \n Default Ingress HTTP Routes \n In this table you can see what are the default routes that are exposed for each ingress\n \n \n \n \n \n \n \n Ingress \n Ingress Http route \n Application \n \n \n \n \n Keycloak ingress \n /auth \n Keycloak \n \n \n Entando cluster infrastructure ingress \n /k8s \n Entando K8S service \n \n \n Entando App ingress \n /entando-de-app \n App engine \n \n \n /app-builder/ \n App builder \n \n \n /digital-exchange \n Entando component manager \n \n \n /<plugin-ingressPath> \n Entando plugin linked to the app \n \n \n Entando plugin ingress \n /<plugin-ingressPath> \n Entando plugin \n \n \n \n Note : The Entando plugin  ingressPath  variable is defined in the Entando Plugin custom resource under the  spec  element. The plugin ingress path is also used to expose the plugin under the Entando App domain \n Exposing Plugins in the EntandoApp Domain \n The process of exposing an Entando Plugin under the same domain (ingress) of the Entando App is made possible from the creation of an  EntandoAppPluginLink  custom resource and the corresponding controller. \n Once the link between the Entando App and the Entando Plugin is created, the controller reads the specification of such link and automatically creates the HTTP routes in the Entando App so that the plugin is exposed on the same domain as the App builder, App engine and Component manager. \n This allows the Microfrontend developers that need to access the plugin to not worry about CORS policy or knowing what is the full path where the plugin is exposed. The plugin is referencable using relative urls. \n How to check Ingresses in my Cluster \n Using the Openshift Dashboard \n On the Openshift dashboard, Ingresses are not exposed directly as pods and deployments. The dashbaord provides direct access to the Ingress Routes (or simply routes) under the  Applications > Routes  menu. \n \n To see the ingress resources, you need to access them from the  Resources > Other resources  menu. From the dropdown you should select the  Ingress  resource and therefore you should be able to see the ingress available on that specific project/namespace \n Using kubectl from the Command Line \n From the command line, getting the ingress is very easy. Once you know the namespace(s) where your Entando Cluster is deployed, you simply need to use the \n kubectl get ingresses.extensions -n <namespace>\n \n Here an example of the result in a test namespace \n > kubectl get ingresses.extensions -n local\n\nNAME               CLASS    HOSTS                               ADDRESS     PORTS   AGE\nqst-eci-ingress   <none>   qst-eci-local.192.168.1.9.nip.io   127.0.0.1   80      2d1h\nqst-ingress       <none>   qst-local.192.168.1.9.nip.io       127.0.0.1   80      2d1h\nqst-kc-ingress    <none>   qst-kc-local.192.168.1.9.nip.io    127.0.0.1   80      2d1h\n \n To get more details about a specific ingress, you can use the  get  command specifing the ingress name you want to check and the  yaml  output format \n > kubectl get ingresses.extensions -n local qst-ingress -o yaml\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  creationTimestamp: "2020-05-13T15:27:08Z"\n  generation: 1\n  labels:\n    EntandoApp: qst\n  managedFields:\n  - apiVersion: extensions/v1beta1\n    fieldsType: FieldsV1\n    fieldsV1:\n      f:status:\n        f:loadBalancer:\n          f:ingress: {}\n    manager: nginx-ingress-controller\n    operation: Update\n    time: "2020-05-13T15:27:08Z"\n  name: qst-ingress\n  namespace: local\n  ownerReferences:\n  - apiVersion: entando.org/v1\n    blockOwnerDeletion: true\n    controller: true\n    kind: EntandoApp\n    name: qst\n    uid: aa7053e1-fd8b-419f-bdee-df3018c013fa\n  resourceVersion: "16802097"\n  selfLink: /apis/extensions/v1beta1/namespaces/local/ingresses/qst-ingress\n  uid: e9b6f027-369a-4b84-b4b1-736a6e49f180\nspec:\n  rules:\n  - host: qst-local.192.168.1.9.nip.io\n    http:\n      paths:\n      - backend:\n          serviceName: qst-server-service\n          servicePort: 8080\n        path: /entando-de-app\n        pathType: ImplementationSpecific\n      - backend:\n          serviceName: qst-server-service\n          servicePort: 8083\n        path: /digital-exchange\n        pathType: ImplementationSpecific\n      - backend:\n          serviceName: qst-server-service\n          servicePort: 8081\n        path: /app-builder/\n        pathType: ImplementationSpecific\nstatus:\n  loadBalancer:\n    ingress:\n    - ip: 127.0.0.1\n Learn More \n For more details about ingress concept in Kubernetes please refer to the official documentation: \n \n Kubernetes Ingress documentation \n Openshift Routes documentation \n \n'},{title:"Cluster Resource Limits",frontmatter:{},regularPath:"/v6.3.2/docs/reference/cluster-resource-limits.html",relativePath:"v6.3.2/docs/reference/cluster-resource-limits.md",key:"v-18d45c68",path:"/v6.3.2/docs/reference/cluster-resource-limits.html",headers:[{level:3,title:"Bundle size limitations",slug:"bundle-size-limitations"}],lastUpdated:"1/31/2022, 11:56:50 AM",lastUpdatedTimestamp:164364821e4,content:" Cluster Resource Limits \n Entando needs a well-defined amount of resources in order to start and Kubernetes takes care of using only the needed amount of them.\nHowever, you can choose to impose boundaries on the minimum and maximum used/allocated resources by updating the downloaded  entando.yaml  file and setting the  ENTANDO_K8S_OPERATOR_IMPOSE_DEFAULT_LIMITS  property to true.\nIn this way, Entando will allocate a predefined amount of resources and Kubernetes will act more strictly checking for resource availability. See  Kubernetes resources  for more information. \n By not imposing limits you can minimize initial needed resources and startup time, leaving Kubernetes free to manage its resources as he wants.\nBy imposing limits you can obtain a better-balanced system. \n It's important to note that, accordingly to the Kubernetes documentation, in order to deploy on a namespace with a\n ResourceQuotas  on memory and cpu, \n \n every Container must have a memory request, memory limit, cpu request, and cpu limit \n \n so, in that case, you will need to set  ENTANDO_K8S_OPERATOR_IMPOSE_DEFAULT_LIMITS  to true, otherwise your deploy will fail. \n Here you can see the detailed resource requests/limits per container: \n \n \n \n Component \n Mem requests \n CPU requests \n Mem limits \n CPU limits \n \n \n \n \n AppBuilderDeployableContainer \n 128Mi \n 125m \n 512Mi \n 500m \n \n \n EntandoAppDeployableContainer \n 448Mi \n 375m \n 1792Mi \n 1500m \n \n \n ComponentManagerDeployableContainer \n 192Mi \n 188m \n 768Mi \n 750m \n \n \n EntandoPluginSidecarDeployableContainer \n 192Mi \n 188m \n 768Mi \n 750m \n \n \n EntandoPluginDeployableContainer \n 256Mi \n 250m \n 1024Mi \n 1000m \n \n \n EntandoK8SServiceDeployableContainer \n 192Mi \n 250m \n 768Mi \n 1000m \n \n \n KeycloakDeployableContainer \n 192Mi \n 250m \n 768Mi \n 1000m \n Bundle size limitations \n Entando supports bundles without size limitations, you can install as many bundles as you want and bundles as big as you desire. \n The only thing you have to check is the  <YOUR-APP-NAME>-de-pvc  volume size. Each bundle is installed in that volume, so when it reaches its maximum capacity you will not be able to install bundles anymore. \n You can find  quickstart-de-pvc  volume inside de-container container, that is part of the pod named  <YOUR-APP-NAME>-server-deployment-*** , where asterisks should assume values based on your instance.\nFeel free to set its size accordingly to your needs. \n"},{title:"Caching and Clustering in an Entando Application",frontmatter:{},regularPath:"/v6.3.2/docs/reference/caching-and-clustering.html",relativePath:"v6.3.2/docs/reference/caching-and-clustering.md",key:"v-64e2fc7c",path:"/v6.3.2/docs/reference/caching-and-clustering.html",headers:[{level:2,title:"App Engine Clustering and High Availability",slug:"app-engine-clustering-and-high-availability"},{level:2,title:"Storage Requirements for Clustered Entando Applications",slug:"storage-requirements-for-clustered-entando-applications"},{level:2,title:"Caching",slug:"caching"},{level:3,title:"Data Management",slug:"data-management"},{level:2,title:"Infinispan Implementation (Default)",slug:"infinispan-implementation-default"},{level:2,title:"Redis Implementation",slug:"redis-implementation"},{level:2,title:"Performance",slug:"performance"},{level:3,title:"Cache Management",slug:"cache-management"}],lastUpdated:"1/31/2022, 10:10:51 AM",lastUpdatedTimestamp:1643641851e3,content:' Caching and Clustering in an Entando Application \n App Engine Clustering and High Availability \n The Entando App Engine can be deployed as a clustered set of instances using the clustering and replication ability of Kubernetes. It is backed by a shared cache with two default choices for implementation. \n This guide demonstrates how to configure and test a clustered instance of the Entando App Engine. \n Microservices clustering that adds functionality to an Entando Application is different from clustering used by the Entando App Engine. Microservices rely on a custom clustering configuration and setup based on implementation and selections made during their creation. Refer to documentation addressing clustered microservices and caching implementation for configuration and deployment details. \n Storage Requirements for Clustered Entando Applications \n To scale an Entando Application across multiple nodes a storage class that supports a  ReadWriteMany  access policy must be instantiated. There are a number of ways to accomplish this, inclusive of dedicated storage providers such as GlusterFS. Cloud Kubernetes providers also offer clustered storage options specific to their implementation, such as Google Cloud File in GKE or Azure Files in AKS. \n Two different storage classes can be used for clustered vs non-clustered storage if the default class doesn\'t support  ReadWriteMany . To achieve this, add the following properties to the operator config map in the helm templates: \n entando.k8s.operator.default.clustered.storage.class: "[clustered RWX storage class]"\nentando.k8s.operator.default.non.clustered.storage.class: "[RWO storage class]"\n \n Set both values to the storage class appropriate to the configuration. \n TIP \n To scale an Entando Application without the use of clustered storage assumes all instances are scheduled to a single node and requires a  ReadWriteOnce (RWO)  policy in conjunction with taints on other nodes. Understanding the pros and cons of same-node scheduling is critical for node resource optimization and application recovery, should the instance become unreachable. Note that if the node quits or is shut down the application will be unavailable until Kubernetes reschedules the pods to an alternate node. \n Caching \n Data Management \n At startup the Entando App Engine will load all database data into the shared cache. Applicable content will be served from the cache when a page is rendered or content is fetched. In the event of a write to the cache, both the cache and database will be updated. \n The following objects are cached in the base implementation of Entando App Engine: \n \n Pages \n Page templates \n Categories \n Widgets \n Configuration (Application level configuration) \n Roles \n Groups \n Languages \n Labels (i18n) \n User profiles \n API Catalog (legacy API metadata separate from swagger) \n Data models and data types (deprecated) \n Infinispan Implementation (Default) \n The default implementation of the Entando App Engine cache is included in the quickstart and base images of the release and utilizes  Infinispan in Library Mode . It is managed through configuration of the application server hosting the Entando App Engine. \n \n Add replicas of the Entando App Engine (entando-de-app) to a deployment to take advantage of the base implementation. Note that new pods will automatically join the cluster. A high availability deployment distributed across nodes is a function of the deployment objectives and underlying Kubernetes implementation. The party responsible for cluster and application implementation must ensure that applications are scheduled and deployed in accordance with uptime and performance goals. \n Read more here  for tutorials and step-by-step instructions to use the Infinispan cache in an Entando Application. \n Redis Implementation \n An Entando Application can also be configured to utilize an external  Redis  cache. In a Redis implementation of an Entando Application the cache is deployed independently of the Entando App Engine and the Entando App Engine is configured to connect to the deployed instance. \n \n The Redis cache is not deployed by the Entando Operator and must be managed by a DevOps team member or Kubernetes cluster administrators. \n Read more here  for tutorials and step-by-step instructions to use a Redis cache in an Entando Application. \n Performance \n Consider the following when designing an Entando App Engine cluster: \n \n In a read only implementation, or an implementation with infrequent writes to the cached objects listed above, the network latency between pods on different nodes will not be a major driver of runtime performance. Each pod will have a fully replicated copy of the cache. \n In write heavy implementations network latency between nodes can factor into performance. \n The overall performance impact of network latency will vary depending upon implementation. Performance is impacted by the types of objects written, the size of those objects, and whether the writes invalidate single or entire lists of objects in the cache. \n \n It is generally recommended that performance testing on clustered instances correlates to the expected runtime traffic pattern of a live application. Every application will have a unique performance profile. \n Cache Management \n When a new replica of an Entando Application joins a cluster of applications the cache is replicated to that node. If the cache is relatively large or the network is slow this may add to the total startup time of the new instance. Existing instances will continue to function. \n'},{title:"Manage Entando Databases",frontmatter:{},regularPath:"/v6.3.2/docs/reference/databases.html",relativePath:"v6.3.2/docs/reference/databases.md",key:"v-78763ecc",path:"/v6.3.2/docs/reference/databases.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Lightweight, low-config Databases with PostgreSQL and MySQL",slug:"lightweight-low-config-databases-with-postgresql-and-mysql"},{level:2,title:"Existing External Databases",slug:"existing-external-databases"},{level:3,title:"Structure",slug:"structure"},{level:3,title:"How it works",slug:"how-it-works"},{level:3,title:"Keeping track of credentials",slug:"keeping-track-of-credentials"},{level:2,title:"Vendor specific notes",slug:"vendor-specific-notes"},{level:3,title:"Oracle",slug:"oracle"},{level:3,title:"Notes",slug:"notes"},{level:3,title:"MySQL",slug:"mysql"},{level:3,title:"Resulting Connection String",slug:"resulting-connection-string-2"},{level:3,title:"Notes",slug:"notes-2"},{level:3,title:"PostgreSQL",slug:"postgresql"},{level:2,title:"Skipping database preparation",slug:"skipping-database-preparation"},{level:3,title:"How it works",slug:"how-it-works-2"}],lastUpdated:"5/19/2021, 9:29:46 AM",lastUpdatedTimestamp:1621430986e3,content:' Manage Entando Databases \n Overview \n Entando’s Docker images currently support three different relational\ndatabase management systems: PostgreSQL, MySQL and Oracle. With\nPostgreSQL and MySQL, by default, Entando’s will automatically create a\nKubernetes Deployment hosting the database management systems. However,\nfor Oracle, and also for other scenarios that may require it, Entando\nsupports connectivity to existing external databases. This document\nprovides the user with the necessary information to decide how to manage\nEntando’s databases. \n Lightweight, low-config Databases with PostgreSQL and MySQL \n When deploying Entando Custom Resources that require databases to a new\nNamespace, the default behavior for Entando is to create a Kubernetes\nDeployment. It uses the standard Openshift compliant images: \n \n \n centos/mysql-57-centos7 and \n \n \n centos/postgresql-96-centos7) \n \n \n This is a fairly low-configuration approach, as Entando will create and\ninitialize the databases transparently. Persistent data is stored on any\nPersistent Volume that meets our Persistent Volume Claim requirements.\nWhen an Entando Custom Resource is redeployed, the Persistent Volumes\nremain in tact. Since the subsequent data initialization is idempotent,\nthe supporting Deployments will scale up and behave as expected. \n Generally our services encapsulate the database they use entirely, and\nprovide facilities to import and export the data without needing any\nknowledge of the internal workings of the underlying data store. For\nmost simple Entando Apps the database doesn’t grow too large and is\nfairly easy to manage. This state of affairs allowed us to keep our\ndatabases isolated from each other, thus allowing for isolated\ndeployments without needing complex coordination of database migration\nfor the different deployment pipelines. \n It is worth noting that these database Deployments are not clustered.\nThe customer is therefore strongly advised to provide redundancy and\nclustering in the form of clustered storage. These database deployments\ndo specify a restartPolicy of \'Always\', so in the event of a\nnon-corrupting failure, the database Pod should therefore restart in\nabout 30 seconds. This by no means offers the features of a full\ndatabase cluster, but may suffice for many scenarios. \n However, in more advanced use cases, such as the use of our CMS\nfunctionality, this simplistic approach may not scale. And where there\nis a a centralized database admin team, or where there is a requirement\nto comply to strict organizational governance w.r.t. databases, this\napproach does result in a multitude of databases that may be difficult\nfor the database admin team to manage. \n Existing External Databases \n For this reason, Entando can also be configured to use an existing\ndatabase service provided by the customer. In these scenarios, the\ncustomer is expected to take responbility for the lower level database\noperations such as tablespace creation, permissions and clustering.\nEntando will however still be responsible for creating and populating\nthe tables, indices and foreing keys. Entando will also create all of\nthese in the appropriate table \'container\' for the DBMS in question such\nas a schema (Oracle/PostgreSQL) or a database (MySQL). In order to\nachieve this, Entando installs a dedicated CustomResourceDefinition in\nKubernetes, called an \'EntandoDatabaseService\' \n The idea is for EntandoDatabaseService custom resources to be created in\nthe namespace the EntandoApps and EntandoPlugin that should use them\nwill be created. The EntandoDatabaseService is usually created along\nwith a secret that carries admin credentials to the database in\nquestion. \n Structure \n The EntandoDatabaseService custom resource looks like this: \n  EntandoDatabaseService\nmetadata:\n  name: string, any K8S compliant name\n  namespace: string, the namespace this will be created in\nspec:\n  dbms: string, one of oracle, postgresql or mysql\n  host: string, either an ip address or hostname where the database service is hosted\n  port: integer, the port on which the database service is hosted\n  databaseName: string, the name of the database, only required for PostgreSQL and Oracle\n  secretName: the name of the Secret in the same namespace carrying admin credentials to the database service\n  tablespace: (Oracle only)  the tablespace to use to create the required schemas in\n  jdbcParameters: a map containing name-value pairs for any additional parameters required for the JDBC driver to connect to the database.\n \n The Secret that will provide the admin credentials, identified by the\nabove  secretName  should look like this: \n Secret:\n  name: string, any K8S compliant name\n  namespace: string, the namespace this will be created in\n  stringData:\n    username: string, name of an admin user that can create schemas and other users\n    password: string, password of the above user\n How it works \n In order for the EntandoApp and EntandoPlugin deployer to pick up the\ncorrect database service, the EntandoDatabaseService needs to be created\nBEFORE the EntandoApps and EntandoPlugins are created. There can be\nmultiple EntandoDatabaseServices in the namespace, but they need to\npoint to database services of different vendors, i.e. PostgreSQL, Oracle\nand MySQL. Entando currently cannot enforce any validation but if there\nare two EntandoDatabaseServices that have the same DBMS vendor, it will\nsimply pick the first one and continue. Please ensure that only one\nEntandoDatabaseService exists for each DBMS vendor you need to use. \n Once the appropriate EntandoDatabaseServices have been created, any\nEntandoApp or EntandoPlugin that is created will have to specify the\nappropriate DBMS vendor in their  spec.dbms  property. If the\nEntandoOperator detects an EntandoDatabaseService with a matching DBMS\nvendor, it will continue to create the necessary schemas on the specific\ndatabase. If the EntandoOperator does not detect an\nEntandoDatabaseService with a matching DBMS vendor, it will fall back\nonto its default behaviour which is to create a matching Deployment and\nspin up a database service from the same namespace. If the  spec.dbms \nproperty is not specified on an EntandoApp, the EntandoOperator will\ndefault to PostgreSQL. If the  spec.dbms  property is not specified on\nan EntandoPlugin, the EntandoOperator will assume that the EntandoPlugin\nin question does not require a database and hence bypass any database\nand schema creation. \n When the EntandoOperator processes your Entandoapp or EntandoPlugin with\nan appropriate  spec.dbms  specified, it will create a Schema/User pair\nfor each datasource required. A typical EntandoApp deployment requires 3\ndatasources (portdb,servdb and dedb). Plugins generally only require one\ndatasource (plugindb). \n The database schema and user created will have the same name. The name\nis derived from the name of the EntandoPlugin or EntandoApp by replacing\nall characters that are not ANSI-SQL compliant with an underscore. The\ndatasource name is then suffixed to the schema name. When defining the\nname of your app or plugin, please keep in mind that some DBMS vendors\ndo not support long schema names. Future versions of Entando will allow\nyou to override the schema prefix for an app or plugin, but for now this\nis a limitation one has to keep in mind. \n Keeping track of credentials \n The EntandoOperator generates a Kubernetes Secret for each schema/user\ncombination it creates. The name of this secret is the concatenation of\nthe name of the EntandoApp or EntandoPlugin, the datasource qualifier\nand then the suffix "-secret". For instance, for an EntandoApp called\n"my-app" the "portdb" datasource will have a corresponding Kubernetes\nSecret called "my-app-portdb-secret". The EntandoOperator will never\noverwrite or update an existing database secret. We generate a random\nstring for the password which is generally considered the safest\napproach. If you do however wish to change the password in for the\nresulting user, please remember to update the password on the Kubernetes\nSecret too. Such an operation is however error prone and could result in\nsubsequent deployments failing. \n The EntandoOperator’s schema creation logic is idempotent. If it\ntherefore finds that the generated schema/user combination found in the\nassociated Kuberentes Secret already exists, it won’t do anything.\nHowever, it will attempt to log in, and if it fails to log in, it will\nattempt to create the user. If the user already exists, but with a\ndifferent password than the one in the Kubernetes Secret, all subsequent\ndeployment operations will fail. \n Vendor specific notes \n Oracle \n Example \n   EntandoDatabaseService\n    metadata:\n      name:oracle-service\n    spec:\n      dbms: oracle\n      host: 10.0.0.13\n      port: 1521\n      databaseName: ORCLPDB1.localdomain\n      secretName: oracle-secret\n      tablespace: entando_ts\n      jdbcParameters: {}\n  Secret:\n    metadata:\n      name: oracle-secret\n    stringData:\n      username: admin\n      password: admin123\n Resulting connection string: \n jdbc:oracle:thin:@//10.0.0.13:1521/ORCLPDB1.localdomain \n Notes \n Oracle has some rather complicated rules in building the correct\nconnection string. Please note that for the sake of portability and\nlightweight image we are limited to the thin driver. The  databaseName \ncould also be an Oracle service as opposed to an Oracle  SID . Please\ncoordinate with your Oracle DB Admin to determine exactly what value to\nuse here. We strongly recommend testing your settings with some code or\na tool that constructs JDBC connection. \n When the EntandoOperator prepares the schemas for your EntandoApp or\nEntandoPlugin, it will create a user for every datasource required, and\nas is standard behaviour for Oracle, that user will have its own schema\nwith the same name. Permissions are set up to ensure that one user\ncannot access tables from another user’s schema. Please note that Oracle\nlimits schema names to 30 characters. If you intend to use Oracle,\nplease keep the name of your apps and plugins short enough. The suffixes\nthat we append to the app or plugin name to ensure the resulting schema\nname is unique are usually shorter than 8 characters, so names of about\n20 characters should be safe. \n You can specify which tablespace Entando should use to create the\nschemas in using the  spec.tablespace  property \n ORA-01704: string literal too long \n Entando requires extended datatypes to be activated in Oracle 12c and\nhigher\n( https://oracle-base.com/articles/12c/extended-data-types-12cR1 ) \n MySQL \n Example \n EntandoDatabaseService\n  metadata:\n    name:mysql-service\n  spec:\n    dbms: mysql\n    host: 10.0.0.13\n    port: 3306\n    databaseName:\n    secretName: mysql-secret\n    jdbcParameters:\n       useSSL: "true"\nSecret:\n  metadata:\n    name: mysql-secret\n  stringData:\n    username: admin\n    password: admin123\n Resulting Connection String \n jdbc:mysql://10.0.0.13:3306 \n Notes \n MySQL doesn’t really support schemas, or more accurately, it doesn’t\ndistinguish between schemas and databases. For this reason, no\ndatabaseName is required. The EntandoOperator will therefore create an\nentirely new database for each datasource your EntandoApp or\nEntandoPlugin requires. It will also create a user with the same name as\nthe database with permission set up to ensure one user cannot access the\ndatabase of another user. Please note that MySQL limits database names\nto 63 characters. Keep this in mind when defining the names of your\nEntandoApps and EntandoPlugins \n PostgreSQL \n Example \n   EntandoDatabaseService\n    metadata:\n      name:postgresql-service\n    spec:\n      dbms: postgresql\n      host: 10.0.0.13\n      port: 5432\n      databaseName: my_db\n      secretName: postgresql-secret\n      jdbcParameters: {}\n\n  Secret:\n    metadata:\n      name: postgresql-secret\n    stringData:\n      username: admin\n      password: admin123\n Resulting Connection String \n jdbc:postgresql://10.0.0.13:5432/my_db \n Notes \n PostgreSQL behaves very similar to Oracle when it comes to how it\nassociates a user with its own schema. The current username is used as a\ndefault schema/prefix to resolve tables. As with Oracle, Entando ensures\nthat two users don’t have access to each other’s schemas. \n Skipping database preparation \n When an Entando App is being deployed, there is an operator responsible for the entire deployment process. It takes care also of DB creation and preparation.\nIf you have an already prepared DB (schemas, tables, and all other stuff), you could skip schemas creation and DB preparation of the EntandoApp in order to speed up the deploy process. \n You can achieve this by specifying some properties for the EntandoApp component present in the helm generated file. Look at  this  for more info. \n For  spec.dbms  property you should choose  none , then you should add all needed DB connection parameters.\nAfter updating parameters with the one you need, you should end with a yaml like this: \n - kind: "EntandoApp"\n  metadata:\n    annotations: {}\n    labels: {}\n    name: "example-qs"\n  spec:\n    dbms: "none"\n    replicas: 1\n    standardServerImage: wildfly\n    ingressPath: /entando-de-app\n    environmentVariables:\n      - name: SPRING_DATASOURCE_USERNAME\n        value: admin\n      - name: SPRING_DATASOURCE_PASSWORD\n        value: adminadmin\n      - name: SPRING_DATASOURCE_URL\n        value: "jdbc:postgresql://192.168.1.82:5432/testdb?currentSchema=admin_qs_dedb"\n      - name: SPRING_JPA_DATABASE_PLATFORM\n        value: org.hibernate.dialect.PostgreSQLDialect\n      - name: PORTDB_URL\n        value: "jdbc:postgresql://192.168.1.82:5432/testdb?currentSchema=admin_qs_portdb"\n      - name: PORTDB_USERNAME\n        value: admin\n      - name: PORTDB_PASSWORD\n        value: adminadmin\n      - name: PORTDB_CONNECTION_CHECKER\n        value: org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLValidConnectionChecker\n      - name: PORTDB_EXCEPTION_SORTER\n        value: org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLExceptionSorter\n      - name: SERVDB_URL\n        value: "jdbc:postgresql://192.168.1.82:5432/testdb?currentSchema=admin_qs_servdb"\n      - name: SERVDB_USERNAME\n        value: admin\n      - name: SERVDB_PASSWORD\n        value: adminadmin\n      - name: SERVDB_CONNECTION_CHECKER\n        value: org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLValidConnectionChecker\n      - name: SERVDB_EXCEPTION_SORTER\n        value: org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLExceptionSorter\n How it works \n Using  spec.dbms: "none"  will cause the operator to skip that initial schema/user creation step entirely.\nThen adding those variables under the  spec.environmentVariables  section will supply connection parameters that will be used by EntandoApp.\nKeep in mind that all these parameters will be applied to each of the containers in the EntandoApp pod and that they will also override existing values. \n'},{title:"Entando Deployment Structure",frontmatter:{},regularPath:"/v6.3.2/docs/reference/deployment-structure.html",relativePath:"v6.3.2/docs/reference/deployment-structure.md",key:"v-78ffa47e",path:"/v6.3.2/docs/reference/deployment-structure.html",headers:[{level:2,title:"entando-operator",slug:"entando-operator"},{level:2,title:"database init containers",slug:"database-init-containers"},{level:2,title:"entando-de-app",slug:"entando-de-app"},{level:2,title:"app-builder",slug:"app-builder"},{level:2,title:"component-manager",slug:"component-manager"},{level:2,title:"entando-k8s-service",slug:"entando-k8s-service"},{level:2,title:"keycloak",slug:"keycloak"},{level:2,title:"Other Key Repositories",slug:"other-key-repositories"},{level:3,title:"entando-core",slug:"entando-core"},{level:3,title:"entando-cms",slug:"entando-cms"},{level:3,title:"entando-components",slug:"entando-components"},{level:3,title:"Entando Kubernetes Controllers",slug:"entando-kubernetes-controllers"}],lastUpdated:"1/31/2022, 9:28:12 AM",lastUpdatedTimestamp:1643639292e3,content:" Entando Deployment Structure \n This page provides a high level overview of the key Entando GitHub repositories along with a brief description\nof how those repositories are realized in a running Entando deployment. The descriptions provided here are meant\nas a guide for identifying opportunities to dig deeper into the architecture and how things are structured\nrather than a panacea for understanding the architecture. \n entando-operator \n The Entando operator coordinates the installation and configuration of all of the components of an Entando\nCluster. The operator can be installed once per Entando Cluster and used to coordinate the plugin lifecycle for\nmultiple Entando applications across many namespaces. \n \n GitHub:  https://github.com/entando-k8s/entando-k8s-controller-coordinator/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-k8s-controller-coordinator \n Customization \n It is unlikely that the operator will be customized as part of an Entando implementation. It is not built to\nbe extended inside the codebase. The most common pattern will be to use the existing custom resources that the\noperator knows how to deploy to extend the Entando platform. \n database init containers \n During installation an Entando application needs to create several databases and also to initialize those\ndatabases with information when deploying from a backup in your images. At initialization the  entando-k8s-dbjob \nwill be run 5 times in total. Once for keycloak, twice for the entando application (port and serv dbs), once to\npopulate the Entando application database, and once to create the Component Repository database. \n \n GitHub:  https://github.com/entando-k8s/entando-k8s-dbjob \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-k8s-dbjob \n \n The screenshot below highlights the init containers for the Entando application schema creation, db\ninitialization, and component repository database. \n \n Many managed kubernetes instances like OpenShift won’t show init containers in their dashboards. So if you’re\ntroubleshooting you may need to look deeper. When fetching logs for an init container using kubectl you must\npass the container name as an argument to the call. For example, \n     kubectl logs <pod> -c <container> -n <namespace>        \n    kubectl logs quickstart-kc-db-preparation-job-ddbdbddb-a  -c quickstart-kc-db-schema-creation-job -n sprint1-rc\n Customization \n It is unlikely that the init containers will be customized as part of an Entando project. The init containers\nwill automatically restore a backup included in your application so that you can create custom images that\ninclude your application setup.\nSee  Backing Up and Restoring Your Environment . \n entando-de-app \n The  entando-de-app  is a J2EE application and is an instance of the  entando-core  (see a description of the\n entando-core  repo below). Reviewing the dependencies of this application in the pom.xml will reveal the\ndependencies on the  entando-core ,  entando-engine , and  admin-console  which encompass the core\nfunctionality in versions of Entando prior to Entando 6. In a quickstart deployment the  entando-de-app  is deployed as part of the  entando-composite-app  multi\ncontainer pod. \n \n GitHub:  https://github.com/entando/entando-de-app/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-de-app-eap , https://hub.docker.com/repository/docker/entando/entando-de-app-wildfly \n Customization \n The  entando-de-app  is very likely to be customized as part of an Entando implementation. This image can be\ncustomized with new APIs, legacy Entando plugins, new database tables, or other extensions to the  entando-core .\nIt is highly recommended that most extensions to the platform in Entando 6 occur in microservices. However, legacy\nintegrations, extensions to the CMS, and migrations from earlier Entando versions may require changes to the  entando-de-app . \n app-builder \n The  app-builder  is the front end of the  entando-de-app . It communicates with the  entando-de-app  via  REST\nAPIs . The  app-builder  is a React JS application and is served via node in the default\ndeployment. In a quickstart deployment the  app-builder  container is deployed in the  entando-composite-app \nmultiple container pod. The  app-builder  also communicates with the Component Manager via REST API to fetch\ninformation about Entando bundles deployed to the Entando Component Repository (ECR). \n \n GitHub:  https://github.com/entando/app-builder/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/app-builder/ \n Customization \n The  app-builder  is built to be customized and will be customized as part of many Entando implementations.\nThe  app-builder  can be customized at runtime via micro frontends\n widget configuration . The  app-builder  can also be\ncustomized via the integration of custom modules that are added at\n build time . \n component-manager \n The  component-manager  provides the link between the entando-de-app (or your custom core instance) and the\nEntando Component Repository (ECR). The  component-manager  queries the entando-k8s service to fetch available\nbundles that have been deployed as custom resources inside of an Entando cluster.\nThe  component-manager  also manages the relationships between an Entando application and the\ninstalled plugins. This can be seen in the plugin link custom resources in Kubernetes. \n \n GitHub:  https://github.com/entando-k8s/entando-component-manager/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-component-manager/ \n Customization \n It is unlikely that the  component-manager  will be customized as part of an Entando implementation. \n entando-k8s-service \n The  entando-k8s-service  acts as an abstraction layer to fetch data from kubernetes APIs. The primary\nfunctionality is in discovering and making available for installation Entando plugins. The\n entando-k8s-service  is invoked by the  component-manager . \n \n GitHub:  https://github.com/entando-k8s/entando-k8s-service/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-k8s-service/ \n Customization \n It is very unlikely that the  entando-k8s-service  will be customized as part of an Entando implementation. \n keycloak \n The  entando-keycloak  project is an extension of the base Keycloak images. The extension provides the default\nthemes for Entando, a customized realm and clients, and adds the Oracle ojdbc jars for connection to Oracle\ndatabases. \n \n GitHub:  https://github.com/entando/entando-keycloak/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-keycloak/ \n Customization \n The keycloak image will often be customized as part of an Entando implementation. Common extensions will\ninclude changing the theme, adding default connections, adding default social logins, adding default clients,\nor other changes. \n Other Key Repositories \n entando-core \n The entando-core project is a J2EE application that exposes APIs for the Entando CMS, includes the legacy\nadmin console, and includes the portal-ui project that performs the server side composition for pages\nrendered via an Entando application. Note that only the composition is performed server side.\nJavascript code is rendered on the client. The entando-core is realized via an instance that includes the\nWAR files generated from a core build as dependencies. In a default deployment this is the  entando-de-app . \n \n GitHub:  https://github.com/entando/entando-core/ \n DockerHub: None (deployed to maven central) \n Customization \n For users familiar with versions prior to Entando 6 there will be cases where the  entando-core  is customized.\nIn most cases these customizations will be delivered via WAR overlay in the instance project.\nUsing WAR overlay is a functional approach for users already  familiar with the process but it is highly\nrecommended to extend the platform using microservices for new projects. \n entando-cms \n The  entando-cms  project is the  app-builder  (React JS) side of the Entando WCMS. It is bundled into the\n app-builder  at build time and will be included in the default deployment of the  app-builder  in almost all cases. \n \n GitHub:  https://github.com/entando/entando-cms/ \n DockerHub: None (deployed to npm) \n Customization \n In some cases the  entando-cms  may be customized if new custom features are added to CMS specific\nfunctionality. However, most cases will use the more general  app-builder  extension points noted above.\nThe  entando-cms  does not expose any dedicated extension interfaces outside of those already provided by the\n app-builder . \n entando-components \n The entando-components project is a collection of legacy plugins for Entando 5 and earlier. These plugins are deployed as WAR dependencies in an entando-core instance. \n \n GitHub:  https://github.com/entando/entando-components/ \n DockerHub: None (deployed to maven central) \n Entando Kubernetes Controllers \n There are a number of controllers that are available to the Entando operator to manage installations and\ncomponents in an Entando Cluster. Those controllers are small and lightweight images that are executed as\nrun to completion pods to manage the installation flow for different parts of the infrastructure. The\ncontrollers are implemented using Quarkus. For more information on the controllers, the Entando custom\nresources, and configuring your Entando deployment see also:\n Custom Resources . \n GitHub: \n \n https://github.com/entando-k8s/entando-k8s-composite-app-controller/ \n https://github.com/entando-k8s/entando-k8s-plugin-controller/ \n https://github.com/entando-k8s/entando-k8s-cluster-infrastructure-controller/ \n https://github.com/entando-k8s/entando-k8s-app-controller/ \n https://github.com/entando-k8s/entando-k8s-app-plugin-link-controller/ \n \n DockerHub: \n \n https://hub.docker.com/repository/docker/entando/entando-k8s-composite-app-controller/ \n https://hub.docker.com/repository/docker/entando/entando-k8s-plugin-controller/ \n https://hub.docker.com/repository/docker/entando/entando-k8s-cluster-infrastructure-controller/ \n https://hub.docker.com/repository/docker/entando/entando-k8s-app-controller/ \n https://hub.docker.com/repository/docker/entando/entando-k8s-app-plugin-link-controller/ \n Customization \n It is unlikely that the controllers will be customized as part of an Entando implementation. \n"},{title:"Entando CLI",frontmatter:{sidebarDepth:2},regularPath:"/v6.3.2/docs/reference/entando-cli.html",relativePath:"v6.3.2/docs/reference/entando-cli.md",key:"v-12c4b8e8",path:"/v6.3.2/docs/reference/entando-cli.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Installation",slug:"installation"},{level:3,title:"Prerequisites",slug:"prerequisites"},{level:3,title:"Install the CLI",slug:"install-the-cli"},{level:3,title:"Check Environment",slug:"check-environment"},{level:3,title:"Update the CLI",slug:"update-the-cli"},{level:2,title:"Available Commands",slug:"available-commands"},{level:2,title:"Project Management",slug:"project-management"},{level:3,title:"Project Setup",slug:"project-setup"},{level:3,title:"Prepare and Publish a Bundle",slug:"prepare-and-publish-a-bundle"},{level:3,title:"Install the bundle into an application",slug:"install-the-bundle-into-an-application"},{level:3,title:"Run a Project locally",slug:"run-a-project-locally"},{level:2,title:"Bundle Commands",slug:"bundle-commands"},{level:2,title:"Profile Management",slug:"profile-management"},{level:2,title:"Configuration management",slug:"configuration-management"},{level:3,title:"Commands",slug:"commands"},{level:3,title:"Good to know keys",slug:"good-to-know-keys"},{level:2,title:"Diagnostic Commands",slug:"diagnostic-commands"},{level:2,title:"Reference",slug:"reference"}],lastUpdated:"2/3/2022, 10:35:06 PM",lastUpdatedTimestamp:1643945706e3,content:' Entando CLI \n Overview \n The Entando Command Line Interface (CLI) provides a set of commands that accelerate the developer experience by assisting the developer with common tasks such as quickly installing a new copy of Entando, generating an Entando project via JHipster, deploying an Entando Bundle, etc. \n Installation \n Prerequisites \n The basic requirements for the CLI vary depending on the category of developer tasks. The Entando CLI is able to install secondary dependencies using the  ent check-env  command as described  here . \n \n \n \n Category \n Prerequisite \n \n \n \n \n Basic Development \n git or  git for windows \n \n \n \n nvm or  nvm for windows \n \n \n Install Entando in a local VM \n multipass \n \n \n Build and publish Entando Bundles \n docker and docker-compose \n \n \n \n a git repository for the bundle artifacts \n \n \n \n a Docker Hub account (or organization) for microservice Docker images \n \n \n Deploy an Entando Bundle \n a Kubernetes cluster with admin access. This could be a local cluster (created via the CLI or manually) or a shared remote cluster. \n \n \n \n TIP \n If you follow the automated option in  Getting Started , then the CLI will be  installed for you along with an Ubuntu VM containing k3s Kubernetes and a quickstart Entando application. \n Install the CLI \n Install the current offical release of the CLI via the following command. \n curl  -L https://get.entando.org/cli  |   bash \n Check Environment \n Use the  check-env  command to prepare your environment for development. This will verify the presence of additional dependencies (such as git, curl, java, JHipster, etc.) as well as the appropriate versions for your specific Entando instance. In most cases  check-env  will automatically install those dependencies and will prompt the developer for guidance or approval as needed. \n ent check-env develop\n Update the CLI \n The CLI can be updated to the latest version (corresponding to your Entando version) using the following command. You should run  ent check-env develop  after updating the CLI in case any dependency versions have changed. \n bash   < ( curl  -L  "https://get.entando.org/cli" )  --update\n Available Commands \n Use  ent help  to review the list of available commands. \n ~~~~~~~~~~~~~~~~~~~\n Entando CLI\n~~~~~~~~~~~~~~~~~~~\n\n> Essentials:\n  - Activate using:  ~/.entando/ent/v6.3.2/cli/v6.3.2/activate\n  - Dectivate using: ~/.entando/ent/v6.3.2/cli/v6.3.2/deactivate\n\n> Available commands:\n  - app                  => Helps managing an EntandoApp\n  - app-info             => Displays information about an entando app\n  - bundler              => Wrapper for the ENT private installation of the entando bundle tool.\n  - check-env            => Checks the environment for required dependencies and settings\n  - diag                 => Runs some diagnostic and collects the related info in a tgz file\n  - ecr                  => Helps managing an the Entando ECR\n  - ent                  => Helps managing an the local ents\n  - help                 => Helps in having help\n  - host                 => Helps managing the system that hosts the quickstart VM\n  - jhipster             => Wrapper for the ENT private installation of jhipster.\n  - kubectl              => Helper for using kubectl in ent managed scenarios\n  - npm                  => Wrapper for the ENT private installation of npm. This is mostly for internal use\n  - pod                  => Displays information related to a set of pods\n  - prj                  => Helps managing Entando bundle projects\n  - profile              => Helps managing an EntandoApp\n  - quickstart           => Helps locally installing entando instances\n  - run-tests            => Run the internal tests\n\n> Further info about entando:\n  - ~/.entando/ent/quickstart/cli/v6.3.2/README.md\n  - https://www.entando.com/\n  - https://developer.entando.com/\n\n> ⚠ RECOMMENDED FIRST STEP ⚠ :\n  - Check the dependencies (ent check-env --help)\n \n Check the help text ( --help ) for any command to see its specific options, e.g.  ent check-env --help . \n Project Management \n These are common sequences for an Entando project. \n Project Setup \n \n Setup a project directory \n \n mkdir  testProject  &&   cd  testProject\n \n \n Generate the project skeleton using the JHipster-based Entando Blueprint. \n \n ent jhipster --blueprints entando\n \n \n Generate an entity and MFEs. \n \n ent jhipster entity Conference\n \n \n Build the new project. Using the  ent-prj  wrapper saves having to build each part of the project individually. The first run can be slower due to node downloads for any MFEs. \n \n ent prj build\n \n See  this tutorial  for more details. \n Prepare and Publish a Bundle \n Use the publication system (pbs) to assemble your Entando project into a bundle that can be loaded into Kubernetes. You\'ll need your github credentials, a github repository to hold your bundle artifacts, and a Docker Hub account or organization. \n \n Initialize the bundle directory \n \n ent prj pbs-init\n \n \n Publish the build artifacts to github and Docker Hub \n \n ent prj pbs-publish\n \n \n Deploy the bundle into the Entando Component Repository. \n \n ent prj deploy\n \n See  this tutorial  for more details. \n Install the bundle into an application \n The ent CLI allows you to install a bundle without the need to access the Entando App Builder.\nNote: To install a given bundle, you need to be sure it has been deployed first. \n \n In your project folder run the following command \n \n ent prj  install \n \n \n If you already installed the bundle, you can use  --conflict-strategy  to adopt a strategy for existing components (CREATE, SKIP, OVERRIDE) \n \n ent prj  install  --conflict-strategy = OVERRIDE\n Run a Project locally \n \n Startup Keycloak. This uses docker-compose under the hood. \n \n ent prj ext-keycloak start\n \n \n Startup the backend microservices \n \n ent prj be-test-run\n \n \n Startup one or more of the frontend widgets, each from its own shell. \n \n ent prj fe-test-run\n \n See  this tutorial  for more details. \n Alternatively, you can perform a completely clean install of the CLI by removing your  ~/.entando  directory and then reinstalling the CLI per the instructions above. This will also remove the private copies of JHipster, Entando Blueprint, etc. \n rm  -rf ~/.entando.\n Bundle Commands \n Use the  ent bundler  command to prepare a bundle for publication or extract a bundle from an application. \n \n Prepare a bundle custom resource from a Git repository. The project command ( ent prj generate-cr ) provides a wrapped version of this command. See the help for options including the bundle name, description, repository, etc. The output of this command is a yaml file which can be piped to a file or directly to  ent kubectl  for application to Kubernetes. \n \n   ent bundler from-git\n \n See  this tutorial  for an example using this command. \n \n Point the bundler to an existing Entando application and extract its components (pages, content, etc.) and static assets into a custom bundle. You can use this bundle to migrate Entando components from one environment to another (e.g. Dev to QA), to provide a template for building a new Entando application, or as the skeleton of an Entando solution. The bundler provides an interactive mode which allows you to identify the components to be exported from the application. The output of this command is the same bundle folder structure created by an Entando project including a top-level descriptor file. \n \n   ent bundler from-env  \n \n You will need to provide an  env.json  file in the same directory where the bundler is run. This is used to configure the application URLs and client credentials. \n { \n    "coreBaseApi" :   "http://<YOUR-DOMAIN-OR-IP>/entando-de-app" , \n    "k8ssvcApi" :   "http://<YOUR-DOMAIN-OR-IP>/k8s" , \n    "clientId" :   "<YOUR-CLIENT-ID>" , \n    "clientSecret" :   "<YOUR-CLIENT-SECRET>" \n } \n \n See  this tutorial  for more instructions on exporting a bundle including how to setup your  env.json . \n Profile Management \n ent profile  is essentially a command to manage and switch between different configurations.\nIt\'s commonly used to switch between different Entando applications, even if they are on different clusters.\nIn order to do this,  ent profile  can be instructed to use kubernetes contextes, kubeconfig files, custom commands or a combination of them. (checkout  ent profile first-use-readme ). \n \n Create a new profile. You need to give the profile name, the Entando application name and the namespace. \n \n ent pro new [profileName] [EntandoAppName] [namespace]\n \n \n Link the current profile to a kubernetes context by the name \n \n ent pro link [contextName]\n \n \n Activate a profile by its name \n \n ent pro use [profileName]\n \n Please note you can use a profile only for the current shell by using this command instead. \n source ent pro use [profileName]\n \n \n List the available profiles \n \n ent pro list\n \n \n Delete a profile \n \n ent pro delete [profileName]\n Configuration management \n ent config  is a key-value archive of configurations related to the current profile.\nIt can serve several purposes, but these are a few "good to know" keys and commands. \n Commands \n \n Print the current config archive \n \n ent config --print\n \n \n Interactively edits the config archive \n \n ent config --edit\n \n \n Get a given config key value \n \n ent config --get {key}\n \n \n Set a given config key to a given value \n \n ent config --set {key} {value}\n \n \n Delete the given config key \n \n ent config --set {key}\n Good to know keys \n \n \n \n Key \n Definition \n \n \n \n \n ENTANDO_NAMESPACE \n stores the fallback namespace used by explicit or implicit runs of "ent kubectl" \n \n \n ENTANDO_APPNAME \n stores the EntandoApp name related to the current profile location profile \n \n \n DESIGNATED_JAVA_HOME \n stores the path of the java version internally used by ent \n Diagnostic Commands \n The following commands can be useful to more quickly understand what is happening with an Entando Application. If you followed the Getting Started steps to setup Entando then the CLI was automatically installed in the Multipass VM and you can run these commands from there. \n \n ent app-info  display basic information about Kubernetes and the Entando resources (e.g. namespace, pods, ingresses) \n \n ent app-info\n \n \n ent pod-info  display the  kubectl describe  and  kubectl logs  for each of the major Entando pods in a given namespace. \n \n ent pod-info\n \n \n ent diag  list the current pods in a given Entando namespace and prepare a diagnostic tar.gz containing  kubectl describe  and  kubectl logs  for each of the major Entando pods. This can be highly useful when working with Entando Support. \n \n ent diag\n \n Output: \n ubuntu@entando:~$ ent diag\nPlease provide the namespace (entando):\n## DNS rebinding protection TEST\n## LOCAL INFO\n## K8S INFO\n> POD: quickstart-kc-deployer-pbyjdp1dom\n>       CONTAINER: deployer\n> POD: quickstart-eci-deployer-smectg3hxy\n>       CONTAINER: deployer\n> POD: quickstart-deployer-9ul8cyjtiq\n>       CONTAINER: deployer\n> POD: quickstart-composite-app-deployer-nlz9lxc6do\n>       CONTAINER: deployer\n> POD: quickstart-eci-k8s-svc-deployment-79c4894767-5p85d\n>       CONTAINER: k8s-svc-container\n> POD: quickstart-kc-server-deployment-85987fc84c-flrlw\n>       CONTAINER: server-container\n> POD: quickstart-operator-7bfd7fc8cd-gd774\n>       CONTAINER: operator\n> POD: quickstart-server-deployment-f69f84798-g6lx5\n>       CONTAINER: server-container\n>       CONTAINER: de-container\n>       CONTAINER: appbuilder-container\n> Collected diagdata available under "~/.entando/reports/entando-diagdata-2020-11-19T02:58:47+0000" for consultation\n> Collected diagdata available in archive "~/.entando/reports/entando-diagdata-2020-11-19T02:58:47+0000.tgz"\n Reference \n \n Source repository:  https://github.com/entando/entando-cli/tree/develop \n \n'},{title:"jACMS Aps Core Tag Library",frontmatter:{},regularPath:"/v6.3.2/docs/reference/freemarker-tags/freemarker-JACMS-tags.html",relativePath:"v6.3.2/docs/reference/freemarker-tags/freemarker-JACMS-tags.md",key:"v-43cc5a82",path:"/v6.3.2/docs/reference/freemarker-tags/freemarker-JACMS-tags.html",headers:[{level:2,title:"Tag content",slug:"tag-content"},{level:3,title:"Tag Class com.agiletec.plugins.jacms.aps.tags.ContentTag",slug:"tag-class-com-agiletec-plugins-jacms-aps-tags-contenttag"},{level:3,title:"Description",slug:"description"},{level:3,title:"Attributes",slug:"attributes"},{level:2,title:"Tag contentInfo",slug:"tag-contentinfo"},{level:3,title:"Tag Class com.agiletec.plugins.jacms.aps.tags.ContentInfoTag",slug:"tag-class-com-agiletec-plugins-jacms-aps-tags-contentinfotag"},{level:3,title:"Description",slug:"description-2"},{level:3,title:"Attributes",slug:"attributes-2"},{level:2,title:"Tag contentList",slug:"tag-contentlist"},{level:3,title:"Tag Class com.agiletec.plugins.jacms.aps.tags.ContentListTag",slug:"tag-class-com-agiletec-plugins-jacms-aps-tags-contentlisttag"},{level:3,title:"Description",slug:"description-3"},{level:3,title:"Attributes",slug:"attributes-3"},{level:2,title:"Tag contentListFilter",slug:"tag-contentlistfilter"},{level:3,title:"Tag Class Tag class: com.agiletec.plugins.jacms.aps.tags.ContentListFilterTag",slug:"tag-class-tag-class-com-agiletec-plugins-jacms-aps-tags-contentlistfiltertag"},{level:3,title:"Description",slug:"description-4"},{level:3,title:"Attributes",slug:"attributes-4"},{level:2,title:"Tag contentListUserFilterOption",slug:"tag-contentlistuserfilteroption"},{level:3,title:"Tag Class Tag class: com.agiletec.plugins.jacms.aps.tags.ContentListUserFilterOptionTag=",slug:"tag-class-tag-class-com-agiletec-plugins-jacms-aps-tags-contentlistuserfilteroptiontag"},{level:3,title:"Description",slug:"description-5"},{level:3,title:"Attributes",slug:"attributes-5"},{level:2,title:"Tag searcher",slug:"tag-searcher"},{level:3,title:"Tag Class com.agiletec.plugins.jacms.aps.tags.SearcherTag",slug:"tag-class-com-agiletec-plugins-jacms-aps-tags-searchertag"},{level:3,title:"Description",slug:"description-6"},{level:3,title:"Attributes",slug:"attributes-6"},{level:2,title:"Tag rowContentList",slug:"tag-rowcontentlist"},{level:2,title:"Tag Class Tag class: com.agiletec.plugins.jacms.aps.tags.RowContentListTag",slug:"tag-class-tag-class-com-agiletec-plugins-jacms-aps-tags-rowcontentlisttag"},{level:3,title:"Description",slug:"description-7"},{level:3,title:"Attributes",slug:"attributes-7"}],lastUpdated:"5/19/2021, 9:29:46 AM",lastUpdatedTimestamp:1621430986e3,content:' jACMS Aps Core Tag Library \n \n \n Version: 2.3 \n \n \n Short Name: jacmsaps \n \n \n URI: /jacms-aps-core \n Tag  content \n Tag Class  com.agiletec.plugins.jacms.aps.tags.ContentTag \n Description \n Displays the content given its ID. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n contentId \n false \n ID of the content to display. It can accept "expression language". \n \n \n modelId \n false \n Id of the model to use to display the content. The model ID can be either specified explicitly (the model must match the content to serve) or the type name ("list" or "default"); in the latter case the model specified in the configuration will be used. The model must adhere to the content being returned. "Expression language" is accepted. \n \n publishExtraTitle \n false \n Toggles the insertion of the values of the titles in the Request Context. The title values are extracted from the attribute marked with the role "jacms:title". Admitted values are (true, false), default \'false\'. \n \n \n var \n false \n Inserts the rendered content in a variable of the page context with the name provided. \n \n \n attributeValuesByRoleVar \n false \n Inserts the map of the attribute values indexed by the attribute role, in a variable of the page context with the name provided. \n Tag  contentInfo \n Tag Class  com.agiletec.plugins.jacms.aps.tags.ContentInfoTag \n Description \n Return information of a specified content. The content can will be extracted by id from widget parameters or from request parameter. The tag extract any specific parameter (by "param" attribute) or entire ContentAuthorizationInfo object (setting "var" attribute and anything on "param" attribute). \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n contentId \n false \n ID of the content \n \n \n param \n false \n Admitted values for "param" attribute are: \'contentId\' (returns the code of content id), \'mainGroup\' (returns the code of owner group), \'authToEdit\' (returns true if the current user can edit the content, else false). \n \n \n var \n false \n Inserts the required parameter (or the entire authorization info object) in a variable of the page context with the name provided. \n Tag  contentList \n Tag Class  com.agiletec.plugins.jacms.aps.tags.ContentListTag \n Description \n Loads a list of contents IDs by applying the filters (if any). Only the IDs of the contents accessible in the portal can be loaded. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n listName \n true \n Name of the variable in the page context that holds the search result. \n \n \n contentType \n false \n Sets the code of the content types to search. The name must match the configured one, respecting capital letters and spaces. \n \n \n category \n false \n Identifier string of the category of the content to search. \n \n \n cacheable \n false \n Toggles the system caching usage when retrieving the list. Admitted values (true, false), default "true". \n \n \n titleVar \n false \n Inserts the title on a variable of the page context with the name provided. \n \n \n pageLinkVar \n false \n Inserts the code of the page to link on a variable of the page context with the name provided. \n \n \n pageLinkDescriptionVar \n false \n Inserts the description of the page to link on a variable of the page context with the name provided. \n \n \n userFilterOptionsVar \n false \n Name of the variable in the page context that holds the user filter options \n Tag  contentListFilter \n Tag Class  Tag class: com.agiletec.plugins.jacms.aps.tags.ContentListFilterTag \n Description \n "ContentListTag" sub-tag, it creates a filter to restrict the result of the content search. Please note that the filters will be applied in the same order they are declared and the result of the search will reflect this fact. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n key \n true \n String used to filter and sort the contents. This string can be: - the name of a content attribute compatible with the type declared in the "contentListTag" (it requires the "attributeFilter" attribute to be "true") - the ID of one of the content metadata (the "attributeFilter" must be false) The allowed filter key that can be applied to content metadata are: - "created" allows sorting by date of creation of content - "modified" allows sorting by date of modification of content. \n \n \n attributeFilter \n true \n Decides whether the filter must be applied to an attribute or to a content metadata, admitted values are (true, false). The "key" attribute will be checked for validity if the filter is going to be applied to a metadata \n \n \n value \n false \n The filtering value. \n \n \n start \n false \n Filters the contents by attribute type or by the field specified with the key (respect the following matches): Text field -→ start Text Text attribute type -→ start Text Numeric attribute type -→ start Numeric date attribute type -→ start data If the data filter is used: - today, oggi or odierna will select all the contents with a date greater or equal to the system date - using date with the pattern "dd/MM/yyyy" will select all the contents with a date greater or equal to the one inserted. \n \n \n end \n false \n Similar the the "start" attribute but with the opposite behavior. \n \n \n order \n false \n Specifies the sorting behavior of the IDs found: "ASC"ending or "DESC"ending. By default no ordering is performed. \n \n \n likeOption \n false \n Toggles the \'like\' functionality. Admitted values: (true, false). Default: false. The option is available for metadata and on Text Content attributes. \n Tag  contentListUserFilterOption \n Tag Class  Tag class: com.agiletec.plugins.jacms.aps.tags.ContentListUserFilterOptionTag = \n Description \n "ContentListTag" sub-tag, it creates a custom user filter to restrict the result of the content search by front-end user. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n key \n true \n The key of the filter. This string can be: - the name of a content attribute compatible with the type declared in the "contentListTag" (it requires the "attributeFilter" attribute to be "true") - the ID of one of the content metadata (the "attributeFilter" must be false) The allowed filter key that can be applied to content metadata are: - "fulltext" allows filter by full-text search<br /> - "category" allows filter by a system category. \n \n \n attributeFilter \n true \n Decides whether the filter must be applied to an attribute or to a content metadata, admitted values are (true, false). The "key" attribute will be checked for validity if the filter is going to be applied to a metadata. \n Tag  searcher \n Tag Class  com.agiletec.plugins.jacms.aps.tags.SearcherTag \n Description \n Generates a list of content IDs, restricting them to the key word contained in the "search" parameter of the http request. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n listName \n yes \n Name of the variable, stored in the page context, containing the list of content IDs. \n Tag  rowContentList \n Tag Class  Tag class: com.agiletec.plugins.jacms.aps.tags.RowContentListTag \n Description \n Publish a list of contents. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n listName \n true \n Name of the variable in the page context that holds the contents (list of properties of key "contentId" and "modelId"). \n \n \n titleVar \n false \n Inserts the title on a variable of the page context with the name provided. \n \n \n pageLinkVar \n false \n Inserts the code of the page to link on a variable of the page context with the name provided. \n \n \n pageLinkDescriptionVar \n false \n Inserts the description of the page to link on a variable of the page context with the name provided. \n \n \n \n'},{title:"Development Tips and Tricks",frontmatter:{sidebarDepth:2,redirectFrom:"/next/tutorials/devops/local-tips-and-tricks.html"},regularPath:"/v6.3.2/docs/reference/local-tips-and-tricks.html",relativePath:"v6.3.2/docs/reference/local-tips-and-tricks.md",key:"v-5940cbec",path:"/v6.3.2/docs/reference/local-tips-and-tricks.html",headers:[{level:2,title:"Quickstart Management",slug:"quickstart-management"},{level:3,title:"General",slug:"general"},{level:3,title:"Multipass",slug:"multipass"},{level:3,title:"Entando in Kubernetes",slug:"entando-in-kubernetes"},{level:2,title:"Shared Servers",slug:"shared-servers"},{level:2,title:"Network Issues",slug:"network-issues"},{level:3,title:".nip.io isn't allowed",slug:"nip-io-isn-t-allowed"},{level:3,title:"The IP address changed after the initial install",slug:"the-ip-address-changed-after-the-initial-install"},{level:2,title:"Windows Development",slug:"windows-development"},{level:3,title:"Multipass loses control of VMs",slug:"multipass-loses-control-of-vms"},{level:3,title:"Hyper-V IP changes",slug:"hyper-v-ip-changes"},{level:3,title:"JHipster",slug:"jhipster"},{level:3,title:"Multipass with VirtualBox",slug:"multipass-with-virtualbox"}],lastUpdated:"2/18/2022, 2:57:25 PM",lastUpdatedTimestamp:1645214245e3,content:" Development Tips and Tricks \n We've collected a list of tips and tricks to optimize your local quickstart or  Getting Started  development environment. We invite you to ask questions, collaborate with the community, and share your own favorite\npractices over on the  Entando forum . \n Quickstart Management \n Here are a few common questions about the quickstart environment. The quickstart environment uses Multipass to launch an Ubuntu VM, where K3s Kubernetes is then installed and from which Entando is deployed. \n General \n Q: How can I remove a quickstart environment? \n A:  If you want to completely remove the VM created by Multipass, you can use  multipass delete <VM-NAME>  (where the default VM-NAME for a quickstart is  entando ) and then  multipass purge  to recover the resources. If you just want to shutdown Entando but keep the VM, you can use  multipass shell <VM-NAME>  to shell into the VM and then remove the namespace via  sudo kubectl delete namespace entando . \n Q: What if the installation fails due to timeout? \n A:  A Docker Hub policy limiting download bandwidth may cause the quickstart installation to fail with timeout errors. The workaround is a two step process: \n \n Delete the  entando  namespace \n \n ent k delete namespace entando\n \n \n Run the following \n \n ent quickstart \"entando\" \"quickstart\" --simple --debug=1 --yes --with-vm --release=v6.3.2\n \n The namespace will be recreated, preserving the images already pulled, so it's unlikely the installation time will exceed the timeout threshold again. \n Multipass \n Q: How can I shell into a Multipass VM? \n A:   multipass shell <VM-NAME> . If you don't provide a VM-NAME, Multipass will use the default name  primary , and even launch it for you if it doesn't exist. \n Q: What do I need to do after restarting my laptop? \n A:  By default, Multipass is installed as a service and will restart automatically. If Multipass isn't running, you'll need to first initialize this service; then you can start your VM via  multipass start <VM-NAME> . Kubernetes will launch automatically along with any installed pods, including Entando. It can take a few minutes for all of the pods to fully initialize, but you can use  sudo kubectl -n entando get pods --watch  to observe the progress. \n Q: How can I pause or idle my Entando instance? \n A:  You can pause with  multipass stop <VM-NAME> , or idle with  multipass suspend <VM-NAME>  to preserve the VM state. You can then use  multipass start <VM-NAME>  to start the VM. \n Q: What else can Multipass do? \n A:  You can run  multipass help  or refer to the  Multipass docs  for more information on Multipass. \n Entando in Kubernetes \n Q: How can I install a new copy of Entando into an existing VM? \n A:  By default, the quickstart installation deploys Kubernetes resources into a dedicated namespace called  entando . If you want to remove all of the resources in  entando , you can simply delete the namespace with  sudo kubectl delete namespace entando . You can then re-create the namespace and re-install the resources by applying the Helm template for your environment. Alternatively, you can achieve this with  ent quickstart --vm-reuse=true , but you'll need to set other  ent quickstart  options, so check the  ent  help. \n Q: How can I shell into a running pod or view its logs? \n A:  You can use the standard Kubernetes commands, e.g.  sudo kubectl exec -it <POD-NAME> -c <CONTAINER-NAME -- bash  or  sudo kubectl logs <POD-NAME> <CONTAINER-NAME> . \n Q: What do I do if Entando doesn't fully initialize? \n A:  The most common cause of this is a networking problem. See the  Network issues  section below for details. If all else fails, reach out to the Entando team on Slack or in the Forums. \n Shared Servers \n We recommend using Multipass to quickly spin up an Ubuntu VM to host a local Kubernetes cluster for test purposes. A local environment is often useful, but most teams utilize a shared Kubernetes cluster. This shared cluster is managed by an operations team, and installed either on premise or with a cloud provider for full integration testing, CI/CD, DevOps, etc. \n Network Issues \n A local Entando 6.3 quickstart installation (e.g. what you'll get if you follow the  Getting Started  guide) may use a set of local domain names to enable access to Entando services. Your IP address will vary, but may look something like this: \n quickstart-entando.192.168.99.1.nip.io\nquickstart-kc-entando.192.168.99.1.nip.io\nquickstart-eci-entando.192.168.99.1.nip.io\n \n The base domain configured via the ENTANDO_DEFAULT_ROUTING_SUFFIX (e.g. in your entando.yaml) borrows a fixed IP address that is created during the initial installation. This domain is used to generate ingress routes to map incoming URLs to individual services. In production environments there's generally a dedicated network layer to manage IPs/routing (both on premise and in the cloud), but this is not readily available in most local setups. Below are a couple of common issues that can prevent Entando from initializing in a local environment: \n  .nip.io isn't allowed \n \n This could be due to firewall settings or corporate security policies. The simplest workaround is to manually edit your /etc/hosts file and map the necessary domains to the IP of your local virtual machine. \n \n  192.168.99.1 quickstart-kc-entando.192.168.99.1.nip.io\n 192.168.99.1 quickstart-eci-entando.192.168.99.1.nip.io\n 192.168.99.1 quickstart-entando.192.168.99.1.nip.io\n \n \n If you add microservices to your installation, you may need to add additional mappings for the new ingresses. \n See  this section below  for detailed steps to perform this on Windows. \n  The IP address changed after the initial install \n \n Restarting a Windows computer can cause this (see  Windows Hyper-V IP Changes  below), and the workaround noted above (e.g. update your /etc/hosts file) also applies. Simply update the IP address in the first column to use the current IP of your virtual machine. \n Windows Development \n Multipass loses control of VMs \n Q: What do I do if Multipass cannot access my VMs? \n A:  The most common symptoms include an  IP=UNKNOWN  entry when issuing a  multipass list , and when attempts to stop or shell into the VM consistently fail. \n Internet Connection Sharing (ICS) is a Windows service that provides Internet connectivity to virtual machines, and its  hosts.ics  file can occasionally get corrupted. Restarting the host laptop or desktop should remedy this, but a quicker and simpler fix is to shutdown any VMs using the hypervisor (Hyper-V or VirtualBox), remove the  hosts.ics  file from  Windows/System32/drivers/etc  using elevated privileges, and then restart the VM(s). You can examine the  hosts.ics  file first to check if it is well-formed, with clean IP to VM-NAME mappings insteaad of spurious numbers or letters. \n Hyper-V IP changes \n Q: My Entando installation stops working when I restart Windows. How can I fix this? \n A:  The basic issue is that Windows Hyper-V makes it difficult to set a static IP for a VM (see this  forum post  for details). As discussed  above , Entando's ingress routes rely on a fixed IP address and will break if the IP address changes after initial installation. Here are a few options to solve this issue, short of modifying your router or network switch settings: \n Option 1: Single host routing \n The simplest way to deal with the peculiarities of Hyper-V IP assignment is to avoid it, instead using Windows-specific mshome.net addresses. This allows you to access a VM with an address like  <VM-NAME>.mshome.net . If you set up your enviroment using the  Automatic Install  instructions, then the ent CLI will select the single host option and the address will be  entando.mshome.net . You can accomplish the same thing yourself using the  ent quickstart  script, but see its  --help  for the current set of options. \n Option 2: Manually update your hosts file \n The next simplest option to re-enable external access to your cluster is to update your hosts file after each Windows restart. \n You need two pieces of information for this workaround, and you'll also need administrator access. \n \n Determine the original IP used for your VM. This is included in the  ENTANDO_DEFAULT_ROUTING_SUFFIX , or you can find it included in the ingress names. Run   kubectl -n entando get ingress  to see something like this: \n \n NAME                          CLASS    HOSTS                                           \nquickstart-kc-ingress         <none>   quickstart-kc-entando.192.168.235.100.nip.io  \nquickstart-eci-ingress        <none>   quickstart-eci-entando.192.168.235.100.nip.io  \nquickstart-ingress            <none>   quickstart-entando.192.168.235.100.nip.io    \n \n \n Determine the current IP using  hostname -I  in the VM, or by running  multipass list  from Windows: \n \n $ multipass list\nName                    State             IPv4             Image\nprimary                 Running           172.31.118.12   Ubuntu 18.04 LTS\n \n \n As a Windows administrator, edit your hosts file  (C:\\Windows\\System32\\drivers\\etc\\hosts)  to map any required URLs from the old IP to the new IP. This will bypass .nip.io lookups. \n \n 172.31.118.12 quickstart-kc-entando.192.168.235.100.nip.io\n172.31.118.12 quickstart-eci-entando.192.168.235.100.nip.io\n172.31.118.12 quickstart-entando.192.168.235.100.nip.io\n \n \n You should now be able to access your Entando URLs via the new IP. If your Entando installation stalled during startup, it should continue initializing as soon as the external address is functional again. \n Option 3: Add a Windows route \n This option is initially a little more involved, but future repairs to your network settings can then be made very easily. You'll need to choose a static IP, configure a Windows route to map it to the Hyper-V interface, and claim the IP in the Ubuntu VM via a netplan entry. \n When implementing this option for the first time, all steps must be executed before installing Entando. Subsequent Windows restarts require steps #1 and #2, only. \n \n \n Determine an IP that is unused on your local network (e.g. via ping). The following steps assume that IP 192.168.99.1 is selected. \n \n \n Determine the interface address to Hyper-V (e.g. 32 below). Use cmd  route print  and find the Interface entry for Hyper-V: \n \n \n Interface List\n 32...00 15 5d 86 45 20 ......Hyper-V Virtual Ethernet Adapter\n \n \n Using elevated privileges, add a persistent route to map your IP to the Hyper-V interface: \n \n route -p add [YOUR-IP] mask 255.255.255.255 0.0.0.0 IF [HYPER-V-INTERFACE]\nroute -p add 192.168.99.1 mask 255.255.255.255 0.0.0.0 IF 32\n \n \n \n Verify the route was added via  route print 192.168.99.1 . This command is useful after restart to check if the route needs to be created again. \n \n \n Configure your VM to claim the same address. Shell into the VM using  winpty multipass shell [YOUR-VM-NAME] . \n \n \n Change to the root user to make the following steps simpler:  sudo -i \n \n \n Determine your network adapter name via  ip link , e.g. eth0. It's often second in the list after the loopback adapter. \n \n \n ubuntu@primary:~$  ip   link \n 1 : lo:  < LOOPBACK,UP,LOWER_UP >  mtu  65536  qdisc noqueue state UNKNOWN mode DEFAULT group default qlen  1000 \n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n 2 : eth0:  < BROADCAST,MULTICAST,UP,LOWER_UP >  mtu  1500  qdisc mq state UP mode DEFAULT group default qlen  1000 \n    link/ether 00:15:5d:00:1a:0c brd ff:ff:ff:ff:ff:ff\n \n \n \n Navigate to your netplan directory:  cd /etc/netplan \n \n \n Create a netplan entry starting with 0 (so it's indexed and loaded first):  vi 0-entando.yaml \n \n \n network : \n   version :   2 \n   renderer :  networkd\n   ethernets : \n     [ YOUR - NETWORK - ADAPTER ] : \n       dhcp4 :  no\n       addresses :  \n         -   [ YOUR - IP ] /24\n \n Example: \n network : \n   version :   2 \n   renderer :  networkd\n   ethernets : \n     eth0 : \n       dhcp4 :  no\n       addresses :  \n         -  192.168.99.1/24\n \n \n \n Apply the changes with  netplan apply \n \n \n From the VM, verify connectivity via  ping 192.168.99.1 . You should receive a response and not a timeout. \n \n \n (Optional) Run a Python server to verify you can access the VM from the host at  http://192.168.99.1:8000.  It may take a minute or so before the server is ready. \n \n \n python3 -m http.server 8000\n \n \n You should now be able to install Entando using the static IP. If your Entando installation stalled during startup, and was previously configured with a static IP, it should continue initializing as soon as the external address is functional again. \n Option 4: Reinstall Entando \n We're including this option because it works and requires no additional configuration. If you plan to regularly work with Entando we recommend developing against a centralized and shared Kubernetes instance rather than running a full stack locally. If you require a local cluster we recommend using option 1 or 2. \n JHipster \n Q: How can I run JHipster on Windows? \n A:  JHipster requires a TTY interface for its menus to function correctly. Here are a few options to satisfy that requirement on Windows: \n \n Run  jhipster  under cmd or Powershell \n Using Git Bash, run  winpty jhipster.cmd \n Use Ubuntu bash via WSL (1 or 2), or within the Multipass VM \n Multipass with VirtualBox \n Q: How do I run Multipass with VirtualBox? \n A:  Multipass supports the use of VirtualBox on Windows as an alternative to Hyper-V. Refer to the Multipass documentation for VirtualBox configuration instructions. \n For Entando to work correctly with VirtualBox you will need to add a port forwarding rule to access Entando from your host system. \n \n Create your VM within Multipass \n Go to the Oracle VM VirtualBox Manager to edit the  Network  settings for the VM \n Go to the  Advanced  options and click  Port Forwarding Rules \n Add a new rule\n \n Name : your choice \n Protocol : TCP \n Host IP : leave this blank \n Host Port : 80 \n Guest IP : leave this blank \n Guest Port : 80 \n Click OK \n \n \n Any requests to port 80 on your localhost should be forwarded to the VM. \n Use the IP of your host to configure the  ENTANDO_DEFAULT_ROUTING_SUFFIX  in your YAML file, e.g.  192.168.64.25.nip.io . You must use the host ID and not the non-routable address identified from within the guest VM, e.g. 10.0.2.15. \n \n"},{title:"Aps Core Tag Library",frontmatter:{},regularPath:"/v6.3.2/docs/reference/freemarker-tags/freemarker-core-tags.html",relativePath:"v6.3.2/docs/reference/freemarker-tags/freemarker-core-tags.md",key:"v-63ebbea9",path:"/v6.3.2/docs/reference/freemarker-tags/freemarker-core-tags.html",headers:[{level:2,title:"Tag action",slug:"tag-action"},{level:3,title:"Description",slug:"description"},{level:3,title:"Example",slug:"example"},{level:3,title:"Attributes",slug:"attributes"},{level:3,title:"Tag class",slug:"tag-class"},{level:2,title:"Tag categories",slug:"tag-categories"},{level:3,title:"Description",slug:"description-2"},{level:3,title:"Example",slug:"example-2"},{level:3,title:"Attributes",slug:"attributes-2"},{level:3,title:"Tag class",slug:"tag-class-2"},{level:2,title:"Tag checkHeadInfoOuputter",slug:"tag-checkheadinfoouputter"},{level:3,title:"Description",slug:"description-3"},{level:3,title:"Attributes",slug:"attributes-3"},{level:3,title:"Tag class",slug:"tag-class-3"},{level:2,title:"Tag cssURL",slug:"tag-cssurl"},{level:3,title:"Description",slug:"description-4"},{level:3,title:"Example",slug:"example-3"},{level:3,title:"Attributes",slug:"attributes-4"},{level:3,title:"Tag class",slug:"tag-class-4"},{level:2,title:"Tag currentPage",slug:"tag-currentpage"},{level:3,title:"Description",slug:"description-5"},{level:3,title:"Example",slug:"example-4"},{level:3,title:"Attributes",slug:"attributes-5"},{level:3,title:"Tag class",slug:"tag-class-5"},{level:2,title:"Tag currentWidget",slug:"tag-currentwidget"},{level:3,title:"Description",slug:"description-6"},{level:3,title:"Example",slug:"example-5"},{level:3,title:"Attributes",slug:"attributes-6"},{level:3,title:"Tag class",slug:"tag-class-6"},{level:2,title:"Tag fragment",slug:"tag-fragment"},{level:3,title:"Description",slug:"description-7"},{level:3,title:"Attributes",slug:"attributes-7"},{level:3,title:"Tag class",slug:"tag-class-7"},{level:2,title:"Tag freemarkerTemplateParameter",slug:"tag-freemarkertemplateparameter"},{level:3,title:"Description",slug:"description-8"},{level:3,title:"Attributes",slug:"attributes-8"},{level:3,title:"Tag class",slug:"tag-class-8"},{level:2,title:"Tag headInfo",slug:"tag-headinfo"},{level:3,title:"Description",slug:"description-9"},{level:3,title:"Example",slug:"example-6"},{level:3,title:"Attributes",slug:"attributes-9"},{level:3,title:"Tag class",slug:"tag-class-9"},{level:2,title:"Tag i18n",slug:"tag-i18n"},{level:3,title:"Description",slug:"description-10"},{level:3,title:"Example",slug:"example-7"},{level:3,title:"Attributes",slug:"attributes-10"},{level:3,title:"Tag class",slug:"tag-class-10"},{level:2,title:"Tag ifauthorized",slug:"tag-ifauthorized"},{level:3,title:"Description",slug:"description-11"},{level:3,title:"Example",slug:"example-8"},{level:3,title:"Attributes",slug:"attributes-11"},{level:3,title:"Tag class",slug:"tag-class-11"},{level:2,title:"Tag imgURL",slug:"tag-imgurl"},{level:3,title:"Description",slug:"description-12"},{level:3,title:"Example",slug:"example-9"},{level:3,title:"Attributes",slug:"attributes-12"},{level:3,title:"Tag class",slug:"tag-class-12"},{level:2,title:"Tag info",slug:"tag-info"},{level:3,title:"Description",slug:"description-13"},{level:3,title:"Example",slug:"example-10"},{level:3,title:"Attributes",slug:"attributes-13"},{level:3,title:"Tag class",slug:"tag-class-13"},{level:2,title:"Tag internalServlet",slug:"tag-internalservlet"},{level:3,title:"Description",slug:"description-14"},{level:3,title:"Example",slug:"example-11"},{level:3,title:"Attributes",slug:"attributes-14"},{level:3,title:"Tag class",slug:"tag-class-14"},{level:2,title:"Tag nav",slug:"tag-nav"},{level:3,title:"Description",slug:"description-15"},{level:3,title:"Example",slug:"example-12"},{level:3,title:"Attributes",slug:"attributes-15"},{level:3,title:"Tag class",slug:"tag-class-15"},{level:2,title:"Tag outputHeadInfo",slug:"tag-outputheadinfo"},{level:3,title:"Description",slug:"description-16"},{level:3,title:"Attributes",slug:"attributes-16"},{level:3,title:"Tag class",slug:"tag-class-16"},{level:2,title:"Tag pageInfo",slug:"tag-pageinfo"},{level:3,title:"Description",slug:"description-17"},{level:3,title:"Attributes",slug:"attributes-17"},{level:3,title:"Tag class",slug:"tag-class-17"},{level:2,title:"Tag pager",slug:"tag-pager"},{level:3,title:"Description",slug:"description-18"},{level:3,title:"Example",slug:"example-13"},{level:3,title:"Attributes",slug:"attributes-18"},{level:3,title:"Tag class",slug:"tag-class-18"},{level:2,title:"Tag parameter",slug:"tag-parameter"},{level:2,title:"Tag pager",slug:"tag-pager-2"},{level:3,title:"Description",slug:"description-19"},{level:3,title:"Example",slug:"example-14"},{level:3,title:"Attributes",slug:"attributes-19"},{level:3,title:"Tag class",slug:"tag-class-19"},{level:2,title:"Tag printHeadInfo",slug:"tag-printheadinfo"},{level:3,title:"Description",slug:"description-20"},{level:3,title:"Attributes",slug:"attributes-20"},{level:3,title:"Tag class",slug:"tag-class-20"},{level:2,title:"Tag resourceURL",slug:"tag-resourceurl"},{level:3,title:"Description",slug:"description-21"},{level:3,title:"Example",slug:"example-15"},{level:3,title:"Attributes",slug:"attributes-21"},{level:3,title:"Tag class",slug:"tag-class-21"},{level:2,title:"Tag show",slug:"tag-show"},{level:3,title:"Description",slug:"description-22"},{level:3,title:"Example",slug:"example-16"},{level:3,title:"Attributes",slug:"attributes-22"},{level:3,title:"Tag class",slug:"tag-class-22"},{level:2,title:"Tag url",slug:"tag-url"},{level:3,title:"Description",slug:"description-23"},{level:3,title:"Example",slug:"example-17"},{level:3,title:"Attributes",slug:"attributes-23"},{level:3,title:"Tag class",slug:"tag-class-23"},{level:2,title:"Tag pageWithWidget",slug:"tag-pagewithwidget"},{level:3,title:"Description",slug:"description-24"},{level:3,title:"Example",slug:"example-18"},{level:3,title:"Attributes",slug:"attributes-24"},{level:3,title:"Tag class",slug:"tag-class-24"},{level:2,title:"Tag currentUserProfileAttribute",slug:"tag-currentuserprofileattribute"},{level:3,title:"Description",slug:"description-25"},{level:3,title:"Attributes",slug:"attributes-25"},{level:3,title:"Tag class",slug:"tag-class-25"},{level:2,title:"Tag userProfileAttribute",slug:"tag-userprofileattribute"},{level:3,title:"Description",slug:"description-26"},{level:3,title:"Attributes",slug:"attributes-26"},{level:3,title:"Tag class",slug:"tag-class-26"}],lastUpdated:"5/19/2021, 9:29:46 AM",lastUpdatedTimestamp:1621430986e3,content:' Aps Core Tag Library \n \n \n Version: 2.3 \n \n \n Short Name: wp \n \n \n URI: /aps-core \n Tag  action \n Description \n Build the URL to call a jsp or a functionality of a servlet defined\nwithin the system. This tag can use the ParameterTag sub-tag to add url\nparameters. \n Example \n (<@wp.action path="/do/my.action" var="myaction" />)  or\n (<@wp.action path="/JSP/my.jsp" var="my.jsp"/>) \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n path \n no \n The relative path of jsp or servlet to invoke, relative to the context of web-application \n \n \n var \n no \n Name of the page-scoped variable where to place the URL. \n Tag class \n com.agiletec.aps.tags.ActionURLTag \n Tag  categories \n Description \n Return the list of the system categories on SelectItem objects. \n Example \n <@wp.categories var="systemCategories" titleStyle="prettyFull" root="$\\{userFilterOptionVar.userFilterCategoryCode}" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n titleStyle \n no \n The style of the single select item. Currently it can be \'default\' (single title node), \'full\' (title with all parents) or \'prettyFull\' (title with all parents in form of \'..\'). The default when none is given is \'default\'. \n \n \n fullTitleSeparator \n no \n The separator beetwen the titles when \'titleStyle\' is \'full\' or \'prettyFull\'. \n \n \n var \n no \n Name of the page-scoped variable where to place the list of categories. \n \n \n root \n no \n The root of the categories to show. The default is the system root categories \n Tag class \n com.agiletec.aps.tags.CategoriesTag \n Tag  checkHeadInfoOuputter \n Description \n This sub-tag verifies the availability of the information to display.\nThis sub-tag can be used only in a page template, in conjunction with\n\'outputHeadInfo\'. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n type \n yes \n Specifies the type of information to analyse. \n Tag class \n com.agiletec.aps.tags.CheckHeadInfoOutputterTag \n Tag  cssURL \n Description \n Extension of the ResourceURL tag. It returns the URL of the css files. \n Example \n <@wp.cssURL />href="<@wp.cssURL />myportal.css" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n Tag class \n com.agiletec.aps.tags.CssURLTag \n Tag  currentPage \n Description \n Returns the requested information held by the current page bean. \n Example \n <@wp.currentPage param="code" var="currentViewCode" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n param \n false \n The wanted parameter: actually can be either "title", "owner" (group), "code", "hasChild" or "childOf" (with attribute "targetPage"). The default when none is given is "title". \n \n \n langCode \n no \n Code of the language to use for the page information being returned. \n \n \n var \n no \n Name of the page context variable where the information are placed. Please note that the in this case the special characters will not be escaped. \n \n \n targetPage \n no \n Target page when "param" is "childOf". \n \n \n escapeXml \n no \n Decides whether to escape the special characters in the information retrieved or not. Value admitted (true, false), the default is true. \n Tag class \n com.agiletec.aps.tags.CurrentPageTag \n Tag  currentWidget \n Description \n Returns information about the widget where the tag resides. To obtain\ninformation about a widget placed in a frame other than the current, use\nthe "frame" attribute. \n Example \n <@wp.currentWidget param="config" configParam="name" var="configName" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n param \n yes \n The requested parameter. It can assume one of the following values: - "code" returns the code of the associated widget type (empty if none associated) - "title" returns the name of the associated widget type (empty if none associated) - "config" returns the value of the configuration parameter declared in the "configParam" attribute. The default is "title". \n \n \n configParam \n no \n Name of the configuration parameter request. This attribute is mandatory when the attribute "param" is set to "config". \n \n \n var \n no \n Name of the page context variable where the requested information is pushed. In this case the special characters will not be escaped. \n \n \n frame \n false \n Id of the frame hosting the widget with the desired information. \n \n \n escapeXml \n no \n Toggles the escape of the special characters. Admitted value are (true, false), the default is "true". \n Tag class \n com.agiletec.aps.tags.CurrentWidgetTag \n Tag  fragment \n Description \n Print a gui fragment by the given code. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n code \n true \n The code of the fragment to return. \n \n \n var \n false \n Name of the page context variable where the requested information is pushed. In this case the special characters will not be escaped. \n \n \n escapeXml \n false \n Toggles the escape of the special characters. Admitted value are (true, false), the default is "true". \n Tag class \n org.entando.entando.aps.tags.GuiFragmentTag \n Tag  freemarkerTemplateParameter \n Description \n Add a parameter into the Freemarker’s TemplateModel Map. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n var \n true \n Name of the variable where the requested information is pushed. \n \n \n valueName \n true \n Name of the variable of the page context where extract the information. \n \n \n removeOnEndTag \n false \n Whether to remove the parameter on end of Tag. Possible entries (true, false). Default value: false. \n Tag class \n org.entando.entando.aps.tags.FreemarkerTemplateParameterTag \n Tag  headInfo \n Description \n Declares the information to insert in the header of the HTML page. The\ninformation can be passed as an attribute or, in an indirect manner,\nthrough a variable of the page context. It is mandatory to specify the\ntype of the information. \n Example \n <@wp.headInfo type="JS" info="entando-misc-bootstrap/bootstrap.min.js" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n type \n yes \n Declaration of the information type. Currently only "CSS" is currently supported. \n \n \n info \n no \n Information to declare. This is an alternative of the "var" attribute. \n \n \n var \n no \n Name of the variable holding the information to declare. This attribute is the alternative of the "info" one. This variable can be used for those types of information that cannot be held by an attribute. \n Tag class \n com.agiletec.aps.tags.HeadInfoTag \n Tag  i18n \n Description \n Return the string associated to the given key in the specified language.\nThis string is either returned (and rendered) or can be optionally\nplaced in a page context variable. This tag can use the ParameterTag\nsub-tag to add label parameters. \n Example \n <@wp.i18n key="COPYRIGHT" escapeXml="false" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n key \n yes \n Key of the label to return. \n \n \n lang \n no \n Code of the language requested for the lable. \n \n \n var \n no \n Name of the variable (page scope) where to store the wanted information. In this case the special characters will not be escaped. \n \n \n escapeXml \n no \n Toggles the escape of the special characters of the returned label. Admitted values (true, false), the default is true. \n Tag class \n com.agiletec.aps.tags.I18nTag \n Tag  ifauthorized \n Description \n Toggles the visibility of the elements contained in its body, depending\non user permissions. \n Example \n <@wp.ifauthorized permission="enterBackend"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n permission \n no \n The code of the permission required. \n \n \n groupName \n no \n The name of the group membership required. \n \n \n var \n no \n The name of the (boolean) page context parameter where the result of the authorization check is placed. \n Tag class \n com.agiletec.aps.tags.CheckPermissionTag \n Tag  imgURL \n Description \n Extension of the ResourceURL tag. It returns the URL of the images to\ndisplay as static content outside the cms. \n Example \n <@wp.imgURL />entando-logo.png" alt="Entando - Access. Build. Connect." /> \n Attributes \n Tag class \n com.agiletec.aps.tags.ImgURLTag \n Tag  info \n Description \n Returns the information of the desired system parameter. \n Example \n <@wp.info key="systemParam" paramName="applicationBaseURL" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n key \n yes \n Key of the desired system parameter, admitted values are: "startLang" returns the code of start language of web browsing "defaultLang" returns the code of default language "currentLang" returns the code of current language "langs" returns the list of the languages defined in the system "systemParam" returns the value of the system param specified in the "paramName" attribute. \n \n \n var \n no \n Name of the variable where to store the retrieved information (page scope). In this case the special characters will not be escaped. \n \n \n paramName \n no \n Name of the wanted system parameter; it is mandatory if the "key" attribute is "systemParam", otherwise it is ignored. \n \n \n escapeXml \n no \n Toggles the escape of the special characters in the information returned. Admitted values are (true,false), the former being the default value. \n Tag class \n com.agiletec.aps.tags.InfoTag \n Tag  internalServlet \n Description \n Tag for the "Internal Servlet" functionality. Publishes a function\nserved by an internal Servlet; the servlet is invoked from a path\nspecified in the attribute "actionPath" or by the widget parameter\nsharing the same name. This tag can be used only in a widgets. \n Example \n <@wp.internalServlet actionPath="/ExtStr2/do/jpuserreg/UserReg/initRegistration" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n actionPath \n false \n The init action path. \n \n \n staticAction \n false \n Whether to execute only the given action path. Possible entries (true, false). Default value: false. \n Tag class \n com.agiletec.aps.tags.InternalServletTag \n Tag  nav \n Description \n Generates through successive iterations the so called "navigation" list.\nFor every target/page being iterated (inserted in the page context) are\nmade available the page code, the title (in the current language) and\nthe link. Is it also possible to check whether the target page is empty\n-that is, with no configured positions- or not. \n Example \n <@wp.nav var="page"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n spec \n no \n Declares the set of the pages to generate. \n \n \n var \n yes \n Name of the page context variable where the data of target being iterated are made available. \n Tag class \n com.agiletec.aps.tags.NavigatorTag \n Tag  outputHeadInfo \n Description \n Iterates over various information in HTML header displaying them; this\ntag works in conjunction with other specific sub-tags. Please note that\nthe body can contain only a sub-tag, or information, at once. This tag\nmust be used only in a page template. E.g (<@wp.outputHeadInfo\ntype="CSS">) \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n type \n yes \n Specifies the type of information to return, in accordance with the sub-tag to use. \n Tag class \n com.agiletec.aps.tags.HeadInfoOutputterTag \n Tag  pageInfo \n Description \n Returns the information of the specified page. This tag can use the\nsub-tag "ParameterTag" to add url parameters if the info attribute is\nset to \'url\'. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n pageCode \n true \n The code of the page. \n \n \n info \n false \n Code of required page parameter. Possible entries: "code" (default value) , "title", "owner" (group), "url", "hasChild" or "childOf" (with attribute "targetPage"). \n \n \n langCode \n false \n Code of the language to use for the returned information. \n \n \n var \n false \n Name used to reference the value pushed into the pageContext. In this case, the system will not escape the special characters in the value entered in pageContext. \n \n \n targetPage \n no \n Target page when "param" is "childOf". \n \n \n escapeXml \n false \n Whether to escape HTML. Possible entries (true, false). Default value: true. \n Tag class \n com.agiletec.aps.tags.PageInfoTag \n Tag  pager \n Description \n List pager. \n Example \n <@wp.pager listName="result" objectName="groupContent" max="10" pagerIdFromFrame="true" advanced="true" offset="5"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n max \n no \n The maximum value for each object group. \n \n \n listName \n yes \n Name of the list as found in the request. \n \n \n objectName \n yes \n Name of the object currently iterated. The following methods are exposed:  getMax, getPrevItem, getNextItem, getCurrItem, getSize, getBegin, getEnd, getMaxItem, getPagerId. \n \n \n pagerId \n no \n Sets the ID of the pager itself, it has to be used when two or more pagers exist in the same page. This attributes overrides "pagerIdFromFrame". \n \n \n pagerIdFromFrame \n no \n Sets the ID of the pager (mandatory when two or more pagers share the same page) based upon the frame where the tag is placed. Admitted values are (true, false), the latter being the default. Please note that the "pagerId" attribute takes precedence over this one. \n \n \n advanced \n no \n Toggles the pager in advanced mode. Admitted values are (true, false). the advanced mode of the tag is used when the list to iterate over is huge. \n \n \n offset \n no \n This attribute is considered only when the pager is in advanced mode. This is the numeric value of the single step increment (or decrement) when iterating over the list \n Tag class \n com.agiletec.aps.tags.PagerTag \n Tag  parameter \n Tag  pager \n Description \n This tag can be used to parameterise other tags. The parameter value can\nbe added through the \'value\' attribute or the body tag. When you declare\nthe param tag, the value can be defined in either a value attribute or\nas text between the start and the ending of the tag. \n Example \n <@wp.parameter name="resourceName"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n name \n true \n The name of the parameter. \n \n \n value \n false \n The value of the parameter. \n Tag class \n com.agiletec.aps.tags.ParameterTag \n Tag  printHeadInfo \n Description \n Returns the information to display. This sub-tag must be used only in a\npage template, in conjunction with \'outputHeadInfo\'. \n Attributes \n Tag class \n com.agiletec.aps.tags.HeadInfoPrinterTag \n Tag  resourceURL \n Description \n Returns URL of the resources. \n Example \n <@wp.resourceURL />static/js/entando-misc-html5-essentials/html5shiv.js"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n root \n no \n Declares the resource root. If not otherwise specified, the value of SystemConstants.PAR_RESOURCES_ROOT_URL is used. \n \n \n folder \n no \n Declares a specific directory for the desired resources. Unless specified, the value "" (empty string) is used in the generation of the URL. \n Tag class \n com.agiletec.aps.tags.ResourceURLTag \n Tag  show \n Description \n Defines the position of inclusion of a widget. This tag can be used only\nin a page template. \n Example \n <@wp.show frame="0" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n frame \n yes \n The positional number of the frame, starting from 0. \n Tag class \n com.agiletec.aps.tags.WidgetTag \n Tag  url \n Description \n Generates the complete URL of a portal page. The URL returned is either\nreturned (and rendered) or placed in the given variable. To insert\nparameters in the query string the sub-tag "ParameterTag" is provided. \n Example \n <@wp.url paramRepeat="true" > \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n page \n no \n Code of the destination page. The default is the current page. \n \n \n lang \n no \n Code of the language to use in the destination page. \n \n \n var \n no \n Name of the page-scoped variable where to place the URL. \n \n \n paramRepeat \n no \n Repeats in the URL all the parameters of the actual request. \n \n \n excludeParameters \n no \n Sets the list of parameter names (comma separated) to exclude from repeating. By default, this attribute excludes only the password parameter of the login form. Used only when paramRepeat="true". \n Tag class \n com.agiletec.aps.tags.URLTag \n Tag  pageWithWidget \n Description \n Search and return the page (or the list of pages) with the given widget\ntype. When "filterParamName" and "filterParamValue" attributes are\npresent, the returned list will be filtered by a specific widget\nconfiguration. \n Example \n <@wp.pageWithWidget widgetTypeCode="userprofile_editCurrentUser" var="userprofileEditingPageVar" listResult="false" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n var \n true \n Attribute_description: \n \n \n widgetTypeCode \n true \n The code of the widget to search \n \n \n filterParamName \n false \n Optional widget config param name \n \n \n filterParamValue \n false \n Optional widget config param value \n \n \n listResult \n false \n Optional, dafault false. When true the result is a list of pages, when false the returned page is the first occurence \n Tag class \n com.agiletec.aps.tags.PageWithWidgetTag \n Tag  currentUserProfileAttribute \n Description \n Current User Profile tag. Return a attribute value of the current user\nprofile. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n attributeName \n false \n the name of the attribute from which extract the value. \n \n \n attributeRoleName \n false \n the name of the attribute role from which extract the value. \n \n \n var \n false \n Name used to reference the value pushed into the pageContext. \n \n \n escapeXml \n false \n Decides whether to escape the special characters in the information retrieved or not. Value admitted (true, false), the default is true. \n Tag class \n org.entando.entando.aps.tags.CurrentUserProfileAttributeTag \n Tag  userProfileAttribute \n Description \n User Profile tag. Return a attribute value from the profile givea an\nusername. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n username \n true \n the username \n \n \n attributeName \n false \n the name of the attribute from which extract the value. \n \n \n attributeRoleName \n false \n the name of the attribute role from which extract the value. \n \n \n var \n false \n Name used to reference the value pushed into the pageContext. \n \n \n escapeXml \n false \n Decides whether to escape the special characters in the information retrieved or not. Value admitted (true, false), the default is true. \n Tag class \n org.entando.entando.aps.tags.UserProfileAttributeTag \n'},{title:"Content Attributes",frontmatter:{redirectFrom:"/v6.3.2/tutorials/cms/content-attributes.html"},regularPath:"/v6.3.2/tutorials/compose/content-attributes.html",relativePath:"v6.3.2/tutorials/compose/content-attributes.md",key:"v-31b33280",path:"/v6.3.2/tutorials/compose/content-attributes.html",headers:[{level:2,title:"Simple Attribute Types",slug:"simple-attribute-types"},{level:2,title:"Composed Attribute Types",slug:"composed-attribute-types"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:" Content Attributes \n Attributes can be seen as the smallest elements that compose a Content\nType. In other words, a Content Type is just a collection of different\nattributes. Attributes are responsible for carrying the actual\ninformation inside a Content in Entando and could be of different types.\nIn this chapter, we will review and describe the different attribute\ntypes. \n Firstly, we can distinguish simple attribute types from composite\nattribute types. In the first case, the attribute type carries a single\npiece of information (for example, an image), while the latter is an\naggregation of simple attribute types (for example, a set of images). \n Simple Attribute Types \n Attach \n This represents the information carried by a file, which is attached to\nthe content. \n It consists of an URL corresponding to the desired file present in the\nsystem’s resources, and a text which can either indicate the description\nor the name of the file. \n This attribute type is rendered as a button named “Add”. By pushing that\nbutton, the user is prompted to select a desired file present in the\nsystem’s Digital Assets Attachments list. \n Boolean \n This attribute type represents a boolean value which can either be true\nor false. This attribute type is rendered as two radio buttons labeled\n“Yes” and “No”. \n Checkbox \n This attribute type behaves in the same way as a Boolean does – it is\nactually an alternative to the Boolean attribute type - but it is\nrendered with a checkbox labeled “Yes” or “No”. \n Date \n This attribute type represents a date, tracking time within a content;\nit is often used to filter contents appearing in lists by publication\ndate, etc. \n It is rendered as a datepicker. \n Timestamp \n This attribute type is specialized for the Date attribute, allowing you\nto also specify the hour, minute and second. \n It is rendered as a datepicker for the date, and a select for hours,\nminutes and seconds. \n Enumerator \n The enumerator attribute type represents textual information with a\npredefined set of choices; it is defined by: \n \n \n Elements which are mandatory and declares the set of available\nchoices; \n \n \n Separator, which is optional and declares the character to use to\nseparate the arguments of the enumerator. By default the comma “,”\nis used. \n \n \n ExtractorBean: this parameter represents the name of the Spring bean\nto use to process the values of the enumerator. The name must\nexactly match the id of the bean as defined in the Spring\nconfiguration file. \n \n \n It is rendered as a select list. \n Enumerator Map \n The enumerator map attribute type represent textual information with a\npredefined set of choices; it is defined by: \n \n \n Elements in the form of a separated list of key=value pairs, (i.e.\nkey1=value1,key2=value2) \n \n \n Separator, which is optional and declares the character to use to\nseparate the key, values pairs. By default the comma is used. \n \n \n It is rendered as a select list which shows the available values. \n Hypertext \n This attribute type holds HTML tagged text; it retains a single value\nfor all languages. \n Even if this attribute type could support all HTML tags, we strongly\nrecommend using only tags which provide meaning and avoid those which\ndecorate or add graphics. \n Hypertext attributes are rendered as a text area in the content edit\npage; if the CKEditor is active, the user has access to a set of\nadditional functionalities from a dedicated editor’s toolbar. Such as\ntable insertion and table manipulation, special characters insertion,\nstring formatting, links creation. \n Image \n This attribute type binds an image resource to the content. \n The image is always taken from the Digital Assets images list. The user\nwill need to specify the description accompanying the image. \n Usually attributes of type Image are not indexed and are not used to\nfilter contents. \n It is rendered as a button named “Add” that, when pushed, allows the\nuser to select an image from the Digital Assets images list. Once\nselected the user is presented with a preview, as a thumbnail, of the\nimage and has the possibility to define some parameters: \n \n \n Text which is mandatory and by default takes the name of the\nselected image \n \n \n legend (optional) \n \n \n alt (optional) \n \n \n description (optional) \n \n \n title (optional) \n \n \n Link \n This attribute type represents an hypertext link; it is normally used to\ninclude a link in your content: it is possible to define up to three\ndifferent types of links: \n \n \n external links: a link pointing to a location external to the Entando\nportal \n \n \n link to page: a link which points to a page of the portal \n \n \n link to a content: a link to another content \n \n \n It is rendered as a button named “Add” that when pushed opens up a modal\nwindow from which the user can select the link type. \n Longtext \n This attribute type represents a simple unformatted text; it supports\nseveral languages and is normally used for small descriptions, when a\nshort string won’t suffice. \n It supports minimum length , maximal length and regular expressions as\noptional parameters. \n It is rendered as a textarea. \n Monotext \n Monotext represents the information in textual form, but supports only a\nlanguage; it is used for all \n those fields which do not require localization. \n It supports minimum length, maximal length, and regular expressions as\noptional parameters. \n It is rendered as a textfield. \n Number \n This attribute type holds an integer number; it retains a single value\nfor all languages. \n Supports the optional parameters: From, To, and Equal to. \n It is rendered as a textfield. \n Text \n This attribute type holds a string; it retains a single value for all\nlanguages. \n It supports minimum length, maximal length, and regular expressions as\noptional parameters. \n It is rendered as a textfield. \n ThreeState \n Conceptually similar to the Boolean attribute, this attribute type\nallows a third status “Both” to be present. \n It is rendered as a radio button with “Yes”, “No”, “Both” options. \n Composed Attribute Types \n All the attributes types of the previous chapter can only retain a\nsingle type of information, but sometimes it is desirable to aggregate\ndifferent types of attributes into one attribute: this is where composed\nattributes are used. \n From a functional point of view, it would be perfectly legal to build a\ncontent type specifying all the attributes back to back: the content\nwould be formally complete, but from a logical point of view the\nattributes would appear mutually unrelated and, worse, the relationship\nbetween them would not be explicit. \n Entando offers three types of composed attributes: List, Monolist,\nComposite. \n List \n This Attribute Type represents a set of independent and homogeneous\nelementary Attribute types, each associated with one of the languages\ndefined in the system. \n An immediate consequence is that this kind of list can handle only\nmono-language basic attributes. \n It is rendered with a button named “Add” that if pushed presents the\nuser a prompt to select or define the single elements which compose the\nlist. \n Monolist \n This attribute type is a list that is common to all the system\nlanguages; this kind of list handles multi-language and mono-language\nattributes. \n It is rendered with a button named “Add” that, if pushed, presents the\nuser with a prompt to select or define the single elements that compose\nthe monolist. \n Composite \n This attribute type is an aggregate of different, non-homogeneous,\nsimple attributes types. The aggregation of different types is treated\nas a single unit. \n It is rendered as a combination of the elementary attribute types, where\neach attribute type presents the proper rendering. \n"},{title:"Entando 6.3.2 Release Notes",frontmatter:{},regularPath:"/v6.3.2/docs/releases/",relativePath:"v6.3.2/docs/releases/README.md",key:"v-c5bccc36",path:"/v6.3.2/docs/releases/",headers:[{level:2,title:"Supported Kubernetes Versions",slug:"supported-kubernetes-versions"},{level:2,title:"Security Updates",slug:"security-updates"},{level:2,title:"New Features and Major Fixes",slug:"new-features-and-major-fixes"},{level:3,title:"Bundler",slug:"bundler"},{level:3,title:"Infrastructure",slug:"infrastructure"},{level:3,title:"Entando Component Repository",slug:"entando-component-repository"},{level:3,title:"Entando Component Generator",slug:"entando-component-generator"},{level:3,title:"App Builder",slug:"app-builder"},{level:3,title:'Entando CLI "ent"',slug:"entando-cli-ent"},{level:3,title:"Google Kubernetes Engine (GKE)",slug:"google-kubernetes-engine-gke"},{level:2,title:"Certifications",slug:"certifications"},{level:3,title:"RedHat Certification",slug:"redhat-certification"},{level:3,title:"Tanzu Kubernetes Grid (TKG) Certification",slug:"tanzu-kubernetes-grid-tkg-certification"},{level:2,title:"Known Issues",slug:"known-issues"},{level:3,title:"Apple M1",slug:"apple-m1"},{level:3,title:"Docker Hub Account Names",slug:"docker-hub-account-names"},{level:3,title:"Entando Component Generator",slug:"entando-component-generator-2"},{level:3,title:"GKE",slug:"gke"},{level:3,title:"Custom Resources",slug:"custom-resources"},{level:2,title:"Deprecation Warnings",slug:"deprecation-warnings"}],lastUpdated:"3/25/2022, 4:02:01 PM",lastUpdatedTimestamp:1648238521e3,content:' Entando 6.3.2 Release Notes \n Supported Kubernetes Versions \n \n GKE (k8s 1.18 - 1.21) \n OpenShift 3.11 (k8s 1.11) \n OpenShift 4.7 (k8s 1.21) \n Tanzu Kubernetes Grid 1.2.1 \n Vanilla k8s (1.18 - 1.21) \n k3s (k8s 1.18 - 1.21) \n Security Updates \n \n In the CMS fixed a missed escaping of the resourceTypeCode that could have lead to XSS, if the attack was also capable\nto evade CSP \n Fixed in several modules the following vulnerable dependencies:\ncommon-io, velocity, spring, guava, hibernate, struts2, taglibs, tika, apache-cxf, jackson, netty dependencies to\nnon-vulnerable versions. This is the related list of CVEs: CVE-2021-22696, CVE-2021-27807, CVE-2021-27906,\nCVE-2021-28657, CVE-2017-6888, CVE-2021-20291, CVE-2020-17530, CVE-2020-10693, CVE-2015-5211, CVE-2020-25649,\nCVE-2018-1000873 \n Several existing Entando Component Generator vulnerabilities have been addressed. The user is strongly suggested to\nrun a vulnerability scan every time a bundle is generated. The remaining vulnerabilities will be fixed with the next\nminor version of Entando but do affect tools that are only present during the development process. These include:\n \n general webpack configuration \n the dev webserver, used when developing the app \n the jest test files, used when running tests with jest \n dev utilities, used in the dev environment \n the postcss utility, used to import the css when building the final artifact \n New Features and Major Fixes \n Bundler \n \n Now able to extract also the categories \n Optimized to download only the resources actually required by the extraction \n Now able to properly export the entire EntandoApp thanks to the "system level bundles" (see the ECR related note) \n Infrastructure \n \n The deployment structure for an Entando application has been changed. In deployments prior to 6.3.2 an EntandoCompositeApp was deployed using a multi-container pod that contained the App Builder, App Engine, and Component Manager. Now each of these pods is deployed independently. \n Entando Component Repository \n \n Implemented bundle plugin descriptor version 3, which by default implies routes without the plugin version in the url, so just organization + bundle name.\n \n Note that the Component Generator doesn\'t support this descriptor version yet, but plugins can be easily adapted manually \n \n \n Introduced the concept of "System Level Bundles", which allows the installation of root level resources. \n Added  support the CMS categories \n Initial implementation of the bundle Installation plan.\n \n The Installation plan allows to inspect the content of a bundle and to resolve conflicts with the components already present in the destination EntandoApp \n \n \n Fixed support for bundles based on mysql \n Fixed bug that in some condition prevented the bundle plugin pod to properly restart when scaled down and up again \n Fixed intermittent issue on the operator that prevented installing new bundles until the operator was restarted \n Entando Component Generator \n \n Fixed support for the plugin descriptor ingressPath \n Fixed native builds in the Quarkus blueprint \n App Builder \n \n Fixed a couple of permission issues related to page editing. \n We started a process of optimization to improve the performance of AppBuilder on scenarios with a high number of\npages and contents. \n The process will likely be completed for the next patch or minor version release (6.3.3 or 6.4.0) \n Added support for user Avatars \n Fixed the CONTENT SEARCH QUERY WIDGET which in some condition returned no results \n Several fixes in assets, content, page and user management \n Entando CLI "ent" \n \n Ent prj to support profiles in backend build \n Ent prj to force semver on bundle versions (X.Y.Z or vX.Y.Z), in accordance with the rest of the installation process \n Ent prj now allows direct deployment of a bundle via  ent prj deploy \n Implemented support for connection profiles and related connection to clusters via Kubernetes configuration files and/or context \n Implemented a set of ECR operations for\n \n Reading the list of bundles \n Installing a bundle in standard mode \n Installing a bundle in override mode (override the components already present) \n Uninstalling a bundle \n Purging a bundle (completely removes the bundle pods and related data) \n Google Kubernetes Engine (GKE) \n \n Tested and validated GKE deployment under new database scenariosImproved the support for GKE that has been tested under several DB and scenarios. \n Added documentation for using Google Cloud File for clustered storage \n Added documentation and testing for TLS scenarios in Google \n Certifications \n RedHat Certification \n \n Entando 6.3.2 operator is now RedHat certified . The operator is available in the OperatorHub in OpenShift 4.X. \n Tanzu Kubernetes Grid (TKG) Certification \n \n Entando 6.3.2 operator is now certified Tanzu Kubernetes Grid and can be accessed in the  VMWare Marketplace \n Known Issues \n Apple M1 \n \n Entando does not currently support ARM64 architecture and cannot be installed on newer Macs built with the Apple M1 processor. Solutions are under investigation. \n Docker Hub Account Names \n \n The microservice deployment of an Entando plugin will fail if the associated Docker Hub account name is purely numeric (as opposed to alphanumeric). \n Entando Component Generator \n \n The default "detail" widget generated for the entities doesn\'t work out of the box. \n Local keycloak loses state across restarts when using --no-recreate option \n GKE \n \n There is  a known issue with the current nginx ingress that can be worked around by using the  singleHost  option for the configuration of your Entando Applications and binding TLS to that single host path\n \n The issue will be solved in the next minor or patch release (6.4.0 or 6.3.3) \n Custom Resources \n \n The EntandoDatabaseService CRD definition needs to be updated for some configurations -  spec.database  needs to be renamed to  spec.databaseName  to support external databases. \n Deprecation Warnings \n \n Support for version 1 and 2 of the plugin descriptor are deprecated and will be removed in the future \n \n'},{title:"Content Templates",frontmatter:{redirectFrom:"/v6.3.2/tutorials/cms/content-templates-tutorial.html"},regularPath:"/v6.3.2/tutorials/compose/content-templates-tutorial.html",relativePath:"v6.3.2/tutorials/compose/content-templates-tutorial.md",key:"v-7f1d8120",path:"/v6.3.2/tutorials/compose/content-templates-tutorial.html",headers:[{level:2,title:"Create a Content Template",slug:"create-a-content-template"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:" Content Templates \n Content Templates define how the information in a Content item is displayed to an end user once published. Content Templates provide styling and layout for Contents Type and can be used to show the same content in different ways. Content Templates can be managed within the App Builder. \n Create a Content Template \n Creating a Content Template is fairly simple. From the App Builder\napplication \n \n \n Go to  Content → Templates \n \n \n Click on the  Add content template  to create a new Content\nTemplate. \n \n \n \n \n \n Access the  Add Content Template  page, where you can \n \n \n Edit the  Code . It is the unique identifier of the content template.\nYou can insert up to 10 numbers. It’s mandatory. \n \n \n Edit the  Name . It is the name or description of the content\ntemplate. \n \n \n Choose the  Content Type  in the dropdown list. \n \n \n Edit the  HTML Model  based on Velocity language \n \n \n (Optional) Define the CSS  Style Sheet  to be applied to the  HTML Model \n \n \n Press the Save button \n \n \n \n \n \n"},{title:"Content Creation",frontmatter:{redirectFrom:"/v6.3.2/tutorials/cms/content-tutorial.html"},regularPath:"/v6.3.2/tutorials/compose/content-tutorial.html",relativePath:"v6.3.2/tutorials/compose/content-tutorial.md",key:"v-7b1bc340",path:"/v6.3.2/tutorials/compose/content-tutorial.html",headers:[{level:2,title:"Creating Content",slug:"creating-content"},{level:2,title:"Finding Content",slug:"finding-content"},{level:2,title:"Content Actions",slug:"content-actions"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:" Content Creation \n This document provides an overview of Content Management and how to create Content that can be displayed in an application. The App Builder is used to create, edit and publish content stored in the web content management system (WCMS). \n Creating Content \n To see the list of Content in the WCMS: \n \n Go to  Content → Management . All existing\ncontent is displayed in a table list. \n \n \n To create a new Content item and add it to the list \n \n Select the  Add Content  button. A drop-down list will let you\nchoose which Content Type the content will be based on. \n \n \n You will be asked to provide the following information: \n \n \n Info \n \n \n Content Type . This information is pre-defined, and lists the\ncontent type for the content. \n \n \n Description . The specific Content's name or description. This field\nis mandatory. \n \n \n \n \n Groups \n \n \n Owner Group.  Use the drop-down list to choose the\navailable user group that can manage the content.\nThis field is mandatory and may be predefined. \n \n \n Join Group.  Use the drop-down list to choose the\navailable user group to share the content with and select +. The group\nselected will only be able to share and can not\nadministrate this content. This field is not mandatory. \n \n \n Categories.  Select the category(s) and select + to add a classification to the\ncontent to use for searching and sorting.  This field is not mandatory. \n \n \n Content Attributes.  Define each required attributes field and any optional fields\ndefined by the content types used for this Content. This field is mandatory. \n \n \n \n \n \n Save the new content by selecting: \n \n \n Save : The content will be saved in a draft version. \n \n \n Save and Continue : The content will be saved and the editable form will be displayed. \n \n \n Save and Approve : The content will be saved, approved and published. \n Finding Content \n You can list specific Content by using the filters: \n \n \n All : All created Content is displayed (Draft, To Approve and\nApproved/Published) \n \n \n Pending Changes : All created Content that was saved by only clicking on the\n Save  or  Save and Continue  button. The content is not\napproved and therefore is not ready to be published. \n \n \n Ready for Approval : All created Content that is in  Ready  status,\nand saved by clicking on the  Save  or  Save and Continue  button.\nThe content is ready for review but has not yet been approved and\ntherefore has not been published. \n \n \n Published : All created Content that has been saved and approved\nby clicking on the  Save and Approve  button. This content has been\npublished. \n \n \n \n In the table list, contents are listed with several parameters: Name,\nCreated by, Last Edited, Type, Created Date, Owner Group, Join Group,\nStatus, Restrictions, Code, Actions. Fields can be added or deleted from view by selecting or unselecting them\nin the Columns drop-down menu. \n Content Actions \n For all Content in the list, you have access to a set of actions\nthrough the  Actions  kebab button, such as: \n \n \n Edit : update the data fields in the content definition \n \n \n Delete : remove the content \n \n \n Clone : replicate the content \n \n \n Publish : make the content visible \n \n \n Unpublish : hide the content \n \n \n \n All Content in the list can be saved to your local file system by clicking the\n Download  button and selecting either CSV or XLS format. \n \n"},{title:"Tutorials",frontmatter:{sidebarDepth:2},regularPath:"/v6.3.2/tutorials/",relativePath:"v6.3.2/tutorials/README.md",key:"v-c5488050",path:"/v6.3.2/tutorials/",headers:[{level:2,title:"Learning Paths",slug:"learning-paths"},{level:3,title:"Frontend Development",slug:"frontend-development"},{level:3,title:"Backend Development",slug:"backend-development"},{level:3,title:"Operations",slug:"operations"}],lastUpdated:"4/1/2022, 9:38:00 AM",lastUpdatedTimestamp:164882028e4,content:" Tutorials \n Entando simplifies the development of modern apps: \n \n Built using modern JavaScript frameworks \n Backed by microservices deployed in containers, and \n Orchestrated by Kubernetes for fully automated DevOps lifecycles \n \n \n Entando supports full stack micro frontend and microservice architectures for codebases that are easier to understand, maintain, and debug across large, distributed teams, and comes with a private component repository that makes it easy for teams to share and reuse components. \n Use the navigation on the left to find step-by-step tutorials for common tasks or check out our learning paths below for a more structured approach. \n Learning Paths \n Frontend Development \n \n \n \n Basic \n Intermediate \n Advanced \n \n \n \n \n Build a Basic Widget \n Add Configuration to a Widget \n Generate Micro Frontends and Microservices Based on a Database Entity \n \n \n Create a React Micro Frontend \n Enable Communication between MFEs \n \n \n \n Create an Angular Micro Frontend \n Add Access Controls to your MFEs \n \n \n \n Create and Manage Content \n Backend Development \n \n \n \n Basic \n Intermediate \n Advanced \n \n \n \n \n Build and Publish a Simple Bundle \n Build and Publish a Project Bundle \n Export a Bundle from an Existing Application \n \n \n Generate Micro Frontends and Microservices Based on a Database Entity \n Use JDL Studio to Create a Complex Database Entity \n \n \n \n Run Micro Frontends and Microservices in Your Local Environment \n Add Access Controls to Your Microservices \n \n \n \n \n Use Postman with OAuth2 APIs \n Operations \n \n \n \n Basic \n Intermediate \n Advanced \n \n \n \n \n Set Up Entando on a Local Kubernetes Cluster \n Backing Up and Restoring Your Entando Environment \n Install Bundle Microservices from a Private Registry \n \n \n Set Up Entando on Amazon Elastic Kubernetes Service (EKS) \n Customize the base Entando Application via a Docker Image \n Add a GitHub Actions CI Workflow \n \n \n Set Up Entando on Azure Kubernetes Service (AKS) \n Connect Your Entando Application to an External Database \n \n \n \n Set Up Entando on Google Kubernetes Engine (GKE) \n Install the Standard Demo Application \n \n \n \n Set Up Entando on Red Hat OpenShift \n \n \n \n \n Set Up Entando on Tanzu Kubernetes Grid (TKG) \n \n \n \n \n \n"},{title:"Content Types",frontmatter:{redirectFrom:"/v6.3.2/tutorials/cms/content-types-tutorial.html"},regularPath:"/v6.3.2/tutorials/compose/content-types-tutorial.html",relativePath:"v6.3.2/tutorials/compose/content-types-tutorial.md",key:"v-737e16c0",path:"/v6.3.2/tutorials/compose/content-types-tutorial.html",headers:[{level:2,title:"Create a Content Type",slug:"create-a-content-type"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:" Content Types \n A Content Type is used to represent or to model a Content.\nIt is characterized by a set of  Attribute Types , each of which defines the value of their properties, called Attributes. A Content is\nan instance or specialization of the Content Type. \n Create a Content Type \n Creating Contents Types is fairly simple. The Content Types are managed\nthrough the Web CMS, its user interface is made available in the App\nBuilder application. \n \n \n Go to  Content → Types \n \n \n Click on the  Add Content Type  button to create a new Content\nType. \n \n \n \n \n \n You be asked to provide \n \n \n Code . The code is the unique identifier of the content type,\nthat must be 3 uppercase letters, (e.g. CNN). It’s mandatory. \n \n \n Name.  The name must be max 50 characters uppercase and\nlowercase letters, including numbers and special characters,\n(e.g. Conference_News). It’s mandatory. \n \n \n \n \n \n \n \n Select the  Save  button, then you’ll see \n \n \n Content Type Information : \n \n \n Code . The value is pre-filled. \n \n \n Name . The name is pre-filled. \n \n \n \n \n Metadata \n \n \n Page for on-the-fly publishing \n \n \n Default content template \n \n \n Default content template for lists \n \n \n \n \n \n \n Default content template  and  Default content template for lists  are used\nrespectively to show the detailed view of the Content and its\nrepresentation as an element in a list. \n \n Attributes \n \n In the Attributes section, select the  Type  from the drop-down list.\nThe list contains all the available attributes types that define which\nproperties/attributes will characterize the Content. \n \n The Add button will start the configuration of the single attribute\ntype. Every attribute type has its own configuration. \n For example, to configure the  Text  Attribute Type, choose Text from\nthe Types drop-down menu and then press the Add button. \n \n \n \n You should specify the following fields \n \n \n Type:  the value is pre-filled. It represents the selected\nattribute type. \n \n \n Code : You should insert the name of the attribute. (You\ncan insert max 10 characters uppercase and lowercase letters,\nnumbers, and special characters _ ). (e.g. title) \n \n \n Name : You should insert the description of the attribute.\n(You can insert max 50 characters uppercase and lowercase letters,\nincluding numbers and special characters). (e.g. Title). \n \n \n You should declare if the attribute is  mandatory ,\n searchable , and  to be used as a filter in the list. \n \n \n The  Roles  section it is possible to assign the  jacms:title\nAttribute Role  to this attribute; in this way other plugins or\nservices will know that within the CNG entity this attribute is a\ntitle, whatever the key is; however, for sake of clarity, the Code\nof the attribute is Title. \n \n \n The remaining fields related to  Sections  and  Validation -\nOGNL  sections are not mandatory and can be left empty. \n \n \n Press the  Continue  button. The Text attribute type requires no\nadditional configuration step. \n \n \n You can add other Attributes Types. \n \n \n Press the  Save  button. The Content type will be saved and displayed\nin the table list \n \n"},{title:"Page and Content Protection",frontmatter:{redirectFrom:"/v6.3.2/tutorials/cms/creating-protected-resources.html"},regularPath:"/v6.3.2/tutorials/compose/creating-protected-resources.html",relativePath:"v6.3.2/tutorials/compose/creating-protected-resources.md",key:"v-a3f44c40",path:"/v6.3.2/tutorials/compose/creating-protected-resources.html",headers:[{level:2,title:"Create a Group",slug:"create-a-group"},{level:2,title:"Protect a Page",slug:"protect-a-page"},{level:2,title:"Protect Content",slug:"protect-content"},{level:2,title:"Protect Images and Attachments",slug:"protect-images-and-attachments"},{level:2,title:"Freemarker Tags and Consuming Protected Resources",slug:"freemarker-tags-and-consuming-protected-resources"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:" Page and Content Protection \n In the Entando Web Content Management System (WCMS) you have the ability to protect pages, content, and digital assets (images and files) by assigning groups that have the authorization to view those assets. If users without the correct authorization attempt to view those assets the platform will return an error. You can handle those errors as required for your application with dedicated error pages or by adding logic to your widgets or freemarker templates. \n Create a Group \n Protected pages, content, and digital assets in the WCMS are protected by assigning groups to the resource that is being created. You can add new groups in the Entando App Builder as follows: \n \n Go to  Users → Groups  from the left navigation \n Select  Add \n Enter a  Name  and a  Code  for your group` \n \n The groups you create here can be utilized to protect pages, content, images, and attachments in the CMS. Groups can be assigned to individual users in the  Users  section of the app builder or as part of a customization of your entando-core-app using APIs or custom code. \n Pages and Content have settings for an  Owner Group  as well as a set of optional  Join Groups . The  Owner Group  indicates the team within the  App Builder  who owns and can modify the page. Additional groups can be given access to the item via the  Join Group  setting. Note: the default App Builder configuration prevents the  Owner Group  from being changed after the item is created. \n Protect a Page \n \n Select  Pages → Management  from the left navigation \n Create a new page. Assign values as you see fit \n To protect a page, assign the  Owner Group  to any group other than  Free Access \n (Optional) Add groups via  Join Group \n Finish configuring the page and select  Save \n \n At this point only users assigned to either the  Owner Group  or  Join Group  will have the ability to view that page. They can also manage the Page if they have the appropriate App Builder role. \n If you would like to test this, navigate to the page URL in a private or incognito browser window and you will be redirected to the  Sign in to Proceed Further  page of your application.\nThe  Sign in to Proceed Further  page can be changed by going to  Pages → Settings  and picking the page you would like to render to users who need to sign in. \n Protect Content \n \n Select  Content → Management  from the left navigation \n Select the  Add Content  button and pick the content type to be created \n To protect a content item, assign the  Owner Group  to any group other than  Free Access \n (Optional) Add groups via  Join Group \n Finish configuring the page and select  Save \n \n The content you are creating will only be available to users assigned to the  Owner Group  of  Join Group . The default WCMS widgets will only return content authorized for a given user. See the  freemarker tags  section below for information on creating custom widgets that utilize protected content. \n Images and Attachments and Groups \n When creating content the  Owner Group  of the content and the  Group  assigned to the digital asset must match. For example, when creating content with an  Owner Group  of  Administrators  the content creator will be unable to select images and attachments that are assigned a different group. The exception to this is assets with a group of  Free Access . Assets with  Free Access  can be added to protected content. \n Protect Images and Attachments \n Images and attachments uploaded to the CMS can be protected by assigning groups. \n \n Select  Content → Assets  from the left navigation \n Upload your file(s) \n In the provided modal window select the  Group  that you would like to own the asset \n Only users with the assigned  Group  will have the ability to view the asset you've created\n \n The asset will only be available to content with the same  Group  unless the attachment or image has been given a group of  Free Access \n Freemarker Tags and Consuming Protected Resources \n The WCMS provides a set of freemarker tags to assist in consuming protected assets in widgets and pages. The  if-authorized  and  tag-nav  tags can help in rendering page lists and fetching assets. \n The  content  and  content-list  tags also provide the ability to fetch and render protected content and protected lists of content. \n Additionally, the   REST APIs  allow clients to fetch protected pages and assets by group via query parameters. The content REST APIs also include the ability to filter by group and access level. \n"},{title:"Digital Assets",frontmatter:{redirectFrom:"/v6.3.2/tutorials/cms/digital-assets-tutorial.html"},regularPath:"/v6.3.2/tutorials/compose/digital-assets-tutorial.html",relativePath:"v6.3.2/tutorials/compose/digital-assets-tutorial.md",key:"v-52142e80",path:"/v6.3.2/tutorials/compose/digital-assets-tutorial.html",headers:[{level:2,title:"Create a Digital Asset",slug:"create-a-digital-asset"},{level:2,title:"Editing Assets",slug:"editing-assets"},{level:3,title:"Cropping Images",slug:"cropping-images"},{level:2,title:"Embedding an Asset in a Page",slug:"embedding-an-asset-in-a-page"},{level:2,title:"Including an Asset in a Content",slug:"including-an-asset-in-a-content"},{level:2,title:"Configuring Allowed File Extensions for Upload",slug:"configuring-allowed-file-extensions-for-upload"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:" Digital Assets \n The Web Content Management System (WCMS) includes capabilities that let you manage contents and digital assets. Digital Assets are images, documents, and other media\nfiles in specific formats. \n Default Supported Document Formats:  The Entando WCMS can be\nconfigured to allow you to load or exclude any type of file extension\nfrom being loaded to your site. For the app builder you should also include the MIME type of the asset you want to allow. The default set of extensions are:\n pdf,xls,doc,ppt,txt,rtf,sxw,sxc,odt,ods,odp,tar,gz,zip,rar,flv,swf,avi,wmv,ogg, \n mp3,wav,ogm,mov,iso,nrg,docx,docm,xlsx,xlsm,xlsb,pptx,pptm,ppsx,ppsm,sldx,sldm \n Default Supported Image Formats :  jpg, jpeg, png, svg,svg+xml \n Create a Digital Asset \n To manage the Digital Assets through the WCMS: \n \n Go to  Content → Types \n \n Add a new image or a new document file \n \n Press the  Drag and Drop or Browse your computer  button and\nchoose, from your file system, images and documents files that you\nwould like to upload \n \n \n \n From the  Add file  modal window, you must choose one of the\navailable Groups and then the  Upload  button. If categories have\nbeen defined, you can apply them to the asset in this step. \n \n \n \n \n The image file that you just uploaded is displayed in the list; a\nstatistical overview of the number of the uploaded resources (images\nand documents) is provided. The App Builder’s interface allows the\nusers to choose grid and list view; most of the time, users prefer\nto use list view when they are searching with specific requirements,\nwhile they love grid view for exploring. For every resource, image,\nor document, the list shows the following information: \n \n \n Preview \n \n \n Name \n \n \n Type \n \n \n Uploaded By \n \n \n Uploaded At \n \n \n Group \n \n \n Categories \n \n \n Actions \n \n \n \n \n Furthermore, the interface lets you perform all management actions, as: \n \n \n Edit:  update the information data related to every single\nresource (image and document) \n \n \n Duplicate:  copy identically the resource from the original \n \n \n Download:  transfer the resource to your local machine \n \n \n Delete:  remove the resource \n \n \n You can list the contents by filtering with: \n \n \n All : All added files are displayed, images and documents both. \n \n \n Images : All added images are displayed \n \n \n Documents : All added documents are displayed. \n Editing Assets \n Once you have a digital asset in place, you have several editing and viewing options. Click the asset's  Actions  button and select  Edit  to update the asset's name/description, categories, and the file represented. \n Cropping Images \n You can crop images newly uploaded via Digital Assets. You can either crop the image dynamically or by using pre-configured crop ratios. \n To set pre-configured crop ratios: \n \n Select  CMS → Content Settings \n Under  Settings Image Crop Dimensions,  click  Add crop dimension . \n Enter a crop ratio, using numeric values separated by a colon. \n Click  Save . \n \n To dynamically crop an image: \n \n Edit the asset by opening  Actions  menu > Edit.\n \n Buttons representing your pre-defined crop ratios are below the image. Clicking any of those buttons changes the selected crop area based on the chosen ratio. \n You can create multiple crops of a single image as part of the upload process. The right side of the screen displays the list of crops created during the current session. \n \n \n \n \n \n Use your mouse or the buttons below the image to move or change the crop area, then click  Save  to crop the selected area. Repeat the process as many times as needed.\n \n Click  Close  to return to the Digital Assets screen. \n Embedding an Asset in a Page \n The uploaded asset can be embedded in a page by using  <@wp.resourceUrl path/to/asset . The path can be found in the CMS Configuration > File Browser page. \n \n Example usage:\n <img src=\"<@wp.resourceUrl cms/images/butterfly_d0_d3.jpg\" \n Including an Asset in a Content \n The asset can be included in a content of a type that has an  Attach  or  Image  attribute. \n \n Create a content type with an image attribute.\n \n Create a content based on the created  type.\n \n Under the  Content Attributes  section at the bottom of the page, click the  Add  button beside the image attribute. It will then open a modal that allows you to select an asset by clicking the  Use  action.\n Configuring Allowed File Extensions for Upload \n The types of files that can be uploaded to an Entando application are controlled by\nconfiguration in the server side of the app builder. If you're using the quickstart this will be the\n entando-de-app . \n There are two properties that control these settings and they are set in  src/main/conf/systemParams.properties  and are a comma delimitted list of values. The property keys are \n \n jacms.imageResource.allowedExtensions= \n jacms.attachResource.allowedExtensions= \n \n If you are configuring the upload for both the App Builder and the legacy Admin Console you should include\nboth the MIME type of the asset and the file extension. The APIs that support resources will check MIME type of the uploaded asset. \n An example configuration for images. \n \n jacms.imageResource.allowedExtensions=jpg,jpeg,png,svg,svg+xml \n \n Where  svg+xml  is the MIME type for an svg image. \n The  systemParams.properties  file is bundled into the WAR and the image for the application so you will need to create and deploy image to reflect changes for these properties in your application. \n"},{title:"Page Management",frontmatter:{redirectFrom:"/v6.3.2/tutorials/cms/page-management.html"},regularPath:"/v6.3.2/tutorials/compose/page-management.html",relativePath:"v6.3.2/tutorials/compose/page-management.md",key:"v-3dbf2024",path:"/v6.3.2/tutorials/compose/page-management.html",headers:[{level:2,title:"Create a Page",slug:"create-a-page"},{level:2,title:"Create a Page Template",slug:"create-a-page-template"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:' Page Management \n The App Builder provides the capability to publish application pages containing content as well as other Entando components. Page Templates are used to layout the available frames on a page. \n Create a Page \n \n Go to  Pages → Management \n Click  Add \n \n \n You will need to supply at least the following fields: \n \n Title : used for SEO \n Code : must be unique \n Page placement : the location of the Page in the Page Tree \n Owner Group : the Group that has access to the Page \n Page Template : the structure and presentation of the Page \n \n \n \n Click the green  Save and Design  button. This brings you to the Designer section which lets you place widgets into the Page Template frames. \n \n \n \n Add widgets by dragging them from the right column into the desired frame. \n If you select the  Content  widget, its corresponding settings page will be shown. \n \n \n \n Click  Add existing content  to bring up the Content selection view. \n \n \n \n \n In the Search field, you can type the name of the content that you\nwould like to publish. Remember\nthat in order to publish the content on your page, it must first be saved\nand approved. \n \n \n Select the appropriate content item from the list. \n \n \n Press the  Save  button. \n \n \n \n \n \n The title of the selected content item will now be displayed in the widget settings. \n \n \n Press the  Save  button. \n \n \n Click on the  Preview  button to show the page preview with the updated settings. \n \n \n Click on the  Publish  button to publish the page. \n \n \n Click on the  View published page  button to view the published page in your application. \n Create a Page Template \n Page Templates provide the scaffolding of a Page and are constructed using two main elements: \n \n A  JSON configuration  field which lists the set of frames that can be used on a page.\n \n Each item in the frames array represents a frame or slot in the page, characterized by the following values:\n \n pos  - a zero-based position index (starts from zero). This value is used in\nAPIs to address a specific widget on the page. \n descr  - the frame description displayed on Page Design view \n mainFrame  - designates the primary frame in the Page Template \n defaultWidget  - widget code for a default widget to use in this frame. Page Template developers can use this field to provide suggestions on common widgets, e.g. header and footer widgets. \n sketch  - an object with 4 coordinates (x1,x2,y1,y2) to allow the developer to place the widgets in the Page preview. Sketch’s x and y values go from 0 to 11 (similar to columns in Bootstrap), so if you want to place a 2x2 frame at the top left corner of the page, the values would be  x1: 0, x2: 1 y1: 0 y2: 1 . \n \n \n \n \n A  Template  field which uses Freemarker code to setup the HTML page itself.\n \n To add a frame in a specific place of the page, add  <@wp.show frame=0 /> , where frame is the pos variable from the  JSON configuration .  <#assign wp=JspTaglibs["/aps-core"]>  is required at the top of the template to setup the  wp  variable. \n Common code can be shared across pages by using  UX Fragments  and  <@wp.fragment code="\\<FRAGMENT\\_CODE\\>" escapeXml=false /\\> . \n \n \n \n This tutorial prepares a Page Template with two frames on it. \n \n \n Go to  Pages → Templates → Add \n \n \n Enter the following: \n \n \n \n Code: double_frame \n \n Note: dashes are not allowed \n \n \n Name: Double Frame \n JSON Configuration: \n \n { \n   "frames" :   [ \n     { \n       "pos" :   0 , \n       "descr" :   "Frame 1" , \n       "mainFrame" :   false , \n       "defaultWidget" :   null , \n       "sketch" :   { "x1" :   0 ,   "y1" :   0 ,   "x2" :   11 ,   "y2" :   1 } \n     } , \n     { \n       "pos" :   1 , \n       "descr" :   "Frame 2" , \n       "mainFrame" :   false , \n       "defaultWidget" :   null , \n       "sketch" :   { "x1" :   0 ,   "y1" :   2 ,   "x2" :   11 ,   "y2" :   3 } \n     } \n   ] \n } \n \n \n Template: \n \n < #assign  wp = JspTaglibs [ "/aps-core" ] > \n <! DOCTYPE   HTML   PUBLIC   "-//W3C//DTD HTML 4.0 Transitional//EN" > \n < html > \n   < head > \n       < title > < @wp . currentPage param = "title"   /> </ title > \n   </ head > \n   < body > \n     < h1 > < @wp . currentPage param = "title"   /> </ h1 > \n     < div > < @wp . show frame = 0   /> </ div > \n     < div > < @wp . show frame = 1   /> </ div > \n   </ body > \n </ html > \n \n Include the following fragment in the  head  section if you want to make use of the user\'s identity information from Keycloak. \n < @wp . fragment code = "keycloak_auth"  escapeXml = false   /> \n \n \n You should see the  Template preview  reflecting the desired two frame layout. \n Click  Save  to save your template. \n \n'},{title:"Widgets and Fragments",frontmatter:{redirectFrom:"/v6.3.2/tutorials/cms/app-builder/hello-world.html"},regularPath:"/v6.3.2/tutorials/compose/widgets-fragments.html",relativePath:"v6.3.2/tutorials/compose/widgets-fragments.md",key:"v-59b51a1c",path:"/v6.3.2/tutorials/compose/widgets-fragments.html",headers:[{level:2,title:"Create a Widget",slug:"create-a-widget"},{level:2,title:"Create a UX Fragment",slug:"create-a-ux-fragment"},{level:2,title:"FreeMarker Basics in Entando",slug:"freemarker-basics-in-entando"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:' Widgets and Fragments \n This tutorial will take you through the basics of creating an Entando\nwidget and placing it on a page. This document will also review the\nbasics of fragments which are re-usable pieces of a user interface. \n Create a Widget \n For this example you will use the Entando App Builder to build and\ndisplay a simple widget on a page. In a production system or a larger\ndevelopment environment you would build and deploy widgets differently,\nhowever this example provides a quick idea of the building blocks. For a more advanced example you can try  this tutorial  which includes building and deploying a micro frontend as a widget in Entando. \n \n \n In the App Builder menu, go to:  Components → Micro frontends & Widgets \n \n At bottom of the page, select ADD \n \n \n \n Now create a widget with the sample HTML code.  Enter into the following fields: \n \n Code:  MyHelloWorld \n en Title:  Hello World \n it Title:  Ciao Mondo \n Custom UI field:  <h2>Hello World</h2> \n Select SAVE \n Note: the Custom UI Field is a freemarker template where you can put raw html and include freemarker logic. This allows you to import javascript, css, or any normal HTML. \n \n \n \n Select a new Home Page \n \n Go To:  Pages → Settings \n From the “Home Page” dropdown menu, select “Home / Service” and select SAVE \n \n \n \n Place the widget on the page \n \n Go To:  Pages → Management \n On the row that says "Service", on the far right side, select the Kebab button and select DESIGN \n From the right hand column, drag and drop the new widget into an open frame in the page \n From the top of the page, select PREVIEW \n You should see "Hello World" on the page \n \n \n \n Publish the updated page \n \n Go To:  Pages → Management \n Note for the row showing the Services page, the Status is now yellow \n Select the Kebab button and select PUBLISH \n Create a UX Fragment \n A UX Fragment is a way to take a common piece of front end code and reuse\nit across multiple pages or widgets. Common elements such as basic HTML,\njavascript, or freemarker logic can be stored as fragments and\nreferenced via the  <@wp.fragment …  tag. \n Starting from the simple widget tutorial above: \n \n \n Create a new fragment: \n \n In the App Builder Go To:  Components → UX Fragments \n At bottom of page, select ADD, and enter the following fields \n Code:  test \n Gui Code:  <h2>Hello World</h2> \n Select SAVE \n \n \n \n Place the fragment in a template: \n \n Go To:  Pages → Page Templates \n On the row for service, select EDIT \n In the  Template  text box, add   <@wp.fragment code="test"/>  on a new line between the  <body>  and   </body>  tags \n SAVE the page template \n \n \n \n View the page with the new fragment: \n \n Go To:  Pages → Management \n On the row that says "Service", on the far right side, select the Kebab button and select CONFIGURE \n From the top of the page, select PREVIEW \n Note: You will see the fragment  <h2> This is a fragment. </h2>  which includes the HTML tags. By default html embedded via a fragment tag is escaped so you get it rendered exactly as you enter it. You’ll need to un-escape it to get it to render correctly. \n \n \n \n Update the Fragment: \n \n Go To:  Pages → Page Templates \n On the row for service, select EDIT \n Change the tag to:  <@wp.fragment code="test" escapeXml=false/> \n \n \n \n View the page with the updated fragment: \n \n Go To:  Pages → Management \n On the row that says "Service", on the far right side, select the Kebab button and select CONFIGURE \n From the top of the page, select PREVIEW \n See correctly rendered fragment \n FreeMarker Basics in Entando \n The FreeMarker templating language gives you a lot of flexibility and\npower in how pages are rendered. You can include conditional logic,\ninject information from the backend, check for query parameters and\nroute to different pages. \n For example, to check for a query parameter you can use:\n <#if RequestParameters.myParam?exists > … \n To check the current username, use:\n <#if (Session.currentUser.username != "guest") > \n When you need dynamic behavior in your widgets consider using the power\nof FreeMarker. \n https://freemarker.apache.org \n'},{title:"Micro Frontends",frontmatter:{sidebarDepth:2,redirectFrom:"/v6.3.2/tutorials/micro-frontends/"},regularPath:"/v6.3.2/tutorials/create/mfe/",relativePath:"v6.3.2/tutorials/create/mfe/README.md",key:"v-740775e4",path:"/v6.3.2/tutorials/create/mfe/",headers:[{level:2,title:"Introduction",slug:"introduction"},{level:2,title:"Tutorials",slug:"tutorials"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:" Micro Frontends \n Introduction \n \n The idea behind Micro Frontends is to think about a website or web app as  a composition of features  which are owned by  independent teams . Each team has a  distinct area of business  or  mission  it cares about and specialises in. A team is  cross functional  and develops its features  end-to-end , from database to user interface. \n —  Michael Geers,  micro-frontends.org \n \n Think of micro frontends as the implementation of a microservices architecture applied to the full web application that extends all the way to the frontend. \n Entando implements micro frontends based on  Web Components , a set of technologies that allow developers to create reusable custom elements supported by all major internet browsers. \n Web Components can work with vanilla JavaScript as well as with the most popular web frameworks (e.g., React, Angular, and Vue). \n Entando's microservice and micro frontend architecture allows developers to work with their favorite technology stack, and makes it easier for companies to integrate disparate applications. \n Tutorials \n \n \n Create a React Micro Frontend \n \n \n Create an Angular Micro Frontend \n \n \n Add an App Builder configuration screen to a\nwidget \n \n \n Display widget configuration \n \n \n Communicate Between Micro Frontends \n \n \n Widget authentication with Keycloak \n \n \n"},{title:"Communicate Between Micro Frontends",frontmatter:{sidebarDepth:2,redirectFrom:"/v6.3.2/tutorials/micro-frontends/communication.html"},regularPath:"/v6.3.2/tutorials/create/mfe/communication.html",relativePath:"v6.3.2/tutorials/create/mfe/communication.md",key:"v-d415568e",path:"/v6.3.2/tutorials/create/mfe/communication.html",headers:[{level:2,title:"Publisher",slug:"publisher"},{level:3,title:"Create Custom Event",slug:"create-custom-event"},{level:3,title:"Update React App to Dispatch Event",slug:"update-react-app-to-dispatch-event"},{level:3,title:"Test Event Dispatcher",slug:"test-event-dispatcher"},{level:2,title:"Subscriber",slug:"subscriber"},{level:3,title:"Add Event Listener",slug:"add-event-listener"},{level:3,title:"Display Custom Event",slug:"display-custom-event"},{level:3,title:"Test Event Listener",slug:"test-event-listener"},{level:2,title:"Add Widgets to App Builder",slug:"add-widgets-to-app-builder"},{level:3,title:"Create Environment File",slug:"create-environment-file"},{level:3,title:"Run npm build",slug:"run-npm-build"},{level:3,title:"Create Public Folder",slug:"create-public-folder"},{level:3,title:"Add Widgets",slug:"add-widgets"},{level:3,title:"View on a Page",slug:"view-on-a-page"},{level:2,title:"Angular to React",slug:"angular-to-react"},{level:3,title:"Create Angular Publisher",slug:"create-angular-publisher"},{level:3,title:"Add to App Builder",slug:"add-to-app-builder"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:" Communicate Between Micro Frontends \n Recommended Learning \n \n Tutorial:  Create a React Micro Frontend \n Tutorial:  Create an Angular Micro Frontend \n \n \n Entando supports communication between micro frontends using  Custom Events , an established web standard. In this tutorial, we'll build: \n \n A React micro frontend that publishes an event \n A React micro frontend that listens to an event \n An Angular micro frontend that publishes an event to a React micro frontend \n Publisher \n Create a simple app to publish an event. \n npx create-react-app publisher-widget --use-npm\n \n Start the app. \n cd  publisher-widget\n \n npm  start\n Create Custom Event \n Next, add event firing logic. \n Add a new file  publisher-widget/src/PublisherWidgetElement.js . \n import  React  from   'react' ; \n import  ReactDOM  from   'react-dom' ; \n import  App  from   './App' ; \n\n const   EVENTS   =   { \n   greeting :   'greeting' , \n } ; \n\n class   PublisherWidgetElement   extends   HTMLElement   { \n\n   constructor ( )   { \n     super ( ) ; \n     this . onGreet   =   name   =>   this . publishWidgetEvent ( EVENTS . greeting ,   {  name  } ) ; \n   } \n\n   connectedCallback ( )   { \n     this . mountPoint  =  document . createElement ( 'div' ) ; \n     this . appendChild ( this . mountPoint ) ; \n     this . render ( ) ; \n   } \n\n   publishWidgetEvent ( eventId ,  detail )   { \n     const  widgetEvent  =   new   CustomEvent ( eventId ,   {  detail  } ) ; \n    window . dispatchEvent ( widgetEvent ) ; \n   } \n\n   render ( )   { \n    ReactDOM . render ( < App onGreet = { this . onGreet }   / > ,   this . mountPoint ) ; \n   } \n } \n\ncustomElements . define ( 'publisher-widget' ,  PublisherWidgetElement ) ; \n\n export   default  PublisherWidgetElement ; \n \n \n In the  CustomEvent  constructor,  detail  is the specific name to use in the event payload, as per the  DOM specification . \n Import Custom Element \n Update  publisher-widget/src/index.js . \n import   './index.css' ; \n import   './PublisherWidgetElement' ; \n Test Custom Element \n Update  publisher-widget/public/index.html , and view it in the browser. \n    < body > \n     < noscript > You need to enable JavaScript to run this app. </ noscript > \n     < publisher-widget   /> \n    ...\n   </ body > \n Update React App to Dispatch Event \n Update  publisher-widget/src/App.js . \n import  React  from   'react' ; \n import   './App.css' ; \n\n class   App   extends   React . Component   { \n   constructor ( props )   { \n     super ( props ) ; \n     this . state  =   {   name :   '' } ; \n   } \n\n   handleNameChange ( value )   { \n     this . setState ( prevState   =>   ( { \n       ... prevState , \n       name :  value , \n     } ) ) ; \n   } \n\n   render ( )   { \n     const   {  name  }   =   this . state ; \n     const   {  onGreet  }   =   this . props ; \n     return   ( \n       < div > \n         < h1 > Send a greeting < / h1 > \n         < label htmlFor = \"name\" > Name < / label > \n         < input id = \"name\"  onChange = { e   =>   this . handleNameChange ( e . target . value ) }  value = { name }   / > \n         < button onClick = { ( )   =>   onGreet ( name ) } > Say hello ! < / button > \n       < / div > \n     ) ; \n   } \n } \n\n export   default  App ; \n Test Event Dispatcher \n In the JavaScript console of your browser, enter: \n window . addEventListener ( 'greeting' ,   ( evt )   =>  console . log ( 'Hello' ,  evt . detail . name ) ) \n \n Write something in the text field. Click the \"Say hello!\" button and take a look at the JS console. It will show the event message. \n Congratulations! \n You’ve now published a custom event. \n Subscriber \n Next, let’s create the subscriber. \n npx create-react-app subscriber-widget --use-npm\n \n Start the app. \n cd  subscriber-widget\n \n npm  start\n Add Event Listener \n Add a new file  subscriber-widget/src/SubscriberWidgetElement.js . \n import  React  from   'react' ; \n import  ReactDOM  from   'react-dom' ; \n import  App  from   './App' ; \n\n const   EVENTS   =   { \n   greeting :   'greeting' , \n } ; \n\n class   SubscriberWidgetElement   extends   HTMLElement   { \n\n   constructor ( )   { \n     super ( ) ; \n     this . name  =   null ; \n     this . subscribeToWidgetEvent ( EVENTS . greeting ,   ( evt )   =>   this . onGreeting ( evt . detail . name ) ) ; \n   } \n\n   connectedCallback ( )   { \n     this . mountPoint  =  document . createElement ( 'div' ) ; \n     this . appendChild ( this . mountPoint ) ; \n     this . render ( ) ; \n   } \n\n   subscribeToWidgetEvent ( eventType ,  eventHandler )   { \n    window . addEventListener ( eventType ,  eventHandler ) ; \n   } \n\n   onGreeting ( name )   { \n     this . name  =  name ; \n     this . render ( ) ; \n   } \n\n   render ( )   { \n    ReactDOM . render ( < App name = { this . name }   / > ,   this . mountPoint ) ; \n   } \n } \n\ncustomElements . define ( 'subscriber-widget' ,  SubscriberWidgetElement ) ; \n\n export   default  SubscriberWidgetElement ; \n Import Custom Element \n Update  subscriber-widget/src/index.js . \n import   './index.css' ; \n import   './SubscriberWidgetElement' ; \n Test Micro Frontend \n Update  subscriber-widget/public/index.html , and view it in the browser. \n    < body > \n     < noscript > You need to enable JavaScript to run this app. </ noscript > \n     < subscriber-widget > \n    ...\n   </ body > \n Display Custom Event \n Update  subscriber-widget/src/App.js . \n import  React  from   'react' ; \n import   './App.css' ; \n\n function   App ( {  name  } )   { \n   return  name  ?   ( < h2 > Just got a greeting from  { name } < / h2 > ) \n     :   ( < h2 > Waiting  for  a greeting ... < / h2 > ) ; \n } \n\n export   default  App ; \n Test Event Listener \n In the JavaScript console of your browser, enter: \n const  widgetEvent  =   new   CustomEvent ( 'greeting' ,   { \n   detail :   { \n     name :   'Pippo' \n   } , \n } ) ; \nwindow . dispatchEvent ( widgetEvent ) ; \n \n The custom event should now display in the  subscriber-widget . \n Congratulations! \n You’ve now created a micro frontend that listens to custom events. \n Add Widgets to App Builder \n Now let's add the publisher and subscriber micro frontends in Entando. \n \n Note: These are the same steps as the  Create a React Micro Frontend  tutorial. \n Create Environment File \n Publisher Widget \n \n \n Create an  .env  file in the project root for the  publisher-widget . \n \n \n Open the  .env  file, and enter the  PUBLIC_URL  where the micro frontend will be hosted. \n \n \n Example: \n PUBLIC_URL=http://quickstart-entando.192.168.64.34.nip.io/entando-de-app/cmsresources/publisher-widget\n \n Notes \n \n Replace  quickstart-entando.192.168.64.34.nip.io  with the ingress you use to access Entando from your local browser. \n /entando-de-app/cmsresources/  is your Resource URL. \n publisher-widget  is the public folder we'll create to host the publisher micro frontend. \n Subscriber Widget \n \n \n Create an  .env  file in the project root for the  subscriber-widget . \n \n \n Open the  .env  file, and enter the  PUBLIC_URL  where the micro frontend will be hosted. \n \n \n \n Use  subscriber-widget  for the name of the public folder we'll create to host the subscriber micro frontend. \n \n Example: \n PUBLIC_URL=http://quickstart-entando.192.168.64.34.nip.io/entando-de-app/cmsresources/subscriber-widget\n Run npm build \n Publisher Widget \n \n \n Open a command line, and navigate to the project root of the  publisher-widget . \n \n \n Run build. \n \n \n npm  run build\n \n \n Rename the following generated files in the  build  directory. \n \n \n \n \n Example of Generated Build File \n Rename to \n Function \n \n \n \n \n build/static/js/2.f14073bd.chunk.js \n static/js/vendor.js \n Third-party libraries \n \n \n build/static/js/runtime-main.8a835b7b.js \n static/js/runtime.js \n Bootstrapping logic \n \n \n build/static/js/main.4a514a6d.chunk.js \n static/js/main.js \n App \n \n \n build/static/css/main.5f361e03.chunk.css \n static/css/main.css \n Stylesheet \n Subscriber Widget \n \n Repeat steps 1-3 for the  subscriber-widget . \n Create Public Folder \n Publisher Widget \n \n \n Navigate to  Entando App Builder  in your browser. \n \n \n Go to  Configuration  →   File Browser   →  public \n \n \n Click  Create Folder . \n \n \n Enter  publisher-widget . \n \n \n Click  Save . \n \n \n Click  public  →  publisher-widget . \n \n \n Create the same folder structure as your generated build directory \n \n \n \n publisher-widget/static/css \n publisher-widget/static/js \n \n \n Upload the files we renamed in the corresponding  js  and  css  folders. \n \n \n publisher-widget/static/css/main.css \n publisher-widget/static/js/main.js \n publisher-widget/static/js/runtime.js \n publisher-widget/static/js/vendor.js \n Subscriber Widget \n \n Repeat steps 1-8 for the  subscriber-widget . \n Add Widgets \n Publisher Widget \n \n \n Go to  Entando App Builder  in your browser. \n \n \n Go to  Components  →  Micro Frontends & Widgets  at the top nav. \n \n \n Click  Add . \n \n \n Enter the following: \n \n \n \n Code: publisher_widget  → note: dashes are not allowed \n Title: Publisher Widget  → for both English and Italian languages \n Group: Free Access \n Custom UI: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < link   rel = \" stylesheet \"   type = \" text/css \"   href = \" < @wp . resourceURL  /> publisher-widget/static/css/main.css \" > \n < script   async   src = \" < @wp . resourceURL  /> publisher-widget/static/js/runtime.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> publisher-widget/static/js/vendor.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> publisher-widget/static/js/main.js \" > </ script > \n < publisher-widget   /> \n \n \n Click  Save . \n Subscriber Widget \n Repeat steps 1-5 for the subscriber widget. \n \n Code: subscriber_widget  → note: dashes are not allowed \n Title: Subscriber Widget  → for both English and Italian languages \n Group: Free Access \n Custom UI: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < link   rel = \" stylesheet \"   type = \" text/css \"   href = \" < @wp . resourceURL  /> subscriber-widget/static/css/main.css \" > \n < script   async   src = \" < @wp . resourceURL  /> subscriber-widget/static/js/runtime.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> subscriber-widget/static/js/vendor.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> subscriber-widget/static/js/main.js \" > </ script > \n < subscriber-widget   /> \n View on a Page \n You can setup the widgets on an existing page (such as the Home page) or create your own page using the tutorial  here . The following steps assume you'll use the Home page. \n \n \n Go to  Pages  →  Management \n \n \n For the  Home  page  (folder icon) , in the  Actions  column, click the  ⋮  icon \n \n \n Click  Edit . \n \n \n In the  Settings  section, select a Page Template with more than one frame, e.g.  1-column : \n \n \n \n Page Template: 1 Column \n \n \n \n Click  Save and Configure . \n \n \n In the  WIDGETS  sidebar on the right: \n \n \n \n Drag  Publisher Widget  and  Subscriber Widget  into  Frame 1  and  Frame 2 . \n \n \n \n Click  Publish . \n \n \n To view the home page, scroll to the top of the page, and click  Go to Homepage . \n \n \n Enter a greeting in the input field. Press the submit button. The subscriber widget will update with the greeting. Done! \n \n \n Congratulations! \n You can now communicate between micro frontends with  Custom Events . \n Angular to React \n We can also communicate between micro frontends using different JavaScript frameworks. \n In this next example, we’ll create an Angular micro frontend to publish an event, and we'll use the React micro frontend we created in the previous section to receive the event. \n Create Angular Publisher \n ng new angular-publisher-widget\n \n Choose the following options: \n ? Would you like to  add  Angular routing? No\n? Which stylesheet  format  would you like to use? CSS\n \n Serve the application. \n cd  angular-publisher-widget\n \n ng serve\n Convert to Custom Element \n Next, let's convert our Angular app into a custom element. We'll use  Angular elements  to transform components into custom elements. \n ng  add  @angular/elements\n \n Replace the contents of  angular-publisher-widget/src/app/app.module.ts . \n \n In this file, we bootstrap the custom element using the  ngDoBootstrap  method. \n \n import   {  BrowserModule  }   from   '@angular/platform-browser' ; \n import   {  NgModule ,  Injector  }   from   '@angular/core' ; \n import   {  createCustomElement  }   from   '@angular/elements' ; \n import   {  AppComponent  }   from   './app.component' ; \n import   {  ReactiveFormsModule  }   from   '@angular/forms' ; \n\n@ NgModule ( { \n   declarations :   [ \n    AppComponent\n   ] , \n   imports :   [ \n    BrowserModule , \n    ReactiveFormsModule\n   ] , \n   providers :   [ ] , \n   entryComponents :   [ AppComponent ] \n } ) \n export   class   AppModule   { \n   constructor ( private   injector :  Injector )   { } \n\n   ngDoBootstrap ( )   { \n     const  el  =   createCustomElement ( AppComponent ,   {   injector :   this . injector  } ) ; \n    customElements . define ( 'angular-publisher-widget' ,  el ) ; \n   } \n } \n Create Custom Event \n Replace the contents of  angular-publisher-widget/src/app/app.component.ts . \n \n Here, we're adding code to dispatch the custom event. \n \n import   {  Component  }   from   '@angular/core' ; \n import   {  FormControl ,  FormGroup  }   from   '@angular/forms' ; \n\n const   EVENTS   =   { \n   greeting :   'greeting' , \n } ; \n\n@ Component ( { \n   selector :   'app-root' , \n   templateUrl :   './app.component.html' , \n   styleUrls :   [ './app.component.css' ] \n } ) \n export   class   AppComponent   { \n  greetingForm  =   new   FormGroup ( { \n     name :   new   FormControl ( '' ) , \n   } ) ; \n\n   publishWidgetEvent ( eventId ,  detail )   { \n     const  widgetEvent  =   new   CustomEvent ( eventId ,   {  detail  } ) ; \n    window . dispatchEvent ( widgetEvent ) ; \n   } \n\n   onSubmit ( )   { \n     const  name  =   this . greetingForm . get ( 'name' ) . value ; \n     this . publishWidgetEvent ( EVENTS . greeting ,   {  name  } ) ; \n   } \n } \n Add HTML Form \n Replace the contents of  angular-publisher-widget/src/app/app.component.html . \n \n In the app component html, we're adding a simple form to call our component class  app.component.ts . \n \n < h1 > Send a greeting </ h1 > \n < form   [formGroup] = \" greetingForm \"   (ngSubmit) = \" onSubmit() \" > \n   < label > \n    Name\n     < input   type = \" text \"   formControlName = \" name \" > \n   </ label > \n   < button   type = \" submit \" > Say hello! </ button > \n </ form > \n View Micro Frontend \n Open  angular-publisher-widget/src/index.html . \n In the  <body> , replace  <app-root></app-root>  with your custom element  <angular-publisher-widget /> . \n < body > \n   < angular-publisher-widget   /> \n </ body > \n \n You can check to see if your micro frontend is working in your browser (e.g., localhost:4200) \n Add to App Builder \n Now we're ready to host our micro frontend in Entando. \n Build It \n From the project root, type: \n ng build --prod --outputHashing = none\n \n This will generate a  dist  directory. \n Create Public Folder \n \n \n Navigate to  Entando App Builder  in your browser. \n \n \n Click  Configuration  →   File Browser   →  public . \n \n \n Create a folder named  angular-publisher-widget . \n \n \n Click  Upload Files . \n \n \n From your generated  dist  folder, upload: \n \n \n \n main-es2015.js \n polyfills-es2015.js \n runtime-es2015.js \n Add Widget \n \n \n Go to  Components > Micro frontends & Widgets  in the Entando App Builder. \n \n \n Click  Add  at the lower right. \n \n \n Enter the following: \n \n \n \n Code: angular_publisher_widget  → note: dashes are not allowed \n Title: Angular Publisher Widget  → for both English and Italian languages \n Group: Free Access \n Custom UI: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < script   async   src = \" < @wp . resourceURL  /> angular-publisher-widget/main-es2015.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> angular-publisher-widget/polyfills-es2015.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> angular-publisher-widget/runtime-es2015.js \" > </ script > \n\n < angular-publisher-widget   /> \n \n \n Click  Save . \n View on Homepage \n \n \n Go to  Pages  →  Management \n \n \n Next to the  Home  page  (folder icon) , in the  Actions  column, click the  ⋮  icon \n \n \n In the Search field in right-hand sidebar, enter  Angular Publisher Widget . \n \n \n Drag and drop  Angular Publisher Widget  into the  Sample Frame  in the main body of the page. \n \n \n \n Replace  Publisher Widget . \n \n \n \n Click  Publish . \n \n \n In the top navigation, on the right, click  Go to Homepage . \n \n \n Enter a greeting in the input field. Press the submit button. The subscriber widget will update with the greeting. Done! \n \n \n \n Note: If you don't see an input field, refresh the page. \n \n Congratulations! \n You've now created an Angular micro frontend that can communicate with a React micro frontend. \n \n"},{title:"Create a React Micro Frontend",frontmatter:{sidebarDepth:2,redirectFrom:"/v6.3.2/tutorials/micro-frontends/react.html"},regularPath:"/v6.3.2/tutorials/create/mfe/react.html",relativePath:"v6.3.2/tutorials/create/mfe/react.md",key:"v-de156dce",path:"/v6.3.2/tutorials/create/mfe/react.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Create React App",slug:"create-react-app"},{level:3,title:"Wrap with Custom Element",slug:"wrap-with-custom-element"},{level:3,title:"Import Custom Element",slug:"import-custom-element"},{level:3,title:"Test Micro Frontend",slug:"test-micro-frontend"},{level:2,title:"Build the Resource URL",slug:"build-the-resource-url"},{level:3,title:"Add Widget",slug:"add-widget"},{level:3,title:"Add Page",slug:"add-page"},{level:3,title:"Build It",slug:"build-it"},{level:3,title:"npm build",slug:"npm-build"},{level:2,title:"Host Micro Frontend",slug:"host-micro-frontend"},{level:3,title:"Create Public Folder",slug:"create-public-folder"},{level:3,title:"Update Custom UI Field",slug:"update-custom-ui-field"},{level:3,title:"View the Widget",slug:"view-the-widget"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:" Create a React Micro Frontend \n Prerequisites \n \n A working instance of Entando. \n Use the Entando CLI to verify all dependencies are installed with the command  ent check-env develop . \n Create React App \n We'll use  Create React App  to generate a simple app in seconds. \n \n Create 'my-widget' directory structure with the following: \n \n npx create-react-app my-widget --use-npm\n \n This is the expected output: \n my-widget\n├── README.md\n├── node_modules\n├── package.json\n├── .gitignore\n├── public\n│   ├── favicon.ico\n│   ├── index.html\n│   ├── logo192.png\n│   ├── logo512.png\n│   ├── manifest.json\n│   └── robots.txt\n└── src\n    ├── App.css\n    ├── App.js\n    ├── App.test.js\n    ├── index.css\n    ├── index.js\n    ├── logo.svg\n    ├── serviceWorker.js\n    └── setupTests.js\n \n \n Start the app \n \n cd  my-widget\n npm  start\n Wrap with Custom Element \n \n Add a new file  src/WidgetElement.js  with the following custom element to wrap the entire React app \n \n import  React  from   'react' ; \n import  ReactDOM  from   'react-dom' ; \n import  App  from   './App' ; \n\n class   WidgetElement   extends   HTMLElement   { \n     connectedCallback ( )   { \n         this . mountPoint  =  document . createElement ( 'div' ) ; \n         this . appendChild ( this . mountPoint ) ; \n        ReactDOM . render ( < App  / > ,   this . mountPoint ) ; \n     } \n } \n\ncustomElements . define ( 'my-widget' ,  WidgetElement ) ; \n\n export   default  WidgetElement ; \n \n The React  root  node is programatically generated in the  connectedCallback  method when the custom element is added to the DOM. \n TIP \n connectedCallback  is a lifecycle hook that  runs each time the element is added to the DOM. \n \n Custom Elements \n \n Must contain a hyphen  -  in the name. \n Cannot be a single word. \n Should follow  kebab-case  for naming convention. \n Import Custom Element \n \n Open  src/index.js . The initial file looks like: \n \n import  React  from   'react' ; \n import  ReactDOM  from   'react-dom' ; \n import   './index.css' ; \n import  App  from   './App' ; \n import   *   as  serviceWorker  from   './serviceWorker' ; \n\nReactDOM . render ( < App  / > ,  document . getElementById ( 'root' ) ) ; \n\n // If you want your app to work offline and load faster, you can change \n // unregister() to register() below. Note this comes with some pitfalls. \n // Learn more about service workers: https://bit.ly/CRA-PWA \nserviceWorker . unregister ( ) ; \n \n \n Replace the entire file with these two lines \n \n import   './index.css' ; \n import   './WidgetElement' ; \n Test Micro Frontend \n \n \n Open  public/index.html \n \n \n Replace  <div id=\"root\"></div>  with the custom element  <my-widget /> \n \n \n    < body > \n     < noscript > You need to enable JavaScript to run this app. </ noscript > \n     < my-widget   /> \n    ...\n   </ body > \n \n Congratulations! \n You’re now running  React  in a containerized micro frontend. \n Build the Resource URL \n Add your micro frontend to Entando by uploading the JavaScript and CSS files to the  public  folder. This is the way Entando makes files available to the public. \n Add Widget \n First, add a widget to get the resource URL for the  public  folder. Then use the same widget to add the Micro Frontend to Entando. \n \n \n Go to  Components > Micro frontends & Widgets  in the App Builder \n \n \n Click  Add  in the lower right corner \n \n \n \n \n Enter the following: \n \n \n Title: My Widget  → enter both English and Italian languages \n Code: my_widget  → dashes are not allowed \n Group: Free Access \n Icon :  → upload an icon of your choice \n In the center panel under  Custom UI , enter the following: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < @wp . resourceURL  /> \n \n \n Click  Save \n \n TIP \n <#assign wp=JspTaglibs[ \"/aps-core\"]>  gives you access to the  @wp  object where you can use environment variables like  resourceURL . \n Add Page \n Next, add the widget to a page to view the  Resource URL .\nIf you're getting started with a new install of Entando, add the widget to the  Home  page. \n \n \n For Experienced Entando users: Add a new page → Add your widget to the page \n \n \n \n \n Go to  Pages  →  Management \n \n \n Next to the  Home  folder, under  Actions , →  Edit \n \n \n In the  Title  field, choose  My Widget \n \n \n In the Code field, choose  my_widget \n \n \n Under Page groups, in the Owner group field, choose  Free Access \n \n \n Scroll down to  Page Template  and select  Single Frame Page . Leave all other fields blank or in the default setting. \n \n \n Click  Save and Design . You are now in the page Designer. \n \n \n In the Search field of the right sidebar, type  My Widget . It will show as an option. \n \n \n Drag and drop  My Widget  into the  Sample Frame  in the body of the page \n \n \n Click  Publish \n \n \n In the top right corner, click  View Published Page . This will take you to a blank home page with your widget. \n \n \n Copy the  Resource URL  at the top. For example, this is the URL in a quickstart environment set up via the Getting Started guide: \n \n \n /entando-de-app/cmsresources/\n Build It \n With the Resource URL where the new React App will be hosted, you are ready to build. \n \n \n Create an  .env.production  file in the root of  my-widget  project \n \n \n Add the  PUBLIC_URL  into the file. \n \n \n PUBLIC_URL=/entando-de-app/cmsresources/my-widget\n \n Notes \n \n /entando-de-app/cmsresources/  is the Resource URL for your Entando application \n /my-widget  is the public folder that's created to host the files. \n npm build \n \n \n Open a command line and navigate to the project root of your  my-widget \n \n \n Run the command: \n \n \n npm  run build\n \n \n Rename the following files generated in the  build  directory \n \n \n \n \n Example of Generated Build File \n Rename to \n Function \n \n \n \n \n build/static/js/2.f14073bd.chunk.js \n static/js/vendor.js \n Third-party libraries \n \n \n build/static/js/runtime-main.8a835b7b.js \n static/js/runtime.js \n Bootstrapping logic \n \n \n build/static/js/main.4a514a6d.chunk.js \n static/js/main.js \n App \n \n \n build/static/css/main.5f361e03.chunk.css \n static/css/main.css \n Stylesheet \n \n \n \n Generated Build Files \n The JavaScript and CSS files are renamed so App Builder can deploy the new versions of the micro frontend without having to update the  Custom UI  field of the widget. \n \n If you want to use the original  file names with the content hashes to avoid potential caching issues in your browser , update the  Custom UI  field of your widget when deploying new versions of your micro frontend. The  Custom UI  settings will be covered in the next section. \n Additional Deployment Options \n \n Install the micro frontend from a bundle in the  Entando Component Repository . \n Add the micro frontend to  Entando App Builder . \n Load the micro frontend from an API. \n Host Micro Frontend \n Now you are ready to host the micro frontend in Entando. \n Create Public Folder \n \n \n Navigate to  Entando App Builder  in your browser \n \n \n Click  Administration  at the lower left hand side of the screen \n \n \n Click the  File browser  tab \n \n \n Choose the  public  folder \n \n \n Click  Create folder \n \n \n Enter  my-widget \n \n \n Click  Save \n \n \n Click  my-widget \n \n \n Create the same folder structure as your generated build directory \n \n \n \n my-widget/static/css \n my-widget/static/js \n my-widget/static/media \n \n \n Upload the renamed files in the corresponding  js  and  css  folders \n \n \n my-widget/static/css/main.css \n my-widget/static/js/main.js \n my-widget/static/js/runtime.js \n my-widget/static/js/vendor.js \n \n Note: You can drag and drop the files in your browser \n \n Upload the  React  logo \n \n \n my-widget/static/media/logo.5d5d9eef.svg  → You don't need to rename this file \n Update Custom UI Field \n \n \n Go to  Components  →  Micro frontends & Widgets \n \n \n Under the  My Widgets  category → next to  My Widget  → under  Action  → select  Edit \n \n \n Update  Custom UI  field: \n \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < link   rel = \" stylesheet \"   type = \" text/css \"   href = \" < @wp . resourceURL  /> my-widget/static/css/main.css \" > \n < script   async   src = \" < @wp . resourceURL  /> my-widget/static/js/runtime.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> my-widget/static/js/vendor.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> my-widget/static/js/main.js \" > </ script > \n < my-widget   /> \n \n \n Click  Save \n View the Widget \n View the React micro frontend in action on your page. \n \n \n In the  Entando App Builder  go back to  Pages  →  Management \n \n \n Next to the page you created, under  Actions →  Design . This takes you back to the page Designer. \n \n \n Click on  View Published Page  on the top right side \n \n \n \n Congratulations! \n You now have a React micro frontend running in Entando. \n \n"},{title:"Add a Configuration Screen in App Builder",frontmatter:{redirectFrom:"/v6.3.2/v6.3.2/tutorials/micro-frontends/widget-configuration.html"},regularPath:"/v6.3.2/tutorials/create/mfe/widget-configuration.html",relativePath:"v6.3.2/tutorials/create/mfe/widget-configuration.md",key:"v-9c365042",path:"/v6.3.2/tutorials/create/mfe/widget-configuration.html",headers:[{level:2,title:"Create React App",slug:"create-react-app"},{level:2,title:"Add Input Field",slug:"add-input-field"},{level:2,title:"Custom Element",slug:"custom-element"},{level:2,title:"Configuration Screen",slug:"configuration-screen"},{level:2,title:"Add Attribute",slug:"add-attribute"},{level:2,title:"Display Input",slug:"display-input"},{level:2,title:"Build It",slug:"build-it"},{level:2,title:"Update Widget in App Builder",slug:"update-widget-in-app-builder"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:' Add a Configuration Screen in App Builder \n Entando 6 widgets can be customized through an App Builder configuration screen that is itself a micro frontend. It can be developed and tested in isolation without a running Entando instance. \n Create React App \n Let’s start with the boilerplate provided by  Create React\nApp , probably the most popular one. \n npx create-react-app my-widget-config --use-npm \n my-widget-config\n├── README.md\n├── node_modules\n├── package.json\n├── .gitignore\n├── public\n│   ├── favicon.ico\n│   ├── index.html\n│   ├── logo192.png\n│   ├── logo512.png\n│   ├── manifest.json\n│   └── robots.txt\n└── src\n    ├── App.css\n    ├── App.js\n    ├── App.test.js\n    ├── index.css\n    ├── index.js\n    ├── logo.svg\n    ├── serviceWorker.js\n    └── setupTests.js\n \n Then, type  cd my-widget-config  and  npm start  to start the app. \n Add Input Field \n Let’s start with a simple form: only an input with a label. So, let’s\nedit  App.js \n import React from \'react\';\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { name: \'\'};\n  }\n\n  handleNameChange(value) {\n    this.setState(prevState => ({\n      ...prevState,\n      name: value,\n    }));\n  }\n\n  render() {\n    const { name } = this.state;\n    return (\n      <div>\n        <h1>Sample Entando 6 Widget Configuration</h1>\n        <label htmlFor="name">Name</label>\n        <input id="name" onChange={e => this.handleNameChange(e.target.value)} value={name} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n \n You are free to use your favorite form handling library e.g.,\n Formik ,\n redux-form  (that requirese redux) or others. \n In regards to styling, since this is going to be an App Builder screen,\nwe strongly suggest using  PatternFly\nv3  ( patternfly  and  patternfly-react \npackages) to keep UX coherence. \n Custom Element \n Now, let’s add the web component that will wrap the entire React app.\nLet’s name it  WidgetElement \n import React from \'react\';\nimport ReactDOM from \'react-dom\';\nimport App from \'./App\';\n\nclass WidgetElement extends HTMLElement {\n  constructor() {\n    super();\n    this.reactRootRef = React.createRef();\n    this.mountPoint = null;\n  }\n\n  get config() {\n    return this.reactRootRef.current ? this.reactRootRef.current.state : {};\n  }\n\n  set config(value) {\n    return this.reactRootRef.current.setState(value);\n  }\n\n  connectedCallback() {\n    this.mountPoint = document.createElement(\'div\');\n    this.appendChild(this.mountPoint);\n    ReactDOM.render(<App ref={this.reactRootRef} />, this.mountPoint);\n  }\n}\n\ncustomElements.define(\'my-widget-config\', WidgetElement);\n\nexport default WidgetElement;\n \n Its responsibility is rendering the react app and syncing the react app\nstate in a  config  property, that  must  be named that way. The key to\nApp Builder communication is that it works in three steps: \n \n \n App Builder reads  config  property when the widget config screen is\nrendered \n \n \n config  property is mutated when a user configures the widget \n \n \n When a user saves the config, App Builder retrieves it (again, from\nthe  config  property) and persists it through Entando APIs \n \n \n This means the widget developer can focus on the configuration screens\nwithout having to call Entando APIs to read or write configuration. \n One more JS file to update:  index.js . Starting from this \n import React from \'react\';\nimport ReactDOM from \'react-dom\';\nimport \'./index.css\';\nimport App from \'./App\';\nimport * as serviceWorker from \'./serviceWorker\';\n\nReactDOM.render(<App />, document.getElementById(\'root\'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n \n You only have to import  WidgetElement  plus the css, if needed.\nSomething like \n import \'./index.css\';\nimport \'./WidgetElement\';\n \n We assume we don’t need a service worker for the widget, so we can\ndelete serviceWorker.js. \n To ensure our web component is working we have to edit\n public/index.html . Remove  <div id="root"></div>  from the  body  (we\nprogrammatically generated the react root in the  connectedCallback \nmethod of  WidgetElement ) and add our new web component tag\n <my-widget /> . \n <!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" />\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\n    <title>React App</title>\n  </head>\n  <body>\n    <my-widget-config />\n  </body>\n</html>\n \n \n Note \n the web component tag name ( my-widget-config  in this tutorial)\n must  match the first parameter of the  customElements.define \nmethod. \n \n The page should auto reload and... congrats, you’re running an Entando 6\nwidget in isolation. \n Configuration Screen \n Next, we’ll build our widget before embedding it into the Entando 6\ninstance. From the react project root, type \n npm run build \n and a  build/static  directory will be generated. For convenience in this tutorial, rename the generated files: \n \n \n a file like  js/runtime~main.c7dcdf0b.js  to  js/runtime.js \n(bootstrapping logic) \n \n \n a file like  js/2.230b21ef.chunk.js  to  js/vendor.js  (third-party\nlibraries) \n \n \n a file like  js/main.1fd3965a.chunk.js  to  js/main.js  (app) \n \n \n Next load these files into Entando under  public/my-widget-config/static  using  Administration  →  File Browser . \n Now go to  Components  →  Micro frontends & Widgets  and find the original widget we\'re creating the configuration screen for. Edit the widget and update the\n configUI  field. \n {\n  "customElement": "my-widget-config",\n  "resources": [\n    "my-widget-config/static/js/runtime.js",\n    "my-widget-config/static/js/vendor.js",\n    "my-widget-config/static/js/main.js"\n  ]\n}\n \n \n Note \n \n \n It is possible to keep the original names in order to avoid\npotential caching issues, but then you will have to update the\n Config UI  field in the App Builder widget screen each time a new\nversion of the widget is deployed. \n \n \n configUI  is a JSON object, so pay attention to save a\nwell-formed one (the integrated JSON editor will help you) \n \n \n value for  customElement  must match the name of custom tag in\n index.html  and the one passed as parameter to\n customElements.define  in  WidgetElement \n \n \n \n You can now add a page in App Builder, drag the widget into the page template slot and you’ll see the configuration screen we just built. \n Display Widget Configuration \n So, we already created a React micro frontend widget and configuration\nscreen to customize a  name  field. \n In this tutorial we will display that field in our micro frontend\nwidget. \n Add Attribute \n Edit  WidgetElement  to add attribute handling to the custom element,\nand re-render our app when an attribute changes. Now, the  name \nattribute is being read from the custom element and passed as a prop to\nthe react root component ( App ). \n import React from \'react\';\nimport ReactDOM from \'react-dom\';\nimport App from \'./App\';\n\nconst ATTRIBUTES = {\n  name: \'name\',\n};\n\nclass WidgetElement extends HTMLElement {\n\n  static get observedAttributes() {\n    return Object.values(ATTRIBUTES);\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (!Object.values(ATTRIBUTES).includes(name)) {\n      throw new Error(`Untracked changed attribute: ${name}`);\n    }\n    if (this.mountPoint && newValue !== oldValue) {\n      this.render();\n    }\n  }\n\n  connectedCallback() {\n    this.mountPoint = document.createElement(\'div\');\n    this.appendChild(this.mountPoint);\n    this.render();\n  }\n\n  render() {\n    const name = this.getAttribute(ATTRIBUTES.name);\n    ReactDOM.render(<App name={name} />, this.mountPoint);\n  }\n}\n\ncustomElements.define(\'my-widget\', WidgetElement);\n\nexport default WidgetElement;\n \n \n Note \n attributeChangedCallback  is also a custom elements lifecycle hook\nmethod. \n Display Input \n Edit the  App  component now, to make it display the  name  prop. \n import React from \'react\';\nimport \'./App.css\';\n\nfunction App({name}) {\n  return (\n    <div className="App">\n      <header className="App-header">\n        <p>\n          Hello, {name}!\n        </p>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n \n Now, to ensure our custom element is working we can edit\n public/index.html  and set a value for the  name  attribute of the\ncustom element. \n <!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" />\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\n    <title>React App</title>\n  </head>\n  <body>\n    <my-widget name="Marco"/>\n  </body>\n</html>\n \n After page reload, you should be able to display a simple "Hello,\nMarco!" message. \n Build It \n From the react project root, type: \n npm run build \n and the  build/static  directory will be regenerated. Again, for convenience, rename the files and then update them in Entando under  public/my-widget/static  using  Administration  →  File Browser : \n \n \n a file like  js/runtime~main.c7dcdf0b.js  to  js/runtime.js \n(bootstrapping logic) \n \n \n a file like  js/2.230b21ef.chunk.js  to  js/vendor.js  (third-party\nlibraries) \n \n \n a file like  js/main.1fd3965a.chunk.js  to  js/main.js  (app) \n \n \n a file like  css/main.d1b05096.chunk.js  to  css/main.css \n(stylesheet) \n \n \n \n Note \n you could keep the original names in order to avoid potential caching\nissues, but then you will have to update the  Custom UI  field in the\nApp Builder widget screen every time a new version of the widget is\ndeployed. \n \n If the application server you’re running does not have hot deploy\nenabled, restart it. \n Update Widget in App Builder \n Open the  Entando App Builder , go to  Components  →  Micro frontends & Widgets , find the widget  My Widget  and click to edit it. \n Update the  Custom UI  field from: \n <#assign wp=JspTaglibs[ "/aps-core"]>\n<link rel="stylesheet" type="text/css" href="<@wp.resourceURL />my-widget/static/css/main.css">\n<script async src="<@wp.resourceURL />my-widget/static/js/runtime.js"><\/script>\n<script async src="<@wp.resourceURL />my-widget/static/js/vendor.js"><\/script>\n<script async src="<@wp.resourceURL />my-widget/static/js/main.js"><\/script>\n<my-widget />\n \n to \n <#assign wp=JspTaglibs[ "/aps-core"]>\n<link rel="stylesheet" type="text/css" href="<@wp.resourceURL />my-widget/static/css/main.css">\n<script async src="<@wp.resourceURL />my-widget/static/js/runtime.js"><\/script>\n<script async src="<@wp.resourceURL />my-widget/static/js/vendor.js"><\/script>\n<script async src="<@wp.resourceURL />my-widget/static/js/main.js"><\/script>\n<@wp.currentWidget param="config" configParam="name" var="configName" />\n<my-widget name="${configName}" />\n \n We basically added a JSTL tag to extract a field (under  configParam )\nfrom the config field of the current widget and put it in a  configName \nvariable, that we pass to the custom element. \n Save the widget and reload the page that contains the widget. You should see\n Hello, Marco!  as expected. \n'},{title:"Role Based Access Controls",frontmatter:{sidebarDepth:2,redirectFrom:"/v6.3.2/tutorials/backend-developers/add-access-controls.html"},regularPath:"/v6.3.2/tutorials/create/ms/add-access-controls.html",relativePath:"v6.3.2/tutorials/create/ms/add-access-controls.md",key:"v-7038fda5",path:"/v6.3.2/tutorials/create/ms/add-access-controls.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Tutorial",slug:"tutorial"},{level:2,title:"Notes",slug:"notes"},{level:3,title:"Realm Roles versus Client Authorities",slug:"realm-roles-versus-client-authorities"},{level:3,title:"Local versus Kubernetes Testing",slug:"local-versus-kubernetes-testing"},{level:3,title:"Debugging",slug:"debugging"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:" Role Based Access Controls \n Overview \n This tutorial guides you through adding access controls to your existing Entando project. Security experts recommend following a practice known as  Defense in Depth  where security controls are placed in each layer of an architecture. This tutorial will help you setup such controls in both the frontend and backend of your Entando application. \n For the purpose of this tutorial we'll use the simple Conference application from  this tutorial  as a starting point. Please work through that tutorial if you have not already. \n The basic security setup for a blueprint-generated application allows any authenticated user to access the functionality contained in the MFEs and/or microservices. Our business requirement for this tutorial is to define two kinds of users in our application -  Conference Users  who can view the Conferences in the tableWidget, and  Conference Admins  who can view and also delete Conferences from the tableWidget. \n Tutorial \n Let's start by securing the list of Conferences so only our two user roles can view the list. \n \n Edit  ConferenceResource.java  located in the  src/main/java/com/<ORG>/<NAME>.web.rest  directory. Modify the REST API  Conference:getAllConferences  method by adding the following annotation. \n \n     @PreAuthorize(\"hasAnyAuthority('conference-user','conference-admin')\")\n    public List<Conference> getAllConferences() {\n \n See the  Spring Security documentation  for more details but this restricts use of the  getConference  method to users who have been assigned either the  conference-user  or the  conference-admin  role on the Keycloak client configured for the microservice. In local testing this defaults to the  internal  client but see notes below on how that works in production. \n Now we should verify this security check is working. \n \n Start up your Keycloak, tableWidget MFE, and microservice. See  these instructions  if you need a refresher but these are the basic commands using the ent CLI and Docker for keycloak. \n \n ent prj ext-keycloak start\nent prj be-test-run\n \n Using a separate cmdline: \n ent prj fe-test-run\n \n \n Access the tableWidget MFE, typically on  http://localhost:3000 , using the default admin/admin account. \n \n Once authenticated, you'll get the message \"No conferences are available\" and, if you check your browser console, you should see a  403 (Forbidden)  error for the request made to  localhost:8080/services/conference/api/conferences . This is expected because we have not yet granted the new role to the admin user. \n Now let's give the admin user the correct role. \n \n Login to keycloak on  http://localhost:9080  using the  admin/admin  credentials. \n \n First we need to create the two roles per our requirements. We're going to add the roles to the  internal  client because it's the one configured by default in the Spring Boot application.yml. \n \n Go to  Clients → internal → Roles  and click  Add Role \n Fill in the  Role Name  with  conference-admin  and click  Save \n Repeat steps 5-6 to create the  conference-user  role. \n \n Now we need to map this role to our user. \n \n Go to  Users → View all users → admin → Role Mappings \n Select  internal  for the  Client Roles  and then move  conference-user  from  Available Roles  to  Assigned Roles \n Go back to the MFE and you should now see the full list of Conferences. \n \n We've now successfully secured the  getAllConferences  API but we have more to do. The admin user was granted just the  conference-user  role but still has access to delete Conferences. We need to lock that down. \n \n Go back into the  ConferenceResource.java  file and add this annotation to the  deleteConference  method: \n \n     @PreAuthorize(\"hasAuthority('conference-admin')\")\n    public ResponseEntity<Void> deleteConference(@PathVariable Long id) {\n \n Here we're restricting the delete method to only the  conference-admin  role. \n \n Restart the microservice. By default this will include rebuilding any changed source files. \n Once the microservice is available, go back to the MFE and try deleting one of the Conferences in the list. You should be able to attempt the delete in the UI but you'll get a 403 error in the browser console and an error like this in the service logs: \n \n 2021-03-22 15:56:16.205  WARN 3208 --- [  XNIO-1 task-3] o.z.problem.spring.common.AdviceTraits   : Forbidden: Access is denied\n \n That's exactly what we wanted! This demonstrates that a user without  conference-admin  is unable to call the delete API. \n Next, let's update the MFE so a user without the  conference-admin  authority cannot even see the delete button in the UI. \n \n Edit the  ConferenceTableContainer.js  under  ui/widgets/conference/tableWidget/src/components . Replace the onDelete logic with an additional check on the user's authorities. \n \n     const isAdmin = (keycloak && keycloak.authenticate) ? keycloak.hasResourceRole(\"conference-admin\", \"internal\"): false;\n    const showDelete = onDelete && isAdmin;\n\n    const Actions = ({ item }) =>\n      showDelete ? (\n \n The key logic there is the hasResourceRole call which checks whether the  internal  client role  conference-admin  was mapped to the current user. \n \n View the MFE (whch should have automatically reloaded) and you should see that the delete icon is no longer visible, matching the admin's current permissions.  We've now verified that a user with just  conference-user  can neither see the delete action in the UI nor call its corresponding API. \n \n Next, let's promote the admin user to a full  conference-admin  so they can delete Conferences. \n \n \n Go back into Keycloak at  http://localhost:9080 , then go to  Users → View all users → admin → Role Mappings , and also give the user the  conference-admin  role. \n \n \n Reload the MFE. The delete icons should now be visible and you should be able to successfully delete a Conference from the list. This satisfies our original business requirement. \n Notes \n Realm Roles versus Client Authorities \n This tutorial made use of authorities which in Keycloak are Roles mapped to a User for a specific Client. You could also make use of higher-level Realm Roles assigned directly to users, e.g.  ROLE_ADMIN . That will work but can result in collisions between applications if they happen to use the same roles. \n If you choose to use Realm-assigned roles then the code above would need to change. In the backend, use the following annotations:  @Secured('ROLE_ADMIN)  or  @PreAuthorize(hasRole('ROLE_ADMIN')) . In the frontend, use  keycloak.hasRealmRole  instead of  keycloak.hasResourceRole . See the  Spring Security page  for more examples. \n Local versus Kubernetes Testing \n This tutorial also makes use of the  internal  client configured in the microservice via the application.yml with roles manually created and assigned in Keycloak. In Kubernetes, Entando will automatically create client roles per the bundle plugin definition (see the plugin definition  here  for more information). Those roles will be created for the client specific to the microservice itself, e.g.  <docker username>-conference-server . This client name will be injected as an environment variable into the plugin container itself so the annotations noted above will work both in local and Kubernetes environments. \n The MFE authorization checks in the tutorial explicitly note the client id,  e.g.  internal , which won't work in Kubernetes. There are a couple options here: \n \n Change the application.yml clientId under  security.oauth2.client.registration.oidc  to match the Kubernetes clientId. That's the most secure and allows the MFE checks to work the same in both local and Kubernetes environments. However, you not be be able to use the same clientId depending on how the microservice is deployed \n An alternative is to broaden the MFE authorization check to look for a named role on any client. This could result in overlap with other clients but with appropriately named roles (e.g. prefixed by feature, e.g.  conference-admin ) this could be the most flexible option. This can be provided via a helper function, e.g. in  api/helpers.js : \n \n //Check if the authenticated user has the clientRole for any keycloak clients\nexport const hasKeycloakClientRole = clientRole => {\n  if (getKeycloakToken()) {\n    const { resourceAccess } = window.entando.keycloak;\n    if (resourceAccess) {\n      for (const client in resourceAccess) {\n        // eslint-disable-line no-unused-vars\n        const roles = resourceAccess[client].roles;\n        if (roles && roles.includes(clientRole)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\n \n This would result in a simpler role check: \n     const isAdmin = hasKeycloakClientRole('conference-admin');\n Debugging \n In both local and Kubernetes environments, the default blueprint javascript will make a global variable available in the browser, e.g.  window.entando.keycloak . Examining this variable can help diagnose issues with assigned roles and authorities. In some cases you may need to logout of Entando and re-authenticate in order to get the latest role assignments. \n"},{title:"Generate Microservices and Micro Frontends",frontmatter:{sidebarDepth:2,redirectFrom:"/v6.3.2/tutorials/backend-developers/generate-microservices-and-micro-frontends.html"},regularPath:"/v6.3.2/tutorials/create/ms/generate-microservices-and-micro-frontends.html",relativePath:"v6.3.2/tutorials/create/ms/generate-microservices-and-micro-frontends.md",key:"v-f96fb7da",path:"/v6.3.2/tutorials/create/ms/generate-microservices-and-micro-frontends.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:3,title:"Manual Setup",slug:"manual-setup"},{level:2,title:"Generate the Project",slug:"generate-the-project"},{level:3,title:"Project Structure",slug:"project-structure"},{level:2,title:"Next Steps",slug:"next-steps"}],lastUpdated:"3/3/2022, 1:24:15 PM",lastUpdatedTimestamp:1646331855e3,content:" Generate Microservices and Micro Frontends \n Overview \n This tutorial describes how to use the Entando Component Generator (ECG) to create microservices and micro frontends for deployment to the  Entando Component Repository  and Entando Applications. The ECG is powered by  JHipster  and leverages the Entando Blueprint. \n \n The general flow of component generation is: \n \n Run the Entando Blueprint to create your components (Spring Boot microservice and optionally React micro frontends) \n Customize and enhance your generated code \n Build an Entando Bundle from your components \n Deploy a  Custom Resource  for your bundle into Kubernetes \n Install your Entando Bundle into your Entando Application(s) \n Prerequisites \n Use the  Entando CLI  to verify environmental dependencies (e.g. Java, npm, git, JHipster, Entando Blueprint). \n ent check-env develop\n Manual Setup \n We recommend using the Entando CLI to generate microservices and micro frontends, but you can also manually initialize JHipster and the Entando Blueprint with the following commands.  Note: If you choose the manual setup, commands in this tutorial that include  ent jhipster  should instead use  jhipster . \n \n Install JHipster \n \n npm   install  -g generator-jhipster@6.10.5\n \n \n Install the Entando Blueprint \n \n npm   install  -g generator-jhipster-entando@6.3.2\n Generate the Project \n Whether you elect to use the  ent jhipster  command or perform a manual setup, the next step is to create a project with microservices. \n \n Setup a new project directory \n \n mkdir  testProject  &&   cd  testProject\n \n \n Use  ent jhipster  (or  jhipster ) to generate the project skeleton via the Entando Blueprint \n \n ent jhipster --blueprints entando\n \n \n \n You'll be presented with a series of prompts to configure your project. These are listed below, with the base values for this tutorial in parentheses. Except where noted in  bold , you can input what works best for you. Note that hitting \"Enter\" will select the default option. \n \n \n What is the base name of your application?  (Up to you) \n \n \n As you are running in a microservice architecture, on which port would like your server to run? It should be unique to avoid port conflicts.  (8081) \n \n \n What is your default Java package name?  (Up to you) \n \n \n Which *type* of database would you like to use?  (SQL)\n- If no database is selected you'll be building a stateless microservice, which is a valid choice, but the rest of this tutorial won't work. \n \n \n Which *production* database would you like to use?  (PostgreSQL or MySQL) \n \n \n Which *development* database would you like to use?  (H2 with disk-based persistence) \n \n \n Do you want to use the Spring cache abstraction?  (Yes, with the Caffeine implementation) \n \n \n  Do you want to use Hibernate 2nd level cache?  (Yes) \n \n \n Would you like to use Maven or Gradle for building the backend?  ( Maven ) <-- this is required for Entando \n \n \n Which other technologies would you like to use?  ( Don't select any other technologies ) \n \n \n What name would you give to the bundle to share on an Entando digital-exchange?  (Up to you) \n \n \n Which is the organization name to use when publishing the docker image?  ( Enter the name of the organization where you are going to push your Docker image. If you're using your personal Docker hub account enter your username. ) <-- this can be changed later as needed \n \n \n Would you like to generate micro frontends when creating entities?  (Always) \n \n \n Would you like to enable internationalization support  (Up to you) \n \n \n Please choose the native language of the application  (Up to you) \n \n \n Please choose additional languages to install  (Up to you) \n \n \n Besides JUnit and Jest, which testing frameworks would you like to use?  (Up to you) \n \n \n Would you like to install other generators from the JHipster Marketplace?  (No) \n \n \n \n \n Next, add an Entity to your microservice and create the corresponding micro frontends. In this tutorial,  Conference  is the name of the entity that will be added to the application. Remember to replace  ent jhipster  with  jhipster  if you are not using the Entando CLI. \n \n \n ent jhipster entity Conference\n \n \n \n You'll be presented with a series of prompts to add fields to your entity. These are listed below, with the base values for this tutorial in parentheses. Input what works best for you, and note that hitting \"Enter\" will select the default option. \n \n \n Do you want to add a field to your entity?  (Yes) \n \n \n What is the name of your field?  (name) \n \n \n What is the type of your field?  (String) \n \n \n Do you want to add validation rules to your field?  (No) \n \n \n Do you want to add a field to your entity?  (Yes) \n \n \n What is the name of your field?  (location) \n \n \n What is the type of your field?  (String) \n \n \n Do you want to add validation rules to your field?  (No) \n \n \n Do you want to add a field to your entity?  (No) \n \n \n Do you want to add a relationship to another entity?  (No) \n \n \n Do you want to use separate service class for your business logic?  (Up to you) \n \n If yes: \n Do you want to use a Data Transfer Object (DTO)?  (Up to you) \n Do you want to add filtering?  (Up to you) \n \n \n \n Is this entity read-only?  (Up to you) \n \n \n Do you want pagination on your entity?  (Yes, with infinite scroll) \n \n \n \n \n \n \n If you asked to be prompted about micro frontends when generating the project: \n \n Do you want to generate micro frontends?  (Up to you) \n \n \n \n At this point the blueprint will generate controllers, repositories, services, and micro frontends for your entity. \n \n Overwrite src/main/resources/config/liquibase/master.xml?   Note: When prompted with a conflict at this stage, you can enter  a  for \"All.\" This will override existing files with the configuration changes needed for your new entity. \n \n \n \n You now have an Entando project, including a Spring Boot microservice with database integration and React-based micro frontends. \n Project Structure \n \n /src/main/docker  contains Docker files to help with local development environments. \n /src/main/java  and  src/main/resources  contain the microservice codebase and configuration. \n /ui  holds the React-based micro frontends. By default, JHipster generates 3 MFEs per entity to contain the details, form, and table. \n /bundle  is used to assemble the project code into an Entando Bundle. \n Next Steps \n Follow one of the links below to learn how to assemble and run a bundle locally or deploy it. \n \n Build and publish a project bundle  to deploy your microservice and micro frontends to the Entando Component Repository \n Learn how to  run Blueprint-generated components locally in dev mode \n Discover the benefits and features of  the Entando Blueprint \n Iterate on your data model  using the JHipster Domain Language (JDL) \n \n"},{title:"Tutorial: Extending the App Builder",frontmatter:{redirectFrom:"/v6.3.2/tutorials/customize-the-platform/extend-app-builder.html"},regularPath:"/v6.3.2/tutorials/compose/extend-app-builder.html",relativePath:"v6.3.2/tutorials/compose/extend-app-builder.md",key:"v-5718e2e0",path:"/v6.3.2/tutorials/compose/extend-app-builder.html",headers:[{level:2,title:"Creating a Basic Application",slug:"creating-a-basic-application"},{level:2,title:"Understanding the Stand Alone Environment",slug:"understanding-the-stand-alone-environment"},{level:2,title:"Customizing the Menu",slug:"customizing-the-menu"},{level:2,title:"Customizing the menu labels",slug:"customizing-the-menu-labels"},{level:2,title:"Customizing the Routes",slug:"customizing-the-routes"},{level:2,title:"state",slug:"state"},{level:2,title:"Customizing the Reducers",slug:"customizing-the-reducers"},{level:2,title:"userList",slug:"userlist"},{level:3,title:"connecting to the store",slug:"connecting-to-the-store"},{level:2,title:"Page Models",slug:"page-models"},{level:3,title:"Connecting to the Store",slug:"connecting-to-the-store-2"},{level:2,title:"Adding the API Calls",slug:"adding-the-api-calls"},{level:2,title:"Creating the Thunk",slug:"creating-the-thunk"},{level:2,title:"changing the mapDispatchToProps in the containers",slug:"changing-the-mapdispatchtoprops-in-the-containers"},{level:2,title:"Updating the List components",slug:"updating-the-list-components"},{level:2,title:"clear the default value of the reducer",slug:"clear-the-default-value-of-the-reducer"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:" Tutorial: Extending the App Builder \n Apps for the Entando App Builder are developed as standalone\napplications which can be run using  npm start  in standalone mode. \n Each application should be deployed in npm using the  @entando \nnamespace and will export into their dist folder several items used by\nthe App Builder when integrating it into the full application. \n Creating a Basic Application \n To create a basic application, use the  entando\nfpg  running the\n npx @entando/fpg ab-app <appName>  command. \n the  appName  should only contain alphanumeric characters and\nunderscores, and should begin with a letter. \n This will create inside the working directory, a boilerplate app-builder\napp in a directory named  <appName>  argument. \n i.e. \n using the command  npm @entando/fpg ab-app testing  inside your home\ndirectory, a directory named  testing  will be created containing the\napp. \n All dependencies will already be installed allowing you to  cd  inside\nthe project directory and run  npm start  to start the app running. \n Understanding the Stand Alone Environment \n Each app for the App Builder, can run in both a stand alone mode and an\nintegrated mode. Using  npm start  will use standalone mode. \n In this environment you’ll be looking at the user interface of the app\ninside a default page. This page, which includes a default menu, will\nnot be exported and therefore can be customized. \n To better understand which elements and components are being exported to\nApp Builder, it is best to understand the anatomy of the app. \n Exports \n Each app will have a  babel.js  export file similar to: \n      import  menu  from   'ui/common/LinkMenu' ; \n     import   {  cms  as  state  }   from   'state/rootReducer' ; \n     import   {  routes ,  routesDir  }   from   'ui/App' ; \n     import  en  from   'locales/en' ; \n     import  it  from   'locales/it' ; \n\n     const  testing  =   { \n       id :   'testing' , \n      menu , \n      state , \n      routes , \n      routesDir , \n       locales :   { \n        en , \n        it , \n       } , \n     } ; \n\n     export   default  testing ; \n id: is the app id. \n This parameter is used by App Builder to differentiate all integrated\napps. \n menu: is a React component containing all the menu elements. \n These elements are used inside the standalone environment and inside the\nintegrated environment as a second level menu. The boilerplate app\ncontains a basic menu. \n      import  React  from   'react' ; \n     import   {  LinkMenuItem  }   from   '@entando/menu' ; \n     import   {  FormattedMessage  }   from   'react-intl' ; \n\n     const   LinkMenu   =   ( )   =>   ( \n       < > \n         < LinkMenuItem\n          id = \"menu-SECTION_ID\" \n          label = { < FormattedMessage id = \"testing.menu.SECTION_NAME\"  defaultMessage = \"SECTION_NAME\"   / > } \n          to = '/use/const/here/imported/from/routes' \n         / > \n       < / > \n     ) ; \n\n     export   default  LinkMenu ; \n Customizing the Menu \n For this exercise, we will create two links inside the menu. The first\nwill link to a page listing all the users inside the entando instance.\nThe second will list all the existing page templates inside the Entando\ninstance. \n For this example we’re using existing APIs from the Entando core just\nfor simplicity, you can instead call any API or data source. \n In your app project, open  src/ui/common/LinkMenu.js  and update the\nconst to the code below. \n      const   LinkMenu   =   ( )   =>   ( \n       < > \n         < LinkMenuItem\n          id = \"menu-userList\" \n          label = { < FormattedMessage id = \"testing.menu.userList\"  defaultMessage = \"User List\"   / > } \n          to = '/use/const/here/imported/from/routes' \n         / > \n         < LinkMenuItem\n          id = \"menu-pageModelList\" \n          label = { < FormattedMessage id = \"testing.menu.pageModelList\"  defaultMessage = \"Page Model List\"   / > } \n          to = '/use/const/here/imported/from/routes' \n         / > \n       < / > \n     ) ; \n \n it is important that both the  <LinkMenuItem>  id property and the\n`<FormattedMessage>`properties inside label have the correct values\nassigned, i.e.: \n the LinkMenuItem id will be  menu-userList  while the FormattedMessage\nid will be  testing.menu.userList  and the defaultMessage will be\n User List . \n locales \n The locales files are objects that contain all of the i18n locales of\nthe app. \n By default the boilerplate contains both the english and italian i18n\nfiles. \n In your app project in  src/locales/en.js  and  src/locales/it.js  you\ncan see your labels. \n      export   default   { \n       locale :   'en' , \n       messages :   { \n         'testing.title' :   '' , \n         'testing.label.errors' :   '' , \n         'testing.label.cancel' :   '' , \n         'testing.chooseAnOption' :   '' , \n         'testing.tip' :   '' , \n         'testing.new' :   '' , \n         'testing.save' :   '' , \n         'testing.saveAndApprove' :   '' , \n         'testing.unpublish' :   '' , \n         'testing.setContentAs' :   '' , \n         'testing.cancel' :   '' , \n         'testing.saveAndContinue' :   '' , \n         'testing.stickySave.status' :   '' , \n         'testing.stickySave.lastAutoSave' :   '' , \n       } , \n     } ; \n \n While running in standalone mode the boilerplate does not offer a way\nfor the user pick a locale, but both will be loaded inside app-builder\nand will be consumed as intended by it, using the correct one based on\nthe user-picked language. \n It is of course possible to change the standalone app to give the user\nthe option to choose the locale in here as well, but this is not\nsomething will be covering in this tutorial. \n Customizing the menu labels \n To customize the existing menu labels, we’ll add the new label ids\ninside both the english and Italian locale files: \n \n Note \n If you named your app something besides  testing  you’ll need to fix\nthese tags to match the name of your app. \n \n      ... \n     messages :   { \n         ... \n         'testing.menu.userList' :   'List of Users' , \n         'testing.menu.pageModelList' :   'Page Models' , \n         ... \n     } , \n     ... \n \n The key in the messages object matches the id of the\n`<FormattedMessage>`component we placed inside the menu, while its\nvalue is the actual string that will be displayed depending on the\ncurrently active language. \n Routes and RoutesDir \n Both of these elements are imported from  src/ui/App.js . The first one\nis a collection of actual  <Route>  components, and the second one is an\nobject containing each route data, i.e.: \n      export   const  routesDir  =   [ \n       { \n         path :   ROUTE_TESTING , \n         component :   < > app component < / > , \n       } , \n     ] ; \n \n The constant  ROUTE_TESTING  is imported from  src/app-init/routes.js \n Customizing the Routes \n Next we will create the two routes for the two links we have created by\ncreating first the two constants needed. \n In your IDE open  src/app-init/routes.js \n      export   const   ROUTE_TESTING   =   '/testing' ; \n     export   const   ROUTE_USER_LIST   =   '/testing/user-list' ; \n     export   const   ROUTE_PAGE_MODELS   =   '/testing/page-models' ; \n \n \n Note \n Change the value of  testing  to what you selected for the name of\nyour App extension. \n \n The value of each constant will be the path of the route. It is\nimportant that each route is a subroute of the id of the app itself,\notherwise this may cause name collision when running inside the\nintegrated environment of app-builder. \n Both routes are next imported inside  App.js : \n Update the imports with your new ROUTE tags. \n      import   { \n       ROUTE_TESTING , \n       ROUTE_USER_LIST , \n       ROUTE_PAGE_MODELS , \n     }   from   'app-init/routes' ; \n \n and then add to the  routesDir  constant: \n      export   const  routesDir  =   [ \n       { \n         path :   ROUTE_TESTING , \n         component :   < > app component < / > , \n       } , \n       { \n         path :   ROUTE_USER_LIST , \n         render :   ( )   =>   < > user list < / > , \n       } , \n       { \n         path :   ROUTE_PAGE_MODELS , \n         render :   ( )   =>   < > page models < / > , \n       } , \n     ] ; \n \n Next, import the routes constants inside  LinkMenu.js  and change\naccordingly the  to  property of the  <LinkMenuItem>  component: \n      ... \n     import   { \n       ROUTE_USER_LIST , \n       ROUTE_PAGE_MODELS , \n     }   from   'app-init/routes' ; \n\n     const   LinkMenu   =   ( )   =>   ( \n       < > \n         < LinkMenuItem\n          id = \"menu-userList\" \n          label = { < FormattedMessage id = \"tatata.menu.userList\"  defaultMessage = \"User List\"   / > } \n          to = { ROUTE_USER_LIST } \n         / > \n         < LinkMenuItem\n          id = \"menu-pageModelList\" \n          label = { < FormattedMessage id = \"tatata.menu.pageModelList\"  defaultMessage = \"Page Model List\"   / > } \n          to = { ROUTE_PAGE_MODELS } \n         / > \n       < / > \n     ) ; \n     ... \n \n Next clicks on the links in the menu will change the routes and display\nthe content defined in the  App.js  file. \n state \n The state in src/babel.js is the combined reducer of the app, the\nrootReducer.js contains the combined reducer of the app and exports it,\nbut also contains the entire reducer of the app when running in\nstandalone mode. \n      export   const  testing  =   combineReducers ( { \n       // implement here your app specific reducers \n     } ) ; \n\n     export   default   combineReducers ( { \n       apps :   combineReducers ( {  testing  } ) , \n      api , \n      currentUser , \n      form , \n      loading , \n      locale , \n      messages , \n      modal , \n      pagination , \n     } ) ; \n \n The app specific reducers are stored inside the  apps  object, this is\ndone to avoid possible name collisions with any reducer stored inside\napp-builder when running the app in integrated mode. \n Customizing the Reducers \n Next we will be creating the two reducers for the user list and page\nmodels. They will be created inside two new directories\n src/state/apps/testing/userList/  and\n src/state/apps/testing/pageModels . The  types.js  files will contain\nthe two action types that we’ll need. \n userList/types.js \n // eslint-disable-next-line import/prefer-default-export\nexport const ADD_USERS = 'apps/testing/add-users';\n \n pageModels/types.js \n // eslint-disable-next-line import/prefer-default-export\nexport const ADD_PAGE_MODELS = 'apps/testing/page-models/add-page-models';\n \n The value of both constants contain the whole namespace\n apps/testing/REDUCER  this is done to avoid any possible name collision\nwhen running the app in integrated mode. \n Next create both actions files: \n userList/actions.js \n      import   { \n       ADD_USERS , \n     }   from   'state/apps/testing/userList/types' ; \n\n     // eslint-disable-next-line import/prefer-default-export \n     export   const   addUsers   =   users   =>   ( { \n       type :   ADD_USERS , \n       payload :  users , \n     } ) ; \n \n pageModels/actions.js \n      import   { \n       ADD_PAGE_MODELS , \n     }   from   'state/apps/testing/pageModels/types' ; \n\n     // eslint-disable-next-line import/prefer-default-export \n     export   const   addPageModels   =   pageModels   =>   ( { \n       type :   ADD_PAGE_MODELS , \n       payload :  pageModels , \n     } ) ; \n \n then the selectors: \n userList/selectors.js \n      import   {  createSelector  }   from   'reselect' ; \n\n     export   const   getUserList   =   state   =>  state . apps . testing . userList ; \n     export   const  getList  =   createSelector ( getUserList ,   userList   =>  userList . list ) ; \n \n pageModels/selectors.js \n      import   {  createSelector  }   from   'reselect' ; \n\n     export   const   getPageModels   =   state   =>  state . apps . testing . pageModels ; \n     export   const  getList  =   createSelector ( getPageModels ,   pageModels   =>  pageModels . list ) ; \n \n And finally the reducers. The default state is going to contain some\nsample data for us to display. \n userList/reducer.js \n      import   {   ADD_USERS   }   from   'state/apps/testing/userList/types' ; \n\n     const  defaultState  =   { \n       list :   [ \n         { \n           username :   'admin' , \n           registration :   '2018-01-08 00:00:00' , \n           lastLogin :   '2018-01-08 00:00:00' , \n           lastPasswordChange :   '2018-01-08 00:00:00' , \n           status :   'active' , \n           passwordChangeRequired :   true , \n           profileAttributes :   { \n             fullName :   'admin' , \n             email :   'admin@entando.com' , \n           } , \n         } , \n         { \n           username :   'user1' , \n           registration :   '2018-01-08 00:00:00' , \n           lastLogin :   '2018-01-08 00:00:00' , \n           lastPasswordChange :   '2018-01-08 00:00:00' , \n           status :   'disabled' , \n           passwordChangeRequired :   true , \n           profileAttributes :   { \n             fullName :   'User Name' , \n             email :   'user1@entando.com' , \n           } , \n         } , \n       ] , \n     } ; \n\n     const   reducer   =   ( state  =  defaultState ,  action  =   { } )   =>   { \n       switch   ( action . type )   { \n         case   ADD_USERS :   { \n           return   {   ... state ,   list :  action . payload  } ; \n         } \n\n         default :   return  state ; \n       } \n     } ; \n\n     export   default  reducer ; \n \n pageModels/reducer.js \n      import   {   ADD_PAGE_MODELS   }   from   'state/apps/testing/pageModels/types' ; \n\n     const  defaultState  =   { \n       list :   [ \n         { \n           code :   'home' , \n           descr :   'Home Page' , \n           configuration :   { \n             frames :   [ \n               { \n                 pos :   0 , \n                 descr :   'Navbar' , \n                 sketch :   { \n                   x1 :   0 , \n                   y1 :   0 , \n                   x2 :   2 , \n                   y2 :   0 , \n                 } , \n               } , \n               { \n                 pos :   1 , \n                 descr :   'Navbar 2' , \n                 sketch :   { \n                   x1 :   3 , \n                   y1 :   0 , \n                   x2 :   5 , \n                   y2 :   0 , \n                 } , \n               } , \n             ] , \n           } , \n           template :   '<html></html>' , \n         } , \n         { \n           code :   'service' , \n           descr :   'Service Page' , \n           configuration :   { \n             frames :   [ \n               { \n                 pos :   0 , \n                 descr :   'Navbar' , \n                 sketch :   { \n                   x1 :   0 , \n                   y1 :   0 , \n                   x2 :   2 , \n                   y2 :   0 , \n                 } , \n               } , \n               { \n                 pos :   1 , \n                 descr :   'Navbar 2' , \n                 sketch :   { \n                   x1 :   3 , \n                   y1 :   0 , \n                   x2 :   5 , \n                   y2 :   0 , \n                 } , \n               } , \n             ] , \n           } , \n           template :   '<html></html>' , \n         } , \n       ] , \n     } ; \n\n     const   reducer   =   ( state  =  defaultState ,  action  =   { } )   =>   { \n       switch   ( action . type )   { \n         case   ADD_PAGE_MODELS :   { \n           return   {   ... state ,   list :  action . payload  } ; \n         } \n\n         default :   return  state ; \n       } \n     } ; \n\n     export   default  reducer ; \n \n Last, we can add the two reducers just created to the\n src/state/rootReducer.js \n      ... \n     import  userList  from   'state/apps/testing/userList/reducer' ; \n     import  pageModels  from   'state/apps/testing/pageModels/reducer' ; \n\n     export   const  testing  =   combineReducers ( { \n      pageModels , \n      userList , \n     } ) ; \n     ... \n \n we will now be able to see with the  reduxDevTools  in our browser. To\nview this state in your reduxDevTools go to: \n State -→ apps -→ testing -→ pageModels  and\n State -→ apps -→ testing -→ userList \n Creating the UI Components \n At this point, both routes created should be rendering a simple string.\nWe will next create the actual component that will be rendered inside\nthe page. \n userList \n Inside  src/ui/userList/  create the  List  component. Create the\n userList  directory and  List.js  file in that directory. \n      import  React  from   'react' ; \n\n     import   { \n      Grid , \n      TablePfProvider , \n     }   from   'patternfly-react' ; \n\n     const   List   =   ( )   =>   { \n       const  data  =   [ \n         { \n           username :   'admin' , \n           registration :   '2018-01-08 00:00:00' , \n         } , \n         { \n           username :   'user1' , \n           registration :   '2018-01-08 00:00:00' , \n         } , \n       ] ; \n\n       const  tr  =  data . map ( row   =>   ( \n         < tr > \n           < td > { row . username } < / td > \n           < td > { row . registration } < / td > \n         < / tr > \n       ) ) ; \n\n       return   ( \n         < Grid fluid > \n           < TablePfProvider\n            striped\n            bordered\n            hover\n           > \n             < thead > \n               < tr > \n                 < td > username < / td > \n                 < td > registration < / td > \n               < / tr > \n             < / thead > \n             < tbody > \n               { tr } \n             < / tbody > \n           < / TablePfProvider > \n         < / Grid > \n       ) ; \n     } ; \n\n     export   default  List ; \n \n Next, change the route inside  src/ui/App.js . Add the import below and\nupdate the component to reference the List component created in the\nprior step. \n      ... \n     import  List  from   'ui/userList/List' ; \n     ... \n       { \n         path :   ROUTE_USER_LIST , \n         component :  List , \n       } , \n     ... \n \n The table will now display correctly when clicking on the menu item. \n connecting to the store \n Next let’s connect the component to the store to get the data from the\nreducer. \n The first step is creating the  ListContainer.js  next to the  List \ncomponent file. \n      import   {  connect  }   from   'react-redux' ; \n     import   {  getList  }   from   'state/apps/testing/userList/selectors' ; \n\n     import  List  from   'ui/userList/List' ; \n\n     export   const   mapStateToProps   =   state   =>   ( { \n       data :   getList ( state ) , \n     } ) ; \n\n     export   default   connect ( \n      mapStateToProps , \n       null , \n     ) ( List ) ; \n \n And then update the List component to receive the property. The List\nfile should now look like this: \n      import  React  from   'react' ; \n     import  PropTypes  from   'prop-types' ; \n\n     import   { \n      Grid , \n      TablePfProvider , \n     }   from   'patternfly-react' ; \n\n     const   List   =   ( {  data  } )   =>   { \n       const  tr  =  data . map ( row   =>   ( \n         < tr > \n           < td > { row . username } < / td > \n           < td > { row . registration } < / td > \n         < / tr > \n       ) ) ; \n\n       return   ( \n         < Grid fluid > \n           < TablePfProvider\n            striped\n            bordered\n            hover\n           > \n             < thead > \n             < tr > \n               < td > username < / td > \n               < td > registration < / td > \n             < / tr > \n             < / thead > \n             < tbody > \n             { tr } \n             < / tbody > \n           < / TablePfProvider > \n         < / Grid > \n       ) ; \n     } ; \n\n     export   default  List ; \n \n Make sure that you remove the predefined  data  const since the data\nwill now be coming from the reducer, on top of defining PropTypes rules\nfor validating and giving a default for the injected property  data . \n Once complete, update the component used in the route inside  App.js .\nUpdate the import to the container and update the component in\n ROUTE_USER_LIST  to the new ListContainer. \n      ... \n     import  ListContainer  from   'ui/userList/ListContainer' ; \n     ... \n       { \n         path :   ROUTE_USER_LIST , \n         component :  ListContainer , \n       } , \n     ... \n \n Go back to your app. We will now see the data inside the table\nreflecting the content of the storage. \n Page Models \n inside  src/ui/pageModels/  we are going to create the  List  component \n      import  React  from   'react' ; \n     import  PropTypes  from   'prop-types' ; \n\n     import   { \n      Grid , \n      TablePfProvider , \n     }   from   'patternfly-react' ; \n\n     const   List   =   ( {  data  } )   =>   { \n       const  tr  =  data . map ( row   =>   ( \n         < tr > \n           < td > { row . username } < / td > \n           < td > { row . registration } < / td > \n         < / tr > \n       ) ) ; \n\n       return   ( \n         < Grid fluid > \n           < TablePfProvider\n            striped\n            bordered\n            hover\n           > \n             < thead > \n             < tr > \n               < td > username < / td > \n               < td > registration < / td > \n             < / tr > \n             < / thead > \n             < tbody > \n             { tr } \n             < / tbody > \n           < / TablePfProvider > \n         < / Grid > \n       ) ; \n     } ; \n\n    List . propTypes  =   { \n       data :  PropTypes . arrayOf ( PropTypes . shape ( { } ) ) , \n     } ; \n\n    List . defaultProps  =   { \n       data :   [ ] , \n     } ; \n\n     export   default  List ; \n \n Next change the route inside  src/ui/App.js \n      ... \n     import  ListPageModels  from   'ui/pageModels/List' ; \n     ... \n       { \n         path :   ROUTE_PAGE_MODELS , \n         component :  ListPageModels , \n       } , \n     ... \n \n The table will now be displayed correctly when clicking on the menu\nitem. \n Connecting to the Store \n Next, connect the component to the store to get the data from the\nreducer. \n The very first thing we’ll do is create the  ListContainer.js  next to\nthe  List  component file. \n      import   {  connect  }   from   'react-redux' ; \n     import   {  getList  }   from   'state/apps/testing/pageModels/selectors' ; \n\n     import  List  from   'ui/pageModels/List' ; \n\n     export   const   mapStateToProps   =   state   =>   ( { \n       data :   getList ( state ) , \n     } ) ; \n\n     export   default   connect ( \n      mapStateToProps , \n       null , \n     ) ( List ) ; \n \n And then update the List component to receive the property. The whole\nList component will have this content: \n      import  React  from   'react' ; \n     import  PropTypes  from   'prop-types' ; \n\n     import   { \n      Grid , \n      TablePfProvider , \n     }   from   'patternfly-react' ; \n\n     const   List   =   ( {  data  } )   =>   { \n       const  tr  =  data . map ( row   =>   ( \n         < tr > \n           < td > { row . code } < / td > \n           < td > { row . descr } < / td > \n         < / tr > \n       ) ) ; \n\n\n       return   ( \n         < Grid fluid > \n           < TablePfProvider\n            striped\n            bordered\n            hover\n           > \n             < thead > \n             < tr > \n               < td > code < / td > \n               < td > descr < / td > \n             < / tr > \n             < / thead > \n             < tbody > \n             { tr } \n             < / tbody > \n           < / TablePfProvider > \n         < / Grid > \n       ) ; \n     } ; \n\n    List . propTypes  =   { \n       data :  PropTypes . arrayOf ( PropTypes . shape ( { } ) ) , \n     } ; \n\n    List . defaultProps  =   { \n       data :   [ ] , \n     } ; \n     export   default  List ; \n \n Next make sure that you remove the predefined  data  const since the\ndata will be coming from the reducer, on top of defining PropTypes rules\nfor validating and giving a default for the injected property  data . \n Once complete, update the component used in the route inside  App.js \n      ... \n     import  PageModelsListContainer  from   'ui/pageModels/ListContainer' ; \n     ... \n       { \n         path :   ROUTE_PAGE_MODELS , \n         component :  PageModelsListContainer , \n       } , \n     ... \n \n You will now see the data inside the table reflecting the content of the\nstorage. \n Connecting the app to an Entando core instance \n By default the app is using mocks and not connecting to any Entando core\ninstance. \n Because the app is making use of  @entando/apimanager  we can easily\nchange this by setting up two  .env  variables inside the  .env  file in\nthe project root: \n     REACT_APP_DOMAIN=http://localhost:8080/entando-app\n    REACT_APP_USE_MOCKS=false\n \n The  REACT_APP_DOMAIN  must pointing towards the domain and container\nwhere the Entando instance is running and  must not  contain trailing\nslashes. \n Once this is done to make the change happen we will have to stop the app\nusing  ctrl + c  and re run it with  npm start . \n Now the toast stating  This application is using mocks  won’t be popping\nup anymore. \n You can make sure that the configuration is correct by looking at the\nnetwork section in the browser dev tools. By default the app\nautomatically makes an admin login against a plain Entando instance to\nauthenticate the user and to be able to consume any protected api. \n This is not an ideal scenario and it is meant to be used only for\ndebugging purposes for many reasons: \n \n \n the username and password should never be hardcoded in your app \n \n \n if authentication is required the user should be the one performing\nthe login action \n \n \n the plain default passwords in use won’t be useful against a proper\nproduction instance of Entando \n Adding the API Calls \n We are now going to add api calls for both users and page models to\nretrieve the data live instead of relying on our store’s default state. \n Inside  src/api  create the  users.js  file: \n      import   {  makeRequest ,   METHODS   }   from   '@entando/apimanager' ; \n\n     // eslint-disable-next-line import/prefer-default-export \n     export   const  getUsers  =   ( page  =   {   page :   1 ,   pageSize :   10   } ,  params  =   '' )   =>   ( \n       makeRequest ( \n         { \n           uri :   ` /api/users ${ params } ` , \n           method :   METHODS . GET , \n           mockResponse :   { } , \n           useAuthentication :   true , \n         } , \n        page , \n       ) \n     ) ; \n \n and then create the  pageModels.js  file: \n      import   {  makeRequest ,   METHODS   }   from   '@entando/apimanager' ; \n\n     // eslint-disable-next-line import/prefer-default-export \n     export   const  getPageModels  =   ( page  =   {   page :   1 ,   pageSize :   10   } ,  params  =   '' )   =>   makeRequest ( { \n       uri :   ` /api/pageModels ${ params } ` , \n       method :   METHODS . GET , \n       mockResponse :   { } , \n       useAuthentication :   true , \n     } ,  page ) ; \n Creating the Thunk \n In order to use the api call we next create a thunk action, which is a\nredux action with side effects, like an API call. \n inside the  src/state/apps/testing/userList/actions.js  file we are\ngoing to add the new action: \n      ... \n     import   {  addErrors  }   from   '@entando/messages' ; \n     import   { \n      getUsers , \n     }   from   'api/users' ; \n     ... \n\n     // thunks \n\n     export   const  fetchUsers  =   ( page  =   {   page :   1 ,   pageSize :   10   } ,  params  =   '' )   =>   dispatch   =>   ( \n       new   Promise ( ( resolve )   =>   { \n         getUsers ( page ,  params ) . then ( ( response )   =>   { \n          response . json ( ) . then ( ( json )   =>   { \n             if   ( response . ok )   { \n               dispatch ( addUsers ( json . payload ) ) ; \n             }   else   { \n               dispatch ( addErrors ( json . errors . map ( err   =>  err . message ) ) ) ; \n             } \n             resolve ( ) ; \n           } ) ; \n         } ) . catch ( ( )   =>   { } ) ; \n       } ) \n     ) ; \n \n Next do the same inside  src/state/apps/testing/pageModels/actions.js : \n      ... \n     import   {  addErrors  }   from   '@entando/messages' ; \n     import   { \n      getPageModels , \n     }   from   'api/pageModels' ; \n     ... \n\n     // thunks \n\n     export   const  fetchPageModels  =   ( page  =   {   page :   1 ,   pageSize :   10   } ,  params  =   '' )   =>   dispatch   =>   ( \n       new   Promise ( ( resolve )   =>   { \n         getPageModels ( page ,  params ) . then ( ( response )   =>   { \n          response . json ( ) . then ( ( data )   =>   { \n             if   ( response . ok )   { \n               dispatch ( addPageModels ( data . payload ) ) ; \n               resolve ( ) ; \n             }   else   { \n               dispatch ( addErrors ( data . errors . map ( err   =>  err . message ) ) ) ; \n               resolve ( ) ; \n             } \n           } ) ; \n         } ) . catch ( ( )   =>   { } ) ; \n       } ) \n     ) ; \n \n Now with two exports, it is safe to remove the\n eslint-disable-next-line  comment on line 5 of both files. \n changing the mapDispatchToProps in the containers \n Next, in order to pass the newly created thunk to both List components,\nwe’ll update the containers accordingly, as: \n src/ui/userList/ListContainer.js \n      ... \n     import   {  fetchUsers  }   from   'state/apps/testing/userList/actions' ; \n     ... \n     export   const   mapDispatchToProps   =   dispatch   =>   ( { \n       fetch :   ( )   =>   dispatch ( fetchUsers ( ) ) , \n     } ) ; \n\n     export   default   connect ( \n      mapStateToProps , \n      mapDispatchToProps , \n     ) ( List ) ; \n \n src/ui/pageModels/ListContainer.js \n      ... \n     import   {  fetchPageModels  }   from   'state/apps/testing/pageModels/actions' ; \n     ... \n     export   const   mapDispatchToProps   =   dispatch   =>   ( { \n       fetch :   ( )   =>   dispatch ( fetchPageModels ( ) ) , \n     } ) ; \n\n     export   default   connect ( \n      mapStateToProps , \n      mapDispatchToProps , \n     ) ( List ) ; \n Updating the List components \n Both List components were simple components with only a  render  method,\ntherefore could be declared as simple constants. \n Next we will fetch data during the  componentDidMount  life cycle event\nwhich will require we turn the constant into a class on top of changing\nthe PropTypes to add the new fetch method passed down to the component. \n src/ui/userList/List.js \n      import  React ,   {  Component  }   from   'react' ; \n     ... \n     class   List   extends   Component   { \n       componentDidMount ( )   { \n         const   {  fetch  }   =   this . props ; \n         fetch ( ) ; \n       } \n\n       render ( )   { \n         const   {  data  }   =   this . props ; \n         const  tr  =  data . map ( row   =>   ( \n           < tr > \n             < td > { row . username } < / td > \n             < td > { row . registration } < / td > \n           < / tr > \n         ) ) ; \n\n         return   ( \n           < Grid fluid > \n             < TablePfProvider\n              striped\n              bordered\n              hover\n             > \n               < thead > \n                 < tr > \n                   < td > username < / td > \n                   < td > registration < / td > \n                 < / tr > \n               < / thead > \n               < tbody > \n                 { tr } \n               < / tbody > \n             < / TablePfProvider > \n           < / Grid > \n         ) ; \n       } \n     } \n\n    List . propTypes  =   { \n       data :  PropTypes . arrayOf ( PropTypes . shape ( { } ) ) , \n       fetch :  PropTypes . func , \n     } ; \n\n    List . defaultProps  =   { \n       data :   [ ] , \n       fetch :   ( )   =>   { } , \n     } ; \n \n src/ui/pageModels/List.js \n      import  React ,   {  Component  }   from   'react' ; \n     ... \n     class   List   extends   Component   { \n       componentDidMount ( )   { \n         const   {  fetch  }   =   this . props ; \n         fetch ( ) ; \n       } \n\n       render ( )   { \n         const   {  data  }   =   this . props ; \n         const  tr  =  data . map ( row   =>   ( \n           < tr > \n             < td > { row . code } < / td > \n             < td > { row . descr } < / td > \n           < / tr > \n         ) ) ; \n\n         return   ( \n           < Grid fluid > \n             < TablePfProvider\n              striped\n              bordered\n              hover\n             > \n               < thead > \n                 < tr > \n                   < td > code < / td > \n                   < td > descr < / td > \n                 < / tr > \n               < / thead > \n               < tbody > \n                 { tr } \n               < / tbody > \n             < / TablePfProvider > \n           < / Grid > \n         ) ; \n       } \n     } \n\n    List . propTypes  =   { \n       data :  PropTypes . arrayOf ( PropTypes . shape ( { } ) ) , \n       fetch :  PropTypes . func , \n     } ; \n\n    List . defaultProps  =   { \n       data :   [ ] , \n       fetch :   ( )   =>   { } , \n     } ; \n clear the default value of the reducer \n Now we should be fetching data from the server, therefore we can safely\nmake the list key in the  defaultState  object an empty array: \n src/state/apps/testing/userList/reducer.js \n      ... \n     const  defaultState  =   { \n       list :   [ ] , \n     } ; \n     ... \n \n src/state/apps/testing/pageModels/reducer.js \n      ... \n     const  defaultState  =   { \n       list :   [ ] , \n     } ; \n     ... \n adding additional dependencies \n It may be necessary to set additional dependencies for your project. If\nthe need arises, it is important to remember a few rules: \n Only actual dependencies that are not already included in  app-builder \ncan be added as pure dependencies. Every other dependency must either be\na  devDependency  or  peerDependency . \n If you are not careful you may end up with duplicated dependencies that\n will  result in errors manifesting themselves when running the app\ninside App Builder. \n running the app in integrated mode within App Builder \n After running  npm install  in the App Builder, the user can run the\n npm run app-install <appId>  command to install the app. \n This command will trigger a download of the app from npm and the\ninstallation of its component within App Builder. After the installation\nprocess is complete, it will be possible to either  npm start  or\n npm build  App Builder. \n To install a dev app, like the one developed in this tutorial which have\nnot been previously published on npm, you will need to use additional\nflags and will have to run a few additional commands. \n Before running the Install command  make sure that you have\nuninstalled all existing peer and dev dependencies to avoid collision\nwith app builder. To do so, from the app builder app directory\n( testing , in this tutorial) just run in the correct order the\nfollowing commands: \n npm run babel \n npm i --only=production \n The first will create the dist directory that will be needed by App\nBuilder while the second one will uninstall anything but production\ndependencies. \n Next, from the App Builder directory, run the install command with these\nadditional flags: \n \n \n -d  specify the relative path where the app is installed. When\nusing this flag the appId should be the normalized app name, without\nthe  @entando/  prefix. \n \n \n -p  specify the package name if it is different from the appId \n \n \n to use flags you will have to use the double dash in the command: \n npm run app-install —  cms -d ../testing -p @entando/testing \n the value in the  -p  flag should always match the actual name of the\napp that is going to be installed inside App Builder . You can check\nyour app name inside the  package.json  file of your app. \n If you experience problems after running the build command delete the\n node_modules  directory before running the second command. \n"},{title:"Run Blueprint-generated Microservices and Micro Frontends in Dev Mode",frontmatter:{sidebarDepth:2,redirectFrom:"/v6.3.2/tutorials/backend-developers/run-local.html"},regularPath:"/v6.3.2/tutorials/create/ms/run-local.html",relativePath:"v6.3.2/tutorials/create/ms/run-local.md",key:"v-58aa9db9",path:"/v6.3.2/tutorials/create/ms/run-local.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"CLI Steps",slug:"cli-steps"},{level:2,title:"Manual Steps",slug:"manual-steps"},{level:3,title:"Start Keycloak using docker-compose",slug:"start-keycloak-using-docker-compose"},{level:3,title:"Start the microservice",slug:"start-the-microservice"},{level:3,title:"Start the table widget",slug:"start-the-table-widget"},{level:3,title:"Start the form widget",slug:"start-the-form-widget"},{level:3,title:"Start the details widget",slug:"start-the-details-widget"},{level:3,title:"Widget Details notes:",slug:"widget-details-notes"},{level:2,title:"Notes",slug:"notes-3"},{level:3,title:"Change Keycloak dev settings",slug:"change-keycloak-dev-settings"},{level:3,title:"The service-url Variable",slug:"the-service-url-variable"},{level:3,title:"User is not authenticated message",slug:"user-is-not-authenticated-message"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:' Run Blueprint-generated Microservices and Micro Frontends in Dev Mode \n Overview \n This tutorial will take you through running an Entando project (microservice and micro frontends) in a local development environment. If you haven\'t generated your Entando project yet, start with the  Generate Microservices and Micro Frontend  tutorial first. \n The steps below assume you are working in the top-level project directory. \n CLI Steps \n The following steps make use of the Entando  ent prj  command. See the  Manual Steps  section below for a more detailed description of what the individual commands do. \n \n Startup Keycloak. This uses docker-compose under the hood. Since this is using Docker it will continue to run in the background until you stop it via  ent prj ext-keycloak stop . You can also view its logs using  ent prj ext-keycloak logs . \n \n ent prj ext-keycloak start\n \n \n Startup the Spring Boot application containing your microservices. The logs will be shown on the console and you can stop the application via  CTRL+C . \n \n ent prj be-test-run\n \n \n Startup one or more of the frontend widgets, each from its own shell. You can stop the application using  CTRL+C . This command runs React in development mode so any changes you make to the source files should be immediately seen in the browser. \n \n ent prj fe-test-run\n Manual Steps \n Start Keycloak using docker-compose \n \n Startup the Keycloak server: \n \n    docker-compose  -f src/main/docker/keycloak.yml up\n Notes: \n \n If you have to install docker-compose you can follow this guide:\n https://docs.docker.com/compose/install/ \n By default docker-compose will recreate the Keycloak container (and reset the H2 database) each time it is started. You can make the following changes to persist Keycloak changes across restarts:\n \n Modify the following line in your  src/main/docker/keycloak.yml \n \n \n \n \'-Dkeycloak.migration.strategy=OVERWRITE_EXISTING\',\n \n and replace it with this \n \'-Dkeycloak.migration.strategy=IGNORE_EXISTING\',\n \n \n In the same file, add a persistent volume under  volumes : \n \n  - ./keycloak-db:/opt/jboss/keycloak/standalone/data\n \n Keycloak changes should now be persistent. You can reset your Keycloak database by emptying the  src/main/docker/keycloak-db  directory and restarting the container. \n Start the microservice \n \n \n Start the generated Microservice executing the command: \n ./mvnw\n Notes: \n If you want to reset the widget data (as example if you deleted all rows from the table widget) if during the generation of the microservice you selected "H2 with disk-based persistence" you can delete the target folder, restart the microservice and the data will be regenerated. \n Start the table widget \n Now you can start your generated table widget: \n \n \n Go to the table widget folder in your project: \n cd ui/widgets/<your-entity-name>/tableWidget\n \n \n \n Then install and start your widget executing the command: \n npm install && npm start\n \n \n \n When the widget is started a browser window is opened and the widget URL is loaded \n \n \n If you’re not logged in you’re redirected to the login page. \n \n \n Log in using: \n Username: user\nPassword: user\n \n \n \n After the login process you’ll be redirected to the widget page and you can see the table widget with some generated data. \n Start the form widget \n Now you can start your generated form widget: \n \n \n If you are running another widget, stop it clicking  Ctrl+C  in your widget command line window \n \n \n Go to the form widget folder in your project: \n cd ui/widgets/<your-entity-name>/formWidget\n \n \n \n Then install and start your widget executing the command: \n npm install && npm start\n \n \n \n When the widget is started a browser window is opened with and the widget URL is loaded \n \n \n If you’re not logged in you’re redirected to the login page. \n \n \n Log in using: \n Username: user\nPassword: user\n \n \n \n You’ll be redirected to the widget page and you can see the widget form with the ID 1 loaded. \n Form widget notes: \n If you want to load other data you have to change the index.html file in the folder: \n cd ui/widgets/<your-entity-name>/formWidget/public\n \n and change the id attribute in this line: \n <my-entity-form service-url="%REACT_APP_SERVICE_URL%" id="1" />\n Start the details widget \n You can also start your generated details widget: \n \n \n If you are running another widget, stop it clicking  Ctrl+C  in your widget command line window \n \n \n Go to the details widget folder in your project: \n cd ui/widgets/<your-entity-name>/detailsWidget\n \n \n \n Then install and start your widget executing the command: \n npm install && npm start\n \n \n \n When the widget is started a browser window is opened with and the widget URL is loaded \n \n \n If you’re not logged in you’re redirected to the login page. \n \n \n Log in using: \n Username: user\nPassword: user\n \n \n \n You’ll be redirected to the widget page and you can see the widget form with the ID 1 loaded. \n Widget Details notes: \n If you want to load other data you have to change the index.html file in the public folder: \n cd ui/widgets/<your-entity-name>/detailsWidget/public\n \n and change the "id" attribute in this line: \n <my-entity-details service-url="%REACT_APP_SERVICE_URL%" id="1" />\n Notes \n Change Keycloak dev settings \n If you want to change your Keycloak settings to use another keycloak installation (not the docker-compose pre-configured one) or if you want to change the service-url of your widget you can change the parameters set in the  .env.local  file that was generated by the entando-blueprint in the root folder of your react widgets: \n cd ui/widgets/<your-entity-name>/tableWidget\n \n then edit the file  .env.local \n By default this variables are set to: \n REACT_APP_SERVICE_URL=http://localhost:8081/services/<your-application-name>/api\nREACT_APP_KEYCLOAK_URL=http://localhost:9080/auth\nREACT_APP_KEYCLOAK_REALM=jhipster\nREACT_APP_KEYCLOAK_CLIENT_ID=web_app\n The service-url Variable \n The  service-url  variable is the Microservice API URL. \n User is not authenticated message \n When you run the widgets if you see the message:  User is not authenticated . This means that probably your keycloak application is not running so please check if the docker-compose command is still in execution. \n'},{title:"Update the Project Data Model",frontmatter:{sidebarDepth:2,redirectFrom:"/v6.3.2/tutorials/backend-developers/update-data-model.html"},regularPath:"/v6.3.2/tutorials/create/ms/update-data-model.html",relativePath:"v6.3.2/tutorials/create/ms/update-data-model.md",key:"v-29922bb7",path:"/v6.3.2/tutorials/create/ms/update-data-model.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:" Update the Project Data Model \n Overview \n This tutorial shows how you can use the Entando Component Generator powered by  JHipster  to quickly update the data model for your Entando project. \n Prerequisites \n The steps below assume you already have an existing project and are working in the top-level project directory. If you don't have a project yet, please see  this tutorial . \n Tutorial \n \n Start by extracting the current application description using JHipster. The resulting JHIpster Domain Language (JDL) file includes the entity definitions that will be used as a starting point for your design work. \n \n ent jhipster export-jdl export.jdl\n \n \n This file contains the application configuration as well as entity definitions for your project. For simplicity, we'll create a new file containing just the elements describing the entities. If you followed the tutorial above, that section could be as simple as this: \n \n entity Conference {\n  name String\n}\n \n \n You can now take this definition and enhance it by adding fields, additional entities, mappings between tables, field validation, etc. The easiest way to do this is by using the online JDL-Studio or corresponding JHipster IDE plugins/extensions. See  the JHipster docs  for more information on those options. Once you're done enhancing your data model, you should create a new file containing it, e.g.  conference.jdl. \n \n entity Conference {\n  name String required\n  location String\n  date ZonedDateTime\n}\n\nentity Session {\n  name String required\n  track Track required\n}\n\nenum Track {\n  BUSINESS, TECHNICAL\n}\n\nrelationship OneToMany {\n   Conference to Session\n}\n \n In this case we've added two fields to the Conference entity, introduced the Session entity plus an enum, and added a mapping between the two entities. This is the view you'll get in JDL-Studio for the updated data model. \n \n \n Now import the jdl file into your application. You may be asked if you want to generate MFEs depended on your options when first generating the project. \n \n ent jhipster import-jdl conference.jdl\n \n If you kept the original project structure, this step will update your data model, add entries to Liquibase so the database schema can be upgraded at deploy time, add new service methods to your microservice, add fields to your MFEs, etc. \n \n You can now build your updated project and  run it locally  or  deploy it to Entando . For a full local test you can use the following commands to build the project, then start Keycloak, the microservices, and one of the MFEs. \n \n ent prj build\nent prj xk start\nent prj be-test-run\nent prj fe-test-run\n \n You can repeat steps 3-5 as many times as needed throughout the life of your project. \n"},{title:"Create an Angular Micro Frontend",frontmatter:{sidebarDepth:2,redirectFrom:"/v6.3.2/tutorials/micro-frontends/angular.html"},regularPath:"/v6.3.2/tutorials/create/mfe/angular.html",relativePath:"v6.3.2/tutorials/create/mfe/angular.md",key:"v-1aaaa2b9",path:"/v6.3.2/tutorials/create/mfe/angular.html",headers:[{level:2,title:"Create Angular App",slug:"create-angular-app"},{level:3,title:"Convert to Custom Element",slug:"convert-to-custom-element"},{level:3,title:"Test Micro Frontend",slug:"test-micro-frontend"},{level:2,title:"Build It",slug:"build-it"},{level:2,title:"Host Micro Frontend",slug:"host-micro-frontend"},{level:3,title:"Create Public Folder",slug:"create-public-folder"},{level:3,title:"Add Widget",slug:"add-widget"},{level:3,title:"See It in Action",slug:"see-it-in-action"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:" Create an Angular Micro Frontend \n Prerequisites \n \n A working instance of Entando. \n \n \n Tested Versions \n node v13.8.0 → We suggest using  nvm  to handle node installations. \n Create Angular App \n Install Angular CLI. \n npm   install  -g @angular/cli\n \n Generate a new angular application. \n ng new angular-widget\n \n Choose the following options: \n ? Would you like to  add  Angular routing? No\n? Which stylesheet  format  would you like to use? CSS\n \n Serve the application. \n cd  angular-widget\n \n ng serve\n \n This is the expected output: \n angular-widget\n├── e2e\n│   └── src\n│       ├── app.e2e-spec.ts\n│       └── app.po.ts\n│\n├── node_modules\n├── src\n│   ├── app\n│   │   ├── app.component.css\n│   │   ├── app.component.html\n│   │   ├── app.component.spec.ts\n│   │   ├── app.component.ts\n│   │   └── app.module.ts\n│   │\n│   ├── assets\n│   │   └── .gitkeep\n│   │\n│   ├── environment\n│   │   ├── environment.prod.ts\n│   │   └── environment.ts\n│   │\n│   ├── favicon.ico\n│   ├── index.html\n│   ├── main.ts\n│   ├── polyfills.ts\n│   ├── styles.css\n│   └── test.ts\n│\n├── .editorconfig\n├── .gitignore\n├── angular.json\n├── browserlist\n├── karma.conf.js\n├── package.json\n├── README.md\n├── tsconfig.app.json\n├── tsconfig.json\n├── tsconfig.spec.json\n└── tslint.json\n Convert to Custom Element \n Next, let's convert our Angular app into a custom element. We'll use  Angular elements  to transform components into custom elements. \n ng  add  @angular/elements\n \n WARNING \n Install the Angular elements package using  ng add , not with  npm install  as it runs additional steps behind the scenes like adding the  document-register-element  polyfill. \n \n TIP \n Angular elements are Angular components packaged as custom elements (also called Web Components), a web standard for defining new HTML elements in a framework-agnostic way. \n \n Open  angular-widget/src/app/app.module.ts . \n \n Here's what the initial file looks like: \n \n import   {  BrowserModule  }   from   '@angular/platform-browser' ; \n import   {  NgModule  }   from   '@angular/core' ; \n\n import   {  AppComponent  }   from   './app.component' ; \n\n@ NgModule ( { \n   declarations :   [ \n    AppComponent\n   ] , \n   imports :   [ \n    BrowserModule\n   ] , \n   providers :   [ ] , \n   bootstrap :   [ AppComponent ] \n } ) \n export   class   AppModule   {   } \n \n Replace the entire file with: \n import   {  BrowserModule  }   from   '@angular/platform-browser' ; \n import   {  NgModule ,  Injector  }   from   '@angular/core' ; \n import   {  createCustomElement  }   from   '@angular/elements' ; \n import   {  AppComponent  }   from   './app.component' ; \n\n@ NgModule ( { \n   declarations :   [ \n    AppComponent\n   ] , \n   imports :   [ \n    BrowserModule\n   ] , \n   providers :   [ ] , \n   entryComponents :   [ AppComponent ] \n } ) \n export   class   AppModule   { \n   constructor ( private   injector :  Injector )   { } \n\n   ngDoBootstrap ( )   { \n     const  el  =   createCustomElement ( AppComponent ,   {   injector :   this . injector  } ) ; \n    customElements . define ( 'angular-widget' ,  el ) ; \n   } \n } \n \n \n In the initial file,  AppModule  is bootstrapped directly during application launch. \n In the updated file, we booststrap our custom element using the  ngDoBootstrap()  method . \n \n Custom Elements \n \n Must contain a hyphen  -  in the name. : \n Cannot be a single word. \n Should follow  kebab-case  for naming convention. \n Test Micro Frontend \n Now, let's check our custom element to see if it's working. \n Open  angular-widget/src/index.html . \n In the  <body> , replace  <app-root></app-root>  with your custom element  <angular-widget /> . \n <! doctype   html > \n < html   lang = \" en \" > \n < head > \n   < meta   charset = \" utf-8 \" > \n   < title > AngularWidget </ title > \n   < base   href = \" / \" > \n   < meta   name = \" viewport \"   content = \" width=device-width, initial-scale=1 \" > \n   < link   rel = \" icon \"   type = \" image/x-icon \"   href = \" favicon.ico \" > \n </ head > \n < body > \n   < angular-widget   /> \n </ body > \n </ html > \n \n Congratulations! \n You’re now running  Angular  in a micro frontend. \n Build It \n From the project root, type: \n ng build --prod --outputHashing = none\n \n This will generate an  angular-widget/dist  directory. \n If we assume browser support for  ES6 (ECMAScript 2015) , we can focus on the following JavaScript files to publish our app: \n \n main-es2015.js \n polyfills-es2015.js \n runtime-es2015.js \n \n Generated Build Files \n --outputHashing=none  generates files without hashes so we can deploy new versions of the micro frontend without having to reconfigure our widget in Entando to point to the newly built files. \n \n If you want to use file names with content hashes to avoid potential caching issues in your browser, you can update the  Custom UI  field of your widget after building new versions of your micro frontend. Widget configuration is covered in the next section. \n Host Micro Frontend \n Now we're ready to host our micro frontend in Entando. \n Create Public Folder \n \n \n Navigate to  Entando App Builder  in your browser. \n \n \n Click  Administration  at the lower left hand side of the screen. \n \n \n Click the  File Browser  tab. \n \n \n Click the  public  folder. \n \n \n Click  Create Folder . \n \n \n Enter  angular-widget \n \n \n Click  Save . \n \n \n Click  angular-widget . \n \n \n Click 'Upload Files`. \n \n \n Upload the following files from  angular-widget/dist/angular-widget : \n \n \n \n main-es2015.js \n polyfills-es2015.js \n runtime-es2015.js \n \n Additional Deployment Options \n \n Install the micro frontend from a bundle in the  Entando Component Repository . \n Add the micro frontend to  Entando App Builder . \n Load the micro frontend from an API. \n Add Widget \n \n Go to  Components > Micro frontends & Widgets  in the Entando App Builder. \n Click  Add  at the lower right. \n \n \n \n Enter the following: \n \n \n Code: angular_widget  → note: dashes are not allowed \n Title: Angular Widget  → for both English and Italian languages \n Group: Free Access \n Custom UI: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < script   async   src = \" < @wp . resourceURL  /> angular-widget/main-es2015.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> angular-widget/polyfills-es2015.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> angular-widget/runtime-es2015.js \" > </ script > \n\n < angular-widget   /> \n \n \n Click  Save . \n \n TIP \n <#assign wp=JspTaglibs[ \"/aps-core\"]>  gives you access to the  @wp  object where you can use environment variables like  resourceURL . \n See It in Action \n Let's see the Angular micro frontend in action on our page. \n Add Page \n Note \n If you've already configured your home page: \n \n   Next to the  Home  folder, under  Actions , click  Configure . \n   Skip to the  Add Widget  section. \n \n \n Let's add our widget to the  Home  page. \n \n \n Go to  Pages  →  Management \n \n \n Next to the  Home  folder, under  Actions , click  Edit . \n \n \n Next to  Page Template  select  Service Page . \n \n \n Click  Save and Configure . \n Add Widget \n \n \n In the Search field in right-hand sidebar, enter  Angular Widget . \n \n \n Drag and drop  Angular Widget  into the  Sample Frame  in the main body of the page. \n \n \n Click  Publish . \n \n \n At the upper right, click  Go to Homepage . \n \n \n \n Congratulations! \n You now have an Angular micro frontend running in Entando. \n \n"},{title:"Authentication",frontmatter:{redirectFrom:"/v6.3.2/tutorials/micro-frontends/authentication.html"},regularPath:"/v6.3.2/tutorials/create/mfe/authentication.html",relativePath:"v6.3.2/tutorials/create/mfe/authentication.md",key:"v-4fb9ceee",path:"/v6.3.2/tutorials/create/mfe/authentication.html",lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:" Authentication \n Keycloak is used for authentication. \n To set up keycloak server, please refer to Keycloak\n documentation . \n As all MFE widgets use the same Keycloak instance, it should be\ninitialized on a container of all widgets. \n Using Details widget generated using Entando JHipster blueprint as an\nexample, let’s get familiar with authentication implementation. \n As mentioned before, widget auth implementation assumes that Keycloak is\ninitialized outside of the widget. In Details example, it is done in\nindex.html where Keycloak server’s keycloak.js is used. \n <head>\n    <script src=\"keycloak.js\"><\/script>\n    <script>\n        var keycloak = new Keycloak();\n        keycloak\n          .init({ onLoad: 'check-sso' })\n          .success(onInit);\n    <\/script>\n</head>\n \n \n Note \n keycloak.js is provided by your Keycloak server at\n <SERVER_URL:PORT>/auth/js/keycloak.js \n \n Keycloak is initialized by passing Keycloak server path, realm and\nclient ID and calling  init({/* options */})  function. \n const keycloak = Keycloak({\n  url: 'http://localhost:9080/auth',\n  realm: 'jhipster',\n  clientId: 'jhipster-entando-react-client',\n});\n\nkeycloak\n  .init({ onLoad: 'check-sso' })\n  .success(onInit);\n \n Depending on Keycloak version you are using,  init()  function can\nreturn a Promise (newer versions support  promiseType: 'native' \noption). \n keycloak\n  .init({ onLoad: 'check-sso', promiseType: 'native' })\n  .then(authenticated => {\n    alert(authenticated ? 'Authenticated' : 'Not authenticated');\n  })\n  .catch(() => {\n    alert('Failed to initialize');\n  });\n \n All the Keycloak events are made custom events - this way widgets could\nreact to them if a need arises. \n function createKcDispatcher(payload) {\n  return () => window.dispatchEvent(new CustomEvent('keycloak', { detail: payload }));\n}\n\nkeycloak.onReady = createKcDispatcher({ eventType: 'onReady' });\nkeycloak.onAuthSuccess = createKcDispatcher({ eventType: 'onAuthSuccess' });\nkeycloak.onAuthError = createKcDispatcher({ eventType: 'onAuthError' });\nkeycloak.onAuthRefreshSuccess = createKcDispatcher({ eventType: 'onAuthRefreshSuccess' });\nkeycloak.onAuthRefreshError = createKcDispatcher({ eventType: 'onAuthRefreshError' });\nkeycloak.onAuthLogout = createKcDispatcher({ eventType: 'onAuthLogout' });\nkeycloak.onTokenExpired = createKcDispatcher({ eventType: 'onTokenExpired' });\nconst onInit = createKcDispatcher({ eventType: 'onInit' });\n \n Keycloak object is then stored into  window.entando  object for widgets\nto have access to. \n window.entando = {\n  ...(window.entando || {}),\n  keycloak,\n};\n \n On the widget side inside the custom element creation logic Keycloak\nobject is accessed and passed into the component via Keycloak context \n const getKeycloakInstance = () =>\n  (window &&\n    window.entando &&\n    window.entando.keycloak &&\n    { ...window.entando.keycloak, initialized: true }\n  ) || { initialized: false };\n\n\n// ...\n\nconstructor(...args) {\n  // ...\n  this.keycloak = getKeycloakInstance();\n}\n\nconnectedCallback() {\n  // ...\n  ReactDOM.render(\n    <KeycloakContext.Provider value={this.keycloak}>\n      <ConferenceDetailsContainer />\n    </KeycloakContext.Provider>,\n    this.mountPoint\n  );\n}\n \n And on the component side you can show different content depending on\nthe authentication status \n At  auth/KeycloakViews.js \n export const AuthenticatedView = ({ children, keycloak }) => {\n  const authenticated = keycloak.initialized && keycloak.authenticated;\n  return authenticated ? children : null;\n};\n\nexport const UnauthenticatedView = ({ children, keycloak }) => {\n  const authenticated = keycloak.initialized && keycloak.authenticated;\n  return !authenticated ? children : null;\n};\n \n At  components/ConferenceDetailsContainer.js \n render() {\n  const { conference, loading } = this.state;\n  const { t, keycloak } = this.props;\n\n  return (\n    <ThemeProvider theme={this.theme}>\n      <UnauthenticatedView keycloak={keycloak}>\n        {t('common.notAuthenticated')}\n      </UnauthenticatedView>\n      <AuthenticatedView keycloak={keycloak}>\n        {loading && t('common.loading')}\n        {!loading && <ConferenceDetails conference={conference} />}\n      </AuthenticatedView>\n    </ThemeProvider>\n  );\n}\n \n \n Note \n Keycloak object is accessible via props because of  withKeycloak  HOC:\n export default withKeycloak(ConferenceDetailsContainer); \n \n Next Steps \n To apply more fine-grained access controls, see  this tutorial . \n"},{title:"Use Postman with OAuth2 APIs",frontmatter:{sidebarDepth:2,redirectFrom:"/v6.3.2/tutorials/backend-developers/use-postman-with-oauth2.html"},regularPath:"/v6.3.2/tutorials/create/ms/use-postman-with-oauth2.html",relativePath:"v6.3.2/tutorials/create/ms/use-postman-with-oauth2.md",key:"v-ce9e808e",path:"/v6.3.2/tutorials/create/ms/use-postman-with-oauth2.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Create a new Postman Collection",slug:"create-a-new-postman-collection"},{level:2,title:"Define Collection variables",slug:"define-collection-variables"},{level:2,title:"Configure new token generation",slug:"configure-new-token-generation"},{level:2,title:"Update your Keycloak configuration (Postman Web only)",slug:"update-your-keycloak-configuration-postman-web-only"},{level:2,title:"Generate a new token",slug:"generate-a-new-token"},{level:2,title:"Add a request",slug:"add-a-request"},{level:2,title:"Troubleshooting",slug:"troubleshooting"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:" Use Postman with OAuth2 APIs \n Overview \n The tutorial will help you to configure Postman to reach your APIs secured with OAuth2 and Keycloak. \n In this tutorial, we will call an API from an application generated with the  Entando JHipster blueprint . \n Prerequisites \n Get the  Postman  application or create an account to use it on the web.\nThe screenshots in this tutorial have been made with the current web version. \n Create a new Postman Collection \n According to the official website \n \n Postman's collection folders make it easy to keep your API requests and elements organized. \n \n This helps us to gather different requests under the same folder but also to share the configuration and the Auth mode among them. \n Click on the button when you are on the collection left menu. \n \n Name it as you want, we usually try to create a collection per application. \n Define Collection variables \n Postman allows us to define variables for a given collection, and we can use them at the collection level to configure the OAuth2 settings but also at the request level. \n \n Please note you can choose the variable names you want, according to what makes sense to you. \n \n \n \n Variable \n Default value in a Blueprint-based Entando App \n Details \n \n \n \n \n client_id \n web_app \n The client id account used to authenticate the user \n \n \n client_secret \n web_app \n The secret for the client_id \n \n \n scope \n openid profile email \n The scope to retrieve during the auth \n \n \n access_token_url \n http://localhost:9080/auth/realms/jhipster/protocol/openid-connect/token \n The token endpoint \n \n \n auth_url \n http://localhost:9080/auth/realms/jhipster/protocol/openid-connect/auth \n The authorization endpoint \n \n \n base_url \n http://localhost:8081/api \n The url all the requests start with \n \n \n \n Notes: \n \n The base_url variable is added for convenience, but is not mandatory for authentication purposes \n \n \n Use the .well-known endpoint to retrieve these values if you don't have them\n http://keycloak_host:keycloak_host/auth/realms/<realm>/.well-known/openid-configuration \nFor a local running app it should be  http://localhost:9080/auth/realms/jhipster/.well-known/openid-configuration \n \n \n In the Postman application, you may need to save the Collection in order to make the variables available in the following steps. \n Configure new token generation \n In your collection view, click on the  Authorization  tab and define the type to  OAuth 2.0  as-is:\n \n Enter the fields with the variables previously defined. You can define the  Token Name  with the value you want: \n \n Please note, regarding you are using the Postman Web or the app, the  Callback URL  field contains different values.\nBasically, the Web solution needs to use a specific value while the App just need to use a value already\npresent in the Keycloak configuration (e.g.  http://locahost:8081 ) \n This is the reason why we need to update the Keycloak configuration with Postman Web. \n Update your Keycloak configuration (Postman Web only) \n To generate a new token you need to ensure the Postman redirect URL is configured in the Keycloak admin panel. There  https://oauth.pstmn.io/v1/browser-callback  (or a wildcard  * ) should be present in the  Valid Redirect URIs  list for your client.\nThis URL is used to redirect to the Postman app after authentication successfully completes. \n Generate a new token \n Clicking on the  Get New Access Token  will open the Keycloak login form and then you can authenticate with the user to be used when testing the API. The user will need to already be assigned the appropriate roles.\n \n After the authentication succeeds, you should be redirected to the Postman app.\n \n The token is then displayed in a window and you can confirm its use by clicking on the  Use Token  button.\n Add a request \n The next step is to add a request to the collection, using the previous OAuth2 config as an authorization method.\nIn your collection name click on the  Add request  entry\n \n In the  Auth  tab select  Inherit auth from parent . Requests in the collection can then inherit those settings,\nallowing you to execute a configuration step every time you add a new one.\n \n Postman will then automatically add an Authorization header with a Bearer  Token  value where  Token  is the token value generated in the previous step. \n \n Note: \n \n By default, these headers are hidden. A button allows you to display them. \n \n Finally, you can define the endpoint you want to consume, the HTTP method to use and add more headers if needed. \n \n The expected result should be a 2XX code from our API.\nIf you experience a 401 error, this probably means that the token is not valid anymore.\nBecause the token has an expiration period, it's mandatory to refresh it frequently.\nTo get a new token execute the  Generate a new token  section again. \n Troubleshooting \n For security reasons, the access token timeout should always be short to avoid security issues if someone steals the token.\nThe refresh token can be used to acquire a new access token when the access token has expired. The process would be: \n \n Get the Access token (and the Refresh Token) \n Call the API \n Check if the token is still valid\n \n The token is valid: execute the call \n The token has expired: use the refresh token to generate a new Token and execute the call \n \n \n \n Unfortunately, Postman doesn't handle the refresh action if the token has expired, and you need to generate a new one by yourself by clicking on the  Get new access token  button.\nTo avoid this manual action you can make the token longer by updating the timeout over 5 min. However, we do not recommend this solution outside of a local development environment. \n The Postman team is tracking this issue and plans to include this feature in a future release:  https://github.com/postmanlabs/postman-app-support/issues/10112 . \n"},{title:"Use Blueprint Generated Plugin and Micro Frontends Without a Bundle",frontmatter:{redirectFrom:"/v6.3.2/tutorials/ecr/deploy-components-without-bundle.html"},regularPath:"/v6.3.2/tutorials/create/pb/deploy-components-without-bundle.html",relativePath:"v6.3.2/tutorials/create/pb/deploy-components-without-bundle.md",key:"v-0dd48473",path:"/v6.3.2/tutorials/create/pb/deploy-components-without-bundle.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Steps",slug:"steps"},{level:2,title:"1. Generate a docker image for your microservice",slug:"_1-generate-a-docker-image-for-your-microservice"},{level:2,title:"2. Publish the Docker image to Docker registry (DockerHub or equivalent)",slug:"_2-publish-the-docker-image-to-docker-registry-dockerhub-or-equivalent"},{level:2,title:"3. Deploy the plugin into your Entando cluster",slug:"_3-deploy-the-plugin-into-your-entando-cluster"},{level:2,title:"4. Wait for your plugin to be in Running state and link the plugin with the app using an EntandoAppPluginLink custom resource",slug:"_4-wait-for-your-plugin-to-be-in-running-state-and-link-the-plugin-with-the-app-using-an-entandoapppluginlink-custom-resource"},{level:2,title:"5. Upload the micro frontends to your Entando App",slug:"_5-upload-the-micro-frontends-to-your-entando-app"},{level:2,title:"6. Use the microfrontend and microservice",slug:"_6-use-the-microfrontend-and-microservice"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:' Use Blueprint Generated Plugin and Micro Frontends Without a Bundle \n Overview \n In this tutorial you will learn how to use the plugin and microfrontend generated using the Entando Blueprint in a running cluster without the need to include the components in a bundle. \n If you haven\'t already generated a plugin and micro frontends with the Component Generator go here first  Generate a Plugin \n Prerequisites \n \n \n An Entando Plugin built with the Entando Component Generator and populated with micro frontends \n \n \n Node and NPM are installed on your machine (use LTS version) \n \n \n Docker is installed on your machine and you are able to upload images to docker-hub or an image repository of your choice \n \n \n An installed instance of the Entando platform running Kubernetes. See  Getting Started \n Steps \n 1. Generate a docker image for your microservice \n JHipster uses the JIB Maven plugin to generate a docker image for your\nmicroservice. \n The name of the output image generated with JIB will be composed by: \n \n The organization you chose during the setup wizard (by default that\'s set to  entando ) \n The name of the application \n Version  0.0.1-SNAPSHOT \n \n You can build the docker image with this command \n ./mvnw -Pprod clean package jib:dockerBuild\n \n If for example during setup wizard you chose a custom organization  myorg  and the set the application name to  jhipster  the resulting docker image is going to be  myorg/jhipster:0.0.1-SNAPSHOT \n \n Note \n The output image name can be changed in the  pom.xml  file by configuring\nthe  plugins.plugin.jib-maven-plugin.configuration.to.image  tag \n \n  <plugin>\n   <groupId>com.google.cloud.tools</groupId>\n   <artifactId>jib-maven-plugin</artifactId>\n   <configuration>\n     \x3c!-- ... --\x3e\n     <to>\n       <image>\x3c!-- use a custom value here --\x3e</image>\n     </to>\n     \x3c!-- ... --\x3e\n   </configuration>\n </plugin>\n \n \n Note \n Output image name can also be set by customizing the  ./mvnw  command using the  -Djib.to.image \nparameter. For example, if you want to build an image with organization  myneworg , name  myapp  and version  latest  you can do \n \n  ./mvnw -Pprod clean package jib:dockerBuild -Djib.to.image=myneworg/myapp:latest\n \n \n Warning \n If you change the target image of the docker build, remember to update\nthe plugin metadata in the bundle accordingly. \n 2. Publish the Docker image to Docker registry (DockerHub or equivalent) \n Let’s now publish the docker image for the microservice to make it\navailable later during bundle installation in the cluster. \n docker push <name-of-the-image:tag>\n 3. Deploy the plugin into your Entando cluster \n You can now deploy the plugin custom resource generated by the Entando Blueprint in the  bundle/plugins  folder. \n \n Warning \n As stated in step 1, if you changed the target image of your docker build, the plugin custom resource\nin the  bundle/plugins  folder needs to be updated to point to the correct image \n \n From the JHipster project directory: \n cd  bundle/plugins\n\nkubectl create -f  < plugin-file.yaml >  -n entando\n 4. Wait for your plugin to be in  Running  state and link the plugin with the app using an  EntandoAppPluginLink  custom resource \n Once the plugin server deployment is up and running, you can create an  EntandoAppPluginLink custom resource \nto make the plugin API available from the EntandoApp domain. \n Here an example of a EntandoAppPluginLink custom resource. Some assumptions with this custom resource: \n \n The EntandoPlugin generated with the blueprint is  my-demo-plugin \n The EntandoApp exposing the  my-demo-plugin  APIs is  quickstart . This is the app name in an environment built using the Getting Started instructions. \n Both are deployed on the  entando  namespace. \n The link itself is named  quickstart-to-my-demo-plugin-link \n The name of the link yaml is  my-link.yaml \n \n \n Warning \n Remember to change the fields to match your setup. \n \n apiVersion: entando.org/v1\nkind: EntandoAppPluginLink\nmetadata:\n  name: quickstart-to-my-demo-plugin-link\n  namespace: entando\nspec:\n  entandoAppName: quickstart\n  entandoAppNamespace: entando\n  entandoPluginName: my-demo-plugin\n  entandoPluginNamespace: entando\n \n Now add this link to your environment \n kubectl create -f my-link.yaml -n entando\n \n A new link deployer will start and will work behind the scenes to add your plugin  ingressPath  (this is part of the\nplugin  spec ) to the EntandoApp ingress. \n 5. Upload the micro frontends to your Entando App \n Now that the plugin and the app are linked together, you can proceed to generate the Micro Frontend from the App Builder\nand upload the static resources like  js  and  css  files. \n \n From AppBuilder go to  Configuration -> File Browser  and create a new folder inside the  public  folder and make the name of the folder the same as the name of the bundle (the value is in the  code  field available in the  /bundle/descriptor.yaml  file of the blueprint project) or using a custom name, e.g.  demo-widget \n \n \n Warning \n If you choose to use a custom folder, remember to update the references in the customUI of the widget later \n \n \n Upload all the resources available in the  /bundle/resources  folder\nof the blueprint project into the folder you created above in the App Builder file browser. \n \n \n Warning \n You can decide to recreate the folder structure to be the same as the one in  /bundle/resources  or not, but you need to update the\nreferences in the customUI / configUI of the widget later if you choose a different folder structure. \n \n \n \n Create the widget. In the App Builder go to  Components → Micro frontends & Widgets . \n \n \n Select  Add \n \n \n Set whatever title you want \n \n \n For the customUI copy the one created in one of the widgets you generated from the blueprint.\nAs an example, the customUI for the  detailWidget  of the conference entity is available in\n /bundle/ui/widgets/conference/detailsWidget/conference-details-widget.ftl \n \n \n \n Warning \n Remember to update all the references in the customUI to use the custom folder structure you defined \n \n \n Update the service url to match the location where you deployed the ingress for your microservice if you used a path different than the default. For example, \n \n Update the service-url value with the relative path of your service if you\'re deploying a bundle\n\t\tEx. <car-table service-url="/newBp/api"  />\n\tOr use the full path if you\'re deploying the BE and FE individually\n\t\tEx. <car-table service-url="http://newbp-plugin-entando.192.168.64.7.nip.io/newBp/api"/>\n \n \n Note \n Your Entando application includes a keycloak_auth fragment that will inject the token\nand connection to Keycloak that your microfrontends need to invoke protected APIs. You can see this token at  Components → UX Fragments  in the\nApp Builder and search for keycloak_auth. \n \n \n If you\'re creating a new page from scratch or your page is missing the Keycloak fragment you can add it with this freemarker snippet \n \n <@wp.fragment code="keycloak_auth" escapeXml=false />\n 6. Use the microfrontend and microservice \n You can now use your micro frontends and your microservice in your Entando App. \n'},{title:"Export and Publish a Bundle",frontmatter:{sidebarDepth:2,redirectFrom:"/v6.3.2/tutorials/ecr/export-bundle-from-application.html"},regularPath:"/v6.3.2/tutorials/create/pb/export-bundle-from-application.html",relativePath:"v6.3.2/tutorials/create/pb/export-bundle-from-application.md",key:"v-49bccbda",path:"/v6.3.2/tutorials/create/pb/export-bundle-from-application.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:3,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Export an Entando Bundle",slug:"export-an-entando-bundle"},{level:3,title:"Setup the Keycloak client",slug:"setup-the-keycloak-client"},{level:3,title:"Create env.json",slug:"create-env-json"},{level:3,title:"Run the Bundler",slug:"run-the-bundler"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:' Export and Publish a Bundle \n Overview \n Use the Entando bundler command to export a bundle of Entando components from an existing Entando application. An Entando bundle can be used to do the initial install of Entando components into an Entando application, migrate Entando components from one environment to another (e.g. Dev to QA), to provide a template for building a new Entando application, or as the skeleton of an Entando solution. The output of this command is the same bundle directory structure created by an Entando project including a bundle descriptor file. \n Prerequisites \n \n Use the  Entando CLI  to verify you have the prerequisites in place for this tutorial (e.g. git, entando-bundler). \n \n ent check-env develop \n \n \n You\'ll also need a running Entando application. \n You\'ll need admin access to Keycloak or admin access to Kubernetes to set it up. \n \n The tutorial assumes you\'re using an Entando quickstart application. You may need to adjust the specific URLs, credentials, namespaces, etc. for a custom application. \n Export an Entando Bundle \n Setup the Keycloak client \n You\'ll need to setup a Keycloak client with the appropriate permissions for the bundler to access all of the necessary Entando APIs. \n \n Find the secret for the Keycloak admin account. If you already have the admin credentials, then you can skip to step 3. \n \n kubectl get secrets -n entando \n \n In a quickstart application, the secret is named  quickstart-kc-admin-secret \n \n Determine the admin password using the secret name. \n \n kubectl get secret quickstart-kc-admin-secret -n entando -o go-template = "{{println}}Username: {{.data.username | base64decode}}{{println}}Password: {{.data.password | base64decode}}{{println}}{{println}}" \n \n Example output: \n Username: entando_keycloak_admin\nPassword: 1pTZev82Ee\n \n \n Login to Keycloak using the admin credentials. The URL will be something like   http://<YOUR-DOMAIN-OR-IP>/auth . You can use this command to verify the URL. \n \n kubectl describe ingress/quickstart-kc-ingress\n \n \n Go to  Clients  →  Create \n Enter a  Client ID  of your choice, e.g.  entando-bundler , and click  Save . \n The  Settings  tab should be shown. Edit the following values: \n \n \n Access Type:  confidential \n Service Accounts Enabled:  On \n Valid Redirect URLs:  * \n Web Origins:  * \n \n \n Click  Save \n Go to the  Service Account Roles  tab \n Select  Client Roles  →  quickstart-server \n Select  Available Roles  →  superuser . \n Click  Add Selected  to add  superuser  to the  Assigned Roles . This change will be saved automatically. \n Go to the  Credentials  tab and copy the  Secret  shown there. You\'ll need this in the next section. \n Create env.json \n \n Create a directory where you\'ll run the bundler and change to that directory. \n \n mkdir  testBundle ;   cd  testBundle\n \n \n Create an  env.json  file with the environment URLs and client credentials. The  clientId  and  clientSecret  are from steps 5 and 12 above. \n \n { \n    "coreBaseApi" :   "http://<YOUR-DOMAIN-OR-IP>/entando-de-app" , \n    "k8ssvcApi" :   "http://<YOUR-DOMAIN-OR-IP>/k8s" , \n    "clientId" :   "<YOUR-CLIENT-ID>" , \n    "clientSecret" :   "<YOUR-CLIENT-SECRET>" \n } \n Run the Bundler \n \n Create a child directory to hold the bundler output. Using the name  bundle  allows you to easily use the  ent prj  command with this bundle. \n \n mkdir  bundle\n \n \n Run the bundler command with your preferred settings. \n \n ent bundler from-env --location bundle --code my-test-bundle --description “My Test Bundle”\n \n The bundler will inspect the application using the Entando APIs, collect information about the individual components, construct the appropriate descriptor files, and finally assemble the top-level descriptor file. \n $ ls bundle\nassets      contentModels  contents         fragments  labels     pageModels  resources\ncategories  contentTypes   descriptor.yaml  groups     languages  pages       widgets\n \n At this point you have a full Entando project structure. You can inspect the output to edit the exported components or you could  deploy it to another Entando application . \n'},{title:"Add a GitHub Actions CI Workflow",frontmatter:{sidebarDepth:2},regularPath:"/v6.3.2/tutorials/create/pb/github-actions-workflow.html",relativePath:"v6.3.2/tutorials/create/pb/github-actions-workflow.md",key:"v-9c20f87e",path:"/v6.3.2/tutorials/create/pb/github-actions-workflow.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Create a Backend Workflow",slug:"create-a-backend-workflow"},{level:2,title:"Add a Frontend Job",slug:"add-a-frontend-job"},{level:2,title:"Extend the Frontend Job for Multiple MFEs",slug:"extend-the-frontend-job-for-multiple-mfes"}],lastUpdated:"1/31/2022, 11:26:30 AM",lastUpdatedTimestamp:164364639e4,content:" Add a GitHub Actions CI Workflow \n Overview \n This tutorial shows how to use the JHipster  ci-cd  sub-generator to quickly create a basic GitHub Actions Workflow for the microservices and micro frontends (MFEs) generated by the Entando Component Generator. \n Prerequisites \n \n An existing project with a GitHub repository. See the  Entando Component Generator  to create a new one. \n GitHub Actions . These are enabled by default without additional configuration. Please note public repositories currently qualify for unlimited usage but private repositories can encounter usage restrictions. \n Use the  Entando CLI  to verify you have the command line prerequisites in place for this tutorial (e.g. npm, git, JHipster). \n Create a Backend Workflow \n \n Go to your main project folder in the shell \n Run the JHipster  ci-cd  subgenerator \n \n ent jhipster ci-cd\n \n \n Select  GitHub Actions \n Click ENTER to choose no  tasks/integrations  and generate the default workflow \n The initial workflow file is available at  .github/workflows/github-ci.yml \n Commit the workflow file and push it to GitHub. \n \n git   add  .github\n git  commit -m  \"Add the backend CI job\" \n git  push\n \n \n Since the workflow runs on  push  or  pull-request , you can immediately check the GitHub  Repository → Actions  tab to see the status of the corresponding jobs. The standard tests in a Blueprint-generated project can take a few minutes to run. \n \n \n You can review the logs for each step to diagnose CI failures. \n If the workflow fails or times out, you should receive an email notification. \n You can choose to skip the CI workflow by including  skip ci  or  ci skip  in your commit message. This can be customized in the job definition. \n See the  GitHub Actions  documentation for more information on alternative trigger options. \n \n Next, let's expand the workflow to also include the micro frontends. \n Add a Frontend Job \n We'll now add a second job to the workflow definition, specifically for the micro frontends. Optionally, you could also create a completely separate workflow file if you'd prefer. \n \n Add a new entry under  jobs: , paying attention to the YAML indentation. \n \n      micro-frontends : \n      name :  micro frontend job\n      runs-on :  ubuntu - latest\n      if :   \"!contains(github.event.head_commit.message, '[ci skip]') && !contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.pull_request.title, '[skip ci]') && !contains(github.event.pull_request.title, '[ci skip]')\" \n      steps : \n        -   uses :  actions/checkout@v2\n        -   uses :  actions/setup - node@v2.1.4\n          with : \n            node-version :   '14.15.0' \n        -   name :  Run tests\n          run :   | \n           cd ui/widgets/conference/detailsWidget\n           npm install\n           npm test \n \n \n (Optional) If your widget path differs from the standard Blueprint example, you should change the first command in  Run tests  to match your path. \n Commit and push the changes to GitHub. \n \n    git add .github\n   git commit -m \"Add the microfrontend CI job\"\n   git push\n \n \n Now check the GitHub  Repository → Actions  tab to see the status of the jobs. When the  micro-frontends  job is complete, you should see something like this: \n \n Test Suites: 2 passed, 2 total\nTests:       4 passed, 4 total\nSnapshots:   0 total\nTime:        2.911s\nRan all test suites.\n Extend the Frontend Job for Multiple MFEs \n You may have multiple micro frontends or widgets in your project. One option is to duplicate the job for each MFE, but you can also use the GitHub Actions matrix feature to avoid duplicating those definitions. \n \n Change your job definition to the following. Note the changes: \n \n \n The  job.name  is dynamically set using the MFE matrix name \n The  job.strategy  has been set to  fail-fast:false  so all MFEs will be tested, rather than stopping the job on the first failure \n The  job.strategy.matrix.mfe  provides the list of MFEs in this project. You should update this list to match your project. \n The first command in  Run tests  is parametrized to use the MFE matrix name \n \n      micro-frontends : \n      name :  $ { {  matrix.mfe  } }  micro frontend\n      runs-on :  ubuntu - latest\n      if :   \"!contains(github.event.head_commit.message, '[ci skip]') && !contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.pull_request.title, '[skip ci]') && !contains(github.event.pull_request.title, '[ci skip]')\" \n      strategy : \n        fail-fast :   false \n        matrix : \n          mfe : \n            -  ui/widgets/conference/detailsWidget\n            -  ui/widgets/conference/formWidget\n            -  ui/widgets/conference/tableWidget\n      steps : \n        -   uses :  actions/checkout@v2\n        -   uses :  actions/setup - node@v2.1.4\n          with : \n            node-version :   '14.15.0' \n        -   name :  Run tests\n          run :   | \n           cd ${{ matrix.mfe }}\n           npm install\n           npm run test \n \n \n Now check the GitHub  Repository → Actions  tab to see the status of the jobs. You should see that the tests were run for all configured MFEs with a summary message like this:  3 jobs completed . \n \n"},{title:"Build and Publish a Project Bundle",frontmatter:{sidebarDepth:2,redirectFrom:"/v6.3.2/tutorials/ecr/publish-project-bundle.html"},regularPath:"/v6.3.2/tutorials/create/pb/publish-project-bundle.html",relativePath:"v6.3.2/tutorials/create/pb/publish-project-bundle.md",key:"v-ca832c1a",path:"/v6.3.2/tutorials/create/pb/publish-project-bundle.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"CLI Steps",slug:"cli-steps"},{level:2,title:"Manual Steps",slug:"manual-steps"},{level:3,title:"Build Docker Image for Microservices",slug:"build-docker-image-for-microservices"},{level:3,title:"Build your bundle and publish to git",slug:"build-your-bundle-and-publish-to-git"},{level:2,title:"Install the bundle into an application",slug:"install-the-bundle-into-an-application"},{level:2,title:"Use the Entando CLI",slug:"use-the-entando-cli"},{level:2,title:"Use the App Builder",slug:"use-the-app-builder"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:' Build and Publish a Project Bundle \n Overview \n This tutorial shows you how to take an existing Entando project directory and deploy it to the Entando Component Repository. This involves building a Docker image from your microservice, creating your Entando bundle, checking your Bundle artifacts into git, and deploying the Entando bundle into Kubernetes. \n The Entando CLI automates many of the tasks involved in deploying an Entando bundle but you can also choose to perform the tasks manually. \n Prerequisites \n \n Use the  Entando CLI  to verify you have the prerequisites in place for this tutorial (e.g. Java, npm, git). \n \n ent check-env develop\n \n \n You will also need your git credentials, a git repository, and an Entando instance. \n You will also need an Entando project directory, either  developed by hand  or  generated by the Entando Component Generator . \n CLI Steps \n The following steps make use of the Entando  ent prj  command and its publication system (pbs) convenience methods. See the  Manual Steps  section below for a more detailed description of the underlying tasks. \n \n Build the project using the  ent prj  command. This saves you from having to build each part of the project individually. If you are using a project directory with just a bundle child directory (e.g. for a bundle exported from an environment or with hand-built components) then you should skip this step since there\'s nothing to build. \n \n ent prj build\n \n TIP \n The first run can take longer due to node downloads for any MFE widgets. For later runs you can use  ent prj fe-build  or  ent prj be-build  to independently build just the frontend or backend components. \n \n \n Initialize the bundle directory \n \n ent prj pbs-init\n \n \n Publish the build artifacts to github and Docker Hub. \n \n ent prj pbs-publish\n \n \n Deploy the bundle into the Entando Component Repository. \n \n ent prj deploy\n \n \n Jump to the section below to finish installing your bundle:  Install the bundle into your application \n Manual Steps \n Build Docker Image for Microservices \n \n Build the project from the project directory \n \n ./mvnw -Pprod clean package jib:dockerBuild\n \n \n Note \n By default the organization used to generate the docker image is  entando , but you can provide a custom value during project initialization, as well as by changing the  pom.xml  file or by providing the  -Djib.to.image=<org>/<name>:<version>  to the  jib:dockerBuild  command. \n \n \n Note \n Output image name is generated using the organization value defined during project initialization. You can override the provided values by altering the  pom.xml  file or by customizing the  -Djib.to.image  parameter used in the  ./mvnw  command \n \n \n Warning \n If you manually override the target image of the docker build, remember to update the plugin metadata in the bundle accordingly in the bundle steps. \n \n \n View your image and tag \n \n docker  images\n \n Output: \n REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE\nmyusername/example-app   0.0.1-SNAPSHOT      4ec7f05b2b27        33 seconds ago      213MB\n \n \n Publish the Docker image to Docker repository (Docker Hub or equivalent). You may need to first login via  docker login . \n \n docker  push  < name-of-the-image:tag > \n \n For example:  docker push myusername/example-app:0.0.1-SNAPSHOT \n \n Note \n The first time your run this command it will have to push all of the layers. Subsequent runs will be much faster \n \n Output: \n  docker push myusername/example-app:0.0.1-SNAPSHOT\nThe push refers to repository [docker.io/myusername/example-app]\n545361404af4: Pushed\n...\nf1b5933fe4b5: Pushed\n0.0.1-SNAPSHOT: digest: sha256:804b3b91b83094c45020b4748b344f7199e3a0b027f4f6f54109cbb3b8a1f867 size: 2626\n Build your bundle and publish to git \n \n Populate the bundle with the generated micro frontends using  ./buildBundle.sh  or  npm run populate-bundle . \n \n ./buildBundle.sh\n \n \n Important \nThe bundle population with the micro frontends requires some time to be processed. You should be able to follow the progress of the operation on the console. \n \n \n \n The output of your bundle will be in the top level  bundle  directory in your microservice \n \n \n Commit your bundle files to git, separate from the top-level project files. \n \n \n echo  bundle  >>  .gitignore\n cd  bundle/\n git  init\n git   add   . \n git  commit -m  "Init Git repository" \n \n \n \n Create a new git repository and name it  my-bundle  (or a name of your choice). \n \n \n Add your remote repository as origin and push the bundle. \n \n \n git  remote  add  origin https://your/remote/repository.git\n git  push -u origin master\n \n \n Publish a git tag using the following commands. \n \n git tag -a "v0.0.1" -m "My first tag"\ngit push --tags\n \n \n Install the  entando-bundler \n \n npm   install  -g @entando/entando-bundler@6.3.2\n \n \n Generate a custom resource for your bundle. You should provide your own bundle name, namespace, and repository URL. \n \n entando-bundler from-git --name = < bundle-name >  --namespace = entando --repository = < your-repository-url >  --dry-run  >  example-bundle.yaml\n \n \n Make your bundle available in Kubernetes \n \n kubectl apply -f example-bundle.yaml -n entando\n Install the bundle into an application \n You can either install the bundle through the ENT CLI or the  App Builder . \n Use the Entando CLI \n \n In your project folder run the following command \n \n ent prj  install \n \n \n If you already installed the bundle, you can use  --conflict-strategy  to adopt a strategy for existing components (CREATE, SKIP, OVERRIDE) \n \n ent prj  install  --conflict-strategy = OVERRIDE\n Use the App Builder \n \n \n Log into the  App Builder \n \n \n Select  Component Repository  in the upper right \n \n \n Find your bundle and select  Install \n \n \n At this point the Entando platform will download and install the Docker image for your microservice and install the micro frontends into the Entando application. You can add those micro frontend widgets to the page(s) of your choice. \n You can use an Entando provided page or follow  this tutorial  to create your own page and/or page template. Please note that an application based on the Entando blueprint expects a user to be authenticated so you\'ll need to include the  keycloak_auth  UX fragment in your page template. \n'},{title:"Build and Publish a Simple Bundle",frontmatter:{sidebarDepth:2,redirectFrom:"/v6.3.2/tutorials/ecr/publish-simple-bundle.html"},regularPath:"/v6.3.2/tutorials/create/pb/publish-simple-bundle.html",relativePath:"v6.3.2/tutorials/create/pb/publish-simple-bundle.md",key:"v-b440bc16",path:"/v6.3.2/tutorials/create/pb/publish-simple-bundle.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Create the project structure",slug:"create-the-project-structure"},{level:2,title:"Add a simple widget",slug:"add-a-simple-widget"},{level:2,title:"Create the bundle descriptor",slug:"create-the-bundle-descriptor"},{level:2,title:"Publish the bundle",slug:"publish-the-bundle"},{level:3,title:"CLI steps",slug:"cli-steps"},{level:3,title:"Manual steps",slug:"manual-steps"},{level:2,title:"Install the bundle into an application",slug:"install-the-bundle-into-an-application"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:' Build and Publish a Simple Bundle \n Overview \n In this tutorial you will learn how to create a simple Entando bundle and deploy it into the Entando Component Repository. This involves manually defining a bundle with a single widget, checking the bundle artifacts into Git, applying the Entando bundle custom resource to Kubernetes, and then installing the bundle into an application. \n Prerequisites \n \n Use the  Entando CLI  to verify all dependencies for this tutorial are installed (e.g. Java, npm, Git). \n \n ent check-env develop\n \n \n Authenticated Git credentials, an empty Git repository and an available Entando instance are required for the commands below to execute without errors. \n \n Publishing a bundle can be simplified by using the  ent prj  command and its publication system (pbs) convenience methods. Both the CLI and manual commands are provided. \n Create the project structure \n First create a parent project directory (e.g.  example-bundle ) along with a child bundle directory. In a project generated by the Entando Component Generator the microservice and micro frontend source files live under the parent directory. \n mkdir  -p example-bundle/bundle ;   cd  example-bundle/bundle\n Add a simple widget \n Create a widget directory \n mkdir  widgets\n \n Create a widget descriptor file within that directory \n touch  widgets/example-widget.yaml\n \n Populate the widget descriptor file  example-widget.yaml  with a simple definition. Make sure to retain the correct YAML indentation of 2 or 4 spaces. \n code :  example - widget\n titles : \n    en :  Example Widget\n    it :  Widget d\'esempio\n group :  free\n customUi :  <h2 > Hi from Example Widget</h2 > \n Create the bundle descriptor \n The main file processed by the Entando Component Repository is  descriptor.yaml , which describes all of the components within the bundle. The name of the bundle descriptor file must be  descriptor.yaml  and it must be stored in the child bundle directory (e.g.  example-bundle/bundle ). \n touch  descriptor.yaml\n \n Populate the bundle descriptor file with the following YAML definition \n code :  example - bundle\n description :  This is an example of an Entando bundle\n components : \n   widgets : \n     -  widgets/example - widget.yaml\n \n Component descriptor file names and locations (e.g.  widgets/example-widget.yaml ) are arbitrary since the bundle descriptor explicitly points to those files. Convention is to group components by type with all widgets in one directory, all page templates in another, etc. \n Publish the bundle \n The bundle can be published using the CLI or the steps can be performed manually. \n CLI steps \n \n Change to the project directory if needed \n \n cd  example-bundle\n \n \n Initialize the Entando project and accept the defaults \n \n ent prj init\n \n \n Initialize the publication system. This step requires the empty Git repository URL (ending in .git) and your Git credentials. \n \n ent prj pbs-init\n \n \n Publish the bundle to Git. By convention the first version is assigned the tag  v0.0.1  but the prefix "v" is optional. \n \n ent prj pbs-publish\n \n Running just the command  ent prj pbs-publish  will quickly push subsequent iterations of the bundle to Git. You will be asked to input the bundle version each time. To ensure that iterations are listed in the correct order you must be consistent with versioning format and alphanumeric precedence. \n \n The bundle can now be deployed into the Entando Component Repository with one command \n \n ent prj deploy\n \n The  prj deploy  command uses the Git repository URL and project name (e.g.  example-bundle ) to create the custom resource. \n \n Jump to  Install the bundle into an application  to finish installing your bundle. \n Manual steps \n \n Change to the bundle directory if needed \n \n cd  example-bundle/bundle\n \n \n Run the following commands to initialize Git and commit the files \n \n git  init\n git   add   . \n git  commit -m  "Init Git repository" \n \n \n Add your remote repository as origin and push the bundle \n \n git  remote  add  origin https://your/remote/repository.git\n git  push -u origin master\n \n \n Publish a Git tag \n \n git  tag -a  "v0.0.1"  -m  "My first tag" \n git  push --tags\n \n \n Now that you\'ve published your bundle to Git you can create the Kubernetes custom resource for it. \n \n Install the bundler if you haven\'t previously done so \n npm   install  -g  @entando/entando-bundler@6.3.2\n \n To generate the custom resource for your bundle run the  entando-bundler from-git  command, then provide your remote Git repository URL via the  --repository  option and the correct namespace via  --namespace . You can also provide a thumbnail for your bundle with  --thumbnail-file  or  --thumbnail-url . \n entando-bundler from-git --name = example-bundle --namespace = entando --repository = https://your/remote/repository.git --dry-run  >  example-bundle.yaml\n \n Now you can apply this definition to Kubernetes. You may need to first transfer the file to your VM (e.g using  multipass transfer ). \n kubectl -n entando apply -f example-bundle.yaml\n \n You can confirm the presence of your custom resource with the command  kubectl get EntandoDeBundle -n entando . \n Install the bundle into an application \n Your bundle should appear in  App Builder  →  Component Repository  in your Entando instance. Clicking  Install  should allow version selection if your bundle has multiple iterations. \n The Entando platform will then download and install the components contained in the bundle. Once complete you should see the  Install  button change to give you the option to  Uninstall  that specific version. If you navigate to  Components  →  Micro Frontends & Widgets  you should find your custom widget within the  User  section. \n'},{title:"Install Bundles from a Private Git Repository",frontmatter:{redirectFrom:"/v6.3.2/tutorials/ecr/ecr-private-git-repo.html"},regularPath:"/v6.3.2/tutorials/curate/ecr-private-git-repo.html",relativePath:"v6.3.2/tutorials/curate/ecr-private-git-repo.md",key:"v-6cfa5998",path:"/v6.3.2/tutorials/curate/ecr-private-git-repo.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Using SSH keys with Git",slug:"using-ssh-keys-with-git"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:' Install Bundles from a Private Git Repository \n Overview \n The standard deployment of the Entando Component Repository (ECR) assumes that bundles are checked out from public Git repositories. Public repositories do not require user authentication, but if a customer chooses to limit repository access to specific Git accounts, a private key is required. This document details how to allow the ECR to access a private Git repository. \n For more background information please consult \n \n Entando custom resource reference \n Entando Component Repository overview \n Using SSH keys with Git \n Entando supports connecting to Git repositories with SSH keys. While SSH Git URLs are accepted, HTTPS git URLs are not. For the private key to work correctly, the SSH syntax of  git@github.com:THE-REPO-OWNER-NAME/THE-REPO-NAME.git  must be used (the HTTPS syntax of  https://github.com/THE-REPO-OWNER-NAME/THE-REPO-NAME.git  is not permitted). \n Using the SSH method a developer can generate a public/private keypair, then register the public key with the Git server while securely storing the private key locally. An operation requiring authentication will trigger the Git command line utility to perform a search and compare between the local private key and the public key provided by the server. If the two keys are identical, the operation is allowed to complete. \n Entando allows a Kubernetes Secret containing a Git SSH private key to be mounted in the container hosting the Entando Component Manager service. This container is deployed with the EntandoApp and can be configured from the EntandoApp Custom Resource. To prepare a Secret, first generate the keypair locally using a Docker image, then create the Secret from the directory where the keypair was generated. \n Tutorial \n Below is the recommended flow on Linux. \n \n \n Navigate to a local folder where you intend to create the Secret \n \n \n Generate the SSH keypair from the known SSH client Docker image \n \n \n Run the Docker container in interactive mode and mount the default user SSH directory to a local directory \n docker run -it -v $PWD/entando_ssh:/root/.ssh kroniak/ssh-client /bin/bash \n \n \n \n Generate the keypair from the shell of the resulting container \n ssh-keygen\n \n Select all of the default options, e.g. no passphrase, etc. \n \n \n Attempt to add the fingerprint to the known_hosts file by connecting to your Git server and responding "yes" to the prompt \n ssh git@github.com\n \n This command is expected to fail. \n \n \n Run  exit \n \n \n \n \n Create the Secret. \n \n \n You are now back in the local operating system\'s shell and can navigate to the directory that was mounted using Docker. \n To give yourself access to this folder and create a Secret with the content\n\n1. Change the folder permissions\n\n    ```\n    sudo chmod ag+r entando_ssh -R\n    ```\n    \n2. Create a Secret from the directory\n\n    ```\n    kubectl create secret generic my-git-secret --from-file=entando_ssh -n <<your-namespace>>\n    ```\n    \n3. Confirm that the Secret exists and has at least two keys: known_hosts, and id_rsa. Without these two keys Entando cannot log into Git.\n    \n    ```\n    kubectl get secret my-git-secret -n <<your-namespace>> -o yaml\n    ```\n \n \n \n Link the resulting private key to the account of a user who has access to the applicable Git repositories. Ideally\nthis should be a dedicated service account user with restricted read only access. For GitHub\naccounts, you can follow the  official GitHub instructions. \nWhen prompted, provide the public key that was generated in the entando_ssh directory\n entando_ssh/id_rsa.pub \n \n \n Modify the EntandoApp resource you are deploying to mount the Secret in the  spec.ecrGitSshSecretName  property. Note: In Entando 6.3.2 the EntandoApp resource must be configured prior to installation. \n \n \n       kind: "EntandoApp"\n      metadata:\n        annotations: {}\n        labels: {}\n        name: "quickstart"\n      spec:\n        dbms: none\n        replicas: 1\n        ecrGitSshSecretName: my-git-secret\n        standardServerImage: wildfly\n        ingressPath: /entando-de-app\n        ingressHostName: ampie.apps.serv.run\n        environmentVariables:\n          - name: SPRING_PROFILES_ACTIVE\n            value: "default,swagger"\n \n '},{title:"Adding a new API to the core app",frontmatter:{redirectFrom:"/v6.3.2/tutorials/customize-the-platform/add-rest-api.html"},regularPath:"/v6.3.2/tutorials/devops/add-rest-api.html",relativePath:"v6.3.2/tutorials/devops/add-rest-api.md",key:"v-67bc2474",path:"/v6.3.2/tutorials/devops/add-rest-api.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:" Adding a new API to the core app \n Prerequisites \n \n \n Java 11 \n \n \n maven \n Overview \n This guide will take you through adding a new REST API to the Entando\ncore app. In some cases it is better to add new APIs to the core rather\nthan creating a new microservice. Some example cases where adding new\nAPIs to the core is recommended are: \n \n \n When extending or adding functionality to the WCMS \n \n \n When you have a simple use case requiring persistence that is\nspecific to only the application you’re working within \n \n \n When exposing configurations that are needed by the portal-ui during\npage rendering \n \n \n For small changes that don’t warrant a full stand-alone microservice \n \n \n You can build widgets and micro frontends that take advantage of these\nAPIs in the same way that your micro-frontends can invoke APIs exposed\nby other services. \n Tutorial \n Creating a controller and services \n \n \n Create a new java package in the project using your favorite IDE at\nthe path  org.entando.training . \n \n \n Under that package add packages for  controllers  and  services . \n \n \n Create a class called  DemoController.java  from the\ntraining package into the controllers package. \n \n This is a normal Spring rest controller and it will be\ndiscovered by annotations. \n \n \n \n Copy  DemoService.java  from the\ntraining package into the services package. \n \n This is a normal Spring service that will be autowired into the\ncontroller. The data in this service is hardcoded but this is\nwhere you can wire in external services or other parts of the\nEntando architecture to fetch the data. \n \n \n \n Copy  commonConfig.xml  to\n src/main/resources/spring/aps/managers . \n \n \n The goal is to enable package scanning for annotation driven\nspring services. This includes the package scan for your package\ndefined above. If you want to scan another package, then you\nneed to add another path to this file. This is the only spring\nXML you will need to change if you want to build annotation\ndriven beans in Entando. \n \n \n See also web.xml for deeper details. \n \n \n \n \n Review the code and annotations in the controller to understand how\nthe APIs are protected and integrated. \n \n \n @RestAccessControl  is a custom Entando annotation that can be used\nto restrict APIs by role. \n \n The rest of the annotations are normal Spring annotations. \n \n \n \n Restart your app using jetty. \n \n \n if you get an error add the entries below to\n src/main/conf/systemParams.properties  This is temporary \nParameters for Argon2 algorithm encryption\nalgo.argon2.type=ARGON2i\nalgo.argon2.hash.length=32\nalgo.argon2.salt.length=16\nalgo.argon2.iterations=4\nalgo.argon2.memory=65536\nalgo.argon2.parallelism=4\nalgo.default.key=changeit\n \n \n \n \n \n Go to Swagger \n \n \n Find the demo-controller and try your new endpoints out using\nswagger \n \n \n"},{title:"Install Bundle Plugins from a Private Image Repository",frontmatter:{redirectFrom:"/v6.3.2/tutorials/ecr/ecr-private-images.html"},regularPath:"/v6.3.2/tutorials/curate/ecr-private-images.html",relativePath:"v6.3.2/tutorials/curate/ecr-private-images.md",key:"v-f04502fc",path:"/v6.3.2/tutorials/curate/ecr-private-images.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Tutorial",slug:"tutorial"},{level:2,title:"Troubleshooting",slug:"troubleshooting"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:" Install Bundle Plugins from a Private Image Repository \n Overview \n The standard deployment of the Entando Component Repository assumes that plugin images are pulled from public repositories. Public repositores do not require user authentication in order to pull an image. The following tutorial will show you how to add secrets to your Kubernetes environment so you can successfully pull images from private repositories. \n Prerequisites \n \n A running Entando application \n A bundle containing a microservice plugin based on an image from a private repository. You can set this up by  creating a microservice bundle  and making the corresponding Docker Hub repository private. \n Tutorial \n The first step demontrates how to create a secret for Docker Hub but please see the  corresponding Kubernetes documentation  for other options. Once you have the created the secret you can either apply it to a deployed Entando application or add it to the Helm template for a new deployment. \n 1. Create the secret \nSupply the following parameters: \n \n the name of the new secret, e.g.  my-docker-secret . \n the URL to your registry server. For Docker Hub this is currently  https://index.docker.io/v1/ \n your Docker Hub username, password, and email. \n the Entando namespace, e.g.  entando  for a quickstart environment. \n \n kubectl create secret docker-registry  < your-secret-name >  --docker-server = < your-registry-server >  --docker-username = < your-name >  --docker-password = < your-pword >  --docker-email = < your-email >  -n entando\n \n 2a. Update a deployed Entando application \n If you're updating a deployed Entando application(for example a quickstart environment), you can add the new secret to the  entando-plugin  account. You'll need to supply your own namespace. \n kubectl edit serviceaccount entando-plugin -n entando\n \n Add the secret to the serviceaccount. You can either add a new section if it's the first secret or add another secret to the list. \n apiVersion :  v1\n imagePullSecrets : \n   -   name :  your - secret - name\n kind :  ServiceAccount\n metadata : \n   name :  entando - plugin\n \n If you describe the serviceaccount, it should list the secret. \n kubectl describe serviceaccount entando-plugin -n entando\n \n Output: \n Name :                 entando - plugin\n Namespace :            entando\n Image pull secrets :   your - secret - name\n \n If  (not found)  is listed next to the secret name, then you may have added the secret to the wrong namespace. \n 2b. Deploy a new Entando application \n If you're setting up a new Entando deployment by using an Entando Helm template (e.g. from the entando-helm-quickstart project), you can add the secret to the  values.yaml  file under the property  operator.imagePullSecrets . This is just a list containing the names of Docker secrets in the operator's namespace. \n <snip > \n operator.imagePullSecrets :   [ your - secret - name ] \n<snip > \n \n You can now generate the deployment yaml and deploy it to Kubernetes as usual. \n 3. Install the Entando Bundle \n You can now install the Entando Bundle from the  Entando App Builder  →  Entando Component Repository . The microservice plugin should now be able to successfully pull the image. \n Troubleshooting \n This is the kind of error you'll see from  kubectl get pods  if a plugin is based on an image from a private repository and if there are any issues with the image URL or credentials, including a missing or incorrect secret. \n NAME                                                            READY   STATUS         \nMYUSERNAME-MYPLUGIN-0-0-2-server-deployment-657688c5x8tfb        1 /2     ErrImagePull\n \n "},{title:"Backing Up and Restoring Keycloak",frontmatter:{sidebarDepth:2},regularPath:"/v6.3.2/tutorials/devops/backing-restoring-keycloak.html",relativePath:"v6.3.2/tutorials/devops/backing-restoring-keycloak.md",key:"v-0d653d78",path:"/v6.3.2/tutorials/devops/backing-restoring-keycloak.html",headers:[{level:2,title:"Prerequisites:",slug:"prerequisites"},{level:2,title:"Create a Backup of Keycloak Realm",slug:"create-a-backup-of-keycloak-realm"},{level:2,title:"Import the Keycloak Realm",slug:"import-the-keycloak-realm"}],lastUpdated:"2/25/2022, 3:26:59 PM",lastUpdatedTimestamp:1645820819e3,content:" Backing Up and Restoring Keycloak \n This tutorial describes how to backup an active Entando Identity Management Keycloak instance and restore it in another environment. \n Prerequisites: \n A Keycloak instance running on Entando with a database management system (DBMS) in the backend. This procedure will not work with an embedded database. \n Create a Backup of Keycloak Realm \n \n \n From the command line, get the pod name of the Keycloak server you wish to backup. In a quickstart environment, the pod name will begin with  quickstart-kc-server-deployment . \n \n \n Use kubectl to start a bash shell in the pod: \n \n \n  kubectl exec -it your-keycloak-pod-name -- /bin/bash\n \n \n Create a new directory in /tmp with: \n \n mkdir -p /tmp/export \n \n \n Run the following script to retrieve the data for the entando realm and save it to a JSON file in the  export  directory. A new Keycloak server will run on a different port (offset=200) to avoid conflicts with the original Entando Keycloak instance. \n \n /opt/jboss/keycloak/bin/standalone.sh\n-Djboss.socket.binding.port-offset=200\n-Dkeycloak.migration.action=export \n-Dkeycloak.migration.provider=singleFile \n-Dkeycloak.migration.realmName=entando\n-Dkeycloak.migration.usersExportStrategy=DIFFERENT_FILES \n-Dkeycloak.migration.file=/tmp/export/entando-prod-realm.json\n \n \n If there are no errors, press Ctrl+C to stop the process. \n Type  exit  to close the bash shell in the pod. \n Execute this command to copy the realm data file to the proper location: \n \n kubectl cp [keycloak-pod-name]:/tmp/export/ keycloak-backup\n Import the Keycloak Realm \n \n \n Login to the new Entando Keycloak server where the realm is to be restored. \n \n \n From the left sidebar, go to  Import . \n \n \n Click  Select file  button and  upload  the JSON file from the  keycloak-backup  directory. You will see the following page: \n \n \n \n \n You have now successfully imported the Keycloak realm to a new environment. \n \n Note \n If you are using a different environment, with a different hostname, you should import only users or set the flag for  If a resource exists  to  Skip . \n \n"},{title:"Building a Docker Image for the Entando Core",frontmatter:{redirectFrom:"/next/tutorials/customize-the-platform/app-engine/build-core-image.html"},regularPath:"/v6.3.2/tutorials/devops/build-core-image.html",relativePath:"v6.3.2/tutorials/devops/build-core-image.md",key:"v-4eda8cf6",path:"/v6.3.2/tutorials/devops/build-core-image.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Introduction",slug:"introduction"},{level:2,title:"Setup",slug:"setup"}],lastUpdated:"12/15/2021, 2:22:26 PM",lastUpdatedTimestamp:1639596146e3,content:" Building a Docker Image for the Entando Core \n Prerequisites \n \n \n Java 11 \n \n \n Docker installed locally\n( https://docs.docker.com/docker-for-windows/install/ ) \n \n \n maven \n \n \n Access to a docker repository (docker.io or other) \n Introduction \n This tutorial will take you through the basic steps to create a docker\nimage from an Entando core application. A more detailed guide with\nadditional commands and configuration can be found here: \n https://github.com/entando/entando-de-app \n Setup \n \n \n Clone the application at:\n https://github.com/entando/entando-de-app  using \n git clone https://github.com/entando/entando-de-app\n \n \n \n On a command line, cd into the entando-de-app you just cloned: \n cd entando-de-app\n \n \n \n Build a docker image from the core app replacing the value of the tag in the  -t   with the tag you want to use for your image. \n mvn clean package\ndocker build . -f Dockerfile.wildfly -t <YOUR-USER>/<YOUR-REPO-NAME>:<YOUR-VERSION>\n \n \n \n Create a repository on your docker repository to house your new\napplication \n \n \n Push the Image to your Repository \n docker push <YOUR-USER>/<YOUR-REPO-NAME>:<YOUR-VERSION>\n \n \n \n"},{title:"Caching and Clustering",frontmatter:{redirectFrom:"/v6.3.2/tutorials/devops/clustering-caching/caching-and-clustering.html"},regularPath:"/v6.3.2/tutorials/devops/caching-and-clustering.html",relativePath:"v6.3.2/tutorials/devops/caching-and-clustering.md",key:"v-62cf23f6",path:"/v6.3.2/tutorials/devops/caching-and-clustering.html",headers:[{level:2,title:"Storage Requirements for Clustered Entando Apps",slug:"storage-requirements-for-clustered-entando-apps"},{level:2,title:"Clustering",slug:"clustering"},{level:3,title:"Prerequisites",slug:"prerequisites"},{level:3,title:"Creating a Clustered App Instance",slug:"creating-a-clustered-app-instance"},{level:3,title:"Validating Clustered Instances",slug:"validating-clustered-instances"},{level:3,title:"Caching Validation",slug:"caching-validation"},{level:2,title:"Configuring and Deploying with Redis",slug:"configuring-and-deploying-with-redis"},{level:3,title:"Deploy Redis to Kubernetes",slug:"deploy-redis-to-kubernetes"},{level:3,title:"Configure implementation",slug:"configure-implementation"}],lastUpdated:"4/13/2022, 2:56:21 PM",lastUpdatedTimestamp:1649876181e3,content:' Caching and Clustering \n The tutorial below covers the basic steps to setup and validate a clustered instance of the Entando App Engine. \n \n NOTE \n When building your deployment architecture, it is important to review your goals, hardware, networking and application-specific setup. You must also optimize App Engine deployment for your environment. The configurations and tests below do not address every type of application or deployment, but they can be used as building blocks to create a deployment architecture that works for your application. \n Storage Requirements for Clustered Entando Apps \n In order to scale an Entando Application across multiple nodes, you must provide a storage class that supports\na  ReadWriteMany  access policy. There are many ways to accomplish this, including using dedicated storage providers like GlusterFS. Cloud Kubernetes providers also offer clustered storage options specific to their implementation, such as Google Cloud File in GKE or Azure Files in AKS. \n If your default class doesn\'t support  ReadWriteMany , add the following operator properties to the ConfigMap of your Helm template to use two different storage classes for clustered vs non-clustered storage: \n entando.k8s.operator.default.clustered.storage.class: [your clustered RWX storage class]\nentando.k8s.operator.default.non.clustered.storage.class: [your RWO storage class]\n \n Set both values to the appropriate storage class for your configuration. \n TIP \n A  ReadWriteOnce (RWO)  policy that ensures instances are all scheduled to the same node will scale an Entando Application without clustered storage and is accomplished via taints on other nodes. Be aware of the pros and cons of scheduling instances to the same node so you can maximize utilization of node resources and recover from an unreachable application instance. If the node terminates or is shutdown, your application will be down while Kubernetes reschedules the pods to a different node. \n Clustering \n This tutorial reviews setting up a clustered Entando App Engine in  entando-de-app . The goal is to deploy a clustered instance of the App Engine and verify the high availability and scalable deployment of the application. \n Prerequisites \n \n An existing deployment of an Entando App or the ability to create one.\n \n If you haven\'t created a deployment or don\'t have a YAML file for an Entando deployment, follow the  Quickstart instructions . \n \n \n The Entando deployment must use a Relational Database Management System (RDBMS) to organize data in a table structure. Clustered instances will not work correctly with in-memory databases. \n Creating a Clustered App Instance \n \n Create an Entando deployment via the Helm template or edit an existing deployment YAML file. \n Scale your Entando server application: \n \n kubectl scale deployment quickstart-server-deployment -n entando --replicas = 2 \n \n \n Run  kubectl get pods -n [your namespace]  to view the pods in your deployment. \n You should have two  quickstart-server-deployment  pods in your namespace. \n The logs of the  quickstart-server-deployment  in either pod contains logging information related to different instances joining the cluster and how data is balanced between instances. See the screenshot below for an example (actual logs will vary). \n Validating Clustered Instances \n This is an advanced exercise and not required or recommended for most deployment scenarios. The steps below validate that the clustered instances are working in your environment and that you have created a high availability deployment. \n \n Create a clustered instance  or have an existing clustered Entando App instance available for testing. \n Get the URL for your  entando-de-app  with  kubectl get ingress -n [your namespace] . \n Open the URL in the browser of your choice and ensure that the application is working. \n Open a new browser window in incognito or private browsing mode to ensure that no data is cached and you\'re receiving a copy of the running application.  Do not navigate to the app. \nIn the next steps, you\'ll delete a pod in your cluster and verify that your application is still getting served. Kubernetes will automatically restore the desired number of replicas, so you\'ll need to perform the validation test inside of approximately 1 minute (environments vary) before the new replica is launched. \n Delete one of the server deployment pods in your clustered instance with  kubectl delete [your-pod-name] -n [your namespace] .\n \n There are other ways to do this. You could also shell into the server-container and manually kill the running app process with  kill -9 357 . \n If you want to test at the hardware level, you could manually terminate a node in your cluster (ensuring that the pods are scheduled to different nodes). \n \n \n In your private/incognito browser window, open the URL to your  entando-de-app . \n Check that the application continues to render while the pod you deleted is no longer present. \n Wait for Kubernetes to restore your deleted pod. \n Check that the application continues to render after the pod is restored. \n Caching Validation \n Validating the shared cache can be done in a similar process to the clustered instance validation. The high level steps are: \n \n Deploy a clustered instance (see  creating a clustered instance tutorial ). \n Create data with the App Builder (pages, page templates, content etc.), using the external route for the application. \n Refer to the logs to note which instance processed the request. \n Terminate that instance. \n Fetch the recently created data and verify that the data are returned. \n Configuring and Deploying with Redis \n In this section, an Entando App Engine instance is deployed using Redis as a cache for data served by the App Engine. For more information on the cache configuration for the App Engine, see the  Caching and Clustering documentation . \n Deploy Redis to Kubernetes \n \n Create the Redis deployment and expose the endpoints: \n \n kubectl create deployment redis --image = redis:6\n \n kubectl expose deployment redis --port = 6379  --target-port = 6379  -n  [ your namespace ] \n \n \n Install the Redis CLI for your environment per  https://redis.io/topics/rediscli . \n Get the IP for your Redis deployment: \n \n kubectl get  service  -n  [ your namespace ] \n \n \n Validate your deployment: \n \n redis-cli -h  10.43 .99.198 -p  6379   ping \n \n \n Should respond PONG. \n \n redis-cli -h  10.43 .99.198 -p  6379  incr mycounter\n \n \n Should increment each time. \n Configure implementation \n \n Use git to clone the  entando-de-app  repository: \n \n git  clone https://github.com/entando/entando-de-app\n \n \n Fetch the tags, checkout the release tag and create a branch for your customization: \n \n git  fetch --tags\n \n git  checkout tags/v6.3.68 -b  6.3 .2-redis\n \n \n \n Open the pom.xml file of the  entando-de-app . \n \n \n Add the Redis caching plugin to the pom.xml: \n \n \n <dependency>\n    <groupId>org.entando.entando.plugins</groupId>\n    <artifactId>entando-plugin-jpredis</artifactId>\n    <type>war</type>\n</dependency>\n \n \n Save the pom. \n Build and push a custom image for the  entando-de-app  with  Building a Docker Image Tutorial . \n Download the operator configuration deployment file: \n \n curl  -L -C - -O https://raw.githubusercontent.com/entando/entando-releases/v6.3.2/dist/ge-1-1-6/namespace-scoped-deployment/orig/namespace-resources.yaml  >  namespace-resources.yaml\n \n \n Update the deployment YAML file to point to your custom  entando-de-app  image with Redis. The line to change is in the  ConfigMap  and is noted below: \n \n entando-de-app-wildfly: >-\n    {"version":"6.3.10","executable-type":"jvm","registry":"docker.io","organization":"entando"}\n \n \n Deploy your edited file with  kubectl . For example: \n \n kubectl apply -f namespace-resources.yaml\n \n \n Run the Helm template to generate the application configuration file  my-clustered-app.yaml : \n \n helm template quickstart ./ > my-clustered-app.yaml\n \n \n Add environment variables for your deployed Redis instance to  EntandoApp  in  my-clustered-app.yaml . The variables to create are: \n \n REDIS_ADDRESS\n \n REDIS_PASSWORD\n \n REDIS_ACTIVE\n \n The following example pertains to the EntandoApp only, not a complete deployment.  Utilize this as a reference to create your configuration in a complete deployment. \n \n NOTE: This example uses a Secret for the  REDIS_PASSWORD , which is recommended. You can also hardcode the password in the YAML for testing purposes, but the use of clear text passwords in deployment files is not recommended.  Create and use a Secret for the password as a best practice. \n \n apiVersion: "entando.org/v1"\nkind: "EntandoApp"\nmetadata:\n  name: "quickstart"\n  annotations:\n    entando.org/processing-instruction: defer\nspec:\n  dbms: embedded\n  replicas: 1\n  standardServerImage: wildfly\n  ingressPath: /entando-de-app\n  environmentVariables:\n    - name: REDIS_ADDRESS\n      value: [your redis URI. For example redis://localhost:6379]\n    - name: REDIS_PASSWORD\n      valueFrom:\n        secretKeyRef:\n          key: password\n          name: quickstart1-redis-secret\n          optional: false \n    - name: REDIS_ACTIVE\n      value: "true" \n \n \n Deploy your file: \n \n kubectl apply -f [your-clustered-app.yaml]\n \n '},{title:"Backing Up and Restoring an Entando Application",frontmatter:{sidebarDepth:2},regularPath:"/v6.3.2/tutorials/devops/backing-up-and-restoring-your-environment.html",relativePath:"v6.3.2/tutorials/devops/backing-up-and-restoring-your-environment.md",key:"v-2cd5b326",path:"/v6.3.2/tutorials/devops/backing-up-and-restoring-your-environment.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Create a Backup",slug:"create-a-backup"},{level:2,title:"Restore a Backup",slug:"restore-a-backup"},{level:3,title:"Build the Custom Image",slug:"build-the-custom-image"},{level:3,title:"Install the Application",slug:"install-the-application"}],lastUpdated:"1/31/2022, 9:28:12 AM",lastUpdatedTimestamp:1643639292e3,content:' Backing Up and Restoring an Entando Application \n Overview \n This tutorial demonstrates how to use an existing Entando Application as a launching point for creating new applications. An alternative is to  use the Entando Bundler  to extract specific content and functionality from an existing application. Entando Bundles are recommended as a more flexible option when a full copy of an application is not required. \n Prerequisites \n \n Java 11 \n Docker \n Maven \n Access to a Docker repository (docker.io or other) \n Create a Backup \n This step requires using a running Entando environment to take an application backup.\nThe output of this step is a local directory with the files (database and static assets) needed to restore the application later. \n \n \n Log into the App Builder \n \n \n Go to  Administration → Database \n \n \n Click on  Create A Backup  and wait for the process to complete. The static assets and database backup will be saved to a persistent volume on the server pod under  /entando-data . \n \n \n Transfer the files from the  server-deployment . The exact command will depend on your Kubernetes environment. \n \n \n \n \n \n kubectl \n OpenShift \n \n \n \n \n kubectl cp <pod>:<path> <local-path> \n oc rsync <pod>:<path> <localPath> \n \n \n e.g.  kubectl cp quickstart-server-deployment-7b8c699599-f84zq:/entando-data backup \n e.g. oc rsync app-entando-server-deployment-67fd5b9954-s72mb:/entando-data \n \n \n \n \n You should see 3 directories -  databases ,  protected , and  resources .\nThe  protected  directory contains the timestamped backup you triggered from the App Builder. The  resources  directory contains the static assets. \n Restore a Backup \n Restoring a backup requires creating and then deploying a custom image of an Entando Application with the\nbackup files included. \n Build the Custom Image \n \n Clone the Entando Application repository \n \n git  clone https://github.com/entando/entando-de-app\n \n \n Change into the  entando-de-app  directory: \n \n cd  entando-de-app\n \n \n (Optional) Checkout a branch for your desired Entando version. You can review  https://github.com/entando/entando-de-app/releases  to determine the correct tag to use. \n \n git  checkout -b my-test v6.3.68-fix.1\n \n WARNING \n If you don\'t perform this step, you\'ll be creating an Entando Application based on the latest  entando-de-app  code, which may not yet be released. \n \n \n \n Move the  resources  and  protected  directory from your Entando backup into  src/main/webapp . You should override any existing content. \n \n \n Build the application \n \n \n mvn clean package\n \n \n \n Create a repository named  entando-de-app-wildfly  in Docker for the new application. The Entando Operator will expect this name when performing the initial install. \n \n \n Create a Docker image for the application. You\'ll need to provide your user name and version. \n \n \n docker  build  .  -f Dockerfile.wildfly -t  < YOUR- USER > /entando-de-app-wildfly: < YOUR-VERSION > \n \n \n Push the image to Docker \n \n docker  push  < YOUR- USER > /entando-de-app-wildfly: < YOUR-VERSION > \n Install the Application \n You can use your typical install steps (or the standard  Manual Install steps ) with one adjustment. When you get to the  Install namespace scoped resources  step, you\'ll need to configure the  namespace-resources.yaml  to use your image. \n \n Retrieve a copy of the  namespace-resources.yaml  for your Entando version \n \n   curl  -sfL https://raw.githubusercontent.com/entando/entando-releases/v6.3.2/dist/ge-1-1-6/namespace-scoped-deployment/orig/namespace-resources.yaml  >  namespace-resources.yaml\n \n \n Edit  namespace-resources.yaml  and update the  entando-de-app-wildfly  configuration with your user name and version \n \n entando-de-app-wildfly :   > - \n     { "version" : "<YOUR-VERSION>" , "executable - type" : "jvm" , "registry" : "docker.io" , "organization" : "<YOUR-USER>" } \n \n \n Now apply the namespace resources to K8s \n \n sudo  kubectl apply -n entando -f namespace-resources.yaml\n \n \n \n You can now continue with the rest of the install instructions \n \n \n Once deployed, review the App Builder or running application to confirm the backup was restored correctly. You can check the  server-deployment  logs for possible errors. \n \n \n'},{title:"Selecting the default databases",frontmatter:{},regularPath:"/v6.3.2/tutorials/devops/default-database.html",relativePath:"v6.3.2/tutorials/devops/default-database.md",key:"v-13a01900",path:"/v6.3.2/tutorials/devops/default-database.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:" Selecting the default databases \n Overview \n This document provides a guide to changing an Entando environment by selecting the default databases used.\nSee  External Database  to connect to a database outside of the cluster. \n Prerequisites \n \n An environment to install your Entando applicaiton \n Network access from your Kubernetes cluster to your database \n Tutorial \n If needed you can set the desired component to use a specific DBMS by updating the Helm-generated yaml file (from  Getting Started  as follows: \n \n open the chosen file and search for  EntandoApp  custom resource \n identify the component to update in the related list \n update the  spec.dbms  property with the desired value (you can specify different DBMS for different components) \n \n Repeat previous steps for all components you need to change used DBMS on. \n Valid values for  spec.dbms  property are:  none ,  embedded ,  postgresql ,  mysql ,  oracle . \n embedded  value will result in using an embedded database with in-file persistence strategy. \n Please note that using embedded databases into distributed systems forces to have only 1 replica per pod.\nThis happens because the volume claimed by each replica points to the same files,\nso the first container locking the files will prevent next replicas to obtain access to the DB files.\nNote that this affects also deployments rolling updates \n If you need to update your deployment, there is a known workaround consisting in setting the replicas number to 0, waiting for pod shutdown completion, update the deployment yaml file, then updating again to 1 the replicas value. In this way, the newly created containers will be able to startup correctly and access the embedded database files on the filesystem. \n These considerations lead us to discourage embedded database use into production environments. \n"},{title:"Change Default Datasources and Connections",frontmatter:{redirectFrom:"/v6.3.2/tutorials/customize-the-platform/change-default-datasources-and-connections/"},regularPath:"/v6.3.2/tutorials/devops/change-default-datasource.html",relativePath:"v6.3.2/tutorials/devops/change-default-datasource.md",key:"v-3fc45506",path:"/v6.3.2/tutorials/devops/change-default-datasource.html",headers:[{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Create a Docker project for your own base image to Entando's standard base image(s)",slug:"_1-create-a-docker-project-for-your-own-base-image-to-entando-s-standard-base-image-s"},{level:3,title:"2. Customize the standalone.xml/standalone-openshift.xml file using environment variables.",slug:"_2-customize-the-standalone-xml-standalone-openshift-xml-file-using-environment-variables"},{level:3,title:"3. Build your own Docker base image",slug:"_3-build-your-own-docker-base-image"},{level:3,title:"4. Modify your Entando App project to use the new Docker base image",slug:"_4-modify-your-entando-app-project-to-use-the-new-docker-base-image"},{level:3,title:"5. Build and push your custom Docker image",slug:"_5-build-and-push-your-custom-docker-image"},{level:3,title:"6. Deploy your EntandoApp with the correct environment variables",slug:"_6-deploy-your-entandoapp-with-the-correct-environment-variables"}],lastUpdated:"2/16/2022, 9:07:34 AM",lastUpdatedTimestamp:1645020454e3,content:' Change Default Datasources and Connections \n Purpose \n This tutorial explains how to customize our EAP and Wildfly base Docker images, and then configure the EntandoApp custom resource to use these customizations. \n Requirements \n \n \n The Entando Operator is running in the target names \n \n \n Keycloak and the Entando Cluster Infrastructure have been deployed \n \n \n The required external databases and other services are up and running. \n \n \n Your own custom project as described in  the tutorial \n Steps \n 1. Create a Docker project for your own base image to Entando\'s standard base image(s) \n Create a project, ideally in Git repository, and put the following files in the folder \n 1.1. The standalone.xml/standalone-openshift.xml file of choice \n It is essential for your custom Docker image to use a file from one of the official Entando Docker base images. \n If you intend to use provide your own EAP based image, please use this\n standalone-openshift.xml \nfile. \n If you intend to use provide your own Wildfly based image, please use this\n standalone.xml \nfile. \n Please note that if you create your own base image with a different version of EAP or Wildfly, using these files\nmay have unintended consequences. \n 1.2. Any modules that may be required for your datasource or other connection resource \n If the resource you need to connect to requires some custom classes, such as JDBC drivers, please add these as \na module to Wildfly/EAP. \n 1.3 Dockerfile \n In your Dockerfile, please be sure to extend the correct base image, and add the correct configuration file to\nthe correct location in the target image. \n For EAP, a most basic Dockerfile would look like this: \n FROM entando/entando-eap71-clustered-base:6.1.2\nCOPY --chown=185:0 ./standalone-openshift.xml /opt/eap/standalone/configuration\n \n For Wildfly, a most basic Dockerfile would look like this: \n FROM entando/entando-eap71-clustered-base:6.1.2\nCOPY --chown=1001:0 ./standalone.xml /wildfly/standalone/configuration\n \n Please take note of the user ownership in these different Dockerfiles. This is quite important as Openshift will\nexpect the user/group ownership to be respected. \n 2. Customize the standalone.xml/standalone-openshift.xml file using environment variables. \n You can now modify your Wildfly/EAP configuration to meet your requirements. Where the configuration could differ\nfrom one environment to a next, we strongly advise using environment variable expressions ( ${env.VAR_NAME} ). The most likely change\nthat would be required in this file is the addition of a datasource. Here is an example of how to add a datasource\nto the datasources subsystem. All the environment variables starting with \'YOURDB\' can be specified from the Docker\ncontainer. \n    ...\n    <subsystem xmlns="urn:jboss:domain:datasources:5.0">\n      <datasources>\n        <datasource jndi-name="${env.YOURDB_JNDI}" enabled="true" use-java-context="true" pool-name="yourDbDataSource" use-ccm="true">\n          <connection-url>${env.YOURDB_URL}</connection-url>\n          <driver>${env.YOURDB_DRIVER}</driver>\n          <security>\n            <user-name>${env.YOURDB_USERNAME}</user-name>\n            <password>${env.YOURDB_PASSWORD}</password>\n          </security>\n        </datasource>\n \n Please take extra care not to remove any lines from these files. This is of particular importance in the case of the\nEAP image as, on startup, scripts in the official EAP look for certain placeholders in this file and populates them\nfrom other environment variables. \n 3. Build your own Docker base image \n You can now build your Docker base image. It is highly recommended that you consider using a dedicated CI/CD build\ntool such as Jenkins X to build the base image and maintain traceability between your source code and the resulting\nDocker image. One possible build command could look like this: \n docker build . -t your-docker-registry.com/your-org/your-base-image:1.0.0 \n 4. Modify your Entando App project to use the new Docker base image \n You can now modify your Entando App project that you have forked as described in the\n relevant tutorial . You would require two changes to the pom.xml file\nof the sample project. \n \n Firstly, you would need to change the variable  server.base.image  to reflect the fully\nqualified URI of your Docker image for EAP and/or Wildfly. For example, if you decided to extend the Wildfly image,\ngo to the Maven profile with the id  wildfly  and change the   server.base.image  to look like this: \n \n <server.base.image>your-docker-registry.com/your-org/your-base-image:1.0.0</server.base.image> \n \n Then you need to change the  <from>  element in the Fabric8 Maven Docker Plugin to reflect this variable.\nNavigate to the first  <image>  element in the pom.xml file. You have found the correct one\nif it contains the following xml: \n \n <from>entando/${server.base.image}:${entando.version}</from> \n Delete the  entando/  prefix and the  :${entando.version}  suffix: \n <from>${server.base.image}</from> \n Please note that, should you still require support for both Wildfly and EAP in your Maven pom, you may need to\nrepeat this exercise for both the  eap  and  wildfly  profiles. \n 5. Build and push your custom Docker image \n Before building your Docker image, it would be a good idea to change the name of the image you want to build. Navigate\nto the previously modified  <image>  element in the Fabric8 Maven Docker Plugin.You can change the  <name>  element\nto reflect your preferred name, e.g. \n <name>your-docker-registry.com/your-org/your-entando-app:1.0.0</name> \n Run: \n mvn clean package -Pwildfly -Pderby \n A new Docker image should now be available named  your-docker-registry.com/your-org/your-entando-app:1.0.0 \n Log into the Docker registry in question and then push the image: \n docker push your-docker-registry.com/your-org/your-entando-app:1.0.0 \n You are now ready to deploy this image. \n 6. Deploy your EntandoApp with the correct environment variables \n The final step is to configure your EntandoApp deployment with the correct environment variables. As is the case with\nall the Entando Custom Resources that result in actual deployments, the property  spec.environmentVariables  will be translated\ninto environment variables on each of the Containers in the Deployment\'s Pod. For an EntandoApp named \'my-app\',\nthe new state of the EntandoApp would could be placed in a file named  my-app.yaml  that would look something like this: \n       kind: "EntandoApp"\n      metadata:\n        name: "my-app"\n      spec:\n        dbms: postgresql\n        replicas: 1\n        customServerImage: your-docker-registry.com/your-org/your-entando-app:1.0.0\n        ingressPath: /your-entando-app\n        environmentVariables:\n          - name: YOURDB_JNDI\n            value: java/your-ds\n          - name: YOURDB_URL\n            value: "jdbc:postgresql://somehost.com:5432/mydb"\n          - name: YOURDB_DRIVER\n            value: postgresql\n          - name: YOURDB_USERNAME\n            value: my_user\n          - name: YOURDB_PASSWORD\n            value: mypassword\n      entandoStatus:\n        entandoDeploymentPhase: requested\n\n \n Notice how this Custom Resource specifies a  parameter  for each environment variable that was referenced from the\n standalone.xml  file referenced earlier. \n To apply the changes to your deployment, change the  entandoStatus.entandoDeploymentPhase  property to requested and\napply the file: \n kubectl apply -f my-app.yaml\n \n '},{title:"Connect to an External Keycloak Instance",frontmatter:{redirectFrom:"/v6.3.2/tutorials/devops/external-keycloak/"},regularPath:"/v6.3.2/tutorials/devops/external-id-management.html",relativePath:"v6.3.2/tutorials/devops/external-id-management.md",key:"v-f28b3930",path:"/v6.3.2/tutorials/devops/external-id-management.html",headers:[{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Get keycloak information",slug:"_1-get-keycloak-information"},{level:3,title:"2. Generate the secret",slug:"_2-generate-the-secret"},{level:3,title:"3. Upload the secret",slug:"_3-upload-the-secret"},{level:3,title:"4. Deploy the Entando6 application",slug:"_4-deploy-the-entando6-application"},{level:2,title:"Conclusion",slug:"conclusion"}],lastUpdated:"2/16/2022, 9:07:34 AM",lastUpdatedTimestamp:1645020454e3,content:' Connect to an External Keycloak Instance \n Purpose \n This tutorial enables the Entando administrator to leverage an existing\nKeycloak instance. \n Requirements \n \n \n A Keycloak instance \n \n \n A realm named "entando" on that instance \n \n \n An admin user for the "entando" realm \n Steps \n 1. Get keycloak information \n Retrieve the relevant information from the Keycloak instance you want to\nuse. \n Specifically you will need: \n \n \n The username of the Keycloak admin that has admin rights to the\n"entando" realm, e.g entando-keycloak-admin \n \n \n The Keycloak admin password, e.g. password123 \n \n \n The base url for the Keycloak server, including the auth value, e.g. https:my-keycloak-instance.com/auth \n 2. Generate the secret \n You now need to generate a secret with name  keycloak-admin-secret \nusing the information retrieved from step 1. The Entando administrator\nwill automatically detect this secret by name, and use it to log onto\nthe provided Keycloak server. \n Here is an example of the secret you will need to construct: \n ---\napiVersion: v1\nstringData:\n    username: <the username of the Keycloak admin user for the "entando" realm>\n    password: <the password of this Keycloak admin user>\n    url: <the base url of the Keycloak service, typically ending with the path /auth>\nkind: Secret\nmetadata\n    name: keycloak-admin-secret\n    namespace: <your-app-namespace>\ntype: Opaque\n \n \n Note \n To encode your values, in bash, you can do\n echo <your-value> | base64 \n 3. Upload the secret \n Next upload the secret to the namespace where you want to deploy your\nEntando 6 instance. \n oc create -f my-secret.yaml -n <my-app-namespace>\n 4. Deploy the Entando6 application \n Now you are ready to deploy your Entando 6 application and the\nadministrator will reuse the  keycloak-admin-secret  secret to populate\nthe environment correctly. \n Conclusion \n You should now have a working Entando 6 instance using an external\nKeycloak server. \n'},{title:"Connecting to an External Database",frontmatter:{redirectFrom:"/v6.3.2/tutorials/devops/external-database/"},regularPath:"/v6.3.2/tutorials/devops/external-db.html",relativePath:"v6.3.2/tutorials/devops/external-db.md",key:"v-94205374",path:"/v6.3.2/tutorials/devops/external-db.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:" Connecting to an External Database \n Overview \n This document provides a guide to connecting an Entando Application to an external database. In\nmany (not all) production configurations it is recommended to use a DBMS\noutside of the cluster where your Entando application is running to\nsimplify maintenance, duplication of resources, and to establish a\nbackup workflow that will scale with your application. \n Prerequisites \n \n \n An environment to install your Entando applicaiton \n \n \n A running PostgreSQL, MySQL, or Oracle environment \n \n \n Administrator access to the database \n \n \n Network access from your Kubernetes cluster to your database \n Tutorial \n \n Create and install a secret or secrets for your database credentials \n Edit the deployment template generated from running the helm command or the helm template you used to deploy your Entando application \n Find the entry for the  EntandoApp  and  EntandoKeycloakServer \n Set the value for  dbms  to  none  in both resources (or only one depending on your requirements) \n Under  environmentVariables  you will need to provide database connection information for two Entando Server databases and one connection for the Entando Component Repository. Example connection information for each of those databases is provided below: \n ECR \n - name: SPRING_DATASOURCE_URL\n  value: {ECRDB_URL}\n- name: SPRING_DATASOURCE_USERNAME\n  valueFrom:\n    secretKeyRef:\n      name: {ECRDB_DBMS_SECRET_NAME}\n      key: username\n      optional: false\n- name: SPRING_DATASOURCE_PASSWORD\n  valueFrom:\n    secretKeyRef:\n      name: {ECRDB_DBMS_SECRET_NAME}\n      key: password\n      optional: false\n- name: SPRING_JPA_DATABASE_PLATFORM\n  value: org.hibernate.dialect.PostgreSQLDialect\n Portal DB \n - name: PORTDB_URL\n  value: {PORTDB_URL}\n- name: PORTDB_USERNAME\n  valueFrom:\n    secretKeyRef:\n      name: {PORTDB_DBMS_SECRET_NAME}\n      key: username\n      optional: false\n- name: PORTDB_PASSWORD\n  valueFrom:\n    secretKeyRef:\n      name: {PORTDB_DBMS_SECRET_NAME}\n      key: password\n      optional: false\n- name: PORTDB_CONNECTION_CHECKER\n  value: {PORTDB_CONNECTION_CHECKER}\n- name: PORTDB_EXCEPTION_SORTER\n  value: {PORTDB_EXCEPTION_SORTER}\n Server DB \n - name: SERVDB_URL\n  value: {SERVDB_URL}\n- name: SERVDB_USERNAME\n  valueFrom:\n    secretKeyRef:\n      name: {SERVDB_DBMS_SECRET_NAME}\n      key: username\n      optional: false\n- name: SERVDB_PASSWORD\n  valueFrom:\n    secretKeyRef:\n      name: {SERVDB_DBMS_SECRET_NAME}\n      key: password\n      optional: false\n- name: SERVDB_CONNECTION_CHECKER\n  value: {SERVDB_CONNECTION_CHECKER}\n- name: SERVDB_EXCEPTION_SORTER\n  value: {SERVDB_EXCEPTION_SORTER}\n \n Set the values for placeholders in the templates above based on your database configuration. Here are examples: \n Postgresql \n XXX_URL:                      jdbc:postgresql://{DBMS_ADDRESS}:{DBMS_PORT}/{DBMS_DBNAME}\nXXX_CONNECTON_CHECKER:        org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLValidConnectionChecker\nXXX_EXCEPTION_SORTER:         org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLExceptionSorter\nSPRING_JPA_DATABASE_PLATFORM: org.hibernate.dialect.PostgreSQLDialect\n MySql \n XXX_URL:                      jdbc:mysql://{DBMS_ADDRESS}:{DBMS_PORT}/{DBMS_DBNAME}\nXXX_CONNECTON_CHECKER:        org.jboss.jca.adapters.jdbc.extensions.mysql.MySQLValidConnectionChecker\nXXX_EXCEPTION_SORTER:         org.jboss.jca.adapters.jdbc.extensions.mysql.MySQLExceptionSorter\nSPRING_JPA_DATABASE_PLATFORM: org.hibernate.dialect.MySQLDialect\n Oracle \n XXX_URL:                      jdbc:oracle:{driver_type}:@//{DBMS_ADDRESS}:{DBMS_PORT}/{DBMS_SERVICE_NAME}\nXXX_CONNECTON_CHECKER:        org.jboss.jca.adapters.jdbc.extensions.oracle.OracleValidConnectionChecker\nXXX_EXCEPTION_SORTER:         org.jboss.jca.adapters.jdbc.extensions.oracle.OracleExceptionSorter\nSPRING_JPA_DATABASE_PLATFORM: org.hibernate.dialect.Oracle\n \n "},{title:"Tutorial: Invoking Entando Core APIs",frontmatter:{},regularPath:"/v6.3.2/tutorials/devops/invoking-api.html",relativePath:"v6.3.2/tutorials/devops/invoking-api.md",key:"v-9ce1dd6c",path:"/v6.3.2/tutorials/devops/invoking-api.html",headers:[{level:2,title:"General Overview",slug:"general-overview"},{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Set up a Postman environment",slug:"_1-set-up-a-postman-environment"},{level:3,title:"2. Get an access token",slug:"_2-get-an-access-token"},{level:3,title:"2. Prepare a generic API request",slug:"_2-prepare-a-generic-api-request"},{level:2,title:"QE ready APIs",slug:"qe-ready-apis"},{level:2,title:"Notes on QE requests collections structure",slug:"notes-on-qe-requests-collections-structure"},{level:2,title:"Conclusion",slug:"conclusion"}],lastUpdated:"1/29/2022, 10:04:58 AM",lastUpdatedTimestamp:1643468698e3,content:' Tutorial: Invoking Entando Core APIs \n General Overview \n Entando supports Swagger and it is accessible, if activated, from its\nweb interface from the base application URL at /api/swagger-ui.html. A\ncomplete list of all available core APIs can be obtained from Swagger. \n Core APIs can be invoked directly from Swagger or from any other\nsuitable tool, i.e., curl or Postman are two common ones. Postman has\nbeen extensively used in API testing and automated API testing because\nof the possibilities it offers and it is the suggested tool. \n All Entando core APIs are accessible from the base URL, for example:\nlocalhost:8080/entando-de-app/api. For example, the Page Controller will\nbe available under /pages from the Base URL (i.e.\nlocalhost:8080/entando-de-app/api/pages), or the Page Template Controller\nwill available under /pageModels (i.e.\nlocalhost:8080/entando-de-app/api/pageModels) and so on. \n Before being able to perform any API request, we will first need to\nobtain an  authorization token , that is achieved with a specific POST\nrequest sent to the oauth/token endpoint, after successful\nauthentication, an access token is returned which grants access to all\nAPI endpoints and actions for which the authenticated user has defined\nprivileges. \n (Refer to User Management Roles for details) \n The best way to proceed in case of extensive testing with APIs with\nPostman, is to set up an environment and define a variable that will\nkeep the access token saved from the POST request to /oauth/token. \n Purpose \n Set up an environment ready to invoke Entando core APIs \n Requirements \n To complete this tutorial you will need: \n \n \n Postman \n \n \n A running Entando 6 instance \n Steps \n 1. Set up a Postman environment \n Create a new Postman environment and define the following variables: \n access_token: (no value)\nrefresh_token: (no value)\nurl: URL of your application (i.e. http://localhost:8080/entando-de-app)\n \n Be careful with the URL variable and make sure you do not have a\ntrailing slash. \n Set Postman to use this environment. \n 2. Get an access token \n Getting an access token is a prerequisite to be able to invoke any API.\nThe following is the required activity. \n \n \n create a Postman collection, name it for example "Access Token" \n \n \n create a new POST request with the following parameters: \n \n \n \n URL field\n{{url}}/api/oauth/token\n \n Note that we are calling the "url" environmental variable for\nconvenience. \n Autorization section\n   Type: Basic Auth\n   Username: (a valid Entando consumer must be defined in Entando) (Refer to appropriate documentation on how to do that) (i.e. appbuilder)\n   Password: (password of the defined consumer) (i.e. appbuilder_secret)\n\nHeaders section\n    Content-Type: application/x-www-form-urlencoded\n\nBody section\nSelect from the radio button the option: x-www-form-urlencoded\n    username: (valid Entando user (i.e. admin))\n    password: (password of the valid user)\n    grant_type: password\n \n The tests section is convenient as we can then set any new API request\nin such a way to make use of that access token. The first line of code\ndefines a variable called "data", which hosts the JSON parsed\nresponseBody from the POST request just sent to /oauth/token; The second\nline sets the environment variable "access_token" to the value returned\nby the POST request. \n Tests section\n    var data = JSON.parse(responseBody);\n    postman.setEnvironmentVariable("access_token", data.access_token);\n \n Launch the POST request to test it, and if successful, you should get a\nresponse like this: \n {\n    "access_token": "b96096493a40b1a7364bd54a6ffb609b",\n    "token_type": "bearer",\n    "refresh_token": "79ff84062b5dc13663961a833b0788f9",\n    "expires_in": 3599\n}\n \n also if you open in edit the Postman environment, you should see that\nthe access_token and the refresh_token variables values have been\nupdated. \n 2. Prepare a generic API request \n Create a new request with the following parameters: \n Authorization section: Inherit auth from parent\n\nHeaders section:\n create the key Authorization with Value: Bearer{{access_token}}\n create the key Content-Type with Value: application/json\n \n Select the appropriate method (GET, DELETE, POST etc.) for your request\nand fill up the URL with appropriate values i.e.\n(localhost:8080/entando-de-app/api/pages) then add to the Body section,\nif needed, the appropriate payload in JSON format, remember to select\nraw and JSON (application/json). \n QE ready APIs \n QE has developed a set of collection requests to automate API testing,\nexamples of that are available on github at\n https://github.com/entando/entando-QE/tree/master/postman_API . \n To use them ,first git clone the project and use the built in Postman\nimporting features. \n Import first the Postman Environment file which can be found under the\nenvironment folder. When imported, from Postman, open in edit that\nenvironment and change the "url" variable to the appropriate value for\nyour specific installation, i.e  http://localhost:8080/entando-de-app/ \nand save it. \n Import from Postman the collections you would like to use and they will\nbecome available in the Postman collections Panel ready to be run. \n Notes on QE requests collections structure \n Each collection is so designed to test a particular use case i.e.\n"Delete an existent page", "Delete a page which has children" etc. \n By design each QE Postman collection is: \n \n \n indipendent (does not require other collections) \n \n \n general (does not make any assumption on the specific Entando\napplication) \n \n \n can be run automatically, with newman, please refer to\n https://github.com/entando/entando-QE  for details \n \n \n Following those requirements, each collection will need to "prepare" the\nenvironment for the actual test. That is achieved by using specific\nrequests, called "helpers", and their only purpose is to create/delete\nall the needed objects. \n Another class of helpers is used to check the persistence of the actions\nperformed by the APIs, i.e. check that after a DELETE, something really\nhas been deleted. \n The request that implements the use case, we can call it main request,\ndoes not contain the word "HELPER" in its name, and it is the only one\ninside a given collection. \n Because collections are designed primarily to run automatically, we have\ndone extensive use of collection variables, so variables like the API\nURL, object names, object codes or payloads are usually defined as a\ncollection variable and can be accessed by all requests inside the\ncollection. \n Conclusion \n This guide let you start invoking Entando 6 APIs \n'},{title:"Manage NGINX",frontmatter:{sidebarDepth:2},regularPath:"/v6.3.2/tutorials/devops/manage-nginx.html",relativePath:"v6.3.2/tutorials/devops/manage-nginx.md",key:"v-3b785c2c",path:"/v6.3.2/tutorials/devops/manage-nginx.html",headers:[{level:2,title:"Verify the NGINX Ingress Install",slug:"verify-the-nginx-ingress-install"},{level:2,title:"Customize the NGINX Configuration",slug:"customize-the-nginx-configuration"},{level:2,title:"Add the cert-manager for TLS Support",slug:"add-the-cert-manager-for-tls-support"},{level:3,title:"Installation",slug:"installation"},{level:3,title:"Configuration",slug:"configuration"},{level:3,title:"cert-manager References",slug:"cert-manager-references"}],lastUpdated:"4/21/2022, 1:23:40 PM",lastUpdatedTimestamp:165056182e4,content:' Manage NGINX \n There are environments where it\'s useful to use NGINX rather than the default ingress controller. This page shows how to verify and refine your NGINX configuration. \n See the following install guides if needed: \n \n Amazon Elastic Kubernetes Service (EKS) \n Azure Kubernetes Service (AKS) \n Google Kubernetes Engine (GKE) \n Verify the NGINX Ingress Install \n To verify that the ingress is working properly you can set up a test application. \n \n Create a simple application: \n \n kubectl create deployment hello-server --image=us-docker.pkg.dev/google-samples/containers/gke/hello-app:1.0\n \n \n Expose the  hello-app  deployment as a Service: \n \n kubectl expose deployment hello-server --type LoadBalancer --port 80 --target-port 8080\n \n \n Create this  ingress-resource.yaml  file: \n \n apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: ingress-resource\n  annotations:\n    kubernetes.io/ingress.class: nginx\n    nginx.ingress.kubernetes.io/ssl-redirect: "false"\nspec:\n  rules:\n  - http:\n      paths:\n      - path: /hello\n        pathType: Prefix\n        backend:\n          service:\n            name: hello-server\n            port: \n              number: 80\n \n \n Create the Ingress Resource: \n \n kubectl apply -f ingress-resource.yaml\n \n \n Verify that the Ingress Resource has been created: \n \n kubectl get ingress ingress-resource\n \n It may take several minutes to populate the  Address . \n \n Verify access to the web application using the  EXTERNAL-IP/hello  address of the  nginx-ingress-controller . You should see the following: \n \n Hello, world!\nVersion: 1.0.0\nHostname: hello-app\n \n Note that you will need the EXTERNAL-IP address of your ingress controller to configure the application. \n \n Verify that you configured the ingress class in the Operator  ConfigMap  so Entando knows which ingress controller should be used: \n \n entando.ingress.class: "nginx" \n \n To reduce costs, remove the test deployment, service, and ingress: \n \n kubectl delete deploy/hello-server service/hello-server ing/ingress-resource\n Customize the NGINX Configuration \n There are situations where the default NGINX ingress configuration isn\'t optimized for Entando, e.g. JWT tokens can be too large or  proxy-buffer-size  can be too small. A  502 Bad Gateway  error may indicate that the config needs to be modified. \n The NGINX controller can be configured for the entire cluster by editing the default NGINX  ConfigMap , called  ingress-nginx-controller  in the  ingress-nginx  namespace. Add the following to the data parameter: \n apiVersion: v1\ndata:\n  allow-snippet-annotations: "true"\n  proxy-buffer-size: 24k\nkind: ConfigMap\n \n Production environments may require additional common annotations: \n nginx.ingress.kubernetes.io/proxy-body-size: 200m # to upload large files (default is 10M)\nnginx.ingress.kubernetes.io/proxy-buffer-size: 64k # for the Keycloak auth-token (default is 16K)\nnginx.ingress.kubernetes.io/proxy-read-timeout: "600" # to increase the timeout when uploading large files\n \n Sticky sessions may be useful for  entando-de-app  deployments with multiple replicas. If you  set up clustering , the following options will enable sticky sessions in NGINX: \n nginx.ingress.kubernetes.io/affinity: cookie\nnginx.ingress.kubernetes.io/affinity-mode: balanced\n Add the  cert-manager  for TLS Support \n Follow the instructions below to install and configure  cert-manager  in Kubernetes environments.\n​ \n Installation \n ​\nCreate a namespace dedicated to  cert-manager : \n kubectl create ns cert-manager\n \n ​\nComplete the installation: \n kubectl apply  - f https : //github.com/jetstack/cert - manager/releases/download/v1.7.0/cert - manager.yaml\n Configuration \n ​\nTo enable  cert-manager  to generate certificates, add these annotations to the ingress:\n​ \n \n cert-manager.io/issuer: "[name of the issuer]"  for namespace-based issuers \n cert-manager.io/cluster-issuer: "[name of cluster issuer]"  for cluster-wide issuers \n \n and modify  spec : \n spec : \n   tls : \n   -   hosts : \n     -  example.example.com\n     secretName :  quickstart - example - tls  # this Secret will be autogenereted by cert-manager. \n Namespace Level Issuer \n ​\nUse the following configuration when deploying an issuer per namespace. This is useful for higher levels of customization.\n​ \n apiVersion :  cert - manager.io/v1\n kind :  Issuer\n metadata : \n   name :  letsencrypt - prod\n spec : \n   acme : \nThe ACME server URL \n     server :  https : //acme - v02.api.letsencrypt.org/directory\n     preferredChain :   "ISRG Root X1" \nEmail address used for ACME registration \n     email :  <your email > \nName of a secret used to store the ACME account privare key \n     privateKeySecretRef : \n       name :  letsencrypt - prod\nEnable the http-01 challenge provider \n     solvers : \n     -   http01 : \n         ingress : \n           class :  nginx\n​\n Cluster Level Issuer \n Use the following configuration when deploying an issuer per cluster: \n apiVersion :  cert - manager.io/v1\n kind :  ClusterIssuer\n metadata : \n   name :  letsencrypt - prod - cluster\n   namespace :  cert - manager\n spec : \n   acme : \nThe ACME server URL \n     server :  https : //acme - v02.api.letsencrypt.org/directory\n     preferredChain :   "ISRG Root X1" \nEmail address used for ACME registration \n     email :  <your email > \nName of a secret used to store the ACME account privare key \n     privateKeySecretRef : \n       name :  letsencrypt - cluster - prod\nEnable the http-01 challenge provider \n     solvers : \n     -   http01 : \n         ingress : \n           class :  nginx\n​\n  cert-manager  References \n \n Installation \n Supported releases \n \n'},{title:"Installation on Azure Kubernetes Service (AKS)",frontmatter:{sidebarDepth:2},regularPath:"/v6.3.2/tutorials/getting-started/azure-install.html",relativePath:"v6.3.2/tutorials/getting-started/azure-install.md",key:"v-92f180c0",path:"/v6.3.2/tutorials/getting-started/azure-install.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"Cluster Setup",slug:"cluster-setup"},{level:3,title:"Setup and Connect to the Cluster",slug:"setup-and-connect-to-the-cluster"},{level:3,title:"Deploy NGINX Ingress Controller",slug:"deploy-nginx-ingress-controller"},{level:3,title:"Install the Entando Custom Resource Definitions",slug:"install-the-entando-custom-resource-definitions"},{level:2,title:"Deploy Your Entando Application",slug:"deploy-your-entando-application"},{level:2,title:"Appendix A - Troubleshooting",slug:"appendix-a-troubleshooting"}],lastUpdated:"2/18/2022, 2:57:25 PM",lastUpdatedTimestamp:1645214245e3,content:" Installation on Azure Kubernetes Service (AKS) \n Prerequisites \n \n Azure account\n \n Note: If you're using an Azure free account, you may need to upgrade your account first to enable pay-as-you-go billing. The Azure free account default quota includes just 1-4 vCPU which is not sufficient for this tutorial. There may be a delay before the quotas are updated when you upgrade your account. \n \n \n If you're not using Azure Cloud Shell, you'll also need:\n \n Azure command line tool \n Helm3 client \n Overview \n The steps below walk you through installing the Entando platform in an Azure Kubernetes Services (AKS) cluster. These are the basic steps: \n \n Create a single cluster with up to 5 nodes \n Install NGINX as an ingress controller \n Install Entando \n \n If you're already comfortable setting up an AKS cluster and installing NGINX, then you may be able to skip to  setting up Entando . \n Cluster Setup \n Setup and Connect to the Cluster \n \n Login to Azure:  https://portal.azure.com/ \n Select the  Kubernetes services  icon\n \n If the icon isn't visible, click  More services  on the right and search for Kubernetes \n \n \n Click  Create  in the upper left corner \n Select  Create a Kubernetes cluster . You'll start with the  Basics  tab. \n Select a  Resource group  or create one with the  Create new  link if it you don’t have one, e.g.  resource-group-1 \n Enter a name of your choice for the Kubernetes cluster name, e.g.  cluster-1 \n Pick your  Region  if it wasn't automatically selected for you. \n In the  Availability zones  dropdown pick  one and only one  availability zone\n \n Generally, you could pick more than one but it will result in a failure in a quickstart environment. If you chose more than one availability zone you will have to provision storage, manage node affinity, and provide the correct network configuration to ensure your application deploys. We recommend only doing this for production clusters. \n \n \n Select an  Entando-compatible Kubernetes version , e.g.  1.20.x \n Keep the default  Node size , e.g.  Standard DS2 v2 \n Keep the  Scale Method  set to  Autoscale  and the  Node count range  set from  1  to  5 \n Click  Next: Node Pools  to move to the next tab \n Keep the default values here\n \n If you're familiar with AKS you can change these settings as desired \n \n \n Click  Next: Authentication \n For  Authentication method  select  System-assigned managed identity \n \n You can also select  Service principal  to have Azure automatically generate one for you. If you use an existing principal, it is up to you to configure it and ensure you have the access you need. \n \n \n Click  Next: Networking \n Enter a value for DNS name prefix, e.g.  cluster-1-dns \n Click  Review + Create \n \n Note: There are many other configuration options available for an AKS cluster. Generally, you can change these based on your experience and comfort level with the AKS platform. Entando uses base Kubernetes APIs so as long as you follow the Entando configuration instructions below you can tune your cluster infrastructure to meet your goals. \n \n \n Select  Create \n Wait for your cluster to initialize. This may take a few minutes. \n \n Note: A different storage class can be configured by following  these instructions . \n Deploy NGINX Ingress Controller \n \n Navigate to your cluster by clicking  Go to Resource  from the results page or by the top navigation  Home - Kubernetes service  and clicking on your cluster. \n Select  Connect \n Select  Open Cloud Shell \n \n With a new Azure account you may see a warning:  You have no storage mounted . Follow the instructions to create a new storage account. \n \n \n Run the first two commands (e.g.  az account set...  and  az aks get-credentials... ) to connect to your cluster. This should only be needed the first time you run the Azure Cloud Shell.\n \n The following instructions assume you'll use the Azure Cloud Shell but you can also run the commands in a local environment via  kubectl \n \n \n Add the NGINX controller to enable access to the cluster \n \n kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.0.5/deploy/static/provider/cloud/deploy.yaml \n \n See  https://kubernetes.github.io/ingress-nginx/deploy/#azure  for more information. \n \n Get the external IP address for your ingress controller \n \n kubectl get services -n ingress-nginx\n \n The output should be similar to this: \n NAME                      TYPE          CLUSTER-IP    EXTERNAL-IP                        \ningress-nginx-controller  LoadBalancer  10.0.28.197   20.120.54.243\n \n Record the value of the EXTERNAL-IP. \n TIP \n NGINX is working correctly if a  404 Not Found  error page is generated when accessing the EXTERNAL-IP from your browser. Alternatively, you can  set up a simple test application  using either Azure Cloud Shell or your local  kubectl . You can also  customize the NGINX ingress  to optimize the configuration for Entando. \n Install the Entando Custom Resource Definitions \n \n Download the Custom Resource Definitions and, once per cluster, deploy the cluster scoped resources \n \n kubectl apply -f https://raw.githubusercontent.com/entando/entando-releases/v6.3.2/dist/ge-1-1-6/namespace-scoped-deployment/cluster-resources.yaml\n \n \n Create the Entando namespace \n \n kubectl create namespace entando\n \n \n Now install the namespace scoped resources \n \n kubectl apply -n entando -f https://raw.githubusercontent.com/entando/entando-releases/v6.3.2/dist/ge-1-1-6/namespace-scoped-deployment/orig/namespace-resources.yaml\n Deploy Your Entando Application \n You can now deploy your application to Azure Kubernetes Service. \n \n Download and unpack the entando-helm-quickstart files \n \n curl  -sfL https://github.com/entando-k8s/entando-helm-quickstart/archive/v6.3.2.tar.gz  |   tar  xvz\n \n See the included README file for more information on subsequent steps. \n \n Change into the new directory \n \n cd  entando-helm-quickstart-6.3.2\n \n \n Edit  sample-configmaps/entando-operator-config.yaml  and add the following settings in the data section \n \n    entando.requires.filesystem.group.override :   \"true\" \n   entando.ingress.class :   \"nginx\" \n \n \n Now create the ConfigMap for the operator \n \n kubectl apply -f sample-configmaps/entando-operator-config.yaml -n entando\n \n \n Next, in  values.yaml  in the root directory, set the following value:\n \n Set  singleHostName  to the value of the  EXTERNAL-IP  of your  ingress-nginx-controller  and add nip.io to the end:\n \n For example:  singleHostName: 20.120.54.243.nip.io  \n \n \n \n \n Run helm to generate the template file \n \n helm template quickstart -n entando ./  >  quickstart.yaml\n \n \n Deploy Entando via this command \n \n kubectl apply -n entando -f quickstart.yaml \n \n \n Watch Entando startup. It can take around 10 minutes before the application is fully deployed and ready. The application will be available when the  quickstart-composite-app-deployer-*  pod has a status of  Completed . \n \n kubectl get pods -n entando --watch\n \n \n Check for the Entando ingresses using \n \n kubectl describe ingress -n entando\n \n \n Access your application using the URL for the corresponding ingress, e.g.  http://EXTERNAL-IP.nip.io/entando-de-app/ \n \n See the  Getting Started guide  for helpful login instructions and next steps. \n Appendix A - Troubleshooting \n If you get an error like:  0/5 nodes are available: 5 node(s) had volume node affinity conflict.  or if your deployment hangs in a situation like this from  kubectl get pods -n entando \n NAME                                                 READY   STATUS      RESTARTS   AGE\nmy-aks-app-operator-644697776f-sxtq2                 1/1     Running     0          13m\nquickstart-composite-app-deployer-2guz0n42pc         1/1     Running     0          13m\nquickstart-deployer-jj4njqk4bg                       1/1     Running     0          10m\nquickstart-eci-deployer-t0xktqsonk                   0/1     Completed   0          11m\nquickstart-eci-k8s-svc-deployment-78f64c8d89-7c578   1/1     Running     0          11m\nquickstart-kc-deployer-16gzv3clsj                    0/1     Completed   0          13m\nquickstart-kc-server-deployment-7c9bc65744-g52nx     1/1     Running     0          13m\nquickstart-server-deployment-55fcfc6b68-szvkl        0/3     Pending     0          10m\n \n Double check your availability zones. By default an Azure cluster will include nodes from multiple zones, but Azure may not automatically provision their storage. \n You can confirm this error in the AKS console as well: \n \n In your cluster select  Workloads  in the left nav \n Click on the deployment for your server application. This is  quickstart-server-deployment  by default \n Click on the deployment name inside that application. There will be one \n Click on the tab labeled  Conditions \n If you see an error that says  0/5 nodes are available: 5 node(s) had volume node affinity conflict.  Then you need to reconfigure\nyour cluster to have nodes in one zone or work with your Azure operations team to provision storage to match node affinity. \n \n"},{title:"Installation on Kubernetes",frontmatter:{},regularPath:"/v6.3.2/tutorials/getting-started/kubernetes-install.html",relativePath:"v6.3.2/tutorials/getting-started/kubernetes-install.md",key:"v-9bcd09c0",path:"/v6.3.2/tutorials/getting-started/kubernetes-install.html",headers:[{level:2,title:"Infrastructure Requirements",slug:"infrastructure-requirements"},{level:2,title:"Minimum Hardware Requirements",slug:"minimum-hardware-requirements"},{level:3,title:"For Entando install only:",slug:"for-entando-install-only"},{level:3,title:"For Entando + Microservices:",slug:"for-entando-microservices"},{level:3,title:"For Entando with CMS:",slug:"for-entando-with-cms"},{level:2,title:"Backup Strategies",slug:"backup-strategies"},{level:2,title:"Notes",slug:"notes"}],lastUpdated:"1/31/2022, 11:26:30 AM",lastUpdatedTimestamp:164364639e4,content:" Installation on Kubernetes \n Infrastructure Requirements \n These are the minimum infrastructure requirements to install Entando directly on a Kubernetes (K8s) cluster: \n \n A working DNS server configured to resolve internal and external names. If you choose to configure K8s with a global wildcard domain name for the entire cluster, be sure it points to the public IP address of the external Load Balancer of the worker nodes. \n A default  Storage Class  is needed for the Entando Operator to create the correct Persistent Volume Claims (PVC) for each pod. \n Nginx  Ingress-Controller  is needed to expose the Entando applications. \n Minimum Hardware Requirements \n The minimum hardware requirements depend on how you intend to use Entando. The more functionality you need, such as a content management system (CMS), the more you will need. \n For Entando install only: \n \n 6 vCPU or virtual central processing unit  (6000 millicores) \n 6 GB of RAM \n 5 GB of allocated storage distributed in many PVCs \n \n Configure a single worker node with the requirements above or designate 3 worker nodes with the minimum of 2 PVC and 4 GB of RAM each. \n For Entando + Microservices: \n \n 500 millicores per microservice or \n 1000 millicores per microservice with a database \n \n The tested instance was generated with a JHipster Entando blueprint. \n For Entando with CMS: \n To install Entando with CMS, the hardware requirements depend on the complexity and number of pages and contents. The minimum requirements are: \n \n 9 vCPU for a single CMS instance. To scale up, you need 4 vCPU per replica. \n 8 GB of RAM for a single CMS instance. To scale up, you need 4 GB of RAM per replica. \n A minimum of 50 GB of storage for all the static resources generated by the use of Entando CMS. \n Backup Strategies \n The recommended method to secure your content is to use database services that automate backups and restores on a Kubernetes cluster like Azure, Red Hat OpenShift, Google K8s Service, Tanzu K8s Grid or Amazon Elastic. If this is not an option, there are tools like  Velero  and  Cloudcase  to manage them. \n Note: Some DevOps teams warn against running databases inside pods in production environments. \n If using the Entando CMS, be sure to protect related schemas ( port  and  serv ) with a valid disaster recovery plan. Protect all volumes containing your static resources with daily snapshots. \n Notes \n See the  Entando compatibility guide  for compatible Kubernetes versions. \n"},{title:"Installation on Amazon Elastic Kubernetes Service (EKS)",frontmatter:{sidebarDepth:2},regularPath:"/v6.3.2/tutorials/getting-started/eks-install.html",relativePath:"v6.3.2/tutorials/getting-started/eks-install.md",key:"v-27a911b8",path:"/v6.3.2/tutorials/getting-started/eks-install.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"Cluster Setup",slug:"cluster-setup"},{level:3,title:"Setup and Connect to the Cluster",slug:"setup-and-connect-to-the-cluster"},{level:3,title:"Install the NGINX Ingress Controller",slug:"install-the-nginx-ingress-controller"},{level:3,title:"Install the Entando Custom Resource Definitions",slug:"install-the-entando-custom-resource-definitions"},{level:2,title:"Deploy Your Entando Application",slug:"deploy-your-entando-application"},{level:2,title:"Appendix A - Troubleshooting",slug:"appendix-a-troubleshooting"}],lastUpdated:"2/18/2022, 2:57:25 PM",lastUpdatedTimestamp:1645214245e3,content:' Installation on Amazon Elastic Kubernetes Service (EKS) \n Prerequisites \n \n AWS CLI \n AWS account \n kubectl \n helm3 client \n Overview \n The steps below walk you though installing the Entando platform in an EKS cluster. Generally the steps are: \n \n Configure an IAM role to allow kubernetes to manage the cluster \n Create an EKS cluster with 5 nodes (to allow expansion for microservices) \n Install NGINX as an ingress controller in the cluster \n Install Entando \n \n If you\'re already comfortable setting up an EKS cluster and installing NGINX then you may be able to skip to  setting up Entando . \n Cluster Setup \n These steps will use the AWS console to create the cluster. If you’re already familiar with creating an EKS cluster and assigning nodes to it via the AWS cli then you can use the cli process for cluster creation as well. \n Setup and Connect to the Cluster \n \n Login to AWS as a non-super admin user\n \n If you don’t have a user besides the super admin it is recommended that you create one. Clusters created using the super admin for your account will have some restrictions that may complicate your installation. \n Your user will need access to EKS and at least the ability to create a cluster. You may need additional policies for Route53 and other services depending on your exact configuration. \n \n \n Create an IAM role for the cluster so that AWS can provision assets. See  https://docs.aws.amazon.com/eks/latest/userguide/worker_node_IAM_role.html  for more details.\n \n Go to  IAM → Roles → Create Role \n Select  AWS Service  for the type of trusted entity \n Click  EKS  from the main list \n Click  EKS - Cluster  under  Select your use case \n Click  Next: Permissions \n A Policy of  AmazonEKSClusterPolicy  should already be present \n Click  Next: Tags \n (Optional) Add tags if you want \n Click  Next: Review \n Name your role (you’ll need this later), e.g.  my-eks-role \n \n \n Refine the role to enable Node Groups management and to add ELB access so that the cluster can deploy a load balancer for NGINX.\n \n Go to  IAM → Roles → my-eks-role \n Under Permissions click  Attach policies \n Add a policy of  AmazonEKSWorkerNodePolicy \n Add a policy of  AmazonEKS_CNI_Policy \n Add a policy of  AmazonEC2ContainerRegistryReadOnly \n Add a policy of  ElasticLoadBalancingFullAccess \n Under Trust Relationships click  Edit trust relationship . Add  ec2.amazonaws.com  so the cluster can manage the EC2 resources. \n \n \n \n     {\n      "Effect": "Allow",\n      "Principal": {\n        "Service": "ec2.amazonaws.com"\n      },\n      "Action": "sts:AssumeRole"\n    }\n \n \n Go to  Services  and select  Elastic Kubernetes Service \n Create an EKS Cluster\n \n Add a cluster name (e.g.  cluster-1 ) and click  Create EKS cluster \n Select an  Entando-compatible Kubernetes version , e.g.  1.20 \n For  Cluster Service Role , select the role you created above, e.g.  my-eks-role . If you choose a different role it must have ELB permissions so the cluster can create a load balancer in  Networking . \n Click  Next \n Use the defaults for  Networking  and click  Next \n Use the defaults for  Configure Logging  and click  Next . \n Review your settings and then click  Create . Cluster provisioning usually takes between 10 and 15 minutes. \n See  https://docs.aws.amazon.com/eks/latest/userguide/create-cluster.html  for more information on cluster creation. \n \n \n Add a Node Group to the cluster\n \n Go to  Services → Elastic Kubernetes Service → Clusters  and click on your cluster name. \n Go to  Configuration  and the  Compute  tab \n Click  Add Node Group \n Name : give your group a name, e.g.  node-1 \n Node IAM Role : Select the cluster role you created above. If the role doesn\'t appear, verify that you added the extra policies to the role. \n Click  Next \n Review the Compute and Scaling configuration. Typically the AWS defaults should work. \n AMI type:  Amazon Linux 2 \n Instance type:  t3.medium \n Review the Node Group scaling configuration \n Set  Maximum size  to 5. This will be over-resourced for a  Getting Started  experience but will leave capacity for adding microservices to your cluster without modifying the Nodegroup. \n Click  Next \n Review the Node Group network configuration. \n Subnets  - VPC subnets should already be setup and selected. \n Select  Configure SSH access to nodes .  Follow the instructions to create a new SSH key pair if you don\'t already have one. \n Select  All  to allow all source IPs to access the nodes, or to set your own restrictions via Selected Security Groups. \n Click  Next \n Review your settings and then click  Create . It may take a few minutes for the node to be created. \n \n \n Connect  kubectl  to the cluster\n \n Note:  If this is a brand new setup you will need to login using the user you used to create your cluster in the console in the steps above. Make sure the users match.\n \n aws-configure  (and then provide the Access key, etc.) \n \n \n Setup your kube context via  aws eks --region region-code update-kubeconfig --name cluster_name , e.g.  aws eks --region us-east-2 update-kubeconfig --name cluster-1 \n More details and troubleshooting  https://docs.aws.amazon.com/eks/latest/userguide/create-kubeconfig.html \n Your current context should now be configured for your AWS cluster. Run the command below to check: \n \n kubectl config current-context\n \n Your output should look something like this: arn:aws:eks:us-east-2:483173223614:cluster/cluster-1\n Install the NGINX Ingress Controller \n \n Add the NGINX controller for ingress. This depends on your role having permissions for ELB.\n \n For basic NGINX ingress install run this command \n \n kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.0.2/deploy/static/provider/cloud/deploy.yaml\n \n \n See  https://kubernetes.github.io/ingress-nginx/deploy/#aws  as well as  this  for more detailed install steps. \n \n \n Get the ELB external URL for your NGINX install\n \n Run:  kubectl get services -n ingress-nginx \n Get the value of the external address (EXTERNAL-IP) for the ingress-nginx-controller: \n \n \n \n NAME                                 TYPE           CLUSTER-IP       EXTERNAL-IP                        \ningress-nginx-controller             LoadBalancer   10.100.102.83    ad234bd11a1ff4dadb44639a6bbf707e-0e0a483d966405ee.elb.us-east-2.amazonaws.com\n \n TIP \n NGINX is working correctly if a  404 Not Found  error page is generated when accessing the EXTERNAL-IP from your browser. Alternatively, you can  set up a simple test application  using your local  kubectl . You can also  customize the NGINX ingress  to optimize the configuration for Entando. \n Install the Entando Custom Resource Definitions \n Once per cluster you need to deploy the  Entando Custom Resources . \n \n Download the Custom Resource Definitions and deploy the cluster scoped resources \n \n kubectl apply -f https://raw.githubusercontent.com/entando/entando-releases/v6.3.2/dist/ge-1-1-6/namespace-scoped-deployment/cluster-resources.yaml\n \n Next you can create a namespace for the Entando Application. \n \n Create the namespace \n \n kubectl create namespace entando\n \n \n Install the namespace scoped resources \n \n kubectl apply -n entando -f https://raw.githubusercontent.com/entando/entando-releases/v6.3.2/dist/ge-1-1-6/namespace-scoped-deployment/orig/namespace-resources.yaml\n \n If you run  kubectl -n entando get pods , you\'ll see the Entando operator is now running. \n Deploy Your Entando Application \n You can now deploy your application to Amazon EKS. \n \n Download and unpack the  entando-helm-quickstart  release: \n \n curl  -sfL https://github.com/entando-k8s/entando-helm-quickstart/archive/v6.3.2.tar.gz  |   tar  xvz\n \n \n See the included README file for more information on the following steps. \n \n \n Go to the downloaded directory \n \n cd  entando-helm-quickstart-6.3.2\n \n \n Edit  sample-configmaps/entando-operator-config.yaml  and add the following settings in the data section \n \n    entando.requires.filesystem.group.override :   "true" \n   entando.ingress.class :   "nginx" \n \n \n Now create the ConfigMap for the operator \n \n kubectl apply -f sample-configmaps/entando-operator-config.yaml -n entando\n \n \n Next, in  values.yaml  in the root directory set the following value:\n \n Set  singleHostName  to the value of the  EXTERNAL-IP  of your  ingress-nginx-controller :\n \n For example:  singleHostName: ad234bd11a1ff4dadb44639a6bbf707e-0e0a483d966405ee.elb.us-east-2.amazonaws.com \n \n \n \n \n Run helm to generate the template file: \n \n helm template my-eks-app -n entando ./  >  my-eks-app.yaml\n \n \n Deploy Entando via this command \n \n kubectl apply -n entando -f my-eks-app.yaml \n \n \n Watch Entando startup  kubectl get pods -n entando --watch . It can take around 10 minutes before the application is fully deployed and ready. \n Check for the Entando ingresses using  kubectl describe ingress -n entando \n Access your app using the URL for the ingress of the App Builder. This will be the URL of your load balancer, followed by  /app-builder/  or  /entando-de-app/  for the deployed application, e.g.  http://ad234bd11a1ff4dadb44639a6bbf707e-0e0a483d966405ee.elb.us-east-2.amazonaws.com/app-builder/ \n \n See the  Getting Started guide  for helpful login instructions and next steps. \n Appendix A - Troubleshooting \n IAM and Roles \n \n https://docs.aws.amazon.com/eks/latest/userguide/install-aws-iam-authenticator.html \n https://stackoverflow.com/questions/56863539/getting-error-an-error-occurred-accessdenied-when-calling-the-assumerole-oper \n \n NGINX \n \n https://docs.nginx.com/nginx/deployment-guides/amazon-web-services/ingress-controller-elastic-kubernetes-services/ \n Issue with permissions for NGINX ingress: \n \n  Warning  SyncLoadBalancerFailed   38m                 service-controller  (combined from similar events): Error syncing load balancer: failed to ensure load balancer: error creating\n \n '},{title:"Installation on Google Kubernetes Engine (GKE)",frontmatter:{},regularPath:"/v6.3.2/tutorials/getting-started/gke-install.html",relativePath:"v6.3.2/tutorials/getting-started/gke-install.md",key:"v-3686193c",path:"/v6.3.2/tutorials/getting-started/gke-install.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Cluster Setup",slug:"cluster-setup"},{level:3,title:"Install the NGINX Ingress Controller",slug:"install-the-nginx-ingress-controller"},{level:3,title:"Install the Entando Custom Resource Definitions",slug:"install-the-entando-custom-resource-definitions"},{level:2,title:"Deploy Your Entando Application",slug:"deploy-your-entando-application"},{level:3,title:"Setup and Deploy",slug:"setup-and-deploy"},{level:2,title:"TLS Notes",slug:"tls-notes"},{level:2,title:"Workaround for invalid login form, redirect when using TLS",slug:"workaround-for-invalid-login-form-redirect-when-using-tls"},{level:2,title:"Appendix A: Configuring Clustered Storage",slug:"appendix-a-configuring-clustered-storage"},{level:3,title:"Clustered Storage Using GCP Cloud Filestore",slug:"clustered-storage-using-gcp-cloud-filestore"}],lastUpdated:"2/18/2022, 2:57:25 PM",lastUpdatedTimestamp:1645214245e3,content:' Installation on Google Kubernetes Engine (GKE) \n Prerequisites \n \n Google Cloud account:  http://cloud.google.com/ \n Install these tools locally if you\'re not using the Google Cloud Shell steps below:\n \n Google Cloud SDK  including gcloud \n kubectl  command line tool \n Cluster Setup \n These steps only need to be completed once per cluster. \n \n Login to your Google Cloud account:  https://cloud.google.com/ \n Go to  Kubernetes Engine → Clusters \n Select an existing project or create a new one. \n Click Enable for the  Kubernetes Engine API \n Once the API is enable, click  Create  to create a cluster \n Click the  Configure  button for the  GKE Standard  option. Unless otherwise indicated you can keep the default configuration options. \n On the left menu select  default-pool → Nodes \n For a basic test cluster with a single Entando application, select e2-standard-2 for the Machine type. For a shared cluster with multiple Entando applications or higher performance, you may want more CPUs and memory. (See  Appendix A  for details on clustered storage.) \n Click  Create \n Wait for the cluster to initialize. This will take a few minutes. There will be a green check mark when complete. \n Click  Connect  for your new cluster. \n Click  Run in Cloud Shell \n \n Alternatively, copy the provided command and execute it in your local environment to connect your local  kubectl  to your GKE cluster. \n \n \n Run  kubectl get namespaces  to verify your connection: \n \n a_user@cs-6000-devshell-vm-c34ef644-5584-4c5d-aa14-6e41af4a5c9a:~$ kubectl get namespaces\nNAME              STATUS   AGE\ndefault           Active   6m11s\nkube-node-lease   Active   6m12s\nkube-public       Active   6m12s\nkube-system       Active   6m13s\n Install the NGINX Ingress Controller \n Entando isn’t compatible out of the box  with the default ingress controller provided in GKE.\nSee here for more if you’re interested in GKE ingress:  https://cloud.google.com/kubernetes-engine/docs/concepts/ingress \n We’re going to install the NGINX ingress controller to manage the ingresses for Entando services\ndeployed by the operator. This will be a simpler and more adaptable configuration for most users and\nenvironments. Users who really need the GKE ingress controller (rare) could integrate it following\nthe instructions provided by GKE and then customize the service definition created by the Entando\noperator. \n These are the minimal instructions to prepare NGINX ingress using the Google Cloud Shell. To install it\nusing your local  kubectl  or to vary other settings please see the more detailed documents here:\n https://cloud.google.com/community/tutorials/nginx-ingress-gke  and  https://kubernetes.github.io/ingress-nginx/deploy/#gce-gke . \n \n Initialize your user as a cluster-admin: \n \n kubectl create clusterrolebinding cluster-admin-binding --clusterrole cluster-admin \\\n--user $(gcloud config get-value account)\n \n \n Install the ingress controller pods: \n \n kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/provider/cloud/deploy.yaml\n \n \n To check if the ingress controller pods have started, run the following command: \n \n    kubectl get pods -n ingress-nginx \\\n     -l app.kubernetes.io/name=ingress-nginx --watch\n \n \n Wait until the ingress-nginx-controller status changes to  Running : \n \n NAME                                        READY   STATUS      RESTARTS   AGE\ningress-nginx-admission-create-27tgt        0/1     Completed   0          65s\ningress-nginx-admission-patch-7wmgl         0/1     Completed   1          65s\ningress-nginx-controller-7656c59dc4-7xgmc   1/1     Running     0          75s\n \n \n Get the external IP address for your ingress controller. Record the value of EXTERNAL-IP for  nginx-ingress-controller  from the command below. Retry the following command if the EXTERNAL-IP shows  <pending>  at first. \n \n kubectl get service -n ingress-nginx\n \n TIP \n NGINX is working correctly if a  404 Not Found  error page is generated when accessing the EXTERNAL-IP from your browser. Alternatively, you can  set up a simple test application  using your local  kubectl . You can also  customize the NGINX ingress  to optimize the configuration for Entando. \n Install the Entando Custom Resource Definitions \n Once per cluster you need to deploy the  Entando Custom Resources . \n \n Download the Custom Resource Definitions and deploy the cluster scoped resources \n \n kubectl apply -f https://raw.githubusercontent.com/entando/entando-releases/v6.3.2/dist/ge-1-1-6/namespace-scoped-deployment/cluster-resources.yaml\n \n Next you can create a namespace for the Entando Application. If you select your own name then update the following commands whenever a namespace is provided. \n \n Create the namespace \n \n kubectl create namespace entando\n \n \n Install the namespace scoped resources \n \n kubectl apply -n entando -f https://raw.githubusercontent.com/entando/entando-releases/v6.3.2/dist/ge-1-1-6/namespace-scoped-deployment/orig/namespace-resources.yaml\n Deploy Your Entando Application \n You can now deploy your Entando application to GKE. \n Setup and Deploy \n \n Download and unpack the entando-helm-quickstart: \n \n curl -sfL https://github.com/entando-k8s/entando-helm-quickstart/archive/v6.3.2.tar.gz | tar xvz\n \n \n See the included README file for more information on the following steps. \n \n \n Go to the downloaded directory \n \n cd entando-helm-quickstart-6.3.2\n \n \n Edit  sample-configmaps/entando-operator-config.yaml  and add these properties (taking of correct yaml spacing): \n \n   entando.requires.filesystem.group.override: "true"\n  entando.ingress.class: "nginx"\n \n \n Run this command: \n \n kubectl apply -f sample-configmaps/entando-operator-config.yaml -n entando\n \n \n \n In the root directory edit  values.yaml \n \n change the dbms setting from  embedded  to  postgresql \n set  singleHostName  to EXTERNAL-IP.nip.io, e.g. 11.111.111.111.nip.io. An alternative is to route your own DNS to the EXTERNAL-IP but this setup will work immediately. \n \n \n \n Run helm to generate the template file: \n \n \n helm template quickstart --namespace=entando ./ > quickstart.yaml\n \n \n Deploy the Entando Application \n \n kubectl apply -n entando -f quickstart.yaml\n \n \n Watch the deployment for completion \n \n kubectl -n entando get pods --watch\n \n Watch Entando startup. The application will be available when the  quickstart-composite-app-deployer  pod has a status of completed \n NAME                                                 READY   STATUS    RESTARTS   AGE\nentando-operator-5cdf787869-s8bwg                    1/1     Running   0          18m\nquickstart-ab-deployment-5655bc6cc6-g55kr            1/1     Running   0          98s\nquickstart-cm-deployment-6565fc67b8-cwgpc            0/1     Running   0          62s\nquickstart-composite-app-deployer-9419               1/1     Running   0          10m\nquickstart-db-deployment-6fdb96f98c-fgm5g            1/1     Running   0          5m55s\nquickstart-deployer-9708                             1/1     Running   0          6m3s\nquickstart-eci-k8s-svc-deployment-588ffd65c8-p5xcl   1/1     Running   0          7m7s\nquickstart-kc-db-deployment-67c7fd4fbf-scwvj         1/1     Running   0          10m\nquickstart-kc-server-deployment-7dbcc968f8-rg5lc     1/1     Running   0          9m31s\nquickstart-server-deployment-6d966c78c4-tp6cz        1/1     Running   0          3m17s\n TLS Notes \n If you have configured TLS related to the ingress for the ECI service \n \n After the installation patch the ingress path for the ECI to include a trailing slash \n \n kubectl -n {NAMESPACE} patch ingress quickstart-eci-ingress --type=\'json\' -p=\'[{"op": "replace", "path": "/spec/rules/0/http/paths/0/path", "value":"/k8s/"}]\'\ningress.extensions/quickstart-eci-ingress patched\n Workaround for invalid login form, redirect when using TLS \n \n In your application manifest add \n \n kind: EntandoCompositeApp\nspec:\n  components:\n  - kind: EntandoKeycloakServer\n    spec:\n      environmentVariables:\n        - name: APPLICATIONBASEURL\n          value: https://{HOSTNAME}/entando-de-app/\n \n \n In App Builder under  Pages → Settings  set  Base URL  to  Static \n Appendix A: Configuring Clustered Storage \n In order to scale an Entando Application across multiple nodes you must provide a storage class that supports\na  ReadWriteMany  access policy. There are many ways to accomplish this including using dedicated storage providers\nlike GlusterFS or others. \n The instructions below provide an example of configuring using the GCP Cloud Filestore to provide the clustered storage\nbut if you have an existing enterprise clustered file solution and you can expose it as a StorageClass it is recommended to\nuse and test that configuration. \n TIP \n You can also scale an Entando Application without clustered storage using a  ReadWriteOnce (RWO)  policy by ensuring that the\ninstances are all scheduled to the same node. This can be accomplished using taints on other nodes. Be aware of the pros and cons of scheduling\ninstances to the same node. This will give you protection if the application instance itself dies or becomes unreachable and will help\nyou get the most utilization of node resources. However, if the node dies or is shutdown you will have to wait for Kubernetes to reschedule the pods to a different node and your application will be down. \n Clustered Storage Using GCP Cloud Filestore \n \n In the GCP portal in the left menu find the Storage section and select  Filestore -> Instances \n Enable the Filestore if you haven\'t already \n Select Create Instance \n Fill in the fields keeping the defaults or updating to fit your specific needs. Remember your Instance ID \n Once the instance is created on the Filestore main page note the IP address of your NFS \n Now install the provisioner that will  create the StorageClass that will allow deployment of Entando Applications using the commands below replacing\n [your nfs ip]  and  [your nfs path]  with the IP address of your cluster and with the instance ID you chose above. \n \n helm repo add nfs-subdir-external-provisioner https://kubernetes-sigs.github.io/nfs-subdir-external-provisioner/\n \n helm install nfs-subdir-external-provisioner nfs-subdir-external-provisioner/nfs-subdir-external-provisioner \\\n    --set nfs.server=[your nfs ip] \\\n    --set nfs.path=[your nfs path]\n \n Read more about the provisioner and additional configuration options here:\nhttps://github.com/kubernetes-sigs/nfs-subdir-external-provisioner \n \n Check to ensure your client provisioned successfully \n \n kubectl get sc\n \n Looking for the storage class with a name of  nfs-client . For example, \n NAME                 PROVISIONER                                     RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE\nnfs-client           cluster.local/nfs-subdir-external-provisioner   Delete          Immediate              true                   37m\npremium-rwo          pd.csi.storage.gke.io                           Delete          WaitForFirstConsumer   true                   27h\nstandard (default)   kubernetes.io/gce-pd                            Delete          Immediate              true                   27h\nstandard-rwo         pd.csi.storage.gke.io                           Delete          WaitForFirstConsumer   true                   27h\n \n \n In your operator config map add these two variables: \n \n entando.k8s.operator.default.clustered.storage.class: "nfs-client"\nentando.k8s.operator.default.non.clustered.storage.class: "standard"\n \n \n Deploy your Entando Application using the instructions above and the server instances will\nautomatically use the clustered storage. \n \n'},{title:"Installation on Red Hat OpenShift using the OperatorHub",frontmatter:{sidebarDepth:2,redirectFrom:"/v6.3.2/tutorials/devops/installation/open-shift/openshift-install-by-operator-hub.html"},regularPath:"/v6.3.2/tutorials/getting-started/openshift-install-by-operator-hub.html",relativePath:"v6.3.2/tutorials/getting-started/openshift-install-by-operator-hub.md",key:"v-531d2164",path:"/v6.3.2/tutorials/getting-started/openshift-install-by-operator-hub.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Scenario 1.1 - Embedded Database",slug:"scenario-1-1-embedded-database"},{level:2,title:"Scenario 1.2 - PostgreSQL",slug:"scenario-1-2-postgresql"},{level:2,title:"Scenario 1.3 - PostgreSQL plus OpenShift SSL",slug:"scenario-1-3-postgresql-plus-openshift-ssl"},{level:2,title:"Scenario 1.4 - PostgreSQL plus self-signed SSL",slug:"scenario-1-4-postgresql-plus-self-signed-ssl"},{level:2,title:"Scenario 1.5 - Cluster-scoped operator with wildcard SSL",slug:"scenario-1-5-cluster-scoped-operator-with-wildcard-ssl"},{level:2,title:"Scenario 2.1 - Developer Project",slug:"scenario-2-1-developer-project"},{level:2,title:"Next Steps",slug:"next-steps"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:" Installation on Red Hat OpenShift using the OperatorHub \n Overview \n The following tutorial shows how to install an Entando application using the Red Hat-certified  Entando Operator  and covers a few common enterprise configurations. If you're working with an OpenShift version prior to 4.6 then you may require the alternative  manual instructions . \n We have two sets of scenarios listed below: \n \n Scenario 1.1-1.5 for cluster admins who can create projects and operators \n Scenario 2.1 for users with access to administer projects \n \n Scenario 1.1 is similar to the Entando quickstart style of deployment and can be applied in many environments, including on local developer laptops. The subsequent scenarios (1.2-1.5) build on this initial configuration and can be performed independently. Unless otherwise noted, you have the freedom to retain or modify the default settings when installing the  Entando Operator  and other resources. \n Prerequisites \n \n A 4.6 (or higher) OpenShift installation\n \n For simplicity the tutorial instructions are for a local Code Ready Containers (CRC) instance but this will require significant dedicated resources, e.g. at least 4 vCPU and 10GB RAM. In some environments you may need to start CRC using  crc start -n 8.8.8.8  in order to install operators. \n \n \n (For scenarios 1.x) cluster-admin access to OpenShift for initial installation of the Entando Operator \n (For scenarios 2.x) namepace-level access to a specific OpenShift project for installation of an Entando application using an Entando Operator installed in the cluster \n Familiarity with the OpenShift console and operation \n Scenario 1.1 - Embedded Database \n The initial scenario is to deploy the operator and Entando application in a single namespace. We'll start with the smallest application footprint which uses an embedded database. \n \n Locate the  Entando Operator  in the  Operators → OperatorHub  using the Filter feature. \n Click  Install  to view the  Entando Operator  install options. \n Select  A specific namespace on the cluster  for the  Installation mode . \n Choose an empty namespace for  Installed Namespace . You can create one from  Home → Projects  first, if needed, e.g.  entando-one . \n Click  Install  to install the operator into your target namespace. \n The install may take a few minutes to complete after which you can click  View Operator  to see the operator in your namespace, or you can go to  Operators → Installed Operators  at any point and select it from there. \n Now go to  Entando Composite Application  and click  Create instance \n Change the  Dbms Override  to  embedded . This is the lightest and quickest way to test a full Entando application but you'll need to modify the YAML as well in step 10. \n (Optional) If you're working in anything but a single project environment, you'll need to provide an  Ingress Host Name Override  specific to your namespace, e.g.  entando-one.<my-base-openshift-url>.  In CRC you can keep the default  entando.apps-crc.testing  for your first project. \n Switch to the YAML view and remove the following section since it isn't needed with an embedded database. \n \n     - kind: EntandoDatabaseService\n      metadata:\n        name: inline-entando-database-service\n      spec:\n        createDeployment: true\n \n \n (Optional) Feel free to edit the YAML to customize the names of the components deployed by the EntandoCompositeApp, e.g.  inline-entando-database-service \n Click  Create . The  Entando Operator  will now proceed to deploy the appropriate resources. \n Go to  Entando Composite Application → my-entando-composite-app  to check the status of the deploy or its  Events  tab to follow its progress. \n \n See the  Next Steps  below to continue your work with Entando. \n Scenario 1.2 - PostgreSQL \n For this scenario we'll prepare a more production-like configuration. Here we'll switch from an embedded on-disk database to a dedicated PostgreSQL database. For this scenario we'll start where step 6 ends in the previous scenario. If you already ran Scenario 1.1 you can either go to that project and remove the Composite App via  Installed Operators → Entando Operator → Entando Composite Application  or prepare a new project using steps 1-5 above. \n Now let's create a new application, this time using PostgreSQL. \n \n Go to  Entando Composite Application  and click  Create instance \n Keep the default  Dbms Override  as  postgresql . You should not remove the EntandoDatabaseService in this case. \n (Optional) Set the  Ingress Host Name Override  as in step 9 above. \n Click  Create . The  Entando Operator  will now proceed to deploy the appropriate resources just as in Scenario 1.1 but with the addition of a PostgreSQL database deployment. \n \n See the  Next Steps  below to continue your work with Entando. \n Scenario 1.3 - PostgreSQL plus OpenShift SSL \n For this scenario we'll build on Scenario 1.2 but enable SSL using OpenShift's internal Certificate Authority. As a starting point, you can either remove the Composite App from the previous scenarios or prepare a new project per steps 1-5 in Scenario 1.1. \n \n Using your browser, examine and save the SSL certificate for your environment. For example, in Chrome, go to any OpenShift console page, click on  View Site Information  next to the URL (it may be labeled  Not secure  ) then go to  Details -> Copy to File  and save the certificate as a Base-64 encoded X.509 file, e.g.  openshift.cer. \n Go to  Workflows → Secrets → Create  and select  Key/value secret \n Set the  Secret Name , e.g.  entando-ca-cert-secret \n Set the  Key , e.g.  openshift.cer \n Set the  Value  by clicking  Browse...  and loading the file you saved in Step 1. \n Click  Create \n Next go to  Workloads → ConfigMaps  and create a ConfigMap named  entando-operator-config  This is the ConfigMap used by the Operator to configure the deployments. You'll need to supply your own project name for the namespace. \n \n kind: ConfigMap\napiVersion: v1\nmetadata:\n name: entando-operator-config\n namespace: entando-one\ndata:\n entando.ca.secret.name: entando-ca-cert-secret\n entando.use.auto.cert.generation: 'true'\n \n \n Click  Create \n \n Now let's create a new application, just like in Scenario 1.2 but with OpenShift SSL in place. \n \n Go to  Entando Composite Application  and click  Create instance \n Keep the default  Dbms Override  as  postgresql . \n (Optional) Set the  Ingress Host Name Override  as in Scenario 1 step 9. \n You don't need to set the  TLS Secret Name Override  since it will be taken from the  entando-operator-config  ConfigMap. \n Click  Create . The  Entando Operator  will now proceed to deploy the appropriate resources. \n \n Once the deployment is complete you can confirm that all routes use https with OpenShift's CA. You will likely still see security warnings in the browser. \n See the  Next Steps  below to continue your work with Entando. \n Scenario 1.4 - PostgreSQL plus self-signed SSL \n This scenario is similar to Scenario 1.3 but here we'll use a self-signed certificate rather than using OpenShift's Certificate Authority. As a starting point, you can either remove the Composite App from the previous scenarios or prepare a new project per steps 1-5 in Scenario 1.1. \n We'll start by creating a self-signed certificate and then preparing the Secrets and ConfigMap to match. There are various ways to create an X.509 self-signed certificate and you can use your own preferred mechanism. \n \n Using  OpenSSL  create a certificate for your application. You'll need to adjust the CN value to match your project. \n \n openssl req -nodes -x509 -newkey rsa:4096 -keyout tls.key -out tls.crt -days 365 -subj \"/CN=entando.apps-crc.testing\"\n \n You should see output similar to this: \n Generating a RSA private key\n.....................................................................++++\n........................................................................................................................................................................................++++\nwriting new private key to 'tls.key'\n-----\n \n Now we can create a TLS Secret using the generated files. \n \n Go to  Workloads → Secrets → Create  and select  From YAML . \n Enter this  YAML , update the namespace to match your project, and click  Create : \n \n kind: Secret\napiVersion: v1\nmetadata:\n  name: entando-tls-secret\n  namespace: entando-one\ndata:\n  tls.key: ''\n  tls.crt: ''\ntype: kubernetes.io/tls\n \n \n Click on  Actions → Edit Secret  and use the  Browse...  buttons to upload the key and cert files. \n \n Now we'll also create the  entando-ca-cert-secret  Secret, similar to what was done in Scenario 1.3 but now using the self-signed certificate. \n \n Go to  Workflows → Secrets → Create  and select  Key/value secret \n Set the  Secret Name , e.g.  entando-ca-cert-secret \n Set the  Key , e.g.  cert1.crt \n Set the  Value  by clicking  Browse...  and loading the cert file from Step 1, e.g.  tls.crt \n Click  Create \n Next go to  Workloads → ConfigMaps  and create a ConfigMap named  entando-operator-config.  This is the ConfigMap used by the Operator to configure the deployments. You'll need to supply your own project name for the namespace. \n \n kind: ConfigMap\napiVersion: v1\nmetadata:\n name: entando-operator-config\n namespace: entando-one\ndata:\n entando.ca.secret.name: entando-ca-cert-secret\n entando.tls.secret.name: entando-tls-secret\n \n \n Click  Create \n \n Now let's create a new application, just like in Scenario 1.3 but with the self-signed SSL certificate. \n \n Go to  Entando Composite Application  and click  Create instance \n Keep the default  Dbms Override  as  postgresql . \n (Optional) Set the  Ingress Host Name Override  as in Scenario 1.1 step 9. \n You don't need to set the  TLS Secret Name Override  since it will be taken from the  entando-operator-config  ConfigMap. \n Click  Create . The  Entando Operator  will now proceed to deploy the appropriate resources. \n \n Once the deployment is complete you can confirm that all routes use https with the self-signed certificate. You will still see security warnings in the browser. \n See the  Next Steps  below to continue your work with Entando. \n Scenario 1.5 - Cluster-scoped operator with wildcard SSL \n For this scenario we'll install the Entando Operator so the same operator instance can manage applications across namespaces. \n \n Locate the  Entando Operator  in the  Operators → OperatorHub  using the Filter feature. \n Click  Install  to view the  Entando Operator  install options. \n Select  All namespaces on the cluster  for the  Installation mode . \n Keep the default  openshift-operators  for the  Installed Namespace . \n Click  Install  to install the operator into the cluster. \n \n Now, similar to Scenario 1.4, we'll setup a self-signed certificate but this time as a wildcard certificate and then configure the Secrets and ConfigMap to match. There are various ways to create an X.509 self-signed certificate and you can use your own preferred mechanism. \n \n Using  OpenSSL  create a certificate for your application. You'll need to adjust the CN value to match your environment but make sure to include the leading  *.  for the wildcard designation. \n \n openssl req -nodes -x509 -newkey rsa:4096 -keyout tls.key -out tls.crt -days 365 -subj \"/CN=*.apps-crc.testing\"\n \n You should see output similar to this: \n Generating a RSA private key\n.....................................................................++++\n........................................................................................................................................................................................++++\nwriting new private key to 'tls.key'\n-----\n \n Now we can go to the  openshift-operators  project and create a TLS Secret using the generated files. \n \n Go to  Workloads → Secrets → Create  and select  From YAML . \n Enter this  YAML  and click  Create : \n \n kind: Secret\napiVersion: v1\nmetadata:\n  name: entando-tls-secret\n  namespace: openshift-operators\ndata:\n  tls.key: ''\n  tls.crt: ''\ntype: kubernetes.io/tls\n \n \n Click on  Actions → Edit Secret  and use the  Browse...  buttons to upload the key and cert files. \n \n Now we'll also create the  entando-ca-cert-secret  Secret using the self-signed wildcard certificate. \n \n Go to  Workflows → Secrets → Create  and select  Key/value secret \n Set the  Secret Name , e.g.  entando-ca-cert-secret \n Set the  Key , e.g.  cert1.crt \n Set the  Value  by clicking  Browse...  and loading the cert file from Step 1, e.g.  tls.crt \n Click  Create \n Next go to  Workloads → ConfigMaps  and create a ConfigMap named  entando-operator-config.  This is the ConfigMap used by the Operator to configure the deployments. You'll need to supply the routing suffix for your environment. Don't include a leading  *.  since this is just the suffix. \n \n kind: ConfigMap\napiVersion: v1\nmetadata:\n name: entando-operator-config\n namespace: openshift-operators\ndata:\n entando.ca.secret.name: entando-ca-cert-secret\n entando.tls.secret.name: entando-tls-secret\n entando.default.routing.suffix: apps-crc.testing \n \n \n Click  Create \n You can now proceed to create one or more Entando applications in their own namespaces, e.g. using the steps for Scenario 1.1 starting from Step 7 or as a different user in Scenario 2.1. You can leave out the  Ingress Host Name Override  since the cluster-scoped operator will provide it for you based on the routing.suffix. \n \n See the  Next Steps  below to continue your work with Entando. \n Scenario 2.1 - Developer Project \n For this scenario we'll use the cluster-installed Entando Operator to install an Entando application by individually creating each of its elements. This is much like what is done in Scenarios 1.1-1.2 but gives you greater control of the overall setup of the application. The prerequisites are that the Operator was installed in the cluster and that you have access to your own project. \n First we'll start by creating the database for the application. \n \n Go to  Installed Operators , make sure you've selected your own Project, e.g.  entando-two , and and then go to  Provided APIs → Entando Database Service  and click  Create EntandoDatabaseService. \n \n The default settings work fine for this step. They include creating the deployment and using PostgresSQL for the DBMS. If you examine the YAML it looks something like this: \n apiVersion: entando.org/v1\nkind: EntandoDatabaseService\nmetadata:\n  namespace: entando-two\n  name: my-entando-database-service\nspec:\n  createDeployment: true\n  dbms: postgresql\n  databaseName: my_database\n \n \n Click  Create.  The operator will now create the deployment and resources needed for the database. \n \n Next let's setup the Keycloak server for identity management. \n \n Similar to Step 1, go to  Installed Operators -> Select your project (if needed) → Provided APIs → Entando Keycloak Server  and click  Create EntandoKeycloakServer. \n (Optional) Select a  TLS Secret  to secure the service, e.g  entando-tls-secret  per Scenario 1.5. \n (Optional) Set the  Ingress Host Name  for your project, e.g.  entando-two.<my-base-openshift-url> \n Click  Create \n \n Once the deployment is complete you can check  Networking → Routes  to find the URL for the new Keycloak if you didn't specify the  Ingress Host Name , e.g.  my-keycloak-entando-two.apps-crc.testing/auth/ . The generated admin credentials can be found under  Workloads → Secrets , e.g.  my-keycloak-admin-secret \n Next we'll prepare the infrastructure service. \n \n Go to  Installed Operators -> Select your project (if needed) → Provided APIs → Entando Cluster Infrastructure  and click  Create EntandoClusterInfrastructure. \n (Optional) Set the  Ingress Host Name , e.g.  entando-two.<my-base-openshift-url> \n (Optional) If you chose to apply a  TLS Secret  in Step 4 then you'll want to do the same here by setting the  TLS Secret Name , e.g.  entando-tls-secret. \n Click  Create \n \n Now we'll create the application itself. \n \n Go to  Installed Operators -> Select your project (if needed) → Provided APIs → CLick on View more (if needed) -> EntandoApp  and click  Create instance. \n (Optional) Set the  Ingress Host Name , e.g.  entando-two.<my-base-openshift-url> \n (Optional) If you chose to apply a  TLS Secret  in Step 4 then you'll want to do the same here by setting the  TLS Secret Name , e.g.  entando-tls-secret. \n \n See the  Next Steps  below to continue your work with Entando. \n Next Steps \n Once you've completed any of the scenarios above, you have several options. \n \n Check out  Networking → Routes  to see the URLs for the running services. Common starting points include the  Entando App Builder  (e.g.  http://entando.apps-crc.testing/app-builder/ ) or  Entando application  itself (e.g.  http://entando.apps-crc.testing/entando-de-app/ ). \n This suggested  list of next steps  could also be useful. \n \n"},{title:"Installation on Tanzu Kubernetes Grid",frontmatter:{sidebarDepth:2,redirectFrom:"/v6.3.2/tutorials/devops/installation/tanzu/tanzu-install.html"},regularPath:"/v6.3.2/tutorials/getting-started/tanzu-install.html",relativePath:"v6.3.2/tutorials/getting-started/tanzu-install.md",key:"v-7cf9c1f4",path:"/v6.3.2/tutorials/getting-started/tanzu-install.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:3,title:"Tanzu Configuration",slug:"tanzu-configuration"},{level:2,title:"Deploy the NGINX Ingress Controller",slug:"deploy-the-nginx-ingress-controller"},{level:2,title:"Setup and Deploy",slug:"setup-and-deploy"},{level:2,title:"Appendix A - Persistent Volumes and Storage",slug:"appendix-a-persistent-volumes-and-storage"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:' Installation on Tanzu Kubernetes Grid \n Prerequisites \n \n An installed instance of Tanzu \n A load balancer with an external IP or inbound DNS name for your cluster \n Tanzu Configuration \n Ensure that the storage class in your Tanzu installation is marked as the  default . The default storage class will include a marker as the default in the name column. For example, \n kubectl get sc\n \n NAME                 PROVISIONER             RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE\nstandard (default)   kubernetes.io/gce-pd    Delete          Immediate              true                   23h\n \n Patch the storage type for your cluster if necessary. If you are using a master Kubernetes instance you may need to patch the storage class in that instance.\nA default storage class can be assigned by adding this annotation to the storage class: \n metadata:\n  annotations:\n    storageclass.kubernetes.io/is-default-class: "true"\n \n See  Appendix A  for more advanced storage class configurations. \n Patch Tanzu File System Types \n If your are running on Tanzu Kubernetes Grid 1.2.1 you need to patch the fs-type on the vsphere controller deployment. Details can be found in the  Tanzu\nKuberetes Grid Release notes \nunder the heading\n Pods using PersistentVolumeClaim do not start or remain in the CrashLoopBackOff status, and Grafana and Harbor extension deployments fail \n This issue will present in an Entando deployment as a failure to create persistent volume claims in the Keycloak or\nServer pods on deployment. \n To fix any existing clusters that you deployed perform the following steps: \n \n Update the vsphere-csi-controller configuration. \n \n kubectl patch deployment -n kube-system vsphere-csi-controller --type=json -p=\'[{"op": "add", "path": "/spec/template/spec/containers/4/args/-", "value": "--default-fstype=ext4"}]\'\n \n \n Delete the vsphere-csi-controller pod. \n \n kubectl delete pod -n kube-system -l app=vsphere-csi-controller\n \n Deleting the pod causes it to be recreated with the new configuration. \n Deploy the NGINX Ingress Controller \n \n Deploy NGINX \n \n helm install --name ingress-nginx ingress-nginx/ingress-nginx\n \n \n Watch for the nginx pod to be in a status of Running. For example \n \n kubectl get pods\n \n NAME                                            READY   STATUS    RESTARTS   AGE\npod/ingress-nginx-controller-66dc9984d8-z5x46   1/1     Running   0          116m\npod/kuard-86664f98c9-7kqb5                      1/1     Running   0          74m\npod/kuard-86664f98c9-bx4zz                      1/1     Running   0          74m\npod/kuard-86664f98c9-fs27d                      1/1     Running   0          74m\n \n \n Note the value of the  EXTERNAL-IP  for the nginx controller \n \n kubectl get services\n \n NAME                                         TYPE           CLUSTER-IP       EXTERNAL-IP      PORT(S)                      AGE\nservice/ingress-nginx-controller             LoadBalancer   100.66.153.199   192.168.100.50   80:30575/TCP,443:31235/TCP   116m\nservice/ingress-nginx-controller-admission   ClusterIP      100.70.59.21     <none>           443/TCP                      116m\nservice/kuard                                ClusterIP      100.64.49.203    <none>           80/TCP                       74m\nservice/kubernetes                           ClusterIP      100.64.0.1       <none>           443/TCP                      42h\n \n In the example above the EXTERNAL-IP used in the setup below is 192.168.100.50. \n Setup and Deploy \n \n Create a namespace for your Entando deployment \n \n kubectl create namespace entando\n \n \n Download and unpack the entando-helm-quickstart: \n \n curl -sfL https://github.com/entando-k8s/entando-helm-quickstart/archive/v6.3.2.tar.gz | tar xvz\n \n \n Download the Custom Resource Definitions (CRDs) and deploy them \n \n kubectl apply -f https://raw.githubusercontent.com/entando/entando-releases/v6.3.2/dist/ge-1-1-6/namespace-scoped-deployment/cluster-resources.yaml\n \n \n Install namespace scoped resources \n \n kubectl apply -n entando -f https://raw.githubusercontent.com/entando/entando-releases/v6.3.2/dist/ge-1-1-6/namespace-scoped-deployment/orig/namespace-resources.yaml\n \n \n In the entando-helm-quickstart edit this file  sample-configmaps/entando-operator-config.yaml \n Add these properties to the file (taking note of correct yaml spacing): \n \n   entando.requires.filesystem.group.override: "true"\n  entando.ingress.class: "nginx"\n \n \n Find this property in the file  entando.default.routing.suffix: \n Change the value to  <your nginx ip>.nip.io . For example,  entando.default.routing.suffix: 35.232.231.65.nip.io \n \n TIP \n Depending on your configuration, network, and intended DNS address an application can also be deployed using a single hostname rather\nthan depending on wildcard DNS resolution. \n \n \n Deploy the operator configuration \n \n kubectl apply -f sample-configmaps/entando-operator-config.yaml -n entando\n \n \n Open the  values.yaml  file in the entando-helm-quickstart \n Change the dbms from  embedded  to  postgresql \n Deploy your Entando application \n \n helm template --name=quickstart ./ | kubectl apply -n entando -f -\n \n \n Watch the deployment for completion \n \n kubectl get pods -n entando --watch\n \n This step is complete when the  quickstart-composite-app-deployer  with a status of completed. For example, \n \n The final deployment will look like this from  kubectl get pods -n entando \n \n NAME                                                 READY   STATUS    RESTARTS   AGE\nentando-operator-5cdf787869-t5xrg                    1/1     Running   0          10m\nquickstart-kc-server-deployment-5f9d7897c6-7jnq5     1/1     Running   0          9m20s\nquickstart-eci-k8s-svc-deployment-699b47595d-wxmmb   1/1     Running   0          7m2s\nquickstart-server-deployment-75bb794647-bt6xk        1/1     Running   0          6m10s\nquickstart-ab-deployment-7d78b79c-q7r6z              1/1     Running   0          3m48s\nquickstart-cm-deployment-86bc545b6f-vtg2c            1/1     Running   0          3m30s\n Appendix A - Persistent Volumes and Storage \n In addition to using a default storage class as described above some installations define different storage for clustered and non-clustered persistent volumes.\nIn order to scale Entando server pods across multiple nodes a persistent storage with support for  ReadWriteMany  is required. You can configure your Entando instance to take advantage of provisioned clustered storage with these properties; \n entando.k8s.operator.default.clustered.storage.class: <your clustered storage class>\nentando.k8s.operator.default.non.clustered.storage.class: <your non-clustered storage class>\n \n '},{title:"Installation on OpenShift",frontmatter:{sidebarDepth:2,redirectFrom:"/v6.3.2/tutorials/devops/installation/open-shift/openshift-install.html"},regularPath:"/v6.3.2/tutorials/getting-started/openshift-install.html",relativePath:"v6.3.2/tutorials/getting-started/openshift-install.md",key:"v-37b585ce",path:"/v6.3.2/tutorials/getting-started/openshift-install.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Local Installation",slug:"local-installation"},{level:3,title:"Install the Entando Custom Resource Definitions (CRDs)",slug:"install-the-entando-custom-resource-definitions-crds"},{level:3,title:"Get your Cluster Default Ingress",slug:"get-your-cluster-default-ingress"},{level:3,title:"Setup and Deploy",slug:"setup-and-deploy"},{level:2,title:"Appendix A - Troubleshooting and Common Errors",slug:"appendix-a-troubleshooting-and-common-errors"},{level:3,title:"Permission Errors",slug:"permission-errors"},{level:3,title:"Forbidden Error installing Entando Custom Resource Definitions in Minishift or CRC",slug:"forbidden-error-installing-entando-custom-resource-definitions-in-minishift-or-crc"},{level:3,title:"Application is not available when accessing app builder",slug:"application-is-not-available-when-accessing-app-builder"},{level:3,title:"Network Issues",slug:"network-issues"}],lastUpdated:"2/8/2022, 3:15:08 PM",lastUpdatedTimestamp:1644351308e3,content:" Installation on OpenShift \n Overview \n This tutorial shows how to manually install Entando into OpenShift 4.x.  If you're working with OpenShift 4.6+ it is highly recommended that you install via the Red Hat-certified Entando Operator, which should be available in your OperatorHub  thanks to the Red Hat Marketplace. See  this tutorial  for instructions specific to the  Entando Operator. \n Prerequisites \n \n An OpenShift installation (3.11 or 4.x) \n oc  command line tool \n A helm 3 client \n Local Installation \n If you want to run OpenShift in your local development environment you can run Minishift (OpenShift 3.11) or Code Ready Containers (OpenShift 4). Use the local development version that matches the cluster where you intend to deploy your application. \n For Minishift:  https://docs.okd.io/3.11/minishift/getting-started/installing.html \n For CRC:  https://developers.redhat.com/products/codeready-containers/download \n Once you've completed the installation above capture the local IP address of your development instance using  minishift ip  or  crc ip . You'll need it when configuring your Entando application. \n Login to your OpenShift environment from the command line with  oc login  using the URL and credentials for your cluster. \n Install the Entando Custom Resource Definitions (CRDs) \n Once per cluster you need to deploy the  Entando Custom Resources . This is the only step in this guide that requires cluster level access. If you are running on Minishift or CRC make sure you are connected using the administrator login provided when you started your local instance. \n Note: If you're on OpenShift 3.11 then replace  ge-1-1-6  with  lt-1-1-6  when creating the resources in the first and third steps. \n \n Download the Custom Resource Definitions (CRDs) and deploy them: \n \n oc apply -f https://raw.githubusercontent.com/entando/entando-releases/v6.3.2/dist/ge-1-1-6/namespace-scoped-deployment/cluster-resources.yaml\n \n \n Create the project for your application: \n \n oc new-project entando\n \n Note: If you choose a different name for your project, then adjust the commands below to supply your project name, e.g.  -n my-custom-projectname \n \n Install namespace scoped resources \n \n oc apply -n entando -f https://raw.githubusercontent.com/entando/entando-releases/v6.3.2/dist/ge-1-1-6/namespace-scoped-deployment/orig/namespace-resources.yaml\n Get your Cluster Default Ingress \n If you're deploying on a managed cluster get the default hostname from your cluster administrator. Entando uses wildcard addressing to connect different parts of your Entando application and the default route for applications exposed on your cluster is needed. You'll set this value in step 3 below. \n Setup and Deploy \n \n Download and unpack the entando-helm-quickstart release you want to use from here:\n https://github.com/entando-k8s/entando-helm-quickstart/releases \n \n \n See the included README file for more information on the following steps. \n \n curl -sfL https://github.com/entando-k8s/entando-helm-quickstart/archive/v6.3.2.tar.gz | tar xvz\n \n \n Change into the new directory \n \n cd entando-helm-quickstart-6.3.2\n \n \n \n Edit  sample-configmaps/entando-operator-config.yaml \n \n If you're deploying to a managed cluster:\n \n Set  entando.default.routing.suffix  to the default URL of applications deployed in your OpenShift cluster. If you're unsure of this value, please check with your cluster administrator for this URL. \n Entando will create applications using that default URL and relies on wildcard DNS resolution. \n \n \n If you're using Minishift or CRC:\n \n Set  entando.default.routing.suffix  to the value from  minishift ip  or  crc ip  plus  nip.io . For example,  entando.default.routing.suffix: 192.168.64.10.nip.io \n \n \n \n \n \n Deploy your configmap: \n \n \n oc apply -n entando -f sample-configmaps/entando-operator-config.yaml\n \n \n Update helm dependencies: \n \n helm dependency update\n \n \n Run helm to generate the template file: \n \n helm template my-app --namespace=entando ./ > my-app.yaml\n \n \n If you're using Helm 2 instead of Helm 3, then replace  helm template my-app  with  helm template --name=my-app \n \n \n Deploy Entando via \n \n oc create -f my-app.yaml\n \n \n If you see this error  no matches for kind \"Deployment\" in version \"extensions/v1beta1\" , then you'll need to edit my-app.yaml and set  apiVersion: \"apps/v1\"  for the Deployment. \n \n \n Watch Entando startup \n \n oc get pods -n entando --watch\n \n \n This step is complete when the  quickstart-composite-app-deployer  with a status of completed. For example, \n \n quickstart-composite-app-deployer-0547               0/1     Completed           0          7m44s\n \n \n The full pod name will differ but by default will start with  quickstart-composite-app-deployer . \n \n \n Check for the Entando ingresses using  oc describe ingress -n entando . This is a snippet: \n \n Name:             quickstart-ingress\nNamespace:        entando\nAddress:          \nDefault backend:  default-http-backend:80 (<none>)\nRules:\n  Host                                 Path  Backends\n  ----                                 ----  --------\n  quickstart-entando.192.168.64.10.nip.io  \n                                       /entando-de-app     quickstart-server-service:8080 (<none>)\n                                       /digital-exchange   quickstart-server-service:8083 (<none>)\n                                       /app-builder/       quickstart-server-service:8081 (<none>)\n \n The host path in the configuration above plus  /app-builder/  (trailing slash is important) will allow you to log into your environment. For example,\n http://quickstart-entando.192.168.64.10.nip.io/app-builder/ \n Appendix A - Troubleshooting and Common Errors \n Permission Errors \n If you get OpenShift permission errors deploying your Entando application into your OpenShift namespace make sure your user has the  escalate  and  bind  verbs on Roles in the namespace you're deploying to. Ultimately you need this command to  oc auth can-i escalate role  to return  yes . That access is only required in the namespace where you are deploying your Entando application. No cluster level access is required. \n Check with your cluster administrator if you need help assigning these roles. Generally this requires the creation of a role with those permissions, preferably a ClusterRole, and then depending on how administrators manage security your Entando installer needs to be given that role in the target namespace. So let's assume the clusterRole we create is  entando-installer  and the user's name is john, on OpenShift creating the rolebinding would be:\n oc policy add-role-to-user entando-installer john -n <your-namespace> \n Before installing, we suggest running  oc auth can-i escalate role  with your given user in the targeted namespace. If it says \"yes\" you should be able to install. \n Forbidden Error installing Entando Custom Resource Definitions in Minishift or CRC \n If you get an error like the one below installing the CRDs in your local instance you need to login using the administrator role. \n /opt/ocInstallLocal$ oc create -f dist/crd/\nError from server (Forbidden): error when creating \"dist/crd/EntandoAppCRD.yaml\": customresourcedefinitions.apiextensions.k8s.io is forbidden: User \"developer\" cannot create resource \"customresourcedefinitions\" in API group \"apiextensions.k8s.io\" at the cluster scope\n \n The administrator credentials are printed when you started your local cluster in a message like this one: \n To access the cluster, first set up your environment by following 'crc oc-env' instructions\nINFO Then you can access it by running 'oc login -u developer -p developer https://api.crc.testing:6443'\nINFO To login as an admin, username is 'kubeadmin' and password is xxxx-xxxx-xxxx-xxxx\n Application is not available when accessing app builder \n If you get the message \"Application is not available\" when accessing the app-builder make sure to include a trailing slash in the URL. For example,\nhttp://quickstart-entando.192.168.64.10.nip.io/app-builder/ \n Network Issues \n If you see errors when images are being retrieved (resulting in errors like ErrImagePull or ImagePullBackOff), you may want to start crc using  crc start -n \"8.8.8.8  or configure the nameserver using  crc config set nameserver 8.8.8.8  before running  crc start . This will allow the cluster to perform DNS lookups via Google's public DNS server. \n If you're on Windows, you should also check out the notes  here  since Minishift and CRC rely on Windows Hyper-V by default. This can result in network issues when the host computer is restarted. \n"},{title:"Entando Solution Templates",frontmatter:{sidebarDepth:2},regularPath:"/v6.3.2/tutorials/solution/landing-page.html",relativePath:"v6.3.2/tutorials/solution/landing-page.md",key:"v-3f492b08",path:"/v6.3.2/tutorials/solution/landing-page.html",headers:[{level:2,title:"Entando Customer Portal",slug:"entando-customer-portal"},{level:2,title:"Entando Hub",slug:"entando-hub"},{level:2,title:"Entando Process Driven Applications Plugin",slug:"entando-process-driven-applications-plugin"},{level:2,title:"Entando Standard Banking Demo",slug:"entando-standard-banking-demo"}],lastUpdated:"3/14/2022, 6:34:39 PM",lastUpdatedTimestamp:1647297279e3,content:" Entando Solution Templates \n The Entando Application Composition Platform offers several Solution Templates to demonstrate various business capabilities and integrations: \n \n Entando Customer Portal \n Entando Hub \n Entando Process Driven Applications Plugin \n Entando Standard Banking Demo \n \n Each open source Solution Template was built with Entando and can be used as-is, reviewed for common development practices, or leveraged as a useful starting point for a related application. \n The following Solution Templates and other sets of components are available in the  public Entando Hub  for installation in a user environment, where turnkey functionality can be customized and extended. \n Entando Customer Portal \n The  Entando Customer Portal  streamlines development of a customer-facing, self-service subscription management application. The platform integrates Keycloak role based access control and Jira Service Management as a ticket tracking system. \n Entando Hub \n The  Entando Hub  empowers a team to share and collaborate on proprietary or Entando open source components. Capabilities, versions and metadata can be transparently analyzed, managed and published. \n Entando Process Driven Applications Plugin \n The  Entando Process Driven Applications Plugin  provides a comprehensive and versatile automation scheme for Business Process Management. It comprises a custom UX layer, a Spring Boot Backend for Frontend microservice interface, and integration with the  Red Hat Process Automation Manager . \n Entando Standard Banking Demo \n The  Entando Standard Banking Demo  showcases the benefits and possibilities of a composable application built from modular components. The example banking environment integrates a transaction table, sign up form, alert icon, and summary cards to demonstrate MFE communication and capabilities. Prominent features include Keycloak role based access control, coexistence of React and Angular MFEs, and pluggable Spring Boot microservices. \n \n TIP \n Check out our Concepts page to explore Entando's approach to composability, or visit  Getting Started  to put these components and capabilities in action! \n \n"},{title:"Entando Customer Portal",frontmatter:{sidebarDepth:2},regularPath:"/v6.3.2/tutorials/solution/customer-portal.html",relativePath:"v6.3.2/tutorials/solution/customer-portal.md",key:"v-1230c726",path:"/v6.3.2/tutorials/solution/customer-portal.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Installation",slug:"installation"},{level:3,title:"Prerequisites",slug:"prerequisites"},{level:3,title:"Installation",slug:"installation-2"},{level:2,title:"Configuration",slug:"configuration"},{level:3,title:"Administrators",slug:"administrators"},{level:3,title:"Jira Service Management",slug:"jira-service-management"},{level:3,title:"Entando Identity Management System",slug:"entando-identity-management-system"},{level:3,title:"Configure the Customer Portal",slug:"configure-the-customer-portal"},{level:2,title:"Managing the Customer Portal",slug:"managing-the-customer-portal"},{level:2,title:"Using the Customer Portal",slug:"using-the-customer-portal"},{level:2,title:"Resources",slug:"resources"}],lastUpdated:"4/20/2022, 10:31:14 AM",lastUpdatedTimestamp:1650465074e3,content:" Entando Customer Portal \n Overview \n The Entando Customer Portal enables an organization to quickly provide a modern, self-service customer-facing application for managing subscriptions. It includes a lightweight integration to Jira Service Management for access to service tickets and a role based access control (RBAC) design for granting users varying levels of access. \n Key Features: \n \n Customizable service ticket and tracking system with Jira Service Management \n Role based access control with Entando Identity Management System \n Integrated user, customer, project, and subscription management \n \n This tutorial covers: \n \n Installation \n Configuration \n Managing the Customer Portal \n Using the Customer Portal \n Resources \n Installation \n Prerequisites \n \n A working instance of Entando running on Kubernetes. See  Getting Started  for more information or  install Entando on any Kubernetes provider . \n Use the Entando CLI command  ent check-env develop  to verify all dependencies. \n A Jira Service Management account. \n Installation \n \n To install the Customer Portal, run the following commands. Edit the  -n entando  option for each command to match your namespace or project. \n \n ent bundler from-git -r https://github.com/entando-samples/customerportal-application-bundle.git -d  |  ent kubectl apply -n entando -f - \n \n ent bundler from-git -r https://github.com/entando-samples/customerportal-content-bundle.git -d  |  ent kubectl apply -n entando -f - \n \n \n \n Log into the App Builder. \n \n \n Go to  Repository  from the left navigation bar. Two Customer Portal bundles will be visible there.  Install  the latest version of the  customerportal-application-bundle  first, then the latest version of the  customerportal-content-bundle . \n \n \n To navigate to your Portal: \n \n From the sidebar →   Page  →  Management \n Find the  Customer Portal  page \n From the  Actions  pull-down menu →   View Published Page \n Configuration \n Administrators \n In order to configure the Customer Portal and its users, the administrator will need Jira Service Management and Entando Identity Management System credentials. In this step, the admin connects the CP to Jira and customizes its features. \n Note: \n \n The built-in mapper for email must be enabled on the server client so that user accounts can be retrieved from Jira and new tickets can use that account information. \n Jira Service Management \n The administrator utilizes Jira Service Management to create users and projects, define the organization, and configure the service ticket system. \n Users who need access to the Customer Portal, beyond subscription and project information, must have a Jira Service Management account. \n \n Go to Customers to add organizations and projects. Once added, click on the name of the organization to get the ID, needed later, from the URL.  \ne.g. example.com/jira/servicedesk/projects/ECS/organization/3 → the Organization ID is “3” \n Entando Identity Management System \n Logging into the Entando Identity Management System, you will see the landing page shown here. Like the App Builder, the left navigation bar is your guide for managing users, groups, and most importantly, roles. Using the RBAC model, define what access users have by the roles and groups they are assigned. Some important guidelines are noted below. \n \n \n \n Set up permissions to configure the service. \n \n Login to your Keycloak instance  as an admin. \n Give at least one user the ability to manage the Customer Portal by granting the  cp-admin  role. Assign the  cp-admin  role for the  entandodemo-customerportal-server  client. See  Role Assignment in ID Management  for more details. \n Give the generated plugin client permission to manage users.\n \n From the left sidebar, go to  Clients  and select client ID  entandodemo-customerportal-server . \n Click the  Service Account  tab at the top of the page and select  realm-management  from the  Client Roles  field. \n Choose  realm-admin  from  Available Roles . Click  Add selected . It should appear as an  Assigned Role . \n \n \n \n \n \n Define the Realm Setting .  \nThe  Realm  is a set of users, credentials, roles, and groups. A user belongs to and logs into a  Realm . \n \n \n Create Roles \n \n You can use the default roles by clicking on  Client Roles  and choosing  entandodemo-customerportal-server . Access for each role is defined as follows:\n \n cp-customer  -  assigned directly to specific projects for a single customer \n cp-partner  - assigned directly to specific projects for multiple customers \n cp-support  -  read only view of all customer projects \n cp-admin  - admin access for the Customer Portal \n \n \n \n \n \n Create New Users : \n \n \n From the sidebar, go to  Users . Click  Add User  at right. \n \n \n Complete the form as needed but note the requirements for these fields: \n Username : a unique name \n Email : must use the same address used in Jira \n User Enabled  → On \n Save \n \n \n Send an email to the user to activate their account and set a new password:  \nGo to the  Credentials  header  \nUnder  Credential Reset , in the  Reset Actions  →  Update Password    \nClick  Send Email \n \n \n Go to Role Mapping: \n \n Select the appropriate roles from  Available Roles  and click  Add Selected  to assign. \n Choose  entandodemo-customerportal-server  from the  Client Roles  pull-down options to assign default roles. \n A full administrative user will need the  realm-admin  role under  Client Roles  →  realm-management  in order to manage users in the Portal. \n Check the  Effective Roles  column on the right to ensure the correct roles have been assigned. \n \n \n \n \n \n \n \n Under  Groups , assign roles to groups as needed. Roles are additive. \n Configure the Customer Portal \n The Customer Portal must be configured to accommodate a specific Jira Service Management instance. The  CP Admin Config  page is where you will establish the Jira connection, manage product versions, define subscription levels, and customize ticket types. \n To access the  CP Admin Config  page, you must be given the  cp-admin  role in the  Entando Identity Management System  as outlined below. \n Go to the  CP Admin Config  page: \n \n In the App Builder, go to  Pages  and select  Management . \n Open the Customer Portal folder and find  CP Admin Config . \n From the  Action  drop-down menu on the right, go to  View Published Page . \n \n \nOnce the Ticketing System Connection is set up with Jira and the correct URL, default parameters such as product versions and ticket types will be displayed. Open each section with the down arrow to add and edit the fields as needed. \n Managing the Customer Portal \n As administrator for the Customer Portal, you can create and manage users, customers, projects, and subscriptions. You can assign projects to users who have activated their account on Jira and have been assigned roles in the Entando Identity Management System. \n \n \n Create a Customer or Partner \nCreating a  Customer  and  Partner  is a similar process. Below are the steps for adding a  Customer . Follow the same procedure for adding a  Partner . \n \n \n Click  Add a Customer \n Fill in the details. Note the following:\n \n The  Customer Number  must be unique \n The  Notes  field is visible only to  support  and  admin  users \n \n \n \n \n \n Create and Assign Projects \n \n \n From the CP landing page, click on any customer to see the associated project list. \n To create a new project:\n \n Click  Add a Project . \n Enter the  Project  information. \n Provide the Organization ID from Jira. Each project must have a unique Organization ID. \n Click  Save . \n \n \n To assign  Projects :\n \n From the  Action  drop-down menu →   Manage Users . \n Select the user for the  Project . \n Click  Submit . \n \n \n \n \n Manage Partners and Subscriptions   \nUse the  Action  drop-down menu to manage Partners, and request and manage subscriptions. \n Using the Customer Portal \n To access the Customer Portal, your organization administrator needs to provide you with the proper user credentials. You can then create and track service tickets as well as request subscriptions. \n Once you login to the Customer Portal, you will see a list of customers. Click on a customer to view details and track their projects. \n \n To create a  Service Ticket  for a project:  \nfrom the  Action  pull-down menu →  Open Ticket . \n \n \n \n To request a Subscription or track Tickets:  \nuse the  Action  pull-down menu and select the corresponding option. \n Resources \n \n \n Go to  Jira Service Management  for more information. \n \n \n The  source code  for the Entando Customer Portal can be found with our other open source examples and tutorials on GitHub at:  https://github.com/entando-samples/customer-portal/ \n \n \n"},{title:"Entando Hub",frontmatter:{sidebarDepth:2},regularPath:"/v6.3.2/tutorials/solution/entando-hub.html",relativePath:"v6.3.2/tutorials/solution/entando-hub.md",key:"v-332e7fa6",path:"/v6.3.2/tutorials/solution/entando-hub.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Installation",slug:"installation"},{level:3,title:"Prerequisites",slug:"prerequisites"},{level:3,title:"Installation Steps",slug:"installation-steps"},{level:2,title:"Configuration",slug:"configuration"},{level:2,title:"Using the Hub",slug:"using-the-hub"},{level:3,title:"Concepts",slug:"concepts"},{level:3,title:"Roles",slug:"roles"},{level:3,title:"Bundle Group Version Status",slug:"bundle-group-version-status"},{level:3,title:"Bundle Group Creation",slug:"bundle-group-creation"},{level:3,title:"Bundle Group Versions",slug:"bundle-group-versions"},{level:2,title:"Application Details",slug:"application-details"},{level:3,title:"Micro Frontends / Widgets",slug:"micro-frontends-widgets"},{level:3,title:"Microservices",slug:"microservices"},{level:3,title:"Content",slug:"content"},{level:3,title:"Integration",slug:"integration"},{level:2,title:"Resources",slug:"resources"},{level:3,title:"Source Code",slug:"source-code"}],lastUpdated:"4/15/2022, 5:01:11 PM",lastUpdatedTimestamp:1650056471e3,content:" Entando Hub \n Overview \n The Entando Hub enables a team to share components across Entando Applications. It can be installed in Entando 6.3.2 or higher and includes API-level integration with the Entando 7.0 App Builder. \n The Hub allows users to: \n \n Centralize components and business capabilities for use across teams, groups, or clients. \n Publish, manage and communicate component features, versions and metadata. \n Perform business-level assessment of component readiness. \n \n This tutorial covers: \n \n Installation \n Configuration \n Using the Hub \n Application Details \n Resources \n Installation \n The Hub is installed using the Entando Component Repository (ECR) and two Entando Bundles.  The first bundle contains the Hub micro frontends and microservices, and the second sets up the initial content and pages for the Hub user experience. \n Prerequisites \n \n An Entando Application on any Kubernetes provider. Follow the  tutorials  appropriate to your environment to install the Entando platform. \n The  ent command line tool , installed and connected to your Kubernetes instance. \n Installation Steps \n \n Apply the Custom Resource Definitions for the Hub component bundles. You'll need to adjust the  -n entando  option in each command to match your namespace or project. \n \n ent bundler from-git -r https://github.com/entando-samples/entando-hub-application-bundle.git -d | ent kubectl apply -n entando -f -\n \n ent bundler from-git -r https://github.com/entando-samples/entando-hub-content-bundle.git -d | ent kubectl apply -n entando -f -\n \n \n \n Log into your App Builder instance. \n \n \n Select  Repository  from the menu on the left. Your bundles will be visible in the repository as shown in the screenshot below. \n \n \n \n \n Select  Install  for each bundle, where order of installation is important. The  entando-hub-application-bundle  must be installed first because it provides the  entando-hub-content-bundle  with MFEs. It may take several minutes to download the Docker images for the microservices and install related assets. \n \n WARNING \n (Entando 6.3.2) A cache issue impacting the first deployment of the  entando-hub-content-bundle  can prevent all widgets or MFEs from appearing on some pages, particularly the Dashboard page. \n To clear the cache, select  Administration  from the bottom of the left menu, then  Reload configuration . \n Alternatively, restarting the quickstart-server pod (which contains the Entando App Engine) will also clear the cache, and can be achieved with  ent k delete pod/<YOUR QUICKSTART-SERVER POD> , e.g.  ent k delete pod/quickstart-server-deployment-5d785b997c-r4sc8 . It will take several minutes for the pod to redeploy after deletion. \n \n \n Set up permissions to configure the service: \n \n \n Login to your Keycloak instance  as an admin. \n Give at least one user the ability to manage the Hub by granting the  eh-admin  role. Assign the  eh-admin  role for the  pn-cee95efc-77ff566e-entandopsdh-entando-hub-catalog-ms-server  client. Go to  Assign client roles  for more details. \n Give the generated plugin client permission to manage users.\n \n From the left sidebar, go to  Clients , and select client ID  pn-cee95efc-77ff566e-entandopsdh-entando-hub-catalog-ms-server . \n Click the  Service Account  tab at the top and select  realm-management  from the  Client Roles  field. \n Choose  realm-admin  from  Available Roles .  Click  Add selected . It should appear as an   Assigned Role . \n \n \n \n \n Access the Hub from the App Builder by navigating to  Pages → Management , finding  Entando Hub  in the page tree, and clicking  View Published Page  from its actions. \n Configuration \n TIP \n (New with Entando 7.0.0) Any Hub instance can be accessed from the Entando App Builder of another Entando Application. Configure the App Builder to access the desired Hub instance via the endpoint  BASEURL/entando-hub-api/appbuilder/api , where the BASEURL is the URL for the Entando Application. \n Using the Hub \n Concepts \n The key entities in the Entando Hub are: \n \n Bundle Group : A Bundle Group is a group of one or more Entando Bundles. \n Bundle Group Version : A Bundle Group can have one or more versions, each with a particular status. \n Bundle : A Bundle is the deployment unit within an Entando Application. A Bundle can contain one or multiple components such as micro frontends, microservices, or any of the  component types  available in Entando. \n Category : Each Bundle Group belongs to a specific category. The initial possible categories are Solution Template, Packaged Business Capability (PBC), or Component Collection. An admin of an Entando Hub can refine the available categories as desired. \n Organization : Bundle Groups belong to a single organization. Authors and managers can only update Bundle Groups for their own organization. \n User : User identity is managed within Keycloak, where users are granted roles within the Hub. Users must be assigned to a specific organization. \n \n Notes: \n \n A private repository can be used for a Bundle, but this requires  an additional Kubernetes secret  before deployment via the App Builder. \n Roles \n Three roles are used to provide access to the Hub features: \n \n eh-author : An author can create and edit Bundle Groups for their organization and submit them for publication. \n eh-manager : A manager has the permissions of an author, but can also approve a publication request for their organization. \n eh-admin : An admin has full access to create, update, and delete Bundle Groups for the entire Hub instance. An admin can also create categories and organizations, and assign users to an organization. \n guest : Any user without one of the preceding roles is considered a guest in the Entando Hub and is given a read-only view of the public catalog. This is also true for unauthenticated users. \n Bundle Group Version Status \n The possible statuses for the versions of a Bundle Group are: \n \n Draft : This is the default status for the first version of a Bundle Group. \n Publication Request : An eh-author sets a version to this status to request an eh-manager or eh-admin to review the version and mark it for publication. An eh-manager or eh-admin may edit versions with this status. \n Published : Versions with this status are visible in the home page list of available Bundle Groups and also available in the App Builder-facing API. An eh-manager or eh-admin may edit Published versions. \n Archived : Previously Published versions are assigned this status. No edits can be made on an Archived version. \n Deletion Request : An eh-manager or eh-admin can delete versions once this status has been set. \n \n Notes: \n \n An eh-author can change any field except Organization while a version is in Draft. \n There is no automated notification process when a Publication Request is made for a Bundle Group version. \n Bundle Group Creation \n Clicking the  Add +  button at the top of the page displays the form for creating a new Bundle Group: \n Bundle Group Versions \n The list of Bundle Group Versions can be seen by clicking  View Versions  on any entry in the catalog: \n \n Notes: \n \n Once the first version of a group is published, the organization, name, and category can no longer be changed. \n A new version of a Bundle Group can be created (via the  New Version  option) after the first version has been published. \n There can be at most two active versions: one Draft or Publication Requested version and one Published version. \n When a new version is published, the previous version is set to Archived. \n Archived versions are only visible in the versions view and are not shown elsewhere in the user interface. \n Application Details \n The Hub includes the following key components: \n Micro Frontends / Widgets \n \n Entando Hub App : This is the main micro frontend which contains the management UI for the Hub entities noted above. \n Entando Hub Login : This is an optional login component which can be used in a page’s top navigation. \n Microservices \n A single Spring Boot microservice provides two REST endpoints: \n \n The first is a backend-for-a-frontend (BFF) service for the Hub UI and contains the various entity APIs. \n The second provides methods that support the Entando App Builder integration (7.0.0+). \n Content \n The Hub content bundle ( entando-hub ) includes a custom template and a page preconfigured with the main Hub micro frontends. \n Integration \n The Entando App Builder should be configured using the endpoint  BASEURL/entando-hub-api/appbuilder/api , where the BASEURL is the URL for the Entando Application. \n Resources \n Source Code \n Entando open source examples and tutorials are available on GitHub. Reference the Hub sample project for instructions to build the project from source code: \n \n https://github.com/entando-samples/entando-hub \n \n"},{title:"PDA Plugin Technical Guide",frontmatter:{},regularPath:"/v6.3.2/tutorials/solution/pda-technical-guide.html",relativePath:"v6.3.2/tutorials/solution/pda-technical-guide.md",key:"v-4d12f6f4",path:"/v6.3.2/tutorials/solution/pda-technical-guide.html",headers:[{level:2,title:"Task Forms",slug:"task-forms"},{level:2,title:"Widgets",slug:"widgets"},{level:2,title:"Code Style",slug:"code-style"},{level:2,title:"Sonar",slug:"sonar"}],lastUpdated:"1/29/2022, 10:04:58 AM",lastUpdatedTimestamp:1643468698e3,content:' PDA Plugin Technical Guide \n This page explores PDA plugin structure and functionality in greater detail. The sample code and linked resources instruct the user in the versatility and usability of: \n \n Task Forms \n Widgets \n Code Style \n Sonar \n Task Forms \n Widgets employ JSON schema to dynamically create any forms they contain. The JSON schemas are converted into React components using the  react-jsonshema-form  library. Entando\'s initial implementation utilizes Material UI components derived from the Material UI theme library ( rjsf-material-ui ) as a baseline, and includes templates, widgets and fields ( react-jsonshema-form  terms for forms components) that are specific to Entando. \n This section will introduce the basic form configuration, but if you would like to learn more, please refer to the  react-jsonshema-form   documentation . \n The themed JSON Form is created using the  withTheme()  method from the  react-jsonschema-form  package: \n import { withTheme } from \'react-jsonschema-form\';\nimport { Theme as MuiRJSForm } from \'rjsf-material-ui\';\n\nconst JSONForm = props => {\n\n  const ThemedForm = withTheme(MuiRJSForm);\n\n  // ...\n\n  return (\n    <ThemedForm\n    schema={formSchema}\n    uiSchema={uiSchema}\n    {...customTemplates}\n    widgets={customWidgets}\n    formData={formData}\n    onSubmit={e => onSubmitForm(e)}\n    >\n  );\n};\n\nexport default JSONForm;\n \n A form schema provides the JSON definition of the form’s structure and is mandatory for a JSON Form to function. Users can supply form data via the  formData  variable, which should follow the structure of JSON schema. UI schema can be supplied via the  uiSchema  variable, which allows users to customize the form’s UI (e.g. components, rules, types). \n You can test the JSON schema, UI schema and form data in the  react-jsonschema-form  sandbox environment. Entando templates, widgets, and fields allow customization of form layout using Grid components. The size parameter in the UI schema’s  ui:options  object specifies the fill area of a field or subform. \n Size refers to the Material UI’s grid column widths (see the Material UI documentation), where the area the form can occupy is divided into 12 columns. A value of 12 (the default value if size is not provided) means the field or subform should take up all 12 columns. If two adjacent fields have size values of 8 and 4, respectively, they will share one row and the first field will be twice as wide as the second. \n In addition, the user can provide an innerSize parameter to scale the input fields inside the columns. This helps with formatting when a user wants to make nonuniform adjustments to sizing. \n Multicolumn layout can also be achieved via  generateColumnedOFT  ( columnSize ) functionality, which assigns the default  columnSize  to the created form. The function  generateColumnedOFT  returns an  ObjectFieldTemplate  that is used as a template for all object fields (fields that contain properties). \n To explain the mapping between JSON schema and UI schema let\'s define an example\nschema: \n {\n  "$schema": "http://json-schema.org/draft-07/schema#",\n  "$id": "http://entando.org/schemas/pda-form.json",\n  "title": "Mortgage Application Form",\n  "type": "object",\n  "properties": {\n    "Application": {\n      "title": "Application",\n    "type": "object",\n    "required": [],\n    "properties": {\n        "mortgageamount": {\n          "type": "integer",\n          "title": "Mortgage amount",\n          "description": "Mortgage amount"\n        },\n        "downpayment": {\n          "type": "integer",\n          "title": "Down Payment",\n          "description": "Down Payment"\n        },\n        "applicant": {\n          "title": "Applicant",\n          "type": "object",\n          "required": [],\n          "properties": {\n            "name": {\n              "type": "string",\n              "title": "Name",\n              "description": "Name",\n              "maxLength": 100\n            },\n            "annualincome": {\n              "type": "integer",\n              "title": "Annual Income",\n              "description": "Annual Income"\n            }\n          }\n        },\n        "property": {\n          "title": "Property",\n          "type": "object",\n          "required": [],\n          "properties": {\n            "age": {\n              "type": "integer",\n              "title": "Age of property",\n              "description": "Age of property"\n            },\n            "address": {\n              "type": "string",\n              "title": "Address of property",\n              "description": "Address of property",\n              "maxLength": 100\n                }\n          }\n        }\n      }\n    },\n    "inlimit": {\n      "type": "boolean",\n    "title": "Is mortgage application in limit?"\n    }\n  }\n}\n \n From this JSON (you can copy & paste it into the  react-jsonschema-form \nsandbox) we can see that there is a main form with a title “Mortgage\nApplication Form." The root form  Mortgage Application Form  has two\nproperties: one is a subform called  Application  and the other is a\ncheckbox field (field ID is  inlimit ). \n The  Application  subform contains two fields:  Mortgage Amount  with field ID  mortgageamount  and  Down Payment  with field ID  downpayment . It also contains two subforms:  Applicant  with field ID  applicant  and  Property  with field ID  property . \n The  Applicant  subform contains two fields:  Name  with field ID  name  and  Annual Income  with field ID  annualincome . The  Property  subform also contains two fields:  Age of property  with field ID  age  and  Address of property  with field ID  address . \n By default (without providing UI schema), these are listed as one field per row. To use Entando’s implementation of Grid layout, users have to\nprovide UI schema with details about each field. For example, if we\nwould like to have a layout that looks like this (fields are marked\n [ field name ] ): \n +----------------------------------------------------------------------------+\n| Mortgage Application Form                                                  |\n+----------------------------------------------------------------------------+\n| Application                                                                |\n+----------------------------------+-----------------------------------------+\n| [Mortgage amount]                | [Down Payment]                          |\n+----------------------------------+-----------------+-----------------------+\n| Applicant                                          | Property              |\n+----------------------------------+-----------------+-----------------------+\n| [Name]                           | [Annual Income] | [Age of property]     |\n+----------------------------------+-----------------+-----------------------+\n|                                                    | [Address of property] |\n+----------------------------------------------------+-----------------------+\n \n To set up the UI schema, you need to use field IDs to define each field you want to customize. For example, to add options to the  Name  field, create an object tree beginning at the root:  Application  —>  Applicant  —>  Name  (equivalent to  Application.Applicant.Name ). The UI schema for the table layout defined above looks like this: \n {\n  Application: {\n    \'ui:options\': {\n      size: 12, // <-- this value is not mandatory; size is 12  columns wide by default\n    },\n    mortgageamount: {\n      \'ui:disabled\': true, // <-- user can define fields disabled at UI schema level\n      \'ui:options\': {\n        size: 6, // <-- Mortgage Amount field should take up half of the row\n      },\n    },\n    downpayment: {\n      \'ui:options\': {\n         size: 4, // <-- Down Payment field should take up the other half of the row\n       },\n    },\n    applicant: {\n      \'ui:options\': {\n         size: 8, // <-- Applicant subform should take up 8 out of 12 columns\n      },\n      name: {\n        \'ui:options\': {\n          size: 8, // <-- Applicant Name field should take up 8 of the 8 columns that Applicant subform occupies\n        },\n      },\n      annualincome: {\n        \'ui:options\': {\n           size: 4, // <-- Annual Income field should take up the remaining 4 columns\n        },\n      },\n    },\n     property: {\n      \'ui:options\': {\n        size: 4, // <-- Property subform should take up the remaining 4 out of 12 columns\n      },\n      // note that Property field occupancy is not specified, defaulting to use all 12 of the columns available\n    },\n  },\n};\n \n As Material UI components are used for field templates, there might be a need to pass some Material UI options into the field. This can be done by adding the  muiProps  object to  ui:options . \n For example, if you would like to make the down payment field resizable, you can add  multiline: true  to the  muiProps  option. If you want the field to take up multiple rows by default, add the fields  rows  and  rowsMax . The latter limits how many rows can be added until the scroll bar is shown. \n downpayment: {\n  \'ui:options\': {\n    size: 4,\n    muiProps: {\n      multiline: true,\n      rows: 2,\n      rowsMax: 4\n    }\n  }\n}\n Widgets \n Different types of widgets can be applied by passing the type via\n ui:widget . This property specifies the widget to use when the form\nrenders a UI field. See the documentation to learn about widgets supported by the  react-jsonschema-form . \n Code Style \n Refer to:  https://github.com/entando/entando-code-style \n Sonar \n Refer to:  https://sonarcloud.io/organizations/entando/projects \n'},{title:"Entando Standard Banking Demo",frontmatter:{sidebarDepth:2,redirectFrom:"/v6.3.2/tutorials/samples/install-standard-demo.html"},regularPath:"/v6.3.2/tutorials/solution/install-standard-demo.html",relativePath:"v6.3.2/tutorials/solution/install-standard-demo.md",key:"v-7b0a15b4",path:"/v6.3.2/tutorials/solution/install-standard-demo.html",headers:[{level:2,title:"Introduction",slug:"introduction"},{level:2,title:"Installation",slug:"installation"},{level:3,title:"Prerequisites",slug:"prerequisites"},{level:3,title:"Installation Steps",slug:"installation-steps"},{level:2,title:"Application Details",slug:"application-details"},{level:3,title:"Micro Frontends (MFE)",slug:"micro-frontends-mfe"},{level:3,title:"Configuration Micro Frontends",slug:"configuration-micro-frontends"},{level:3,title:"Microservices",slug:"microservices"},{level:3,title:"Static Widgets",slug:"static-widgets"},{level:3,title:"Static CMS Content",slug:"static-cms-content"},{level:2,title:"Source Code",slug:"source-code"}],lastUpdated:"3/30/2022, 4:33:36 PM",lastUpdatedTimestamp:1648672416e3,content:" Entando Standard Banking Demo \n Introduction Installation Prerequisites Installation Steps Application Details Micro Frontends (MFE) Configuration Micro Frontends Microservices Static Widgets Static CMS Content Source Code \n Introduction \n This tutorial will guide you through installing a demo application using the Entando Component Repository (ECR) and a set of Entando\nbundles. This solution template includes: \n \n microservices \n micro frontends \n multiple pages \n CMS content \n \n The goal of this exercise is to demonstrate how Entando bundles can be used to: \n \n quickly install and create functionality in an Entando Application \n enable packaged business capabilities \n allow developers to reuse full stack operations via bundles \n \n Some of the key elements of the template are reviewed in the  Application Details section  below. \n Installation \n There are numerous assets installed as part of the Standard Banking Demo. Entando Bundles can include more or less components, depending on objectives. It is recommended that organizations develop guidelines for bundle sizing that fit the goals of their applications and teams. \n Prerequisites \n \n An Entando Application on any Kubernetes provider. Follow one of the  tutorials  appropriate to your environment to install the Entando platform. \n The ent command line tool, installed and connected to your Kubernetes instance. \n Installation Steps \n \n Apply the definitions for the four bundles that comprise the Standard Banking Demo. You'll need to adjust the  -n entando  option in each command to match your namespace or project. \n \n ent bundler from-git -d -r https://github.com/entando-samples/standard-demo-banking-bundle.git | ent kubectl apply -n entando -f -\n \n ent bundler from-git -d -r https://github.com/entando-samples/standard-demo-customer-bundle.git | ent kubectl apply -n entando -f -\n \n ent bundler from-git -d -r https://github.com/entando-samples/standard-demo-manage-users-bundle.git | ent kubectl apply -n entando -f -\n \n ent bundler from-git -d -r https://github.com/entando-samples/standard-demo-content-bundle.git | ent kubectl apply -n entando -f -\n \n \n \n Log into your App Builder instance. \n \n \n Select  Repository  from the menu on the left. Your bundles will be visible in the repository as shown in the screenshot below.\n \n \n \n Select  Install  for each bundle, where order of installation is important. The  standard-demo-content-bundle  will need to be installed last, as it relies on MFEs from the other bundles to set up each of the pages.\n \n \n \n Each installation can take several minutes while the application downloads the Linux images for the microservices and installs the related assets. The  standard-demo-banking-bundle  and  standard-demo-customer-bundle  include microservices that require the initialization of containers and will take longer to install. \n In the unlikely event you encounter conflicts during an initial installation, you will be presented with an Installation Plan like the one shown below. Select  Update All  in the upper right after making your selections.\n \n \n Access the Standard Banking Demo via one of the following options: \n \n Option 1  If you'd like to make the Standard Banking Demo your default home page, go to  App Builder → Pages → Settings . In\nthe dropdown for Home Page, select  Home / Home SD  and click  Save .\n \n You can now navigate to your application's home page using the home icon in the upper right of the App Builder. \n Option 2  Alternatively, you can view the Standard Banking Demo home page by going to  Pages → Management , finding  Home SD  in the page tree, and clicking  View Published Page  from its actions. \n \n WARNING \n (Entando 6.3.2) A cache issue impacting the first deployment of the  standard-demo-content-bundle  can prevent all widgets or MFEs from appearing on some pages, particularly the Dashboard page. \n To clear the cache, select  Administration  from the bottom of the left menu, then  Reload configuration . \n Alternatively, restarting the quickstart-server pod (which contains the Entando App Engine) will also clear the cache, and can be achieved with  ent k delete pod/<YOUR QUICKSTART-SERVER POD> , e.g.  ent k delete pod/quickstart-server-deployment-5d785b997c-r4sc8 . It will take several minutes for the pod to redeploy after deletion. \n Application Details \n The Entando Standard Banking Demo application demonstrates a number of the major features of the Entando platform, including: \n \n Keycloak integration for role based access controls \n Micro frontends implemented using React and Angular and co-existing on the same dashboard page \n Micro frontend communication techniques \n Microservices via Spring Boot \n Entando Content Management \n Micro Frontends (MFE) \n The application includes six MFEs in which the above features complement one another to achieve custom functionality. These are described below. \n 1. Card \n \n \n The Card MFE is a React micro frontend that is visible on the My Dashboard page. The MFE makes an API call to the banking microservice to fetch a numeric result depending on the configured card type. The displayed value will change as the configuration is changed. \n The MFE is authorization-aware and will pass the bearer token to the microservice for authorization and authentication. If you render the dashboard page and you aren't authenticated, the widget displays an error message. \n This MFE emits events that are consumed by the Transaction Table widget. \n 2. Card NG \n \n \n The Card NG MFE is an Angular widget that is similar to the Card widget above, except for the choice of frontend technology. \n This MFE communicates with the Transaction Table widget, which is implemented in React. \n 3. Manage Users \n \n The Manage Users MFE makes an API call to Keycloak to fetch user information. When the user is logged into the app, the MFE is visible from the dropdown under the username. \n By default, application users are not granted Keycloak authorization to manage users. This demonstrates role based access control for an MFE using Keycloak. To enable the Manage Users widget, login to Keycloak and assign the realm-management client's  view-users  and  manage-users  roles to the desired user. \n \n Authorized View\n \n Not Authorized View\n 4. Transaction Table \n \n This MFE is a React micro frontend that consumes events from the Card MFEs detailed above. \n The Transaction Table widget makes an API call to the banking microservice to fetch transaction data for the user. \n 5. Sign Up \n \n \n The Sign Up MFE is a form widget that makes an API call to the customer microservice to create a new user. The Sign Up MFE is visible on the sign up page, and can be accessed from any page when a user is not authenticated. \n 6. Alert Icon \n \n The Alert Icon MFE displays an icon on the dashboard page. It includes a configuration MFE to allow the user to select the appropriate icon and datatype to display. \n In the default deployment, the Alert Icon MFE makes an API call to the banking microservice to fetch data. \n Configuration Micro Frontends \n When placed on a page, many of the MFEs detailed above include configuration screens visible in the App Builder at  Components → Micro frontends & Widgets . To see the rendered config screen, place the MFE on a new page. \n Microservices \n The application includes two microservices (service paths:  /banking  and  /customer ) to support the data visible in the MFEs detailed above. Both microservices demonstrate the automated deployment and linking of a microservice to an Entando Application via the Entando Operator. \n The data for the microservices are created with Liquibase, demonstrating the use of the Operator and Liquibase + Spring Boot to automatically provision data into an environment. The demo data is available in the source code for the microservices on GitHub. \n Static Widgets \n The application uses static HTML, FreeMarker, and JavaScript widgets to display content, e.g. headers, footers, images, etc. To view the static widgets, log into the App builder and select  Components → Micro frontends & Widgets . \n Static CMS Content \n The application makes extensive use of the Entando CMS. This includes the creation of content templates, content types, and content. If you want to learn more about the Entando CMS in the application, log into the App Builder and select  Content →  Templates ,  Content → Management , or  Content → Types . \n Source Code \n The source code for the Entando Standard Banking Demo can be found on GitHub  here , along with our other open source examples and tutorials. \n"},{title:"PDA Architecture",frontmatter:{},regularPath:"/v6.3.2/tutorials/solution/pda-architecture.html",relativePath:"v6.3.2/tutorials/solution/pda-architecture.md",key:"v-2f87b6a0",path:"/v6.3.2/tutorials/solution/pda-architecture.html",headers:[{level:2,title:"PDA MFEs",slug:"pda-mfes"},{level:2,title:"PDA API",slug:"pda-api"},{level:2,title:"Sidecar",slug:"sidecar"},{level:2,title:"PDA Core",slug:"pda-core"},{level:2,title:"PAM Impl",slug:"pam-impl"}],lastUpdated:"1/31/2022, 10:10:51 AM",lastUpdatedTimestamp:1643641851e3,content:" PDA Architecture \n The objective of this document is to provide an explanation for the components\nthat compose the Process Driven Applications plugin (PDA) architecture from a\ndeployment perspective as well as how they interact with each other. \n The image below shows the components in high level: \n PDA MFEs \n The PDA Micro Frontends run on the browser and they render the UI custom\ncomponents the user interacts with. These components are written in React and\nthey fetch data from the PDA API, passing the Keycloak token for authentication.\nThe MFEs also make calls to the Entando Core API in order to retrieve the\nsettings required for the configuration UI. These components will be available\non Entando App Builder after the PDA plugin bundle is installed and the user\ncan create pages with them. \n The source code for this component:\n https://github.com/entando/entando-process-driven-plugin/tree/master/widgets \n PDA API \n The Spring Boot application that communicates with the engine and make its data\navailable in a Rest API. It interacts with Keycloak to validate the token and\nwith the sidecar to retrieve the connections/sensitive data, depending on how it\nwas deployed. The application shouldn't call specific engine classes directly,\ninstead it always calls the abstractions defined in PDA Core library. The engine\nimplementation to use is decided at runtime based on the connection details\nprovided. It is important to note that the PDA API application is stateless,\nsince it doesn't have a database. All data available on the API is retrieved\nfrom the BPM engine. After bundle installation, it will be deployed as a\nmicroservice in the Kubernetes infrastructure and an Ingress will be created to\nmake the API available to the MFEs, as described by the Entando Plugin custom\nresource. \n The source code for this component:\n https://github.com/entando/entando-process-driven-plugin \n Sidecar \n The sidecar is another application (docker container) deployed in the same Pod\nas the PDA API. It exposes services to manage connection details, which will be\nstored as secrets in Kubernetes. The PDA API communicates with the sidecar to\nmanage BPM engine connection details. \n The source code for this component:\n https://github.com/entando/entando-plugin-sidecar \n PDA Core \n This is the library that defines the interfaces and abstractions that should be\nimplemented to interact with specific BPM engines. This way it is possible to\nhave multiple engine implementations at the same time. \n The source code for this component:\n https://github.com/entando/pda-core-engine \n PAM Impl \n The Red Hat PAM implementation for the PDA Core library. If the connection maps\nto a PAM engine, these are the classes that are going to be executed when the\nPDA API requests for engine operations. This implementation communicates with\nthe Kie Server, which executes the defined process operations. \n The source code for this component:\n https://github.com/entando/pda-redhatpam-engine \n"},{title:"Entando Platform",frontmatter:{sidebarDepth:0},regularPath:"/v6.3/docs/",relativePath:"v6.3/docs/README.md",key:"v-adb93754",path:"/v6.3/docs/",headers:[{level:2,title:"Entando Architecture",slug:"entando-architecture"},{level:2,title:"Why Kubernetes?",slug:"why-kubernetes"}],lastUpdated:"1/11/2021, 4:49:35 PM",lastUpdatedTimestamp:1610401775e3,content:" Entando Platform \n Entando is a  micro frontend platform for Kubernetes  that helps enterprises innovate faster with parallel development teams that have end-to-end autonomy across the entire stack. \n With native support for Javascript app development, a micro frontend and microservices architecture, deployment of apps in containers that can be individually scaled up and down, and automated management of containers with Kubernetes, we simplify the move for enterprises looking to modernize across on-prem and cloud infrastructures. \n Entando Architecture \n \n The Entando platform includes the following major elements: \n \n Entando App Engine : assemble micro frontends & microservices and compose them on a page. \n Entando App Builder : the user interface to build and design applications. \n Entando Component Generator : provide advanced data modeling capabilities and automatically generate the corresponding microservices and micro frontends. \n Entando Component Repository : a shared, internal repository to encourage code reuse across the enterprise. \n Entando Identity Management : token-based authentication across multiple domains and connect service providers with identity providers. \n Entando WCMS : a web content management system that supports headless CMS. \n (optional)  Entando Business Automation Bundle : workflow and task automation including out of the box integration with Red Hat Process Automation Manager (PAM). \n Why Kubernetes? \n Instead of you doing the work to ensure your apps and services stay up and running, Kubernetes does the work for you. For each app or service, you can set resource limits, the number of pods you want backing each service, upgrade strategy, and auto-scaling. Kubernetes actively manages your cluster to match your defined resource utilization and ensures your site doesn't go down. \n How Google Runs Containers in Production \n Each week, Google deploys over 2 billion containers in production to run all of its services like Gmail, YouTube, and Search. Kubernetes is Google's open source solution to automate the management of containers at scale. \n \n Over 50% of Fortune 500 companies use Kubernetes with product offerings from Amazon Elastic Kubernetes Service (EKS), Google Cloud Platform (GKE), IBM (Red Hat) OpenShift, Microsoft Azure (AKS), and VMWare Pivotal (PKS). \n"},{title:"Entando Process Driven Applications Plugin",frontmatter:{sidebarDepth:2,redirectFrom:"/v6.3.2/tutorials/samples/pda-tutorial.html"},regularPath:"/v6.3.2/tutorials/solution/pda-tutorial.html",relativePath:"v6.3.2/tutorials/solution/pda-tutorial.md",key:"v-6729fcec",path:"/v6.3.2/tutorials/solution/pda-tutorial.html",headers:[{level:2,title:"Introduction",slug:"introduction"},{level:2,title:"Installation",slug:"installation"},{level:3,title:"Prerequisites",slug:"prerequisites"},{level:3,title:"Installation Steps",slug:"installation-steps"},{level:2,title:"Configuration",slug:"configuration"},{level:2,title:"Application Details",slug:"application-details"},{level:3,title:"Micro Frontends (MFEs)",slug:"micro-frontends-mfes"},{level:3,title:"Process Automation Manager (PAM)",slug:"process-automation-manager-pam"},{level:3,title:"Backend for Frontend (BFF)",slug:"backend-for-frontend-bff"},{level:2,title:"Customization and Extension",slug:"customization-and-extension"},{level:3,title:"Styling",slug:"styling"},{level:3,title:"Implementing a New Engine or Integrating a New Task Source",slug:"implementing-a-new-engine-or-integrating-a-new-task-source"},{level:2,title:"Resources",slug:"resources"},{level:3,title:"Source Code",slug:"source-code"}],lastUpdated:"4/20/2022, 10:31:14 AM",lastUpdatedTimestamp:1650465074e3,content:" Entando Process Driven Applications Plugin \n Introduction \n The Entando Process Driven Applications (PDA) plugin is engineered to provide a rich and full-featured user experience while facilitating the management and completion of business processes and automation.  This solution template includes: \n \n A general purpose UX layer created from micro frontends that can be implemented for any business process or task engine. The UX layer can serve data via the included Entando integration adapter or by implementing a set of interfaces on the server side. \n A Spring Boot microservice backend providing a pluggable interface for the injection of underlying processes or automation toolkits. The interfaces and steps for creating a new PDA backend implementation are described in further detail  here . \n \n This tutorial will guide you through installing the PDA plugin using the Entando Component Repository (ECR) and an Entando Bundle. This exercise demonstrates the scope of process automation enabled by integrating the following: \n \n Custom Micro Frontends (MFEs) \n Backend for Frontend (BFF) microservice \n Red Hat Process Automation Manager  (PAM) \n \n Key elements of the template are reviewed in the  Application Details section  below. \n Installation \n There are numerous assets installed as part of the Entando PDA plugin. Entando Bundles can include more or less components, depending on objectives. It is recommended that organizations develop guidelines for bundle sizing that fit the goals of their applications and teams. \n Prerequisites \n \n An Entando Application on any Kubernetes provider. Follow one of the  tutorials  appropriate to your environment to install the Entando platform. \n The ent command line tool, installed and connected to your Kubernetes instance. \n Red Hat PAM \n Installation Steps \n \n Apply the Custom Resource Definition for the PDA plugin component bundle. You'll need to adjust the  -n entando  option in each command to match your namespace or project. \n \n ent bundler from-git -r https://github.com/entando-samples/entando-process-driven-plugin-bundle.git -d | ent kubectl apply -n entando -f -\n \n \n \n Log into your App Builder instance. \n \n \n Select  Repository  from the menu on the left. Your bundles will be visible in the repository as shown in the screenshot below. \n \n \n \n \n Select  Install  to install the bundle. The installation may take several minutes while the application downloads the Linux image for the microservice and installs the related assets. \n Configuration \n Follow the steps below to configure service permissions and connections. \n \n \n Login to your Keycloak instance  as an admin. \n \n \n Assign client roles  to authorize permissions. \n \n \n \n Select  entando-pda-plugin-server  from  Client Roles . \n Select all roles from  Available Roles  and click  Add selected . \n \n \n Log in to the App Builder and configure the PDA connection. \n \n \n Go to  Pages  →  Management , find  PDA Connections  in the page tree and select  View Published Page  from the Actions. This redirects you to the browser tab opened for PDA Connections. \n Click on  Create new connection  in the upper right corner. The  Name* ,  Engine*  and  Timeout*  fields are prepopulated with base values.\n \n The default name value  pam-demo  may be edited, but the datasource names of other widgets must match your edit. Go to  Pages  →  Management  and select  Design  from the Actions of each page below. The Actions of affected widgets will include a  Settings  option, from which you can update the  Knowledge Source  field.\n \n PDA Dashboard \n PDA Process Definition \n PDA Smart Inbox \n PDA Task Details \n \n \n Leave  pam  as the engine name. This value is appropriate for jBPM or PAM. \n Leave the timeout as  60000 , which is in milliseconds. \n Provide your connection URL to the KIE Server rest services, e.g. 'http://my.server.net:8080/kie-server/services/rest/server'. \n Username/password should be for a jBPM or PAM service account user, e.g. 'krisv'. \n \n \n \n WARNING \n (Entando 6.3.2) A cache issue impacting the first deployment of the  entando-pda-plugin-bundle  can prevent all widgets or MFEs from appearing on some pages, particularly the Dashboard page. \n To clear the cache, select  Administration  from the bottom of the left menu, then  Reload configuration . \n Alternatively, restarting the quickstart-server pod (which contains the Entando App Engine) will also clear the cache, and can be achieved with  ent k delete pod/<YOUR QUICKSTART-SERVER POD> , e.g.  ent k delete pod/quickstart-server-deployment-5d785b997c-r4sc8 . It will take several minutes for the pod to redeploy after deletion. \n \n Go to the Smart Inbox to begin working with the PDA plugin. It can be accessed from the App Builder by navigating to  Pages → Management , finding  PDA Smart Inbox  in the page tree and clicking  View Published Page  from its Actions. \n Application Details \n The Entando PDA plugin demonstrates several of the major features of the Entando platform, the configuration and capabilities of which are summarized below. For a discussion of these components in the context of deployment, see  PDA Deployment Architecture . \n Micro Frontends (MFEs) \n This section provides a brief description of each MFE available to the PDA plugin. Details specific to the PAM implementation of an MFE are included where appropriate. MFE behavior and datasources must be defined if the integration layer is extended to other engines or custom implementations. \n Task List \n The Task List MFE provides the user with a list of visible tasks that are\neither assigned to or could be claimed by that user. In the default implementation, the visible tasks are limited to a\nsingle process instance. At configuration time, the application designer\nis given the option to select a set of columns that will be visible in\nthe task list for that page. \n \n The default PAM implementation exposes the top level task fields in the task list for selection. It is possible to fetch task and process variables from the task list for rendering, but this is disabled by default to optimize performance. \n Task Details \n The Task Details MFE renders detailed information about a task in a read only grid. It is intended to give the end user the information necessary to process the task. See the Styling section below to customize the layout. \n \n The PAM implementation renders task variables in the task details widget. \n Task Comments \n The Task Comments MFE enables the user to view and add the notes attached\nto a task. \n \n The PAM implementation reads and publishes notes to the comments endpoint. \n Task Form \n The Task Form can be accessed by clicking on the Task Overview link found in the Task Details MFE. Its implementation renders a form specific to a task and enables\nthe user to complete that form. It is a\nwrapper around a JSON schema that describes the layout, style and\ncontent of the form. The backend implementation provides the mapping\nto the schema and default UX layout needed to render the form. See the\n technical documentation  for more on the JSON schema\nimplementation. \n The PAM implementation of forms depends on the presence of a form definition for the PAM task. The Entando PAM engine implementation transforms the PAM format to the JSON schema to render the form. It also transforms the API format back to the PAM format. There are some limitations on form customization due to the format required to return data to PAM. See the Task Forms section in the technical documentation for more information. \n Attachments \n The Attachments MFE enables the user to view and add documents attached to a task, case or process. After selecting an entry in the Smart Inbox task list, use the App Builder to add the Attachment MFE to that entry's page by navigating to  Pages → Management ; select  Design  from the  PDA Smart Inbox  Actions and drag the \"PDA - Task Attachments\" widget into its placeholder. \n \n The PAM implementation posts the documents to the PAM endpoints for storage. \n New Process Form \n The New Process Form renders a form enabling the end user to instantiate a new business process instance. The same technology is used to generate a New Process Form and the JSON schema definition for a Task Form. \n \n The PAM implementation relies on a form definition attached to the process definition. Entando transforms the PAM representation into a JSON schema form that can be rendered to the end user. \n Summary Cards \n The Summary Card MFEs provide a view into aggregate data for the process\nimplementation. The rendered information includes a total value, a trend\nvalue, and a timeframe selector. The Summary Card provides the\nthe option to request rendering information. This request maps to a call in the underlying engine and provides the summarized data. \n \n The PAM implementation of the Summary Card widget relies on the PAM custom query functionality. The PAM PDA engine exposes a configuration file where the custom query can be defined. This allows user customization of the data rendered on the summary cards. The application contains a \"properties\" file where the user can submit a custom query for each of the cards. \n Totals Over Time \n The Totals Over Time MFE provides a dual axis line/bar graph displaying\ntrend information about the process environment. Three summary values can be compared over a single time period. \n \n The PAM implementation of the Totals Over Time MFE utilizes custom queries to fetch the summary data rendered in the chart. The queries used in the implementation are defined in configuration files in the MFE and can be updated to render implementation specific data. \n Process Automation Manager (PAM) \n The Entando PDA is built on Process Automation Manager, which is a business process automation engine built and maintained by Red Hat. \n Backend for Frontend (BFF) \n A microservice architecture allows teams to iterate quickly and\ndevelop technology to scale rapidly. Backend for Frontend\nis an architecture pattern built with microservices. The key\ncomponent of this pattern is an application connecting the frontend\nof an application with the backend. The BFF Code Pattern helps to build that component according to IBM’s best practices. \n Customization and Extension \n This section describes how the PDA plugin can be customized and extended via: \n \n Styling \n Implementing a new engine \n Integrating a new task source \n \n For an in-depth discussion of the PDA architecture, refer to the  PDA Technical Guide . \n Styling \n The Entando PDA MFEs are styled via a Material UI theme. That theme can\nbe downloaded and updated  here . \n Implementing a New Engine or Integrating a New Task Source \n Implementing a new engine for Process Driven Applications means\ncreating a new Java project and implementing the interfaces defined in the\n pda-core-engine  project. The new project should therefore include the\n pda-core-engine  as a dependency. \n To see an implementation in action, consider the  pda-redhatpam-engine  project, which implements the Red Hat PAM engine integration. The resultant JAR file should be available in the classpath for the  entando-process-driven-plugin , which is the project that\nis ultimately executed and exposes the Rest APIs for the frontend\napplication. \n One way to achieve this is by publishing the engine\nimplementation to a Maven repository and adding it as a dependency to\nthe  entando-process-driven-plugin  project. Below are the descriptions of\nthe engine class and key interfaces in the  pda-core-engine  project that must be inherited or implemented when creating a new engine\nimplementation. \n Classes \n Engine : represents a Business Process Management (BPM) engine and exposes the services that are available for that specific implementation. It is intended to be inherited, and the subclass should provide the implementation for each service by calling the superclass constructor with the service implementations as arguments. If any service is not supported, a null value should be passed to the corresponding constructor argument. The engine can provide implementations for service interfaces. \n Interfaces \n TaskService : defines service methods for task retrieval from the BPM engine. \n TaskDefinitionService : defines service methods related to task definition. A task definition specifies which fields or columns are available for all task instances. \n TaskCommentService : defines service methods related to task comment manipulation. It should be implemented if the task comment is supported by the engine. \n TaskAttachmentService : defines service methods to operate on task attachments. It should be implemented if the engine supports file attachment on the task. \n TaskFormService : defines service methods for task form operations, like retrieving the form definition and submitting a form. The Form object can be used to render a form dynamically. \n TaskLifecycleService : defines service methods related to the task lifecycle. The lifecycle operations move the task from one state to another. \n TaskLifecycleBulkService : defines methods for bulk lifecycle operations. Like the TaskLifecycleService, these methods move the task from one state to another, but this interface works with multiple tasks at a time. \n ProcessService : defines service methods for process definitions operations. \n ProcessFormService : defines service methods for process form operations, like retrieving the form definition and submitting a form. The Form object can be used to render a form dynamically. \n GroupService : defines service methods related to groups in the BPM engine. \n Resources \n Source Code \n The source code for the Entando PDA plugin can be found on GitHub, along with our other open source examples and tutorials. Reference the component projects for instructions to build from source code: \n \n https://github.com/entando/entando-process-driven-plugin \n https://github.com/entando/entando-process-driven-plugin/tree/master/widgets \n https://github.com/entando/pda-redhatpam-engine \n https://github.com/entando/pda-core-engine \n \n"},{title:"Contributing to Entando",frontmatter:{},regularPath:"/v6.3/docs/community/contributing.html",relativePath:"v6.3/docs/community/contributing.md",key:"v-4120e3f8",path:"/v6.3/docs/community/contributing.html",headers:[{level:2,title:"Contributing to the Source",slug:"contributing-to-the-source"},{level:2,title:"Code Style and Formatting",slug:"code-style-and-formatting"},{level:3,title:"Java",slug:"java"},{level:3,title:"Javascript",slug:"javascript"},{level:3,title:"Find the Code",slug:"find-the-code"},{level:2,title:"Get Help",slug:"get-help"},{level:2,title:"Licenses",slug:"licenses"}],lastUpdated:"2/22/2021, 4:38:05 PM",lastUpdatedTimestamp:1614029885e3,content:" Contributing to Entando \n There are many ways to contribute to Entando including participating in the  Entando Forum , opening issues on GitHub,  updating documentation , building bundles using the  Entando Component Repository , and contributing directly to the source. \n Contributing to the Source \n Entando welcomes contributions to our source code repositories. This is a brief overview of how to create a pull request for an Entando repository. \n If you're new to forks in the git world checkout this guide  Working with Forks \n \n Find the repository you want to edit on the Entando GitHub\n \n https://github.com/entando \n https://github.com/entando-k8s \n \n \n Create a fork of the repository you want to update \n Make your changes or updates on your fork. We recommend making your changes on a branch so that you can update your commits as needed before creating your PR \n Submit a PR against the main (or master) branch of the repository you're working against. If you're fixing a specific issue reference that issue number in the notes and linked issues \n Watch the automated builds to make sure everything passes \n The Entando team will merge your changes! \n Code Style and Formatting \n Most Entando repositories enforce code style rules. References and setup for the main\nsource types are provided below. \n Java \n Java rules are based on checkstyle and PMD can be found at in the  entando-code-style  project. There are configuration files for Intellij, Eclipse, and Netbeans for automated formatting. \n Javascript \n Code style and formatting rules for all Entando javascript projects are enforced by linters in every project. For a reference example see: .sass-lint.yml and .eslintrc.js in the  App builder \n In the future these rules will be replaced by Prettier. \n Find the Code \n Entando source can be found on GitHub in the following organizations. \n \n https://github.com/entando \n https://github.com/entando-k8s \n \n For an overview of the key projects in both GitHub organizations and their role in the architecture see  Entando Deployment Structure \n Get Help \n If you have questions, need help, or want to find out more about contributing join us at \n \n Entando Forum \n Community Slack \n Licenses \n The Entando Platform is 100% open source and most Entando repositories are licensed under the LGPL V3.0. The entando-docs repository is one exception with a  CC BY 4.0 license . See the LICENSE file in the root directory of a given repository for its specific license information. \n Entando libraries licensed with LGPL V3.0 that are used to build applications may be linked to proprietary applications. If linked statically, the application code must also be released as LGPL. If the application is linked dynamically to Entando, the proprietary code does not need to be released. \n A commercial open source license is provided for the Entando Platform for customers with Gold and Platinum subscriptions. This license permits freely extending or modifying Entando without requiring contribution of confidential IP back to the open source community. \n"},{title:"Entando Contributor Covenant Code of Conduct",frontmatter:{},regularPath:"/v6.3/docs/community/code-of-conduct.html",relativePath:"v6.3/docs/community/code-of-conduct.md",key:"v-3514fc0c",path:"/v6.3/docs/community/code-of-conduct.html",headers:[{level:2,title:"Our Pledge",slug:"our-pledge"},{level:2,title:"Our Standards",slug:"our-standards"},{level:2,title:"Enforcement Responsibilities",slug:"enforcement-responsibilities"},{level:2,title:"Scope",slug:"scope"},{level:2,title:"Enforcement",slug:"enforcement"},{level:2,title:"Enforcement Guidelines",slug:"enforcement-guidelines"},{level:3,title:"1. Correction",slug:"_1-correction"},{level:3,title:"2. Warning",slug:"_2-warning"},{level:3,title:"3. Temporary Ban",slug:"_3-temporary-ban"},{level:3,title:"4. Permanent Ban",slug:"_4-permanent-ban"},{level:2,title:"Attribution",slug:"attribution"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:" Entando Contributor Covenant Code of Conduct \n Our Pledge \n We as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, religion, or sexual identity\nand orientation. \n We pledge to act and interact in ways that contribute to an open, welcoming,\ndiverse, inclusive, and healthy community. \n Our Standards \n Examples of behavior that contributes to a positive environment for our\ncommunity include: \n \n Demonstrating empathy and kindness toward other people \n Being respectful of differing opinions, viewpoints, and experiences \n Giving and gracefully accepting constructive feedback \n Accepting responsibility and apologizing to those affected by our mistakes,\nand learning from the experience \n Focusing on what is best not just for us as individuals, but for the\noverall community \n \n Examples of unacceptable behavior include: \n \n The use of sexualized language or imagery, and sexual attention or\nadvances of any kind \n Trolling, insulting or derogatory comments, and personal or political attacks \n Public or private harassment \n Publishing others' private information, such as a physical or email\naddress, without their explicit permission \n Other conduct which could reasonably be considered inappropriate in a\nprofessional setting \n Enforcement Responsibilities \n Community leaders are responsible for clarifying and enforcing our standards of\nacceptable behavior and will take appropriate and fair corrective action in\nresponse to any behavior that they deem inappropriate, threatening, offensive,\nor harmful. \n Community leaders have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions that are\nnot aligned to this Code of Conduct, and will communicate reasons for moderation\ndecisions when appropriate. \n Scope \n This Code of Conduct applies within all community spaces, and also applies when\nan individual is officially representing the community in public spaces.\nExamples of representing our community include using an official e-mail address,\nposting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event. \n Enforcement \n Instances of abusive, harassing, or otherwise unacceptable behavior may be\nreported to the community leaders responsible for enforcement at\ncommunity@entando.com. \n All complaints will be reviewed and investigated promptly and fairly. \n All community leaders are obligated to respect the privacy and security of the\nreporter of any incident. \n Enforcement Guidelines \n Community leaders will follow these Community Impact Guidelines in determining\nthe consequences for any action they deem in violation of this Code of Conduct: \n 1. Correction \n Community Impact : Use of inappropriate language or other behavior deemed\nunprofessional or unwelcome in the community. \n Consequence : A private, written warning from community leaders, providing\nclarity around the nature of the violation and an explanation of why the\nbehavior was inappropriate. A public apology may be requested. \n 2. Warning \n Community Impact : A violation through a single incident or series\nof actions. \n Consequence : A warning with consequences for continued behavior. No\ninteraction with the people involved, including unsolicited interaction with\nthose enforcing the Code of Conduct, for a specified period of time. This\nincludes avoiding interactions in community spaces as well as external channels\nlike social media. Violating these terms may lead to a temporary or\npermanent ban. \n 3. Temporary Ban \n Community Impact : A serious violation of community standards, including\nsustained inappropriate behavior. \n Consequence : A temporary ban from any sort of interaction or public\ncommunication with the community for a specified period of time. No public or\nprivate interaction with the people involved, including unsolicited interaction\nwith those enforcing the Code of Conduct, is allowed during this period.\nViolating these terms may lead to a permanent ban. \n 4. Permanent Ban \n Community Impact : Demonstrating a pattern of violation of community\nstandards, including sustained inappropriate behavior,  harassment of an\nindividual, or aggression toward or disparagement of classes of individuals. \n Consequence : A permanent ban from any sort of public interaction within\nthe community. \n Attribution \n This Code of Conduct is adapted from the  Contributor Covenant ,\nversion 2.0, available at\nhttps://www.contributor-covenant.org/version/2/0/code_of_conduct.html. \n Community Impact Guidelines were inspired by  Mozilla's code of conduct\nenforcement ladder . \n For answers to common questions about this code of conduct, see the FAQ at\nhttps://www.contributor-covenant.org/faq. Translations are available at\nhttps://www.contributor-covenant.org/translations. \n"},{title:"Customizing the Entando Component Generator",frontmatter:{},regularPath:"/v6.3/docs/component-generator/component-gen-customize.html",relativePath:"v6.3/docs/component-generator/component-gen-customize.md",key:"v-b64319e8",path:"/v6.3/docs/component-generator/component-gen-customize.html",lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:" Customizing the Entando Component Generator \n The Entando Component Generator is an instance of a JHipster blueprint that can be extended to match your team's needs and requirements. If you're interested in extending the blueprint or creating your own blueprint, contact us on the  Entando Forum  or  Community Slack  and we'll help you get started. \n The source for the Entando blueprint can be found  here . \n To learn more about creating blueprints and to see other blueprints available from JHipster checkout the  blueprint documentation  or visit  JHipster  for an overview. \n"},{title:"Overview",frontmatter:{},regularPath:"/v6.3/docs/component-generator/component-gen-overview.html",relativePath:"v6.3/docs/component-generator/component-gen-overview.md",key:"v-64ee1b00",path:"/v6.3/docs/component-generator/component-gen-overview.html",headers:[{level:2,title:"Introduction",slug:"introduction"},{level:2,title:"Objectives",slug:"objectives"},{level:2,title:"Generated Component Flow",slug:"generated-component-flow"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:" Overview \n Introduction \n The Entando Component Generator powered by JHipster is a tool that gives developers the ability to quickly generate Entando components that can be used to extend an Entando Application. \n The component generator takes advantage of the concept of  JHipster blueprints  to provide powerful templating and standard generation patterns. \n Objectives \n The component generator has two main objectives \n \n \n Accelerate development \n \n Automate the creation of microservices and micro frontends with code that runs without changes. Start from running software. \n Code is meant to be developed on and changed by developers. Ready for customization. \n Using standard tools, technologies, and patterns that can be consumed by developers who are not familiar with the underlying blueprint \n \n \n \n Standardize microservice creation and technology choices \n \n Encode business standards for networking, monitoring, build tools, and distribution into a blueprint to ensure that developers are starting from a technical point that matches your teams requirements \n Ensure code follows standards and practices of your teams including code formatting, testing tools, static analysis tools, package structures, and other rules specific to your organization \n Enable teams to quickly recognize and adopt code from system integrators and other third parties because the patterns and standards are encoded in the starting point of your applications \n Generated Component Flow \n This section provides an overview of the component generation process. If you want to jump into the code and a tutorial start here:  Entando Component Generator Tutorial \n \n \n \n Create components \n \n The Component Generator will create a Spring Boot microservice and optionally will create React micro frontends for entities that you add to your project \n The microservice and generated micro frontends are runnable out of the box and preconfigured to connect to  Entando Identity Management \n The code is meant to be edited and enhanced by developers. JHipster provides interactive updates and merges if you need to re-run the generator or add new functionality via JHipster \n The microservice includes liquibase and integrated data mocking if you want to generate data in your API calls \n \n \n \n Define bundle and deploy assets \n \n The Entando blueprint includes scripts and tools to automatically generate a bundle ready for deployment to the ECR. The bundle will include your microservice, generated microfrontends, and any microfrontends that you have created manually under the  ui  folder \n The generated Spring Boot microservice can be built and deployed to a Docker registry using the provided maven Jib plugin \n Generated bundles can be pushed to a git repository of the users choice \n \n \n \n Deploy bundles to  Entando Component Repository (ECR) \n \n Once your Docker images are pushed to your registry and your bundle is available in Git you can generate an Entando bundle descriptor and push the bundles to the ECR \n The bundles can be versioned and updated using tags in the git repository \n \n \n \n Install in Entando Apps \n \n Once the bundles are in the ECR they are available for deployment in any Entando application that has access to the ECR in the cluster \n \n \n \n"},{title:"Overview",frontmatter:{},regularPath:"/v6.3/docs/concepts/",relativePath:"v6.3/docs/concepts/README.md",key:"v-3bdbce85",path:"/v6.3/docs/concepts/",headers:[{level:2,title:"Entando App Engine",slug:"entando-app-engine"},{level:2,title:"Entando App Builder",slug:"entando-app-builder"},{level:2,title:"Entando Component Generator",slug:"entando-component-generator"},{level:2,title:"Entando Component Repository",slug:"entando-component-repository"},{level:2,title:"Entando Identity Management",slug:"entando-identity-management"},{level:2,title:"Entando WCMS",slug:"entando-wcms"},{level:2,title:"Entando Cluster Citizens",slug:"entando-cluster-citizens"},{level:3,title:"Architecture diagram",slug:"architecture-diagram"},{level:3,title:"Members of the cluster",slug:"members-of-the-cluster"},{level:2,title:"Entando Ingresses",slug:"entando-ingresses"},{level:3,title:"What is an ingress",slug:"what-is-an-ingress"},{level:3,title:"How ingresses are used in an Entando Cluster",slug:"how-ingresses-are-used-in-an-entando-cluster"},{level:3,title:"Default Ingress HTTP Routes",slug:"default-ingress-http-routes"},{level:3,title:"Exposing plugins in the EntandoApp domain",slug:"exposing-plugins-in-the-entandoapp-domain"},{level:3,title:"How to check ingresses in my cluster",slug:"how-to-check-ingresses-in-my-cluster"},{level:3,title:"Learn more",slug:"learn-more"}],lastUpdated:"1/29/2021, 10:47:17 AM",lastUpdatedTimestamp:1611935237e3,content:' Overview \n A portal, website, web app, or mobile app built with Entando is called an Entando application.\nAn Entando application is an assembly of out of the box and/or custom built components running on the\nEntando Platform. Components can be widgets, micro frontends, microservices, page templates, WCMS content or WCMS content types. \n Entando App Engine \n The Entando App Engine is the heart of the Entando Platform by providing the primary out-of-the-box services for\ndeveloping applications. Key features: \n \n Expose the APIs the Entando App Builder uses to provide the page and content management interface for your application. \n Handle the work of assembling micro frontends and microservices and combining them on specific pages as defined by the Entando App Builder. \n Provide the data access layer to persist the page and application design. \n Manage the cluster infrastructure. \n \n See also:  APIs tutorial \n Entando App Builder \n The Entando App Builder is the feature-rich management interface used to design and build pages for Entando applications. \n See also:  Widget Tutorial \n Entando Component Generator \n The Entando Component Generator is Entando\'s implementation of  JHipster  that allows users to\nquickly and efficiently generate the skeleton of an Entando Component. The Entando Component Generator provides advanced\ndata modeling capabilities including object relational mapping and automatic generation of micro frontends and microservices.\nThe generated skeleton serves as a starting point to help a development team swiftly meet the needs of the business. \n See also:  Entando JHipster Blueprint \n Entando Component Repository \n The Entando Component Repository (ECR) is used to store and retrieve shareable components so they can be used in multiple\nEntando applications across the enterprise. \n See also:  ECR Overview \n Entando Identity Management \n Entando Identity Management is the  Keycloak -based token-based authentication mechanism used by the\nEntando platform. It provides the ability to add Single Sign On capabilities across multiple domains and to connect service\nproviders with identity providers. \n See also:  Entando Authentication \n Entando WCMS \n The Entando Web Content Management System (WCMS) is a lightweight content and digital asset management system with support\nfor headless operation. It allows management of widgets and html fragments so they can be placed within an Entando application. \n See also:  Content Types  or  Content Templates \n Entando Cluster Citizens \n The purpose of this guide is to give an overview of the members of an Entando cluster and their role. \n Architecture diagram \n Let’s start with a picture of an Entando 6 cluster and how the various\nmembers interact with each other. \n Members of the cluster \n An Entando 6 cluster is composed of various citizens which interact with\neach other. Most of these citizens have a Custom Resource Definition\nfile associated with them and are deployable on Kubernetes using the\nEntando operator and controllers. \n Entando app \n An Entando application is composed of three parts: \n \n \n Entando App Builder : the user interface to customize and build an Entando application, as well as interact with the Entando Component Repository. \n \n \n Entando App Engine : the backend APIs providing access to Entando\nservices. \n \n \n Entando Component Manager : the service providing the Entando\nComponent Repository functionality, e.g. listing the available\nbundles, install/uninstall a bundle, etc. Check the  dedicated\nsection  for more details. \n \n \n The interaction between these three components (and the rest of the\nEntando cluster) use the authorization/authentication features provided\nby Keycloak. \n Entando Component Manager \n As briefly introduced before, the Entando component manager is able to\nlist the EntandoDeBundles accessible from the EntandoApp and provide the\ninstall/uninstall services to install a bundle on an Entando App. All of\nthese services are made possible by the communication with the Entando\nKubernetes service, the only service of the Entando ecosystem (other\nthan the operator itself) able to interact with the cluster and some of\nthe Entando custom resources. \n Entando Kubernetes Service \n The Entando Kubernetes Service is part of the Entando cluster\ninfrastructure custom resource, and provides an access point to some of\nthe custom resources defined by Entando, in particular: \n \n \n Entando applications \n \n \n Entando plugins \n \n \n Entando links \n \n \n Entando Component Repository bundles \n \n \n Some of the main services provided by the Entando Kubernetes Service\nare: \n \n \n Provide a list of the available EntandoDeBundles to the\ncomponent-manager \n \n \n Deploy a plugin during the installation of a bundle or discovery of\nan already available plugin and expose that to an app \n \n \n Create a link between an EntandoApp and an EntandoPlugin to expose\nthe plugin’s APIs to the EntandoApp and the micro frontends (MFEs) \n Entando Component Repository bundles \n An EntandoDeBundle - or Component Repository bundle - is a package with\na set of Entando components and resources. The Entando component manager\nis able to read these kind of packages and install the components to\nextend the functionalities of an EntandoApp. For more details on the\nEntandoDeBundle and the Entando Component Repository, check the\n component repository overview \ndocumentation \n Entando plugin \n An Entando plugin is a microservice that exposes APIs reusable by one or\nmore Entando apps. Usually the plugin services are exposed to the\nEntando developer and the end users via micro frontends. Check the\n micro frontends  tutorials for more details. You can\nquickly generate an Entando plugin using the  Entando JHipster Blueprint . The generated project\nwill be ready to work in an Entando environment providing the\nintegration with Keycloak, generating a set of default micro frontends\nand exposing the plugin’s logic via an EntandoDeBundle (check the\nreferences for details). \n Keycloak \n Keycloak in Entando 6 is responsible for authorization and\nauthentication All the members of an Entando 6 cluster interact with\nkeycloak to verify user/service authorization to perform any specific\ntask. Check out the references below for more details on keycloak. \n Entando Ingresses \n What is an ingress \n An Ingress is a Kubernetes resource which purpose is to expose HTTP and HTTPS routes from outside the cluster to services within the cluster. Traffic routing is controlled by rules defined on the Ingress resource. \n How ingresses are used in an Entando Cluster \n When deploying an Entando Cluster, ingresses are generated for the resources that requires to be exposed to the outside world. The process of creating an ingress, setup the correct routes and the certificates is done by the via the Entando Operator and the entando custom resource controllers. \n Keycloak ingress \n An dedicated ingress is created for keycloak to expose the authentication and authorization functionalities. Having a dedicated ingress is required to guarantee that both token issuing and token validation work correctly, even when the services using the keycloak instance are on different namespaces. \n Cluster infrastructure ingress \n Another ingress is created for the cluster infrastructure services in order to expose the api endpoint to interact with the cluster correctly \n Entando App ingress \n Another ingress is automatically created to expose App builder, App engine and the Entando component manager, a service part of the ECR.\nThe three containers are served under the same domain, and this is beneficial as they are able to interact without cross-origin issues. \n The Entando App ingress is also used when linking an Entando Plugin with and Entando App, operation that usually happens when a bundle containing an Entando Plugin is installed via the ECR in an Entando App. Check out the dedicated section for details. \n Entando Plugin ingress \n Also Entando Plugins are automatically exposed via an ingress when deployed in an Entando Cluster. \n Default Ingress HTTP Routes \n In this table you can see what are the default routes that are exposed for each ingress\n \n \n \n \n \n \n \n Ingress \n Ingress Http route \n Application \n \n \n \n \n Keycloak ingress \n /auth \n Keycloak \n \n \n Entando cluster infrastructure ingress \n /k8s \n Entando K8S service \n \n \n Entando App ingress \n /entando-de-app \n App engine \n \n \n /app-builder/ \n App builder \n \n \n /digital-exchange \n Entando component manager \n \n \n /<plugin-ingressPath> \n Entando plugin linked to the app \n \n \n Entando plugin ingress \n /<plugin-ingressPath> \n Entando plugin \n \n \n \n Note : The Entando plugin  ingressPath  variable is defined in the Entando Plugin custom resource under the  spec  element. The plugin ingress path is also used to expose the plugin under the Entando App domain \n Exposing plugins in the EntandoApp domain \n The process of exposing an Entando Plugin under the same domain (ingress) of the Entando App is made possible from the creation of an  EntandoAppPluginLink  custom resource and the corresponding controller. \n Once the link between the Entando App and the Entando Plugin is created, the controller reads the specification of such link and automatically creates the HTTP routes in the Entando App so that the plugin is exposed on the same domain as the App builder, App engine and Component manager. \n This allows the Microfrontend developers that need to access the plugin to not worry about CORS policy or knowing what is the full path where the plugin is exposed. The plugin is referencable using relative urls. \n How to check ingresses in my cluster \n Using the Openshift dashboard \n On the Openshift dashboard, Ingresses are not exposed directly as pods and deployments. The dashbaord provides direct access to the Ingress Routes (or simply routes) under the  Applications > Routes  menu. \n \n To see the ingress resources, you need to access them from the  Resources > Other resources  menu. From the dropdown you should select the  Ingress  resource and therefore you should be able to see the ingress available on that specific project/namespace \n Using kubectl from the command line \n From the command line, getting the ingress is very easy. Once you know the namespace(s) where your Entando Cluster is deployed, you simply need to use the \n kubect get ingresses.extensions -n <namespace>\n \n Here an example of the result in a test namespace \n > kubectl get ingresses.extensions -n local\n\nNAME               CLASS    HOSTS                               ADDRESS     PORTS   AGE\nqst-eci-ingress   <none>   qst-eci-local.192.168.1.9.nip.io   127.0.0.1   80      2d1h\nqst-ingress       <none>   qst-local.192.168.1.9.nip.io       127.0.0.1   80      2d1h\nqst-kc-ingress    <none>   qst-kc-local.192.168.1.9.nip.io    127.0.0.1   80      2d1h\n \n To get more details about a specific ingress, you can use the  get  command specifing the ingress name you want to check and the  yaml  output format \n > kubectl get ingresses.extensions -n local qst-ingress -o yaml\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  creationTimestamp: "2020-05-13T15:27:08Z"\n  generation: 1\n  labels:\n    EntandoApp: qst\n  managedFields:\n  - apiVersion: extensions/v1beta1\n    fieldsType: FieldsV1\n    fieldsV1:\n      f:status:\n        f:loadBalancer:\n          f:ingress: {}\n    manager: nginx-ingress-controller\n    operation: Update\n    time: "2020-05-13T15:27:08Z"\n  name: qst-ingress\n  namespace: local\n  ownerReferences:\n  - apiVersion: entando.org/v1\n    blockOwnerDeletion: true\n    controller: true\n    kind: EntandoApp\n    name: qst\n    uid: aa7053e1-fd8b-419f-bdee-df3018c013fa\n  resourceVersion: "16802097"\n  selfLink: /apis/extensions/v1beta1/namespaces/local/ingresses/qst-ingress\n  uid: e9b6f027-369a-4b84-b4b1-736a6e49f180\nspec:\n  rules:\n  - host: qst-local.192.168.1.9.nip.io\n    http:\n      paths:\n      - backend:\n          serviceName: qst-server-service\n          servicePort: 8080\n        path: /entando-de-app\n        pathType: ImplementationSpecific\n      - backend:\n          serviceName: qst-server-service\n          servicePort: 8083\n        path: /digital-exchange\n        pathType: ImplementationSpecific\n      - backend:\n          serviceName: qst-server-service\n          servicePort: 8081\n        path: /app-builder/\n        pathType: ImplementationSpecific\nstatus:\n  loadBalancer:\n    ingress:\n    - ip: 127.0.0.1\n Learn more \n For more details about ingress concept in Kubernetes please refer to the official documentation: \n \n Kubernetes Ingress documentation \n Openshift Routes documentation \n \n'},{title:"Component Generation Technologies",frontmatter:{},regularPath:"/v6.3/docs/component-generator/component-gen-tech.html",relativePath:"v6.3/docs/component-generator/component-gen-tech.md",key:"v-dcd8b7f4",path:"/v6.3/docs/component-generator/component-gen-tech.html",headers:[{level:2,title:"Technology in the Generated Components",slug:"technology-in-the-generated-components"},{level:2,title:"Blueprint Technology",slug:"blueprint-technology"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:" Component Generation Technologies \n Technology in the Generated Components \n When generating a microservice using the Entando Component Generator there are a number of technical choices that need to be made \n \n Microservice code\n \n The Component Generator currently only supports the generation of Spring Boot microservices but will support the generation of Quarkus based services soon. \n If you're interested in using Quarkus in your Entando app contact us on the  Forum  or  Community Slack  and we'll help you get started. \n \n \n Database type\n \n Entando recommends standardizing your choice of database to simplify operational maintenance but you do have the ability to use different databases for different microservices if you choose. \n Supported choices are none, MySQL, and Postgres. Enterprise customers can choose Oracle but should contact Entando Support for details. \n \n \n Development databases\n \n You can choose to utilize a full RDBMS or developers can utilize lightweight in memory or on disk databases with h2. \n \n \n Caching implementation\n \n When generating a microservice you will be presented with the type of cache to inject into the services. It is recommended that this is a standard choice for all of the microservices in your application but can be customized on a per service basis if desired. \n \n \n Build system\n \n Determines the java build tool to use when building your services \n Supports maven or gradle \n \n \n Other technologies\n \n Users of the component generator can also decide to use other technologies from JHipster or from the JHipster marketplace. \n There are many powerful technologies in the marketplace but it is up to the developer to integrate any choices from the marketplace into their Entando application. Entando doesn't provide any direct support for marketplace tech choices. \n \n \n Micro frontends\n \n Users can optionally choose to generate micro frontends for entities generated via the blueprint. \n The Entando Component Generator only provides micro frontends in React from the generation flow but developers can create and bundle micro frontends in other technologies as well. \n \n \n \n If you want to try out these choices follow the tutorial on  creating Entando microservices and micro frontends using the component generator \n Blueprint Technology \n JHipster and the Entando Blueprint are built using EJS which is a Javascript based templating language that provides powerful constructs for large scale file generation. Learn more about EJS here at  https://ejs.co/  or checkout the core  Jhipster Generator  or  Entando Blueprint  for examples of EJS in action. \n"},{title:"The Entando Operator",frontmatter:{},regularPath:"/v6.3/docs/concepts/operator-intro.html",relativePath:"v6.3/docs/concepts/operator-intro.md",key:"v-7901b1b4",path:"/v6.3/docs/concepts/operator-intro.html",headers:[{level:2,title:"Installation Scope Options",slug:"installation-scope-options"},{level:3,title:"When to use Cluster Scoped Deployments",slug:"when-to-use-cluster-scoped-deployments"},{level:3,title:"When to use Namespace Scoped Deployments",slug:"when-to-use-namespace-scoped-deployments"},{level:2,title:"TLS Secret Creation",slug:"tls-secret-creation"},{level:2,title:"Database Deployment",slug:"database-deployment"},{level:2,title:"Ingress Path Generation",slug:"ingress-path-generation"}],lastUpdated:"4/2/2021, 9:05:10 AM",lastUpdatedTimestamp:161736871e4,content:" The Entando Operator \n The Entando Operator processes the custom resources in Kubernetes that represent the different  components of an Entando application .\nThe goal of the operator is to provide automation and a set of default configuration options to simplify and accelerate the deployment of an Entando application. \n The sections below provide details and assumptions that the operator makes when deploying Entando Custom Resources. If you're using OpenShift these\nsections will provide details on how to configure your deployment via the Operator Hub. \n For details on the individual custom resources and their configuration check out the  custom resources documentation . \n Installation Scope Options \n The Entando Operator can be installed in one of two modes. Either cluster scoped or namespace scoped. In a cluster scoped deployment the operator will have\nvisibility across the cluster and will manage all of the Entando applications in the Kubernetes cluster. In a namespace scoped deployment the operator\nwill only have visibility to the namespace where it is deployed and will manage only the components in that namespace. \n When installing the operator via OpenShift look for the  Installation Mode  option to select the scoping for the operator. \n When choosing how to deploy your operator there are no right or wrong answers. Think about the deployment that best fits your goals and team. Here are some items to think about. \n When to use Cluster Scoped Deployments \n \n Cluster scoped deployments are common in production clusters and in environments with strong operational support and controls. \n A cluster scoped deployment can saves resources When you want to optimize resource consumption and share Kubernetes infrastructure. \n When you are planning to centralize and share other infrastructure resources like Keycloak and databases a cluster scoped deployment can fit into the same management processes.\n \n Sharing infrastructure resources is a recommended approach for medium or large teams and the operator can be treated like other infrastructure services. \n \n \n In some cases security requirements will require that the permissions required for the operator are managed separately from the deployed applications. A cluster scoped deployment isolates the operator permissions in a separate namespace. \n Cluster scoped deployments can simplify the deployment of an Entando app by developers or end users because they have fewer resources to manage \n When to use Namespace Scoped Deployments \n \n Namespace scoped deployments are common in dev clusters. Or in clusters where application naemspaces come and go frequently \n Namespace scoped deployments are useful in scenarios where you plan to, or could have, many different versions of Entando \n Namespace scoped deployments give your teams complete team autonomy and the ability to create and destroy applications \n When teams are small and self managing from an operational perspective a namespace scoped deployment is a simpler architecture \n If you plan to have a small number of applications deployed in the cluster a namespace scoped deployment can be easier to manage \n \n Click here for tutorials and instructions for deploying via operator hub \n TLS Secret Creation \n When configuring and deploying Entando via the operator you will be asked to provide a secret for some of the components in the architecture. A few things to be aware of when creating and configuring a secret: \n \n The secret is assumed to be in the same namespace as the component being created. \n This secret is expected to have a private key, and a certificate for the hostname (or a wildcard cert) that the service\nwill be exposed on. \n Refer to the 'ingressHostname' property in the custom resource for more information on how the hostname is\ndetermined. \n If a secret isn't provided the Entando Operator will evaluate the value of the  ENTANDO_PATH_TO_TLS_KEYPAIR  which is\nexpected to contain two files: tls.key and tls.crt.\n \n If a key pair is found in the folder specified, it will revert to the keypair found. \n If a key pair is not found the Entando Operator will evaluate the value of the  ENTANDO_USE_AUTO_CERT_GENERATION .\nIf that property is set to  true  the Entando Operator will assume that the cluster has been configured with a valid CA and leave it to\nthe Ingress controller to generate its own certificates. \n \n \n \n Click here for tutorials on creating secrets and setting up TLS in your Entando Apps. \n Database Deployment \n Some Entando components include the ability to select a database management system (DBMS) when deploying the component. \n \n \n The DBMS field in Entando Custom Resources can be one of mysql, oracle, postgresql or embedded. \n \n IMPORTANT!  -- If embedded is selected for a component only 1 replica for the component can be created. \n IMPORTANT!  -- Oracle instances are not supported for automatic deployment in a container. You must create an Oracle instance or use an existing instance and configure it as an  external database  for your Entando app \n \n \n \n If an EntandoDatabaseService has been deployed in the component's namespace, and the DBMS specified on this EntandoDatabaseService\nis the same as the DBMS specified on this EntandoApp, the Entando Operator will create dedicated\nschemas (in the case of PostgreSQL or Oracle), or databases in the case of MySQL. \n \n If a matching EntandoDatabaseService does not exist in this namespace, the Entando Operator\nwill automatically deploy the appropriate container to host the DBMS specified. This last option is not\nyet supported for Oracle. \n \n \n \n For an EntandoApp three schemas/database will be created: the Entando Port DB, tne Entando Serv DB and a database for\nthe Entando Component Manager. \n \n If the Port and Serv schemas/databases are empty, the Entando Operator  will use the underlying Entando App to populate these databases with the data backup available in the standard backup path in the WAR deployment. \n In scenarios where the EntandoApp needs to connect to an existing database that is fully managed\nby the customer, it is best to setup the standard database connection variables using the\n spec.environmentVariables  property and set this property to 'none'. This will skip any database\npreparations steps in the deployment. \n \n \n \n When deploying a component the operator will evaluate the spec and if it supports the standard  spec.dbms \nproperty, the value of this property will be given to the component's  spec.dbms . Please consult\nthe documentation for each component's CRD to determine how each Entando resource uses the dbms (if any). \n Ingress Path Generation \n When deploying an Entando Custom Resource that uses an Ingress path: \n \n The  ingressHostName  property defines the host path that will be used to access this\nservice from outside the cluster. The Entando Operator will\ncreate an ingress reflecting this hostname, and expose the resource at its default path.\n \n IMPORTANT!  -- If omitted, the Entando Operator will automatically generate a hostname\nusing the value of the ENTANDO_DEFAULT_ROUTING_SUFFIX environment variable that the Entando Operator was\nconfigured with. It will prefix the name and namespace of the EntandoKeycloakServer to this default routing suffix. \n \n \n \n"},{title:"Entando's Custom Resources for Kubernetes",frontmatter:{},regularPath:"/v6.3/docs/concepts/custom-resources.html",relativePath:"v6.3/docs/concepts/custom-resources.md",key:"v-1450c2a6",path:"/v6.3/docs/concepts/custom-resources.html",headers:[{level:2,title:"Objective",slug:"objective"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"The Core Entando Custom Resources",slug:"the-core-entando-custom-resources"},{level:2,title:"The ResourceRequirements specification",slug:"the-resourcerequirements-specification"},{level:2,title:"EntandoKeycloakServer",slug:"entandokeycloakserver"},{level:3,title:"Overview",slug:"overview-2"},{level:3,title:"Example",slug:"example"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties"},{level:2,title:"EntandoClusterInfrastructure",slug:"entandoclusterinfrastructure"},{level:3,title:"Overview",slug:"overview-3"},{level:3,title:"Example",slug:"example-2"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-2"},{level:2,title:"EntandoApp",slug:"entandoapp"},{level:3,title:"Overview",slug:"overview-4"},{level:3,title:"Example",slug:"example-3"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-3"},{level:2,title:"EntandoPlugin",slug:"entandoplugin"},{level:3,title:"Overview",slug:"overview-5"},{level:3,title:"Example",slug:"example-4"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-4"},{level:2,title:"EntandoAppPluginLink",slug:"entandoapppluginlink"},{level:3,title:"Overview",slug:"overview-6"},{level:3,title:"Example",slug:"example-5"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-5"},{level:2,title:"EntandoDatabaseService",slug:"entandodatabaseservice"},{level:3,title:"Example",slug:"example-6"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-6"},{level:2,title:"EntandoCompositeApp",slug:"entandocompositeapp"},{level:3,title:"Overview",slug:"overview-7"},{level:3,title:"Example",slug:"example-7"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-7"}],lastUpdated:"12/15/2021, 2:22:26 PM",lastUpdatedTimestamp:1639596146e3,content:' Entando\'s Custom Resources for Kubernetes \n Objective \n This document provides an overview of the Entando Kubernetes Custom Resources and their semantics in Entando 6. \n Prerequisites \n \n Basic knowledge of Kubernetes and how to deploy Docker images to it \n Basic knowledge of Helm and how Helm Charts use YAML templates for parameterized deployments to Kubernetes \n Overview \n Amongst the many features it offers, Kubernetes also comes with a REST API that for dozens of different resources types.\nGenerally these API off full Create/Retrieve/Update/Delete (CRUD) access to each of the resource types. We\ntypically format these resources in YAML or JSON and use commandline tools such as\n kubectl  or  oc  to manage them. Each of these resources has a clearly defined structure\nthat is well documented in the  Kubernetes API  .\nKubernetes  also allows clients to subscribe to events generated as these resources get updated. These subscriptions\nare called \'watches\' and allow clients to be notified whenever the state of a resource changes. Kubernetes also\nenforces very strong role based access control (RBAC) support on all resources, with permissions down to the level\nof granularity of operation (Create/Retrieve/Update/Delete/Watch) per resource. \n The basic architecture for Kubernetes worked so well for the developers of Kubernetes that they decided to also make it\navailable to third  party developers. Kubernetes now offers a mechanism to allow 3rd parties to provide its own custom\nresource types that still leverage the CRUD support, event subscriptions and RBAC provided by Kubernetes out of the box.\nThis mechanism is referred to as Custom Resources. \n Custom Resources are very commonly used with Kubernetes Operators. Operators are Docker images that have been\ndeployed to Kubernetes Deployments. The generally observe a set of custom resources and perform some operations against\nthe Kubernetes API to reflect the state changes in the Custom Resource. We can say that the Custom Resources are associated\nwith specific semantics in how they are translated to \n One can introduce a new Custom Resource into Kubernetes by registering a Custom Resource Definition (CRD). This is really\njust another yaml or json resource that defines the structure of the Custom Resource to be installed using the OpenAPI\nJSON Schema format. When talking about Custom Resources, it is very important to distinguish between Custom Resource\nDefinitions and Custom Resources. CRD\'s are static type definitions provided by an Operator\nprovider such as Entando. For those familiar with programming languages, CRD\'s are like class definitions, whereas\nCustom Resources are actual instances of that class. \n Entando introduces two groups of Custom Resources. On the one hand, there are the core Entando Custom Resources required\nfor a basic installation of Entando in a Kubernetes cluster. These Custom Resources directly result in other\nKubernetes resources being deployed in the cluster. On the other hand, there are the Custom Resources specific\nto the Entando Component Repository that serve primarily as metadata for other Entando components. \n The Core Entando Custom Resources \n The Entando Operator observes all the Core Entando Custom Resources in one or more namespaces. This means that if a Core\nEntando Custom Resource is created, updated or deleted, the Entando Operator will trigger a new run-to-completion Pod\nthat will translate that state change into a state change in the actual Kubernetes Cluster. Often, this will\nresult in the Deployment of one or more Docker images, but also one or more Services and sometimes and Ingress\ntoo. We refer to the Docker Images that implement these run-to-completion Pods as Entando Kubernetes Controllers. \n The Entando Operator itself is also implemented as a Docker Image. You can have a closer look at how it works in the\n entando-k8s-controller-coordinator  project on Github.\nApart from the normal Maven, Java and Docker files one would expect, you will also notice the\n entando-k8s-controller-coordinator Helm Chart .\nThis Helm Chart is basically the entrypoint for installations of Entando 6 on Kubernetes. More detailed instructions\non how to install the Entando 6 Operator are available in our\n installation instructions \n The ResourceRequirements specification \n All of the Entando Custom Resources that result in physical Kubernetes Deployments can be configured with specific\nresource requirements. These settings can be provided under the  spec  object of the custom resource. It currently\nsupports the following attributes: \n \n spec.resourceRequirements.storageRequest  - the initial storage requested from the persistence provider. Please keep\nin mind that resizable storage is not supported by all storage providers, and that this may be the final size of the storage\nallocated. \n spec.resourceRequirements.storageLimit  - the maximum amount of storage required by the deployment. \n spec.resourceRequirements.memoryRequest  - the initial memory requested from the node the deployment\'s primary container is running on \n spec.resourceRequirements.memoryLimit  - the maximum amount of memory the deployment\'s primary container will use. If\nit exceeds this amount, the container maybe be terminated by Kubernetes. \n spec.resourceRequirements.cpuRequest  - the initial CPU allocation from the node the deployment\'s primary container is running on \n spec.resourceRequirements.cpuLimit  - the maximum CPU allocation for the deployment\'s primary container. \n spec.resourceRequirements.fileUploadLimit   - the maximum upload file size supported by the deployment \n \n All of these attributes require a number and a unit of measurement, e.g. "64Mi". Please consult the\n official Kubernetes documentation \nfor more information on how to configure these attributes. \n EntandoKeycloakServer \n The EntandoKeycloakServer Custom Resource is used to deploy and configure a Red Hat Keycloak Server instance on the\ncluster. After deploying this Keycloak instance, the Entando Operator will create a Kubernetes Secret that provides\nthe necessary information for subsequent deployment operations to access the Keycloak instance as the Admin user. This\nallows the rest of the Entando Kubernetes Controllers to create a Keycloak OIDC client for every HTTP service that\ngets deployed. If you already have a Keycloak instance that you would use, you can skip this custom resource entirely\nand simply create the `keycloak-admin-secret\' in the operator\'s namespace as specified in\n this tutorial \n Overview \n \n Entando Cluster Citizen:  Keycloak \n Custom Resource Definition:  EntandoKeycloakServer \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-keycloak-controller \n Github Repo:  entando-k8s/entando-k8s-keycloak-controller \n \n \n Deployment Details:\n \n Docker image:  entando/entando-keycloak \n Github Repo:  entando/entando-keycloak \n \n \n Possible Database Images:\n \n MySQL:  docker.io/centos/mysql-57-centos7 \n PostgreSQL:  docker.io/centos/postgresql-96-centos7 \n Example \n ---\nkind: "EntandoKeycloakServer"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-keycloak"\n  namespace: "keycloak-namespace"\nspec:\n  dbms: "postgresql"\n  imageName: "entando/entando-keycloak"\n  ingressHostName: "test-keycloak.ampie.dynu.net"\n  isDefault: true\n  environmentVariables: \n    - name: KEYCLOAK_WELCOME_THEME\n      value: my-custom-theme\n  tlsSecretName: my-tls-secret\n  replicas: 1\n Explanation of properties \n \n spec.dbms  is used to select the database management of choice. If this value matches up to the  spec.dbms  property\nof a previously  configured  EntandoDatabaseService ,\nthe Keycloak image will be configured to use this service.\nAlternatively, the Entando Operator will use this value to deploy a dedicated Database instance in this namespace\nfor Keycloak to use. If left empty, or given value of \'none\', Keycloak will be deployed using its own internal\nH2 database. \n spec.imageName  is used to provide a customized image. By default, the operator will use the  entando/entando-keycloak \ndiscussed above. When using the default image, please refer to the\n relevant section \nin the README of the Entando Operator to determine how the Docker registry and version of this image will be calculated.\nWhen you need to customize the theme or add extensions to Keycloak, you can create your own custom image and provide\nthe value in this property. In this custom image, make sure you use the default image ( entando/entando-keycloak )\nas a base image. You can then add your customizations and build your own image. Please use a fully qualified\nDocker image name here. \n spec.ingressHostName  is the hostname of the Kubernetes Ingress to be created for Keycloak. Please ensure that this is\naccessible using the default routing suffix of your Entando Operator Deployment, or a DNS name previously\nregistered with your DNS provider. \n spec.isDefault  is \'true\' by default and this should suffice for most conditions. This will result in the standard\n keycloak-admin-secret  being replaced by a Secret connecting you to this newly created Keycloak instance.\nTheoretically one could use multiple Keycloak instances in a cluster, in which case this property should be false. \n spec.environmentVariables  is a Map of environment variables to pass to the Keycloak Docker image. For example, this could\nbe used to select a specific theme for Keycloak to use using the variable KEYCLOAK_WELCOME_THEME. These parameters\nare applied to the container\'s environment variables after all variables have been calculated. It can therefore\nalso be used as a mechanism to override any of the default environment variables that need customization. \n spec.tlsSecretName  is the name of a standard Kubernetes\n TLS Secret  that will be used for the\nresulting Ingress. This is only required if the\n globally configured TLS Secret \nfor the Operator is absent or has not been created with a wildcard hostname that supports this Keycloak instance\'s hostname. \n spec.replicas  - the number of replicas to be made available on the Deployment of this Keycloak Server \n spec.resourceRequirements  - the minimum and maximum  resource allocation  for the Keycloak Server container. \n EntandoClusterInfrastructure \n The EntandoClusterInfrastructure custom resource can be used to create the shared services that Entando requires in a cluster.\nAt the time of the writing of this document, there is really only one service, which is the Entando K8S Service, but this\nmay change in future. Deployments resulting from this custom resources are configured to use the default Keycloak\nServer specified in the  keycloak-admin-secret  using the  entando  realm. An Ingress will also be created as part of this\ndeployment. At this point, there is no way to customize the image in question. \n Overview \n \n Entando Cluster Citizen:  Entando Kubernetes Service \n Custom Resource Definition:  EntandoClusterInfrastructure \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-cluster-infrastructure-controller \n Github Repo:  entando-k8s/entando-k8s-keycloak-controller \n \n \n Deployment Details:\n \n Docker image:  entando/entando-k8s-service \n Github Repo:  entando-k8s/entando-k8s-service \n \n \n Possible Database Images: none \n Example \n ---\nkind: "EntandoClusterInfrastructure"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-eci"\n  namespace: "eci-namespace"\nspec:\n  keycloakSecretToUse: some-keycloak-secret\n  ingressHostName: "test-keycloak.ampie.dynu.net"\n  isDefault: true\n  environmentVariables: \n    - name: ENTANDO_NAMESPACES_TO_OBSERVE\n      value: my-namespace\n  tlsSecretName: my-tls-secret\n  replicas: 1\n Explanation of properties \n \n spec.keycloakSecretToUse  is used to determine which Kubernetes Secret to use to connect to the correct\nKeycloak instance. If not specified, the default Secret  keycloak-admin-secret  will be used. Only useful\nif you have more than one Keycloak server in your cluster. \n spec.ingressHostName  is the hostname of the Kubernetes Ingress to be created for the Entando K8S Service. Please\nensure that this is accessible using the default routing suffix of your Entando Operator Deployment, or a DNS\nname previously registered with your DNS provider. \n spec.isDefault  is \'true\' by default and this should suffice for most conditions. This will result in the standard\n entando-cluster-infrastructure-secret  being replaced by a Secret connecting you to this newly created\nEntando K8S Service.  Theoretically one could use multiple Entando K8S Services in a cluster, in which\ncase this property should be false for new Entando K8S Services that should not override the default Secret. \n spec.environmentVariables  is a Map of environment variables to pass to the Entando K8S Service Docker image. For example, this could\nbe used to override the ENTANDO_NAMESPACES_TO_OBSERVE variable that configures the set of Kubernetes namespaces\nthis service should read EntandoDeBundles from. Also note that all of the\n Spring variables in entando-k8s-service project \ncan also be overridden here by specifying the equivalent SNAKE_CASE names of the dot-delimited Spring properties.\nThese parameters are applied to the container\'s environment variables after all variables have been calculated.\nIt can therefore also be used as a mechanism to override any of the default environment variables that need customization. \n spec.tlsSecretName  is the name of a standard Kubernetes\n TLS Secret  that will be used for the\nresulting Ingress. This is only required if the\n globally configured TLS Secret \nfor the Operator is absent or has not been created with a wildcard hostname that supports this Keycloak instance\'s hostname. \n spec.replicas  - the number of replicas to be made available on the Deployment of this Entando K8S Service \n spec.resourceRequirements  - the minimum and maximum  resource allocation  for the Entando Kubernetes Service container. \n EntandoApp \n An EntandoApp is a Deployment of a Docker image that hosts an Entando and Java based web application. Entando offers two\nstandard images that can be used, but generally we expect our customers to provide their own images here. An EntandoApp\nDeployment packages three images into a single Pod: the Entando App Image in question, AppBuilder and Component Manager. \n Overview \n \n Custom Resource Definition:  EntandoApp \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-app-controller \n Github Repo:  entando/entando-k8s-app-controller \n \n \n Deployment Details - Entando App:\n \n Docker image:  entando/entando-de-app-wildfly   or    entando/entando-de-app-eap \n Github Repo:  entando-k8s/entando-de-app \n Entando Cluster Citizen:  Entando App \n \n \n Deployment Details - AppBuilder:\n \n Docker image:  entando/app-builder \n Github Repo:  entando/app-builder \n \n \n Deployment Details - ComponentManager:\n \n Docker image:  entando/entando-component-manager \n Github Repo:  entando-k8s/entando-component-manager \n Entando Cluster Citizen:  Component Manager \n \n \n Possible Database Images:\n \n MySQL:  docker.io/centos/mysql-57-centos7 \n PostgreSQL:  docker.io/centos/postgresql-96-centos7 \n Example \n ---\nkind: "EntandoApp"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-app"\n  namespace: "my-namespace"\nspec:\n  standardServerImage: wildfly\n  customServerImage: your-org/your-image:4.3.2\n  dbms: "postgresql"\n  ingressPath: my-app\n  keycloakSecretToUse: some-kc-secret\n  clusterInfrastructureToUse: some-eci-secret  \n  ingressHostName: "test-app.my-routing-suffix.com"\n  environmentVariables: \n    - name: ENTANDO_VAR1\n      value: my-var1\n  tlsSecretName: my-tls-secret\n  replicas: 1\n  ecrGitSshSecretName: my-secret\n Explanation of properties \n \n spec.standardServerImage  can be either wildfly  or  eap . This instructs the Entando Operator to use one of the\ntwo standard Entando App images.\n \n For  wildfly  it will deploy the  entando/entando-de-app-wildfly  image \n For  eap  it will deploy the  entando/entando-de-app-eap  image\nThis property and the  spec.customServerImage  are  assumed to be mutually exclusive. Only provide a value to\none of the two. Please refer to the\n relevant section \nin the README of the Entando Operator to determine how the Docker registry and version of these images will be calculated. \n \n \n spec.customServerImage  can be used to deploy the Docker image containing your own custom Entando App. Please\nfollow the instructions on how to  build your own image . \nThis property and the  spec.standardServerImage  are  assumed to be mutually exclusive. Only provide a\nvalue to one of the two. \n spec.dbms  is used to select the database management of choice. If left empty, a default value of  postgresql \nis assumed. The value  none  is not supported. If this value matches up to the  spec.dbms  property\nof a previously configured  EntandoDatabaseService ,\nthe Entando App will be configured to use this service.\nAlternatively, the Entando Operator will use this value to deploy a dedicated Database instance in this namespace\nfor the EntandoApp to use. \n spec.ingressPath  specifies the web context of the Entando App to be deployed. This is required to create a single\npath entry in the Ingress that is used to expose the Entando App. The default behaviour of Wildfly and\nJBoss EAP is to use the name of the WAR file that is deployed, but it is possible to override this in the EntandoApp\nproject itself using a  jboss-web.xml  file .\nIn the absence of the  jboss-web/xml  file, the web context  would be the the\nMaven artifactId of the Entando Opp project. It is also possible to modify this by changing the  <finalName>  element\nin the Maven  pom.xml \n spec.clusterInfrastructureToUse  is the name of the Kubernetes Secret that provides the connection details to the\nEntandoClusterInfrastructure containining the Entando Component Repository for this App to use. This is only\nrequired if more than one EntandoClusterInfrastructure is available and this value can be omitted entirely under\nmost conditions. \n spec.keycloakSecretToUse  is used to determine which Kubernetes Secret to use to connect to the correct\nKeycloak instance. If not specified, the default Secret  keycloak-admin-secret  will be used. Only useful\nif you have more than one Keycloak server in your cluster. \n spec.ingressHostName  is the hostname of the Kubernetes Ingress to be created for the Entando App. Please\nensure that this is accessible using the default routing suffix of your Entando Operator Deployment, or a DNS\nname previously registered with your DNS provider. Keep in mind that EntandoPlugins linked to this app will\nalso be made available on this host. \n spec.environmentVariables  is a Map of environment variables to pass to the EntandoApp Docker image. For example, this could\nbe used to provide connection details for custom datasources or message queues as discussed in the\n custom datasources tutorial . Also note that all of the\n Spring variables in an Entando project \ncan also be overridden here by specifying the equivalent SNAKE_CASE names of the dot-delimited Spring properties.\nThese parameters are applied to the container\'s environment variables after all variables have been calculated.\nIt can therefore also be used as a mechanism to override any of the default environment variables that need customization.\nKeep in mind that these parameters will be passed to each of the three containers in this Pod as environment\nvariables, and that care needs to be taken to avoid conflicting variable names. \n spec.tlsSecretName  is the name of a standard Kubernetes\n TLS Secret  that will be used for the\nresulting Ingress. This is only required if the\n globally configured TLS Secret \nfor the Operator is absent or has not been created with a wildcard hostname that supports this Keycloak instance\'s hostname. \n spec.replicas  - the number of replicas to be made available on the Deployment of this Entando App \n spec.resourceRequirements  - the minimum and maximum  resource allocation  for the Entando App Engine container. \n spec.ecrGitSshSecretName  - a secret containing a private key file named  rsa_id  that matches a public key configured in the Git server. \n EntandoPlugin \n An Entando Plugin is a microservice that can be made available to one or more EntandoApps in the cluster. Please follow\nour instructions on using our blueprint to  build your own EntandoPlugin . The\nDeployment resulting from an EntandoPlugin is also a multi-container Pod deployment, and will include both the\nplugin Docker image specified and the EntandoPluginSidecar Docker Image \n Overview \n \n Custom Resource Definition:  EntandoPlugin \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-plugin-controller \n Github Repo:  entando/entando-k8s-plugin-controller \n \n \n Deployment Details - plugin:\n \n Docker image: as provided by user \n Entando Cluster Citizen:  Plugin \n \n \n Deployment Details - EntandoPluginSidecar:\n \n Docker image:  entando/entando-plugin-sidecar \n Github Repo:  entando/entando-plugin-sidecar \n \n \n Possible Database Images:\n \n MySQL:  docker.io/centos/mysql-57-centos7 \n PostgreSQL:  docker.io/centos/postgresql-96-centos7 \n Example \n ---\nkind: "EntandoPlugin"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-plugin"\n  namespace: "my-namespace"\nspec:\n  image: your-org/your-image:4.3.2\n  securityLevel: lenient\n  ingressPath: /my-plugin\n  healthCheckPath: /actuator/health\n  dbms: "postgresql"\n  keycloakSecretToUse: some-kc-secret\n  clusterInfrastructureToUse: some-eci-secret  \n  ingressHostName: "test-app.my-routing-suffix.com"\n  roles:\n    - code: admin\n      name: Administrators\n    - code: user\n      name: Users\n  permissions: \n    - clientId: some-keycloak-client \n      role: some-admin\n    - clientId: another-keycloak-client \n      role: another-admin\n  environmentVariables: \n    - name: ENTANDO_VAR1\n      value: my-var1\n  tlsSecretName: my-tls-secret\n  replicas: 1\n Explanation of properties \n \n spec.image  is the Docker image you can provide for the plugin you want to deploy. Please follow\nour instructions on using our blueprint to  build your own EntandoPlugin \nCurrently only Docker images hosting Spring Boot applications are supported. It is therefore of  utmost\nimportance to start off with our blueprint and ensure that the resulting Spring Boot application respects\nthe Spring variables to be set from the Entando Operator. \n spec.dbms  is used to select the database management of choice. If left empty, or if the value is  none , it\nis assumed that the plugin in question does not required a database. If this value matches up to\nthe  spec.dbms  property  of a previously  configured\n EntandoDatabaseService ,\nthe Entando Plugin will be configured to use this service.\nAlternatively, the Entando Operator will use this value to deploy a dedicated Database instance in this namespace\nfor the Entando Plugin to use. \n spec.ingressPath  specifies the web context where the Entando Plugin will be made available when linked to EntandoApps.\nPlease ensure this is in sync with the  server.servlet.context-path  property set on your Spring Boot application. \n spec.clusterInfrastructureToUse  is the name of the Kubernetes Secret that provides the connection details to the\nEntandoClusterInfrastructure this Plugin will use. This is only\nrequired if more than one EntandoClusterInfrastructure is available and this value can be omitted entirely under\nmost conditions. \n spec.keycloakSecretToUse  is used to determine which Kubernetes Secret to use to connect to the correct\nKeycloak instance. If not specified, the default Secret  keycloak-admin-secret  will be used. Only useful\nif you have more than one Keycloak server in your cluster. \n spec.ingressHostName  is the hostname of the Kubernetes Ingress to be created for the Entando Plugin. Please\nensure that this is accessible using the default routing suffix of your Entando Operator Deployment, or a DNS\nname previously registered with your DNS provider. This hostname will not be used from your Widgets that you\nhave implemented for this plugin as these widgets will use the hostname of the EntandoApp they are being used from.\nThis hostname is useful for embedded web user interfaces used only on this plugin, such as admin user interfaces\nor diagnostic user interface. \n spec.roles  specifies the set of roles that this plugin expects. At deployment time, the Entando Operator ensures\nthat each of these roles are created on Keycloak for the Keycloak client representing this EntandoPlugin. It is\nup to the Plugin provider to ensure that Spring Security has been set up to enforce the access rules implied\nby the individual roles. Each role has a unique  code  and a more human readable   name  as property. \n spec.permissions  specifies the set of permissions this plugin requires on other services with known Keycloak Clients.\nAt deployment time, the Entando Operator will use the service account user of this EntandoPlugin\'s Keycloak Client\nand create the necessary role bindings on the specified client id of the service to be used.\nEach permission specifies the  clientId  in Keycloak of the target service, and the  role  that this EntandoPlugin\nshould be bound to in that Keycloak client. \n spec.environmentVariables  is a Map of environment variables to pass to the EntandoPlugin Docker image.\nIt is entirely up to the plugin provider to determine the semantics of each variable. We strongly suggest for\nplugin provider  to use  the standard Spring Property Resolver syntax for Spring variables, as this would allow\nany of these variables to be overridden here by specifying the equivalent SNAKE_CASE names of the dot-delimited\nSpring properties.\nThese parameters are applied to the container\'s environment variables after all variables have been calculated.\nIt can therefore also be used as a mechanism to override any of the default environment variables that need customization.\nKeep in mind that these parameters will be passed to both containers in this Pod as environment\nvariables, and that care needs to be taken to avoid conflicting variable names. \n spec.tlsSecretName  is the name of a standard Kubernetes\n TLS Secret  that will be used for the\nresulting Ingress. This is only required if the\n globally configured TLS Secret \nfor the Operator is absent or has not been created with a wildcard hostname that supports this Keycloak instance\'s hostname. \n spec.replicas  - the number of replicas to be made available on the Deployment of this Entando Plugin \n spec.resourceRequirements  - the minimum and maximum  resource allocation  for the Entando Plugin container. \n EntandoAppPluginLink \n The EntandoAppPluginLink custom resource is created when an AppBuilder user links an EntandoPlugin to the current\nEntandoApp, or deploys an EntandoPlugin for use in the current EntandoApp. The Entando Operator processes the resulting\nEntandoAppPluginLink and creates a path for the Plugin on the Ingress that exposes the EntandoApp in question. This path\nis determined by the  spec.ingressPath  property on the EntandoPlugin custom resource itself. If the EntandoPlugin\nresides in a namespace other than the namespace of the EntandoApp, the EntandoOperator creates a Kubernetes\nService in the namespace of the EntandoApp that simply delegates to the Service in the namespace of the EntandoPlugin. \n Overview \n \n Custom Resource Definition:  EntandoAppPluginLink \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-app-plugin-link-controller \n Github Repo:  entando/entando-k8s-app-plugin-link-controller \n Example \n ---\nkind: "EntandoAppPluginLink"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-link"\n  namespace: "my-namespace"\nspec:\n  entandoAppName: my-app\n  entandoAppNamespace: my-namespace\n  entandoPluginName: my-app\n  entandoPluginNamespace: my-namespace\n Explanation of properties \n \n spec.entandoAppName  specifies the name of the EntandoApp that requires the plugin, found in  EntandoApp.metadata.name \n spec.entandoAppNamespace  specifies the namespace of the EntandoApp that requires the plugin, found in  EntandoApp.metadata.namespace \n spec.entandoPluginName  specifies the name of the EntandoApp that requires the plugin, found in  EntandoPlugin.metadata.name \n spec.entandoPluginNamespace  specifies the namespace of the EntandoApp that requires the plugin, found in  EntandoPlugin.metadata.namespace \n EntandoDatabaseService \n By default, the Entando Operator deploys one of either the MySQL or PostgreSQL database Docker images for every custom\nresource that requires a database. Many customers may however have existing infrastructure for their databases which\nthey may want to leverage. The EntandoDatabaseService custom resource allows customers to deploy a Service that points\nto an external database. When deploying one of the Entando custom resources that require a database, the Entando\nOperator will look for EntandoDatabases in the same namespace, and if it finds one with the same  spec.dbms  setting\nas the database required by the custom resource , it will create a dedicated schema/username/password combination\nfor the custom resource and point the deployment emanating from custom resource to this external database. \n \n Custom Resource Definition:  EntandoDatabaseService \n Example \n ---\nkind: "EntandoDatabaseService"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-database-service"\n  namespace: "my-namespace"\nspec:\n  dbms: "osracle"\n  host: 10.0.12.41\n  port: 1521\n  databaseName: mydb \n  tablespace: \n  secretName: some-secret\n  jdbcParameters:\n    maxStatements: 300 \n    loginTimeout: 180\n Explanation of properties \n \n spec.dbms  is used to select the database management of choice. If this value matches up to the  spec.dbms  property\nof the Entando custom resource that will use it. Valid values are  oracle ,  postgresql  and  mysql . \n spec.host  can either be a valid IPv4 address, or a hostname. Where an IP address is provided, the Entando Operator\nwill create a Kubernetes Service with an associated EndPoints resource to allow for routing to this address. Where\na hostname is provided, the Entando Operator will simply create a Kubernetes Service of type  cname \n spec.port  is the port that the external database service is running on. This value is optional in which case we will\nuse the default port for the DBMS vendor in question \n spec.databaseName  is the name of the database that the Entando Operator should be creating schemas in. This property\nis only for use with PostgreSQL and Oracle, as MySQL doesn\'t distinguish between schemas and databases. \n spec.tablespace  is only required for Oracle so that Schemas can be created in different tablespaces. \n spec.secretName  should be the name ( Secret.metadata.name ) of a Kubernetes Secret in the same namespace that has\na  username  key and a  password  key that will provide the Entando Operator with the necessary access and permissions\nto create Schemas and users on the database in question. \n spec.jdbcParameters  is a map of name/value pairs that will be appended to the JDBC connection string to allow for\nfurther customization of the actual connection to the database. \n EntandoCompositeApp \n The EntandoCompositeApp custom resource can be used to package a collection of Entando Core Custom Resources in a\nsingle YAML file for sequential deployment. Keep in mind that one can already use standard YAML syntax to package\na set of Kubernetes resources in a single file, separating each resource with a triple dash ( --- ). The purpose\nof this custom resource is therefor specifically to ensure that the deployment of the previous \'component\' has\ncompleted, and that  the resulting Pod is up and running before commencing deploying on the \'component\'. \n The primary use case of this custom resource is to package a full Entando App and all its supporting service and\nplugins for easy installation as is often required for demos and POCs. Creating this kind of dependency for typical\nproduction deployments is not advised, as it will inevitably result in a violation of pipeline isolation. The\nmore commonly recommended approach is for your Entando Apps and Plugins to be fully deployable in isolation. Use this\ncustom resource with care. \n Overview \n \n Custom Resource Definition:  EntandoCompositeApp \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-composite-app-controller \n Github Repo:  entando/entando-k8s-composite-app-controller \n Example \n ---\nkind: "EntandoCompositeApp"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-composite-app"\n  namespace: "my-namespace"\nspec:\n  components:\n    - kind: "EntandoKeycloakServer"\n         metadata:\n           name: "my-kc"\n         spec:\n           dbms: postgresql\n           isDefault: true\n           replicas: 1\n       - kind: "EntandoClusterInfrastructure"\n         metadata:\n           name: "my-eci"\n         spec:\n           dbms: postgresql\n           replicas: 1\n           isDefault: true\n       - kind: "EntandoApp"\n         metadata:\n           name: "my-app"\n         spec:\n           dbms: postgresql\n           replicas: 1\n           standardServerImage: wildfly\n           ingressPath: /entando-de-app\n       - kind: "EntandoPlugin"\n         metadata:\n           name: "my-pda"\n         spec:\n           image: "docker.io/entando/entando-process-driven-plugin:latest"\n           replicas: 1\n           dbms: "mysql"\n Explanation of properties \n \n spec.components  specifies the list of Entando Core Custom Resources to be deployed  in sequence . Please note\nthat only the Entando Custom Resources discussed in this section can be used in this list. Custom resources\nrelated to the Entando Component Repository never result in actual deployments on the Kubernetes cluster and\ntherefore do not need to be specified in any sequence. You can use the normal triple dash YAML notation to\ninclude them in the same YAML file \n \n'},{title:"PDA Architecture",frontmatter:{},regularPath:"/v6.3/docs/concepts/pda-architecture.html",relativePath:"v6.3/docs/concepts/pda-architecture.md",key:"v-258a5de6",path:"/v6.3/docs/concepts/pda-architecture.html",headers:[{level:2,title:"PDA MFEs",slug:"pda-mfes"},{level:2,title:"PDA API",slug:"pda-api"},{level:2,title:"Sidecar",slug:"sidecar"},{level:2,title:"PDA Core",slug:"pda-core"},{level:2,title:"PAM Impl",slug:"pam-impl"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:" PDA Architecture \n The objective of this document is to provide an explanation for the components\nthat compose the Process Driven Applications plugin (PDA) architecture from a\ndeployment perspective as well as how they interact with each other. \n The image below shows the components in high level: \n PDA MFEs \n The PDA Micro Frontends run on the browser and they render the UI custom\ncomponents the user interacts with. These components are written in React and\nthey fetch data from the PDA API, passing the Keycloak token for authentication.\nThe MFEs also make calls to the Entando Core API in order to retrieve the\nsettings required for the configuration UI. These components will be available\non Entando App Builder after the PDA plugin bundle is installed and the user\ncan create pages with them. \n The source code for this component:\n https://github.com/entando/entando-process-driven-plugin/tree/master/widgets \n PDA API \n The Spring Boot application that communicates with the engine and make its data\navailable in a Rest API. It interacts with Keycloak to validate the token and\nwith the sidecar to retrieve the connections/sensitive data, depending on how it\nwas deployed. The application shouldn't call specific engine classes directly,\ninstead it always calls the abstractions defined in PDA Core library. The engine\nimplementation to use is decided at runtime based on the connection details\nprovided. It is important to note that the PDA API application is stateless,\nsince it doesn't have a database. All data available on the API is retrieved\nfrom the BPM engine. After bundle installation, it will be deployed as a\nmicroservice in the Kubernetes infrastructure and an Ingress will be created to\nmake the API available to the MFEs, as described by the Entando Plugin custom\nresource. \n The source code for this component:\n https://github.com/entando/entando-process-driven-plugin \n Sidecar \n The sidecar is another application (docker container) deployed in the same Pod\nas the PDA API. It exposes services to manage connection details, which will be\nstored as secrets in Kubernetes. The PDA API communicates with the sidecar to\nmanage BPM engine connection details. \n The source code for this component:\n https://github.com/entando/entando-plugin-sidecar \n PDA Core \n This is the library that defines the interfaces and abstractions that should be\nimplemented to interact with specific BPM engines. This way it is possible to\nhave multiple engine implementations at the same time. \n The source code for this component:\n https://github.com/entando/pda-core-engine \n PAM Impl \n The Red Hat PAM implementation for the PDA Core library. If the connection maps\nto a PAM engine, these are the classes that are going to be executed when the\nPDA API requests for engine operations. This implementation communicates with\nthe Kie Server, which executes the defined process operations. \n The source code for this component:\n https://github.com/entando/pda-redhatpam-engine \n"},{title:"Bundle and Component Descriptors",frontmatter:{sidebarDepth:2},regularPath:"/v6.3/docs/ecr/ecr-bundle-details.html",relativePath:"v6.3/docs/ecr/ecr-bundle-details.md",key:"v-80e62764",path:"/v6.3/docs/ecr/ecr-bundle-details.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:3,title:"Bundle Conventions",slug:"bundle-conventions"},{level:3,title:"Bundle Descriptor",slug:"bundle-descriptor"},{level:2,title:"Plugin",slug:"plugin"},{level:3,title:"Kubernetes pod names",slug:"kubernetes-pod-names"},{level:3,title:"Permissions",slug:"permissions"},{level:2,title:"Widget",slug:"widget"},{level:2,title:"Fragment",slug:"fragment"},{level:2,title:"Page Template",slug:"page-template"},{level:2,title:"Page",slug:"page"},{level:2,title:"CMS Asset",slug:"cms-asset"},{level:2,title:"Content Template",slug:"content-template"},{level:2,title:"Content Type",slug:"content-type"},{level:2,title:"Content",slug:"content"},{level:2,title:"Categories",slug:"categories"},{level:2,title:"Groups",slug:"groups"},{level:2,title:"Labels",slug:"labels"},{level:2,title:"Languages",slug:"languages"},{level:2,title:"Static Resources",slug:"static-resources"}],lastUpdated:"6/18/2021, 5:36:22 AM",lastUpdatedTimestamp:1624008982e3,content:' Bundle and Component Descriptors \n Overview \n The Entando Component Manager reads the  descriptor.yaml  file from the root of the bundle package and uses it to install any components and resources included in the bundle. Here is the basic bundle structure: \n .\n├ descriptor.yaml\n├ resources/\n│ └ ...\n└ ... (folders reported in descriptor.yaml file)\n Bundle Conventions \n \n \n The bundle descriptor file needs to be named  descriptor.yaml  or the bundle will not be recognized. \n \n \n Static resources should be placed in a  resources  folder. They are not explicitly referenced in the  descriptor.yaml  file itself. \n Bundle Descriptor \n The bundle descriptor file aggregates all included components and has the following structure: \n \n Warning \n Remember the file needs to be named  descriptor.yaml . \n \n descriptor.yaml. \n code: survey_bundle # The bundle ID\ndescription: This is the survey bundle # The description of the bundle\n\ncomponents: # All components will be here\nOptional. Use if the component requires a deployment\n  plugins:\n    - folder/you/want/my_plugin_descriptor.yaml\n    - folder/you/want/another_plugin_descriptor.yaml\nTo create widgets you will need to add references to the descriptor file\'s\n  widgets:\n    - widgets/my_widget_descriptor.yaml\n    - widgets/another_widget_descriptor.yaml\nTo create fragments, you will need to add references to the descriptor file\'s\n  fragments:\n    - fragments/my_fragment.yaml\nTo create Page Templates you will need to add references to the descriptor file\'s\n  pageModels:\n    - pageModels/my_page_model_descriptor.yaml\n    - pageModels/another_page_model_descriptor.yaml\nTo create and publish pages you will need to add references to the descriptor file\'s\n  pages:\n    - page/my_page_descriptor.yaml\n    - page/another_page_descriptor.yaml\nTo create a CMS Asset you will need to add a reference to the descriptor file and put on the same location the image or file you want to upload.\n  assets:\n    - assets/my-asset/my_asset_descriptor.yaml\n    - assets/my-asset/my_image.jpg\nTo create Content Types you will need to add references to the descriptor file\'s\n  contentTypes:\n    - contentTypes/my_content_type_descriptor.yaml\nTo create Content Templates you will need to add references to the descriptor file\'s\n  contentModels:\n    - contentModels/my_content_model_descriptor.yaml\n    - contentModels/another_content_model_descriptor.yaml\nTo create and publish Contents you will need to add references to the descriptor file\'s\n  contents:\n    - contents/my_content_descriptor.yaml\n    - contents/another_content_descriptor.yaml\nTo create categories you will need to add references to the descriptor file\'s\n  categories:\n    - categories/my_categories.yaml\nTo create groups you will need to add references to the descriptor file\'s\n  groups:\n    - groups/my_groups.yaml\nTo create labels you will need to add references to the descriptor file\'s\n  labels:\n    - labels/my_labels.yaml\nTo enable labels you will need to add references to the descriptor file\'s\n  languages:\n    - languages/languages.yaml\n Plugin \n Here is an example of a plugin descriptor: \n Plugin descriptor.yaml \n image: "entando/my-image:1.0.0" # The docker image used to create the plugin\ndeploymentBaseName: "myplugin" # The base name to assign to the pods that have to be created in Kubernetes\ndbms: "postgresql" # The DBMS the plugin will use\nroles: # The roles the plugin will expose in keycloak\n  - "task-list"\n  - "task-get"\n  - "connection-list"\n  - "connection-get"\n  - "connection-create"\n  - "connection-delete"\n  - "connection-edit"\nhealthCheckPath: "/actuator/health" # The health check path that kubernetes will use to check status of the plugin deployment\ningressPath: "/myhostname.io/entando-plugin" # the ingress path to assign to the plugin deployment\npermissions: # a list of keycloak clientId / role to bind each to the other\n  - clientId: realm-management\n    role: manage-users\n  - clientId: realm-management\n    role: view-users\n Kubernetes pod names \n Each plugin is deployed onto Kubernetes using composite names. The first part is created reading the descriptor file, the second one is appended autonomously by Kubernetes.\nThis second part is 31 char long and each Kubernetes pod name length must be at most 63: longer name will result in the fail of the deployment. \n deploymentBaseName \n Initially, the first part of the pod name was generated concatenating and manipulating the  image  field value, however sometimes this approach could lead to a pod name longer than 63.\nTo solve this problem, another (optional) property is available:  deploymentBaseName . \n It accepts a string not longer than 32 and, if present, its value will be used as the first part for the pod\'s names, instead of the  image  one. \n In the previous example of the descriptor a possible resulting pod name will be this one in case the  deploymentBaseName  property is not present: \n entando-my-image-1-0-0-server-deployment-6f86f459wj9k \n and this one if the  deploymentBaseName  property is present: \n myplugin-server-deployment-6f86f459wj9k \n Please note that if you are using the  deploymentBaseName  property and you want to install more versions of the same plugin at the same time, you need to specify different values for  deploymentBaseName , maybe including the plugin version. \n Permissions \n The  permissions  property specifies a list of coupled clientId and roles that will be bound in Keycloak. \n To find them you can open the Keycloak console and then navigate to  clients  →  awesomeplugin-server  →  Service Account Roles . \n Currently using a non-existing clientId or role will be ignored and the plugin deployment will succeed without errors. \n TIP \n The more verbose CRD plugin descriptor format is deprecated as of Entando 6.3 but is documented  here . \n Widget \n Here is an example of a widget descriptor: \n Widget descriptor.yaml. \n code: another_todomvc_widget # The Widget identification\n\ntitles: # Widget\'s Titles\n  en: TODO MVC Widget # Title in English\n  it: TODO MVC Widget # Title in Italian\n\ngroup: free # The owner group of the widget\nOptional. The UI Path, the widget.ftl file will have the customUi content\ncustomUiPath: widget.ftl\nOptional. The Custom UI\ncustomUi: >-\n    <h1>My custom widget UI</h1>\nOptional. ConfigUI\nconfigUi:\n  customElement: todomvc-config # The name of the custom-element used to render the configUI\n  resources:\n    - <bundleid>/static/js/main.js # The resources necessary to the custom element to render the configUI, like the code\n Fragment \n Fragment descriptor.yaml. \n code: my_fragment # The unique id\nOptional. The fragment content\nguiCode: >-\n  "<div>Here the content</div>"\nOptional. A path to a FreeMarker file containing the fragment content.\nguiCodePath: fragment.ftl\n Page Template \n Page Template descriptor.yaml. \n code: todomvc_page_template # The Page Template identification\ndescription: TODO MVC basic page template # The Page Template description\n\ntitles: # Page Template\'s Titles\n  en: TODO MVC PageTemplate # Title in English\n  it: TODO MVC PageTemplate # Title in Italian\nThe Page Template configuration\nconfiguration:\n  frames: # All frames\n    - pos: 0 # Frame position\n      description: Header # Frame description\n      sketch: # Frame sketch configuration\n        x1: 0\n        y1: 0\n        x2: 11\n        y2: 1\n      defaultWidget:\n        code: my-widget # the code of the widget to apply when using the button "apply default widgets" in the page configuration UI\nA simplified way to define a Frame\n    - pos: 1\n      description: Breadcrumb\n      sketch: { x1: 0, y1: 0, x2: 11, y2: 1 }\nOptional. Define the Page Template in a separate file or inside the descriptor file with `template`\ntemplatePath: page.ftl\nOptional. Define the Page Template this way or in a separate file with `templatePath`\ntemplate: >-\n  <#assign wp=JspTaglibs[\\"/aps-core\\"]>\n  <!DOCTYPE HTML PUBLIC \\"-//W3C//DTD HTML 4.0 Transitional//EN\\">\n  <html>\n      <head>\n          <title><@wp.currentPage param=\\"title\\" /></title>\n      </head>\n      <body>\n          <h1><@wp.currentPage param=\\"title\\" /></h1>\n          <a href=\\"<@wp.url page=\\"homepage\\"/>\\">Home</a><br>\n          <div>\n              <h1>Bundle 1 Page Template</h1>\n              <@wp.show frame=0 />\n          </div>\n      </body>\n  </html>\n Page \n This descriptor enables a page to be created and published via a bundle. Status can be  published  or  draft . The widgets section can be used to fully configure a page layout. \n Page descriptor.yaml. \n code: dashboard\nparentCode: homepage\ntitles:\n  en: My dashboard\n  it: La mia Dashboard\npageModel: dashboard\nownerGroup: free\njoinGroups: []\ndisplayedInMenu: true\nseo: false\ncharset: utf-8\nECR will publish the page according to this property\nstatus: published|draft\nPage Configuration\nwidgets:\n  - code: Brand-Logo\n    config: null\n    pos: 0\n  - code: Login_buttons\n    config: null\n    pos: 2\n  - code: seeds_card\n    config:\n      cardname: creditcard\n    pos: 6\n  - code: list_item\n    config:\n      icon: managealerts\n      count: \'0\'\n      title: Alerts\n    pos: 7\n  - code: list_item\n    config:\n      icon: viewstatements\n      count: \'0\'\n      title: View Statements\n    pos: 11\n  - code: seedscard-transaction-table\n    config: null\n    pos: 13\n CMS Asset \n This descriptor contains the metadata required for uploading and updating a CMS Asset. \n Asset descriptor.yaml. \n correlationCode: \'my-reference-code\'\ntype: image\nThis file should be placed on same folder as the descriptor.yaml\nname: 113f4437cac3b3f3d4db7229f12287a4_d3.png\ndescription: 113f4437cac3b3f3d4db7229f12287a4_d3.png\ngroup: free\ncategories: []\n Content Template \n Content-template descriptor.yaml. \n id: 8880003\ncontentType: CNG\ndescription: Demo Content Template\nOptional. Define the Content Template Shape in a separate file or inside descriptor file with `contentShape`\ncontentShapePath:\nOptional. Define the Content Template Shape this way or in a separate file with `contentShapePath`\ncontentShape: >-\n  <article>\n    <h1>$content.Title.text</h1>\n    <h2>Demo content template</h2>\n    #if ( $content.MainBody.text != "" )\n    $content.MainBody.text\n    #end\n  </article>\n\n\nwidgets:\n  - code: Brand-Logo\n    config: null\n    pos: 0\n  - code: Login_buttons\n    config: null\n    pos: 2\n  - code: seeds_card\n    config:\n      cardname: creditcard\n    pos: 6\n  - code: list_item\n    config:\n      icon: managealerts\n      count: \'0\'\n      title: Alerts\n    pos: 7\n  - code: list_item\n    config:\n      icon: viewstatements\n      count: \'0\'\n      title: View Statements\n    pos: 11\n  - code: seedscard-transaction-table\n    config: null\n    pos: 13\n Content Type \n For more details on the Content Type properties, refer to the  Content Type\ndocumentation . \n Content-type descriptor.yaml. \n code: CNG\nname: Demo\nstatus: 0\n\nattributes:\n  - code: title\n    type: Text\n    name: Title\n    roles:\n      - code: jacms:title\n        descr: The main title of a Content\n    disablingCodes: []\n    mandatory: true\n    listFilter: false\n    indexable: false\n\n    enumeratorStaticItems: string\n    enumeratorStaticItemsSeparator: string\n    enumeratorExtractorBean: string\n\n    validationRules:\n      minLength: 0\n      maxLength: 100\n      regex: string\n      rangeStartString: string\n      rangeEndString: string\n      rangeStartStringAttribute: string\n      rangeEndStringAttribute: string\n      equalString: string\n      equalStringAttribute: string\n      rangeStartDate: string\n      rangeEndDate: string\n      rangeStartDateAttribute: string\n      rangeEndDateAttribute: string\n      equalDate: string\n      equalDateAttribute: string\n      rangeStartNumber: 0\n      rangeStartNumberAttribute: string\n      rangeEndNumber: 0\n      rangeEndNumberAttribute: string\n      equalNumber: 0\n      equalNumberAttribute:\n      ognlValidation:\n        applyOnlyToFilledAttr: false\n        errorMessage: Something\n        keyForErrorMessage: some\n        keyForHelpMessage: thing\n        ognlExpression: string\n Content \n This descriptor enables a content to be created and optionally published via a bundle, according to the  status  property. The content id is optional and can be auto generated or explicitly declared for linking from other components, like Content Widget. \n Content descriptor.yaml. \n id: NWS650\ntypeCode: NWS\ndescription: Dealing with a financial emergency\nmainGroup: free\nstatus: PUBLIC\nattributes:\n  - code: date\n    value: \'2020-04-23 00:00:00\' # the date should be in ISO-8601 format\n  - code: title\n    values:\n      en: Dealing with a financial emergency\n  - code: subtitle\n    values:\n      en: |\n        <p>How to tackle financial stress</p>\n  - code: body\n    values:\n      en: |\n        <p>For many Americans, financial concerns are their number-one stress point. Here are 6 ways to help reduce your money stress and get motivated to take control of your finances.</p>\n  - code: img\n    values:\n      en:\n        correlationCode: \'651\'\n        name: bank_750xx684385064_d0.jpg\n  - code: links\n    elements:\n      - code: links\n        value:\n          symbolicDestination: \'#!U;http://www.mysite.com/!#\'\n          destType: 1\n          urlDest: \'http://www.mysite.com/\'\n          pageDest: null\n          contentDest: null\n          resourceDest: null\n        values:\n          en: mio sito\n      - code: links\n        value:\n          symbolicDestination: \'#!U;http://www.mysite.com/!#\'\n          destType: 1\n          urlDest: \'http://www.mysite.com/\'\n        values:\n          en: mio sito 2\n  - code: attaches\n    elements:\n      - code: attaches\n        values:\n          en:\n            correlationCode: \'205\'\n            name: Entando_Admin_Console_Overview_4.3.3_EN.pdf\n Categories \n This descriptor contains a  list  of Categories. \n Category descriptor.yaml. \n - code: new-category # Identifies the category\n  parentCode: home # The parent category, home is the base category\n  titles:\n    it: "Una nuova categoria" # Category name in Italian\n    en: "New category" # Category name in English\n Groups \n This descriptor contains a  list  of Groups. \n Group descriptor.yaml. \n - code: my_group # Identifies the group\n  name: "My group" # The name of the group\n Labels \n This descriptor contains a  list  of Labels. \n Label descriptor.yaml. \n - key: MY-FIRST-LABEL # Identifies the label\n  titles: # The titles on the label\n    it: Mio Titolo # The title in Italian\n    en: My Title # The title in English\n Languages \n This descriptor contains a  list  of Languages to enable during the installation process. \n Language descriptor.yaml. \n - code: en\n  description: English\n- code: it\n  description: Italian\n Static Resources \n In order to upload static files, you will need to create a folder called\n resources . All files inside this folder will be uploaded into Entando using the same\nfolder structure. \n resources/\n├ css/\n│ └ styles.css\n├ js/\n│ └ script.js\n├ images/\n│ ├ favicon.ico\n│ └ logo.png\n└ page.html\n \n On the structure mentioned above, the resulting files in the Entando\narchitecture will be: \n yourbundleid/\n├ css/\n│ └ styles.css\n├ js/\n│ └ script.js\n├ images/\n│ ├ favicon.ico\n│ └ logo.png\n└ page.html\n \n \n Important \n yourbundleid  is the  code  property inside  descriptor.yaml \n \n If you need to use one of these static files in a widget or page template, use this FTL\ntag  <@wp.resourceURL /> : \n <img src="<@wp.resourceURL />yourbundleid/images/logo.png">\n<link rel="stylesheet" href="<@wp.resourceURL />yourbundleid/css/styles.css">\n<link rel="shortcut icon" href="<@wp.resourceURL />yourbundleid/images/favicon.ico" type="image/x-icon"/>\n<script type="application/javascript" src="<@wp.resourceURL />yourbundleid/js/script.js"><\/script>\n \n '},{title:"Filtering bundles",frontmatter:{},regularPath:"/v6.3/docs/ecr/ecr-bundle-filters.html",relativePath:"v6.3/docs/ecr/ecr-bundle-filters.md",key:"v-6ab3389c",path:"/v6.3/docs/ecr/ecr-bundle-filters.html",headers:[{level:2,title:"Filtering bundles by component",slug:"filtering-bundles-by-component"},{level:3,title:"Supported labels keys are:",slug:"supported-labels-keys-are"},{level:3,title:"Example",slug:"example"},{level:2,title:"Filtering bundles by status",slug:"filtering-bundles-by-status"},{level:2,title:"Filtering bundles by textual search",slug:"filtering-bundles-by-textual-search"},{level:2,title:"Mixing search criteria",slug:"mixing-search-criteria"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:' Filtering bundles \n ECR bundles are filterable by component, by status or by textual research. \n Filtering bundles by component \n ECR bundles are filterable by component from App Builder user interface. \n \n Behind the scenes, filtering is done using the label-based filtering provided out of the box from Kubernetes. \n To enable filtering of a bundle, the custom-resource representing the bundle on the Entando Cluster needs to contain the correct labels. An important note on the values to add the  labels  field, even if to correctly define a label in a k8s resource both the key and the value are required, from an Entando point of view only the key part of the label is used for filtering. The value could be set to anything, but our reccomendation is to use  "true"  for clarity and simplicity. \n Supported labels keys are: \n \n \n \n \n \n \n \n Label entry \n Description \n \n \n \n \n widget: "true" \n The bundle contains one or more microfrontends (widgets)  \n \n \n plugin: "true" \n The bundle contains one or more microservices (plugins) \n \n \n fragment: "true" \n The bundle contains one or more fragments \n \n \n pageTemplate: "true" \n The bundle contains one or more page templates \n \n \n contentType: "true" \n The bundle contains one or more content types \n \n \n contentTemplate: "true" \n The bundle contains one or more content templates \n Example \n Here is an example of the metadata for a ecr bundle containg micro-frontends, some microservices and page templates \n apiVersion: entando.org/v1\nkind: EntandoDeBundle\nmetadata:\n  name: demo-bundle\n  labels:\n    widget: "true"\n    plugin: "true"\n    pageTemplate: "true"\nspec:\n  details:\n  ...\n Filtering bundles by status \n ECR bundles are filterable by status from App Builder user interface. \n \n You can choose to see the full list of the bundles available in Kubernetes cluster by selecting the  Explore  tab, or the list of the currently installed bundles by clicking on the  Installed  tab. \n Filtering bundles by textual search \n You can search for bundles containing some keywords by executing a textual search. \n \n You can open the menu on the left to select which field to target. \n If you are creating a new bundle, keep in mind the textual search is performed against data extracted from the bundle CRD file. \n Mixing search criteria \n You can mix all previous search criteria to refine the scope of your search as you want.\nFor example, you could search for all available bundles ( Explore  tab) that contain  Page Templates  components\n(using the checkboxes) and the word  Login  in their name (using the textual search). \n'},{title:"Bundle versions and updates - FAQ",frontmatter:{},regularPath:"/v6.3/docs/ecr/ecr-bundle-versions-faq.html",relativePath:"v6.3/docs/ecr/ecr-bundle-versions-faq.md",key:"v-0cf3f5ec",path:"/v6.3/docs/ecr/ecr-bundle-versions-faq.html",headers:[{level:2,title:"Does the ECR support versioning?",slug:"does-the-ecr-support-versioning"},{level:2,title:"How is a bundle version defined?",slug:"how-is-a-bundle-version-defined"},{level:2,title:"What format should I use to version my bundle?",slug:"what-format-should-i-use-to-version-my-bundle"},{level:2,title:"As a bundle developer, how should I create a new version of a bundle?",slug:"as-a-bundle-developer-how-should-i-create-a-new-version-of-a-bundle"},{level:2,title:"How to prevent a particular bundle version from being visible in the ECR?",slug:"how-to-prevent-a-particular-bundle-version-from-being-visible-in-the-ecr"},{level:2,title:"My bundle contains a microservice generated with the Entando Component Generator, does the version of the microservice have to be the same as the bundle version?",slug:"my-bundle-contains-a-microservice-generated-with-the-entando-component-generator-does-the-version-of-the-microservice-have-to-be-the-same-as-the-bundle-version"},{level:2,title:"How bundle versions are installed from the ECR",slug:"how-bundle-versions-are-installed-from-the-ecr"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:" Bundle versions and updates - FAQ \n Does the ECR support versioning? \n A bundle, as discussed in the  overview , is a package containing one or more components.\nAs in many other packaging systems, the ECR supports bundle versioning, allowing developers to create and release improvements of their package over time. \n How is a bundle version defined? \n In the ECR, the bundle custom resource comes with a set of  tags , each one representing a version of the bundle.\nHere an example for a CMS quickstart bundle \n apiVersion: entando.org/v1\nkind: EntandoDeBundle\nmetadata:\n    name: cms-quickstart-bundle\nspec:\n  details:\n    name: Entando Example CMS Bundle\n    description: Example Bundle containing CMS components for the Quickstart experience\n  tags:\n    - integrity: ''\n      shasum: ''\n      tarball: 'https://github.com/entando/entando-cms-quickstart-bundle.git'\n      version: v0.0.1\n    - integrity: ''\n      shasum: ''\n      tarball: 'https://github.com/entando/entando-cms-quickstart-bundle.git'\n      version: v0.0.2\n \n As you can see from the code above, the bundle  cms-quickstart-bundle  has 2 versions available.\nEach version in the  tags  object must correspond a tag in the git repository provided in the  tarball  field. \n What format should I use to version my bundle? \n The ECR requires versions to follow the  semantic versioning 2.0.0 , with the possibility to prepend a  v  to the version itself. Some valid bundle versions are: \n \n 1.0 \n v0.1.0-alpha \n 1.0.1-SNAPSHOT \n 22.109.10234-RC.1 \n As a bundle developer, how should I create a new version of a bundle? \n If you're a bundle developer and you want to release a new version of your bundle, you can simply update the content of your bundle and commit the changes to the bundle git repository.\nOnce all the required changes are committed, you can create a new tag in the git repository using the  git tag  command and publish it to the remote repository using the  git push --tags  command \n For example, let's assume my bundle already has a version  1.0.0  and I want to publish the version  2.0.0  of my bundle, here the commands I need to use to create and publish the new tag: \n     git tag -a \"2.0.0\" -m \"My new version\"\n    git push --tags\n How to prevent a particular bundle version from being visible in the ECR? \n If, for some reason, you don't want a particular version to be available for the installation, you can proceed as follows: \n \n You can edit the bundle directly using the command  kubectl edit entandodebundles.entando.org -n <namespace-of-the-bundle> <name-of-the-bundle> \n \n or if you still have the original file you can also: \n \n remove the undesired version from the tag list in your bundle Kubernetes file ( integrity ,  shasum ,  tarball  and  version ) \n delete your bundle from your cluster using a command like this  kubectl delete -f your-bundle-file.yml [-n your-cluster-namespace] \n upload your bundle again to Kubernetes using a command like this  kubectl create -f your-bundle-file.yml [-n your-cluster-namespace] \n My bundle contains a microservice generated with the Entando Component Generator, does the version of the microservice have to be the same as the bundle version? \n The version of the microservice - or to be more precise the docker image associated with the microservice - isn't bound to the version of the bundle containing the microservice itself. \n This gives the bundle developer complete control over the bundle release process, especially in those situations where the bundle contains more components and even more microservices. \n How bundle versions are installed from the ECR \n When the user decides to install a version of the bundle, the ECR checks the provided tag in the git repository and clones locally just the content of the repository for that tag. \n For this reason it's important that for each provided tag in the custom-resource a corresponding tag is available in the git repository, otherwise the ECR will not be able to donwload the bundle and will throw an error. Note that the ECR can only see published tags, so make sure that all the time you create a new tag in your git repository you publish it to the remote repository too. \n"},{title:"How to customize bundle info shown in Entando App Builder",frontmatter:{},regularPath:"/v6.3/docs/ecr/ecr-bundle-presentation-config.html",relativePath:"v6.3/docs/ecr/ecr-bundle-presentation-config.md",key:"v-00077730",path:"/v6.3/docs/ecr/ecr-bundle-presentation-config.html",lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:" How to customize bundle info shown in Entando App Builder \n \n In the image above you can see an example of a bundle as is displayed in the ECR user interface inside the Entando App Builder. \n The corresponding custom-resource file on Kubernetes is similar to this: \n apiVersion: entando.org/v1\nkind: EntandoDeBundle\nmetadata:\n  name: simple-entando-bundle\nspec:\n  details:\n    name: \"Entando Bundle\"\n    description: An example of an Entando bundle\n    dist-tags:\n      latest: v0.0.1\n    time:\n      created: '2020-05-20T15:59:21.946Z'\n      modified: '2020-05-20T15:59:21.946Z'\n      v0.0.1: '2020-05-20T15:59:21.946Z'\n    versions:\n      - v0.0.1\n    keywords:\n      - entando6\n    author: Entando\n    thumbnail: >-\n      data:image/jpeg;base64,....\n  tags:\n....\n \n In order to change the UI elements, you need to update the custom-resource in accordance with this table \n \n \n \n Field \n UI Element \n \n \n \n \n spec.details.name \n Set the bundle title \n \n \n spec.details.description \n Set the bundle description (only visible in the list presentation format) \n \n \n spec.details.thumbnail \n Set the bundle thumbnail, expressed as a base64 encoded string \n \n \n spec.details.dist-tags.latest \n Set what's the latest version of the bundle \n \n \n \n"},{title:"How Microservices get Connected to Entando Apps",frontmatter:{},regularPath:"/v6.3/docs/ecr/ecr-how-microservices-connect-to-apps.html",relativePath:"v6.3/docs/ecr/ecr-how-microservices-connect-to-apps.md",key:"v-65aa6b28",path:"/v6.3/docs/ecr/ecr-how-microservices-connect-to-apps.html",headers:[{level:2,title:"How a Microservice from a Bundle gets Deployed with the ECR?",slug:"how-a-microservice-from-a-bundle-gets-deployed-with-the-ecr"},{level:2,title:"Other Options",slug:"other-options"},{level:2,title:"Kubernetes naming conventions",slug:"kubernetes-naming-conventions"}],lastUpdated:"12/8/2021, 3:41:44 PM",lastUpdatedTimestamp:1638996104e3,content:" How Microservices get Connected to Entando Apps \n In this document we will describe some of the assumptions and details related to the process of connecting a microservice part of a bundle to an Entando App. \n In order to fully understand the concepts explained in this piece of the documentation, please make sure you have familiarity with these concepts: \n \n Entando custom resources \n Entando ingresses \n How a Microservice from a Bundle gets Deployed with the ECR? \n When a bundle containing a microservice is installed using the ECR, behind the scenes some actions take place. \n \n To begin, an  EntandoPlugin custom resource  is generated starting from the PluginDescriptor. Some fields will be automatically generated from the provided image. \n \n \n From the  image  field in the PluginDescriptor, we will extract the  organization ,  name  and  version  of the image. \n organization ,  name  and  version  are then converted to valid characters and composed to form the plugin name ( metadata.name ), the labels ( metadata.labels ) and the ingressPath ( spec.ingressPath ) of the custom resource. \n \n NOTE : Two PluginDescriptors having images with the same organization, name and version will generate a custom resource with the same  metadata.name  and  spec.ingressPath . \n \n Next, a check for a microservice with the same name is performed to verify if a new deployment is required for the microservice. \n If a microservice with the same name is not available in the namespace where the Entando App has been deployed, a new EntandoPlugin custom resource is created and deployed in the namespace using the details defined in the bundle. \n At the same time, an EntandoAppPluginLink custom resource is deployed in the namespace in order to expose the microservice ingress path on the EntandoApp ingress. \n If both the EntandoPlugin custom resource and the EntandoAppPluginLink are deployed correctly, the APIs of the microservice will be available from the same domain of the EntandoApp, making it possible reach those APIs from the EntandoApp using relative urls. \n \n This is the standard flow when no other micorservice with a given name is already available in the EntandoApp namespace. \n If there is an existing microservice with the same name as the one generated from the PluginDescriptor, the ECR will connect the EntandoApp to\nthe existing microservice by generating and deploying the required EntandoAppPluginLink per step 3 above.\nThis way, plugins can be reused by many applications at the same time. \n Other Options \n The naming convention recommendations above are accurate for creating bundles and for self contained applications where the Entando operator is managing the lifecycle of your microservices. If you have a substantial API infrastructure or you intend to deploy a large number of versioned microservices you can also utilize Entando with API management infrastructure like API gateways. If you are using an API gateway or other API abstraction layer you will need to manually manage the ingress for your micro frontends in your application to point to the API gateway deployment. \n In cases where conflicts occur bundles can easily be renamed by updating metdata. \n Kubernetes naming conventions \n Here some rules about naming conventions extracted from the  Kubernetes documentation on object names and ids \n \n Most resource types require a name that can be used as a DNS subdomain name as defined in RFC 1123. This means the name must: \n \n contain no more than 253 characters \n contain only lowercase alphanumeric characters, '-' or '.' \n start with an alphanumeric character \n end with an alphanumeric character \n \n \n"},{title:"Overview",frontmatter:{},regularPath:"/v6.3/docs/ecr/ecr-overview.html",relativePath:"v6.3/docs/ecr/ecr-overview.md",key:"v-5899f08a",path:"/v6.3/docs/ecr/ecr-overview.html",headers:[{level:2,title:"Introduction",slug:"introduction"},{level:2,title:"Glossary",slug:"glossary"},{level:3,title:"Component",slug:"component"},{level:3,title:"ECR Bundle",slug:"ecr-bundle"},{level:3,title:"EntandoDeBundle custom resource",slug:"entandodebundle-custom-resource"},{level:3,title:"Entando-component-manager",slug:"entando-component-manager"},{level:3,title:"Entando-K8S-service",slug:"entando-k8s-service"},{level:2,title:"Architecture",slug:"architecture"},{level:2,title:"Example flow",slug:"example-flow"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:" Overview \n Introduction \n The Entando Component Repository (ECR) is meant to be a repository to\nshare reusable components among different Entando instances. \n The following glossary relates to the ECR and related concepts: \n Glossary \n Component \n An Entando component - simply referred to as component - is a piece of\nreusable code/resource to be used in an Entando widget, page or\napplication. Examples of components are widgets, microfrontends,\ncontent-types, labels, plugins, and static resources \n ECR Bundle \n An ECR bundle - is a package containing one or more components and a\n'descriptor.yaml' file providing information about the bundle. The\nbundle is published on an Git registry and is shared with an Entando\napplication using the EntandoDeBundle custom resource. \n EntandoDeBundle custom resource \n The EntandoDeBundle custom resource is a Kubernetes custom resource\nreadable by the Entando6 operator. It’s used to provide information\nabout an ECR bundle and make the bundle available in kubernetes for the\nentando-component-manager. \n Entando-component-manager \n The entando-component-manager - a.k.a component-manager is part of the\nEntando6 app and dialogs both with the Kubernetes cluster via the\nentando-k8s-service and with the entando-core. The\nentando-component-manager reads the bundles from the cluster and exposes\nthem via an API accessible from AppBuilder. The component-manager is\nalso responsible of the installation/removal of components from\nentando-core \n Entando-K8S-service \n The Entando-K8S-Service is part of the Entando infrastructure and is\nresponsible for the low-level communication with the K8S cluster API. \n Architecture \n \n From an architectural point of view, the ECR is composed of \n \n The EntandoDeBundles which contain the metadata associated with a bundle \n The Entando-k8s-service which reads the bundles from the\ncluster/namspace(s) and serves them via a consumable API \n The Component-manager which creates the connection between the EntandoApp\nand the K8S-service. \n Example flow \n \n \n The user lands on the ECR page in app-builder and wants to see the\nlist of bundles shared with that EntandoApp \n \n \n AppBuilder asks the component-manager for the list of available\nbundles \n \n \n Component-manager queries the k8s-service to get the available\nbundles \n \n \n The k8s-service queries the cluster/namespace(s) it is able to read\nfrom for available bundles and returns the list to the\ncomponent-manager \n \n \n Component-manager returns a list to App-Builder \n \n \n The user is able to see the available bundles and is able to install\none or more of them \n \n \n"},{title:"Troubleshooting ECR",frontmatter:{},regularPath:"/v6.3/docs/ecr/ecr-troubleshooting-guide.html",relativePath:"v6.3/docs/ecr/ecr-troubleshooting-guide.md",key:"v-19e7e228",path:"/v6.3/docs/ecr/ecr-troubleshooting-guide.html",headers:[{level:2,title:"A bundle installation/removal has failed, how to access the logs?",slug:"a-bundle-installation-removal-has-failed-how-to-access-the-logs"},{level:3,title:"Overview",slug:"overview"},{level:3,title:"Solution",slug:"solution"},{level:2,title:"My bundle has an issue, how should I publish a new version of the bundle?",slug:"my-bundle-has-an-issue-how-should-i-publish-a-new-version-of-the-bundle"},{level:3,title:"Overview",slug:"overview-2"},{level:3,title:"Solution",slug:"solution-2"},{level:2,title:"Bundle installation fails because a file has not been found in the bundle",slug:"bundle-installation-fails-because-a-file-has-not-been-found-in-the-bundle"},{level:3,title:"Overview",slug:"overview-3"},{level:3,title:"Solution",slug:"solution-3"},{level:2,title:"Bundle installation failed due to plugin(s) images not reachable",slug:"bundle-installation-failed-due-to-plugin-s-images-not-reachable"},{level:3,title:"Overview",slug:"overview-4"},{level:3,title:"Solution",slug:"solution-4"},{level:2,title:"I can't uninstall a bundle because some components are in use",slug:"i-can-t-uninstall-a-bundle-because-some-components-are-in-use"},{level:3,title:"Overview",slug:"overview-5"},{level:3,title:"Solution",slug:"solution-5"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:" Troubleshooting ECR \n A bundle installation/removal has failed, how to access the logs? \n Overview \n Currently the Entando component manager logs are available in kubernetes via dashboard (openshift) or cli tools (k9s or kubectl).\nIf in you Entando cluster you have more than one Entando App custom resource, you will need to know what's the correct component-manager to check using the corresponding Entando App name and namespace where the app has been deployed. \n Solution \n Using  kubectl  and assuming for simplicity that you have only one Entando App named  quickstart  and your Entando cluster is only composed of one namespace, also named  quickstart ,\nyou can get the component-manager logs using the command \n kubectl logs -f deployment/quickstart-server-deployment --namespace quickstart -c de-container\n \n Note : the  -f  flag is optional and could be used to follow the logs for debugging purposes \n My bundle has an issue, how should I publish a new version of the bundle? \n Overview \n Sometimes a bundle could have some issues: typos in the  descriptor.yaml  file, wrong references of components or to not available docker images are just a few of the possible errors. \n Solution \n \n If the bundle is shared using a git repository, you can make the required changes to your project and publish the new version to git and generate a new tag for it. \n Once the new tag is published, update the bundle costum-resource avaialble in you Entando Cluster by adding the new tag to the  tags  objects  and replacing the latest  dist-tags  to point to this new version. \n Proceed with the new installation \n \n If you're actively working on your bundle and you simply want to verify things are working correctly, instead of generating a new tag for each release of the bundle you can try to keep overriding a specific tag using the git command  git tag -f . We suggest you to follow this practice only during development and not in production. \n Bundle installation fails because a file has not been found in the bundle \n Overview \n When a component that is referenced in the  descriptor.yaml  is missing in the bundle or not correctly referenced, the bundle installation fails and in the logs is reported which file has not been found. \n ERROR - File with name {filename} not found in the bundle\n Solution \n When such a problem happens, verify that the component referenced in the descriptor file are actually present in the bundle and that the reference is properly typed. \n Publish a new version of your bundle as described in the\n \"My bundle has an issue\"  section \n Bundle installation failed due to plugin(s) images not reachable \n Overview \n Plugin included in a bundle are referenced using their docker image. Sometime the image is not available - maybe has not yet be published or is in a private docker registry - and plugin installation can't happen and the entire bundle installation process can't finish successfully \n Solution \n Verify that the docker image you are referencing is correct and publicly available. \n \"My bundle has an issue\"  section \n I can't uninstall a bundle because some components are in use \n Overview \n When removing an installed bundle, the Entando component manager verfies that the bundle components\nare not in use by any other component. Removing such components would cause an error during removal\nas in certain case the deleting a component in use is not permitted. \n Solution \n In order to prevent such errors, the user is alerted and required to manually decouple the bundle\ncomponents before beign able to completely remove the bundle from the system. \n"},{title:"Bundle uninstall",frontmatter:{},regularPath:"/v6.3/docs/ecr/ecr-uninstall-flow.html",relativePath:"v6.3/docs/ecr/ecr-uninstall-flow.md",key:"v-516c114a",path:"/v6.3/docs/ecr/ecr-uninstall-flow.html",headers:[{level:2,title:"Uninstall process",slug:"uninstall-process"},{level:2,title:"Troubleshooting",slug:"troubleshooting"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:" Bundle uninstall \n Uninstall process \n To uninstall a bundle that was previously installed on an Entando App Engine, from Entando App builder UI go to\nthe  Component Repository  tab and select the bundle you want to uninstall \n \n An initial check is made to verify none of the bundle components are in use.\nIf any of the components are in use, a popup will alert you.\nNote that you can't force the removal of a bundle if its components are in use. \n Once the removal process starts: \n \n Bundle resources are deleted from the Entando App Engine \n Components included in the bundle are removed from the Entando App Engine \n Plugins are unlinked \n Troubleshooting \n If any error happens during the uninstall process and you don't know what to do,\ncheck out the  Troubleshooting guide  or the  Entando Forum \n"},{title:"Welcome Wizard",frontmatter:{},regularPath:"/v6.3/docs/getting-started/welcome-wizard.html",relativePath:"v6.3/docs/getting-started/welcome-wizard.md",key:"v-8852b36c",path:"/v6.3/docs/getting-started/welcome-wizard.html",lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:" Welcome Wizard \n The Welcome Wizard is displayed when you first log in to the Application Builder. You can also start it later by going to the top navigation bar in the Application Builder, click on the information icon, and click  Begin Welcome Wizard . You can disable it from the wizard popup by selecting  Don't show next time  and then  Close , or by going to  My Profile → Preferences  and setting the  Welcome Wizard  preference to  Off . \n \n The Wizard will guide you through the key steps in designing and publishing a page in your application: \n \n Create a Page by setting its title, code, location, group, and template. \n Design the Page by placing a set of pre-configured widgets on the page. \n Preview the Page \n Publish the Page \n \n For more information see the following tutorials: \n \n Page Management \n Widgets and Fragments \n Content Creation \n Digital Assets \n \n"},{title:"Getting Started with Entando",frontmatter:{sidebarDepth:2},regularPath:"/v6.3/docs/getting-started/",relativePath:"v6.3/docs/getting-started/README.md",key:"v-1b9bdef1",path:"/v6.3/docs/getting-started/",headers:[{level:2,title:"Automatic Install",slug:"automatic-install"},{level:2,title:"Manual Install",slug:"manual-install"},{level:3,title:"Install Kubernetes",slug:"install-kubernetes"},{level:3,title:"Prepare Kubernetes",slug:"prepare-kubernetes"},{level:3,title:"Deploy Entando",slug:"deploy-entando"},{level:2,title:"Log in to Entando",slug:"log-in-to-entando"},{level:2,title:"Next Steps",slug:"next-steps"}],lastUpdated:"3/11/2021, 5:55:10 AM",lastUpdatedTimestamp:161546011e4,content:" Getting Started with Entando \n You have two options for getting started with Entando. \n \n Automatically install Entando via the Entando command-line interface (CLI) . This is the fastest way to start up an Entando application in Kubernetes. \n Manually install Entando step by step . This is useful if you're preparing a shared cluster rather than a local developer environment, the CLI defaults don't meet your specific needs, or if you want to customize the deploy itself. \n Automatic Install \n The following steps will launch an Ubuntu VM via Multipass, install Kubernetes, and then deploy Entando to it. \n \n Install  Multipass \n \n https : //multipass.run/#install \n \n \n Install Entando into Kubernetes on Ubuntu using the  Entando CLI \n \n curl  -sfL https://get.entando.org  |   bash \n \n \n The progress of the install will be displayed on the console and can take 10 minutes or so depending on the time needed to download the Docker images. The sequence of steps matches the manual steps below. It can be useful to review those steps to help understand what the CLI is doing. \n Once complete, the installer will give you the URL to access the  Entando App Builder . \n Login with username: admin  and password:  adminadmin . See the  Log in to Entando  section for more information and next steps. \n Manual Install \n This in-depth guide takes a learn-as-you-go approach, and will give you a working knowledge of Kubernetes as you get Entando up and running in a local environment. \n \n Install Kubernetes \n Prepare Kubernetes Environment \n Deploy Entando \n \n Note: For advanced or long-time Entando users, check out our  Quick Reference  install guide with just the steps. \n Since Entando is designed to run on Kubernetes, let's get started by installing our own instance of Kubernetes locally. \n We've tested a variety of Kubernetes implementations including Minikube, Minishift, CodeReady Containers, K3s, and Microk8s to find the best combination of low cpu/memory usage, fast startup times, and minimal configuration so we can get started quickly. After downloading the necessary files, we'll have our own instance of Kubernetes up and running in < 60 seconds. \n What's Needed to Run Kubernetes? \n Kubernetes is a container orchestrator designed to manage a server cluster. It requires at least one master node running a Linux OS. We'll be using Multipass to create a lightweight Ubuntu VM in seconds that runs on a bare metal hypervisor for speed and performance. \n Install Kubernetes \n Enable Hypervisor \n Why a Hypervisor? \n Hypervisors allow you to create and run virtual machines. Virtualization software that run on top of your operating system like VirtualBox or VMWare Workstation are Type 2 hypervisors. Type 1 hypervisors run on bare metal. \n \n Let's install a bare metal hypervisor for optimal performance. \n Mac:  Install  hyperkit . \n brew  install  hyperkit\n \n Windows:   Install Hyper-V \n \n What if my machine doesn't support hyperkit or Hyper-V? \n Use a Type 2 hypervisor that runs on top of your operating system: \n \n Install Virtual Box:\n Mac \n Windows \n Launch Ubuntu VM \n Why Multipass? \n Multipass is a cross-platform tool developed by the publishers of Ubuntu to create lightweight Ubuntu VMs in seconds. \n \n \n \n Install  Multipass \n \n \n Launch VM \n \n \n multipass launch --name ubuntu-lts --cpus  4  --mem 8G --disk 20G\n \n \n Open a shell \n \n multipass shell ubuntu-lts\n Run Kubernetes \n Why K3s? \n K3s is a certified Kubernetes distribution designed for production workloads in resource-constrained environments. \n It's packaged as a single <40MB binary that reduces the dependencies and steps needed to install, run and auto-update a production Kubernetes cluster. \n \n \n Install  k3s \n \n curl  -sfL https://get.k3s.io  |   sh  -\n \n \n Check for  Ready   STATUS . \n \n sudo  kubectl get  node \n \n \n What's running out of the box? \n sudo  kubectl get pods -A\n \n \n \n Congratulations! \n You now have a local instance of Kubernetes up and running. \n \n Now that Kubernetes is running, you can setup kubectl to send commands directly to k3s from the host machine rather than from within the VM. See the instructions  here . \n Prepare Kubernetes \n To install Entando, we'll add  Custom Resources , create a  Namespace , download a  Helm  chart, and configure external access to our cluster. \n Add Custom Resources \n Why Custom Resources? \n Standard resources in Kubernetes include things like  Pods , which are a group of one or more containers,  Services , the way to call or access your pods, and  Ingresses , for managing external access to your cluster. \n Custom resources  let you store and retrieve structured data. Combining a custom resource with a custom controller allows you to define a desired state to automate the running of your applications or services in a Kubernetes cluster. \n \n Examples of custom resources in Entando are: \n \n Entando App Engine \n Entando Identity Management System \n \n From your Ubuntu shell: \n \n Download custom resource definitions. \n \n curl  -L -C - https://raw.githubusercontent.com/entando/entando-releases/v6.3.0/dist/qs/custom-resources.tar.gz  |   tar  -xz\n \n \n Create custom resources \n \n sudo  kubectl create -f dist/crd\n Create Namespace \n What are Namespaces? \n Kubernetes supports multiple virtual clusters backed by the same physical cluster. These virtual clusters are called  namespaces. \n You can use namespaces to allocate resources and set cpu/memory limits for individual projects or teams. They can also encapsulate projects from one another. \n \n sudo  kubectl create namespace entando\n Download Helm Chart \n What is Helm? \n Helm is a package manager for Kubernetes that helps you define, install, and upgrade Kubernetes applications.\nThis  Getting Started  guide uses a Helm-generated file with a number of default values to help get you started faster,\ne.g. use embedded databases, don't include OpenShift support, don't include PDA widgets, etc. If you want to\nchange any of those defaults please see  https://github.com/entando-k8s/entando-helm-quickstart . \n \n curl  -L -C - -O https://raw.githubusercontent.com/entando/entando-releases/v6.3.0/dist/qs/entando.yaml\n EntandoCompositeApp \n To quickly deploy an application, Entando uses a Kubernetes Custom Resource named  EntandoCompositeApp . It's composed of 3 parts: \n \n EntandoKeycloakServer  (authentication manager) \n EntandoClusterInfrastructure  (interface between Entando app and Kubernetes) \n EntandoApp  (core logic application) \n \n To speed up the  Getting Started  environment, embedded databases are used by default for these components.\nSee  this tutorial  for more information on how to change your\ndatabase connection. \n Configure Access to Your Cluster \n What about Networking? \n Entando sets up  Ingresses  in Kubernetes to expose HTTP routes from outside the cluster to services within the cluster. We'll use this to access Entando from a local browser. \n If you run into network issues during startup or if you are using Windows for your local development instance, please see  the tips . Symptoms can include having Entando fail to completely start the first time or a working Entando installation may fail to restart later. \n \n To set up external access to your cluster, you'll need to replace the value of\n ENTANDO_DEFAULT_ROUTING_SUFFIX  with your Ubuntu IP. You can look up your Ubuntu IP, and edit the\nYAML file manaully, but running the below commands will automatically update the IP address for you. \n IP = $( hostname  -I  |   awk   '{print $1}' ) \n \n sed  -i  \"s/192.168.64.25/ $IP /\"  entando.yaml\n Deploy Entando \n Deploying the Helm chart will deploy all of the Kubernetes resources required for Entando to run. \n sudo  kubectl create -f entando.yaml\n \n sudo  kubectl get pods -n entando --watch\n \n \n What does a successful startup look like? \n \n First, you'll see the Entando operator:  ContainerCreating  >  Running \n Next, the Entando composite app deployer:  Pending  >  ContainerCreating  >  Running \n Then, Keycloak:  kc-deployer  >  kc-db-deployment \n \n Jobs / Deployments \n \n Jobs, like  kc-db-preparation-job  run once, and are  Completed :  0/1 \n Database deployments, like  kc-db-deployment , should end up as  Running :  1/1 \n The Keycloak server deployment  kc-server-deployment , should end up as  Running :  1/1 \n The  quickstart-server-deployment  should end up as  3/3 \n \n Lifecycle Events \n \n Each line represents an event:  Pending ,  ContainerCreating ,  Running  or  Completed \n Restarts should ideally be  0 ; otherwise, there was a problem with your cluster, and Kubernetes is trying to self-heal \n \n ubuntu@test-vm : ~ $   sudo  kubectl get pods -n entando --watch \n NAME                                   READY   STATUS              RESTARTS   AGE\nquickstart-operator-8556c9c6f8-9ghwg   0/1     ContainerCreating   0          3s\nquickstart-operator-8556c9c6f8-9ghwg   0/1     Running             0          49s\nquickstart-composite-app-deployer-picaju7bf0   0/1     Pending             0          0s\nquickstart-composite-app-deployer-picaju7bf0   0/1     Pending             0          0s\nquickstart-composite-app-deployer-picaju7bf0   0/1     ContainerCreating   0          0s\nquickstart-composite-app-deployer-picaju7bf0   1/1     Running             0          20s\nquickstart-kc-deployer-mx7ms3sc2l              0/1     Pending             0          0s\nquickstart-kc-deployer-mx7ms3sc2l              0/1     Pending             0          0s\nquickstart-kc-deployer-mx7ms3sc2l              0/1     ContainerCreating   0          0s\nquickstart-operator-8556c9c6f8-9ghwg           1/1     Running             0          88s\nquickstart-kc-deployer-mx7ms3sc2l              1/1     Running             0          19s\nquickstart-kc-db-deployment-c57f75d7f-wxmqr    0/1     Pending             0          0s\nquickstart-kc-db-deployment-c57f75d7f-wxmqr    0/1     Pending             0          7s\nquickstart-kc-db-deployment-c57f75d7f-wxmqr    0/1     ContainerCreating   0          7s\nquickstart-kc-db-deployment-c57f75d7f-wxmqr    0/1     Running             0          77s\nquickstart-kc-db-deployment-c57f75d7f-wxmqr    1/1     Running             0          87s\nquickstart-kc-db-preparation-job-1d6ab9b6-7    0/1     Pending             0          0s\nquickstart-kc-db-preparation-job-1d6ab9b6-7    0/1     Pending             0          0s\nquickstart-kc-db-preparation-job-1d6ab9b6-7    0/1     Init:0/1            0          0s\nquickstart-kc-db-preparation-job-1d6ab9b6-7    0/1     Init:0/1            0          13s\nquickstart-kc-db-preparation-job-1d6ab9b6-7    0/1     PodInitializing     0          15s\nquickstart-kc-db-preparation-job-1d6ab9b6-7    0/1     Completed           0          17s\nquickstart-kc-server-deployment-66484d596d-qr78q   0/1     Pending             0          0s\nquickstart-kc-server-deployment-66484d596d-qr78q   0/1     Pending             0          0s\nquickstart-kc-server-deployment-66484d596d-qr78q   0/1     ContainerCreating   0          0s\nquickstart-kc-server-deployment-66484d596d-qr78q   0/1     Running             0          3m\nquickstart-kc-server-deployment-66484d596d-qr78q   1/1     Running             0          4m36s\nquickstart-kc-deployer-mx7ms3sc2l                  0/1     Completed           0          6m50s\nquickstart-eci-deployer-kx9nhop22g                 0/1     Pending             0          0s\nquickstart-eci-deployer-kx9nhop22g                 0/1     Pending             0          0s\nquickstart-eci-deployer-kx9nhop22g                 0/1     ContainerCreating   0          0s\nquickstart-eci-deployer-kx9nhop22g                 1/1     Running             0          5s\nquickstart-eci-k8s-svc-deployment-7c58c78b55-z52xj   0/1     Pending             0          0s\nquickstart-eci-k8s-svc-deployment-7c58c78b55-z52xj   0/1     Pending             0          0s\nquickstart-eci-k8s-svc-deployment-7c58c78b55-z52xj   0/1     ContainerCreating   0          0s\nquickstart-eci-k8s-svc-deployment-7c58c78b55-z52xj   0/1     Running             0          97s\nquickstart-eci-k8s-svc-deployment-7c58c78b55-z52xj   1/1     Running             0          2m7s\nquickstart-eci-deployer-kx9nhop22g                   0/1     Completed           0          2m15s\nquickstart-deployer-os19rw3eto                       0/1     Pending             0          0s\nquickstart-deployer-os19rw3eto                       0/1     Pending             0          0s\nquickstart-deployer-os19rw3eto                       0/1     ContainerCreating   0          1s\nquickstart-deployer-os19rw3eto                       1/1     Running             0          6s\nquickstart-db-deployment-7fff4c8479-qf469            0/1     Pending             0          0s\nquickstart-db-deployment-7fff4c8479-qf469            0/1     Pending             0          4s\nquickstart-db-deployment-7fff4c8479-qf469            0/1     ContainerCreating   0          4s\nquickstart-db-deployment-7fff4c8479-qf469            0/1     Running             0          7s\nquickstart-db-deployment-7fff4c8479-qf469            1/1     Running             0          19s\nquickstart-db-preparation-job-5a55b267-6             0/1     Pending             0          0s\nquickstart-db-preparation-job-5a55b267-6             0/1     Pending             0          0s\nquickstart-db-preparation-job-5a55b267-6             0/1     Init:0/4            0          0s\nquickstart-db-preparation-job-5a55b267-6             0/1     Init:0/4            0          4s\nquickstart-db-preparation-job-5a55b267-6             0/1     Init:1/4            0          5s\nquickstart-db-preparation-job-5a55b267-6             0/1     Init:1/4            0          8s\nquickstart-db-preparation-job-5a55b267-6             0/1     Init:2/4            0          9s\nquickstart-db-preparation-job-5a55b267-6             0/1     Init:2/4            0          6m42s\nquickstart-db-preparation-job-5a55b267-6             0/1     Init:3/4            0          7m20s\nquickstart-db-preparation-job-5a55b267-6             0/1     Init:3/4            0          7m22s\nquickstart-db-preparation-job-5a55b267-6             0/1     PodInitializing     0          7m23s\nquickstart-db-preparation-job-5a55b267-6             0/1     Completed           0          7m25s\nquickstart-server-deployment-5597597575-gtptz        0/3     Pending             0          0s\nquickstart-server-deployment-5597597575-gtptz        0/3     Pending             0          4s\nquickstart-server-deployment-5597597575-gtptz        0/3     ContainerCreating   0          4s\nquickstart-server-deployment-5597597575-gtptz        0/3     Running             0          2m35s\nquickstart-server-deployment-5597597575-gtptz        1/3     Running             0          2m37s\nquickstart-server-deployment-5597597575-gtptz        2/3     Running             0          2m38s\nquickstart-server-deployment-5597597575-gtptz        3/3     Running             0          3m5s\nquickstart-deployer-os19rw3eto                       0/1     Completed           0          11m\nquickstart-composite-app-deployer-picaju7bf0         0/1     Completed           0          20m\n \n \n \n Press  Ctrl-C  to exit the watch command once everything is up and running. \n \n What pods come out of the box? \n sudo  kubectl get pods -n entando\n \n NAME                                                 READY   STATUS      RESTARTS   AGE\nquickstart-operator-8556c9c6f8-9ghwg                 1/1     Running     0          132m\nquickstart-kc-db-deployment-c57f75d7f-wxmqr          1/1     Running     0          130m\nquickstart-kc-db-preparation-job-1d6ab9b6-7          0/1     Completed   0          129m\nquickstart-kc-server-deployment-66484d596d-qr78q     1/1     Running     0          128m\nquickstart-kc-deployer-mx7ms3sc2l                    0/1     Completed   0          130m\nquickstart-eci-k8s-svc-deployment-7c58c78b55-z52xj   1/1     Running     0          123m\nquickstart-eci-deployer-kx9nhop22g                   0/1     Completed   0          124m\nquickstart-db-deployment-7fff4c8479-qf469            1/1     Running     0          121m\nquickstart-db-preparation-job-5a55b267-6             0/1     Completed   0          121m\nquickstart-server-deployment-5597597575-gtptz        3/3     Running     0          113m\nquickstart-deployer-os19rw3eto                       0/1     Completed   0          121m\nquickstart-composite-app-deployer-picaju7bf0         0/1     Completed   0          131m\n \n \n \n Get the URL to access Entando from your local browser. \n sudo  kubectl get ingress -n entando -o  jsonpath = \\ \n '{.items[2].spec.rules[*].host}{.items[2].spec.rules[*].http.paths[2].path}{\"\\n\"}' \n \n \n Example URL: \n \n quickstart-entando.192.168.64.33.nip.io/app-builder/\n Log in to Entando \n Now that we've installed Entando, let's log in to the  Entando App Builder . \n \n \n Username:  admin \n Password:  adminadmin \n \n After login, change your password to activate your account. \n \n Note: If the login process hangs for more than 5 seconds, refresh the browser. \n \n \n The App Builder is where we'll compose our micro frontends alongside CMS pages and content. \n Congratulations! \n We now have Entando up and running on Kubernetes in our local environment. \n Next Steps \n Choose one of the following actions to continue your journey with Entando! \n \n \n Build Your First Application:  Use the  Welcome Wizard  to build your first application via guided prompts. \n \n \n Try a Tutorial:  Take advantage of the  Learning Paths  which organize a few of the most popular tutorials by user type. \n \n \n Dig Deeper into Entando Concepts:  Review the  Docs  sections to more deeply understand the Entando building blocks. \n \n \n Learn about the Quickstart Environment:  See the  Quickstart Tips  for more information on how to manage your Getting Started or quickstart environment. \n \n \n \n"},{title:"Quick Reference",frontmatter:{},regularPath:"/v6.3/docs/getting-started/quick-reference.html",relativePath:"v6.3/docs/getting-started/quick-reference.md",key:"v-400aa74c",path:"/v6.3/docs/getting-started/quick-reference.html",headers:[{level:2,title:"Quick Reference",slug:"quick-reference"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:" Quick Reference \n Just the steps, for advanced users. \n \n Install  Multipass \n Launch VM \n multipass launch --name ubuntu-lts --cpus  4  --mem 8G --disk 20G\n \n Open Ubuntu shell \n multipass shell ubuntu-lts\n \n Install k3s \n curl  -sfL https://get.k3s.io  |   sh  -\n \n Check for node ready \n sudo  kubectl get  node \n \n Download custom resource definitions \n curl  -L -C - https://raw.githubusercontent.com/entando/entando-releases/v6.3.0/dist/qs/custom-resources.tar.gz  |   tar  -xz\n \n Create custom resources \n sudo  kubectl create -f dist/crd\n \n Create namespace \n sudo  kubectl create namespace entando\n \n Download Helm chart (or  generate your own ) \n curl  -L -C - -O https://raw.githubusercontent.com/entando/entando-releases/v6.3.0/dist/qs/entando.yaml\n \n Configure external access to your cluster with your VM IP \n IP = $( hostname  -I  |   awk   '{print $1}' ) \n \n sed  -i  \"s/192.168.64.25/ $IP /\"  entando.yaml\n \n Deploy Entando \n sudo  kubectl create -f entando.yaml\n \n Check for quickstart-composite-app-deployer  Completed \n sudo  kubectl get pods -n entando --watch\n \n Get URL to access Entando App Builder from your browser \n sudo  kubectl get ingress -n entando -o  jsonpath = \\ \n '{.items[2].spec.rules[*].host}{.items[2].spec.rules[*].http.paths[2].path}{\"\\n\"}' \n \n "},{title:"Cluster Resource Limits",frontmatter:{},regularPath:"/v6.3/docs/reference/cluster-resource-limits.html",relativePath:"v6.3/docs/reference/cluster-resource-limits.md",key:"v-6a3fd5e8",path:"/v6.3/docs/reference/cluster-resource-limits.html",headers:[{level:3,title:"Cluster Resource Limits",slug:"cluster-resource-limits"},{level:3,title:"Bundle size limitations",slug:"bundle-size-limitations"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:" Cluster Resource Limits \n Entando needs a well-defined amount of resources in order to start and Kubernetes takes care of using only the needed amount of them.\nHowever, you can choose to impose boundaries on the minimum and maximum used/allocated resources by updating the downloaded  entando.yaml  file and setting the  ENTANDO_K8S_OPERATOR_IMPOSE_DEFAULT_LIMITS  property to true.\nIn this way, Entando will allocate a predefined amount of resources and Kubernetes will act more strictly checking for resource availability. See  Kubernetes resources  for more information. \n By not imposing limits you can minimize initial needed resources and startup time, leaving Kubernetes free to manage its resources as he wants.\nBy imposing limits you can obtain a better-balanced system. \n It's important to note that, accordingly to the Kubernetes documentation, in order to deploy on a namespace with a\n ResourceQuotas  on memory and cpu, \n \n every Container must have a memory request, memory limit, cpu request, and cpu limit \n \n so, in that case, you will need to set  ENTANDO_K8S_OPERATOR_IMPOSE_DEFAULT_LIMITS  to true, otherwise your deploy will fail. \n Here you can see the detailed resource requests/limits per container: \n \n \n \n Component \n Mem requests \n CPU requests \n Mem limits \n CPU limits \n \n \n \n \n AppBuilderDeployableContainer \n 128Mi \n 125m \n 512Mi \n 500m \n \n \n EntandoAppDeployableContainer \n 448Mi \n 375m \n 1792Mi \n 1500m \n \n \n ComponentManagerDeployableContainer \n 192Mi \n 188m \n 768Mi \n 750m \n \n \n EntandoPluginSidecarDeployableContainer \n 192Mi \n 188m \n 768Mi \n 750m \n \n \n EntandoPluginDeployableContainer \n 256Mi \n 250m \n 1024Mi \n 1000m \n \n \n EntandoK8SServiceDeployableContainer \n 192Mi \n 250m \n 768Mi \n 1000m \n \n \n KeycloakDeployableContainer \n 192Mi \n 250m \n 768Mi \n 1000m \n Bundle size limitations \n Entando supports bundles without size limitations, you can install as many bundles as you want and bundles as big as you desire. \n The only thing you have to check is the  <YOUR-APP-NAME>-de-pvc  volume size. Each bundle is installed in that volume, so when it reaches its maximum capacity you will not be able to install bundles anymore. \n You can find  quickstart-de-pvc  volume inside de-container container, that is part of the pod named  <YOUR-APP-NAME>-server-deployment-*** , where asterisks should assume values based on your instance.\nFeel free to set its size accordingly to your needs. \n"},{title:"Caching and Clustering in an Entando Application",frontmatter:{},regularPath:"/v6.3/docs/reference/caching-and-clustering.html",relativePath:"v6.3/docs/reference/caching-and-clustering.md",key:"v-3723c578",path:"/v6.3/docs/reference/caching-and-clustering.html",headers:[{level:2,title:"App Engine Clustering and High Availability",slug:"app-engine-clustering-and-high-availability"},{level:2,title:"Storage Requirements for Clustered Entando Apps",slug:"storage-requirements-for-clustered-entando-apps"},{level:2,title:"Caching",slug:"caching"},{level:3,title:"Data Management",slug:"data-management"},{level:2,title:"Infinispan Implementation (Default)",slug:"infinispan-implementation-default"},{level:2,title:"Redis Implementation",slug:"redis-implementation"},{level:2,title:"Performance",slug:"performance"},{level:3,title:"Cache Management",slug:"cache-management"}],lastUpdated:"5/28/2021, 3:20:46 AM",lastUpdatedTimestamp:1622186446e3,content:" Caching and Clustering in an Entando Application \n App Engine Clustering and High Availability \n The Entando App Engine can be deployed as a clustered set of instances using the clustering and replication ability of Kubernetes. The App Engine is\nbacked by a shared cache with two chioices of implementation out of the box. \n See this tutorial for configuring and testing a clustered instance of the App Engine. \n The clustering of microservices built to add functionality to an Entando application is separate from the clustering used by the App Engine. The microservices\nhave a separate clustering configuration and setup depending on the implementation and choices made in creating those microservices. See the documentation\nfor your microservices caching implementation for details on configuring and deploying clustered microservices. \n Storage Requirements for Clustered Entando Apps \n In order to scale an Entando Application across multiple nodes you must provide a storage class that supports\na  ReadWriteMany  access policy. There are many ways to accomplish this including using dedicated storage providers\nlike GlusterFS. The cloud Kubernetes providers also provide clustered storage options specific to their implementation like Google Cloud File in GKE or Azure Files in AKS. \n The storage class that supports  ReadWriteMany  must be marked as the default storage class in the deployment \n TIP \n You can also scale an Entando Application without clustered storage using a  ReadWriteOnce (RWO)  policy by ensuring that the\ninstances are all scheduled to the same node. This can be accomplished using taints on other nodes. Be aware of the pros and cons of scheduling\ninstances to the same node. This will give you protection if the application instance itself dies or becomes unreachable and will help\nyou get the most utilization of node resources. However, if the node dies or is shutdown you will have to wait for Kubernetes to reschedule the pods to a different node and your application will be down. \n Caching \n Data Management \n At startup time the App Engine will load all database data into the shared cache. When a page is rendered or content is fetched that content will be served from the cache. In the event of a write to the cache the cache and database will both be updated. \n The following objects are cached in the base App Engine implementation \n \n Pages \n Page templates \n Categories \n Widgets \n Configuration (application level configuration) \n Roles \n Groups \n Languages \n Labels (i18n) \n User profiles \n API Catalog (legacy API metadata separate from swagger) \n Data models and data types (deprecated) \n Infinispan Implementation (Default) \n The default implementation, included in the quickstart and base images of the release, of the cache for the App Engine utilizes  Infinispan in Library Mode  and it is managed via configuration in the app server hosting the Entando App Engine. \n \n To utilize this implementation you can add replicas of the app engine (entando-de-app) to your deployment. New pods will automatically join the cluster. Ensuring a high availability deployment distributed across nodes depends on the underlying Kubernetes implementation and goals of the deployment. It is up to the implementor of the cluster and the application to ensure that the applications are scheduled to nodes and deployed in a fashion that meets the uptime and performance goals of the Entando Application. \n Read more here  for tutorials and step by step instructions on using the Infinispan cache in an Entando App. \n Redis Implementation \n An Entando App can also be configured to utilize an external  Redis  cache. In a Redis implementation of an Entando App the cache is deployed separately from the App Engine and the App Engine is configured to connect to the deployed instance. \n \n The Redis cache is not deployed by the Entando Operator and must be managed by the implementing teams dev ops or Kubernetes cluster administrators. \n Read more here  for tutorials and step by step instructions on using a Redis cache in an Entando App. \n Performance \n As you design your Entando App Engine cluster there are a couple of things to keep in mind: \n \n In a read only implementation, or an implementation with infrequent writes to the cached objects listed above, the network latency between pods on different nodes will not be a major driver of runtime performance. Each pod will have a fully replicated copy of the cache \n In write heavy implementations network latency between nodes can be a factor in performance\n \n The overall performance impact of network latency will vary depending on the implementation. The performance depends on the types of objects being written, the size of those objects, and whether the writes invalidate single objects or entire lists of objects in the cache. \n \n \n \n In general, it is recommended that performance testing on clustered instances matches the expected runtime traffic pattern of a live application. Every application will have a unique performance profile. \n Cache Management \n When a new replica of an Entando App joins a cluster of applications the cache is replicated to that node. If the cache is very large or the network is slow this may add to the total startup time of the new instance. Existing instances will continue to function. \n"},{title:"Manage Entando Databases",frontmatter:{},regularPath:"/v6.3/docs/reference/databases.html",relativePath:"v6.3/docs/reference/databases.md",key:"v-efcc73e8",path:"/v6.3/docs/reference/databases.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Lightweight, low-config Databases with PostgreSQL and MySQL",slug:"lightweight-low-config-databases-with-postgresql-and-mysql"},{level:2,title:"Existing External Databases",slug:"existing-external-databases"},{level:3,title:"Structure",slug:"structure"},{level:3,title:"How it works",slug:"how-it-works"},{level:3,title:"Keeping track of credentials",slug:"keeping-track-of-credentials"},{level:2,title:"Vendor specific notes",slug:"vendor-specific-notes"},{level:3,title:"Oracle",slug:"oracle"},{level:3,title:"Notes",slug:"notes"},{level:3,title:"MySQL",slug:"mysql"},{level:3,title:"Resulting Connection String",slug:"resulting-connection-string-2"},{level:3,title:"Notes",slug:"notes-2"},{level:3,title:"PostgreSQL",slug:"postgresql"},{level:2,title:"Skipping database preparation",slug:"skipping-database-preparation"},{level:3,title:"How it works",slug:"how-it-works-2"}],lastUpdated:"3/24/2021, 9:59:27 AM",lastUpdatedTimestamp:1616594367e3,content:' Manage Entando Databases \n Overview \n Entando’s Docker images currently support three different relational\ndatabase management systems: PostgreSQL, MySQL and Oracle. With\nPostgreSQL and MySQL, by default, Entando’s will automatically create a\nKubernetes Deployment hosting the database management systems. However,\nfor Oracle, and also for other scenarios that may require it, Entando\nsupports connectivity to existing external databases. This document\nprovides the user with the necessary information to decide how to manage\nEntando’s databases. \n Lightweight, low-config Databases with PostgreSQL and MySQL \n When deploying Entando Custom Resources that require databases to a new\nNamespace, the default behavior for Entando is to create a Kubernetes\nDeployment. It uses the standard Openshift compliant images: \n \n \n centos/mysql-57-centos7 and \n \n \n centos/postgresql-96-centos7) \n \n \n This is a fairly low-configuration approach, as Entando will create and\ninitialize the databases transparently. Persistent data is stored on any\nPersistent Volume that meets our Persistent Volume Claim requirements.\nWhen an Entando Custom Resource is redeployed, the Persistent Volumes\nremain in tact. Since the subsequent data initialization is idempotent,\nthe supporting Deployments will scale up and behave as expected. \n Generally our services encapsulate the database they use entirely, and\nprovide facilities to import and export the data without needing any\nknowledge of the internal workings of the underlying data store. For\nmost simple Entando Apps the database doesn’t grow too large and is\nfairly easy to manage. This state of affairs allowed us to keep our\ndatabases isolated from each other, thus allowing for isolated\ndeployments without needing complex coordination of database migration\nfor the different deployment pipelines. \n It is worth noting that these database Deployments are not clustered.\nThe customer is therefore strongly advised to provide redundancy and\nclustering in the form of clustered storage. These database deployments\ndo specify a restartPolicy of \'Always\', so in the event of a\nnon-corrupting failure, the database Pod should therefore restart in\nabout 30 seconds. This by no means offers the features of a full\ndatabase cluster, but may suffice for many scenarios. \n However, in more advanced use cases, such as the use of our CMS\nfunctionality, this simplistic approach may not scale. And where there\nis a a centralized database admin team, or where there is a requirement\nto comply to strict organizational governance w.r.t. databases, this\napproach does result in a multitude of databases that may be difficult\nfor the database admin team to manage. \n Existing External Databases \n For this reason, Entando can also be configured to use an existing\ndatabase service provided by the customer. In these scenarios, the\ncustomer is expected to take responbility for the lower level database\noperations such as tablespace creation, permissions and clustering.\nEntando will however still be responsible for creating and populating\nthe tables, indices and foreing keys. Entando will also create all of\nthese in the appropriate table \'container\' for the DBMS in question such\nas a schema (Oracle/PostgreSQL) or a database (MySQL). In order to\nachieve this, Entando installs a dedicated CustomResourceDefinition in\nKubernetes, called an \'EntandoDatabaseService\' \n The idea is for EntandoDatabaseService custom resources to be created in\nthe namespace the EntandoApps and EntandoPlugin that should use them\nwill be created. The EntandoDatabaseService is usually created along\nwith a secret that carries admin credentials to the database in\nquestion. \n Structure \n The EntandoDatabaseService custom resource looks like this: \n  EntandoDatabaseService\nmetadata:\n  name: string, any K8S compliant name\n  namespace: string, the namespace this will be created in\nspec:\n  dbms: string, one of oracle, postgresql or mysql\n  host: string, either an ip address or hostname where the database service is hosted\n  port: integer, the port on which the database service is hosted\n  databaseName: string, the name of the database, only required for PostgreSQL and Oracle\n  secretName: the name of the Secret in the same namespace carrying admin credentials to the database service\n  tablespace: (Oracle only)  the tablespace to use to create the required schemas in\n  jdbcParameters: a map containing name-value pairs for any additional parameters required for the JDBC driver to connect to the database.\n \n The Secret that will provide the admin credentials, identified by the\nabove  secretName  should look like this: \n Secret:\n  name: string, any K8S compliant name\n  namespace: string, the namespace this will be created in\n  stringData:\n    username: string, name of an admin user that can create schemas and other users\n    password: string, password of the above user\n How it works \n In order for the EntandoApp and EntandoPlugin deployer to pick up the\ncorrect database service, the EntandoDatabaseService needs to be created\nBEFORE the EntandoApps and EntandoPlugins are created. There can be\nmultiple EntandoDatabaseServices in the namespace, but they need to\npoint to database services of different vendors, i.e. PostgreSQL, Oracle\nand MySQL. Entando currently cannot enforce any validation but if there\nare two EntandoDatabaseServices that have the same DBMS vendor, it will\nsimply pick the first one and continue. Please ensure that only one\nEntandoDatabaseService exists for each DBMS vendor you need to use. \n Once the appropriate EntandoDatabaseServices have been created, any\nEntandoApp or EntandoPlugin that is created will have to specify the\nappropriate DBMS vendor in their  spec.dbms  property. If the\nEntandoOperator detects an EntandoDatabaseService with a matching DBMS\nvendor, it will continue to create the necessary schemas on the specific\ndatabase. If the EntandoOperator does not detect an\nEntandoDatabaseService with a matching DBMS vendor, it will fall back\nonto its default behaviour which is to create a matching Deployment and\nspin up a database service from the same namespace. If the  spec.dbms \nproperty is not specified on an EntandoApp, the EntandoOperator will\ndefault to PostgreSQL. If the  spec.dbms  property is not specified on\nan EntandoPlugin, the EntandoOperator will assume that the EntandoPlugin\nin question does not require a database and hence bypass any database\nand schema creation. \n When the EntandoOperator processes your Entandoapp or EntandoPlugin with\nan appropriate  spec.dbms  specified, it will create a Schema/User pair\nfor each datasource required. A typical EntandoApp deployment requires 3\ndatasources (portdb,servdb and dedb). Plugins generally only require one\ndatasource (plugindb). \n The database schema and user created will have the same name. The name\nis derived from the name of the EntandoPlugin or EntandoApp by replacing\nall characters that are not ANSI-SQL compliant with an underscore. The\ndatasource name is then suffixed to the schema name. When defining the\nname of your app or plugin, please keep in mind that some DBMS vendors\ndo not support long schema names. Future versions of Entando will allow\nyou to override the schema prefix for an app or plugin, but for now this\nis a limitation one has to keep in mind. \n Keeping track of credentials \n The EntandoOperator generates a Kubernetes Secret for each schema/user\ncombination it creates. The name of this secret is the concatenation of\nthe name of the EntandoApp or EntandoPlugin, the datasource qualifier\nand then the suffix "-secret". For instance, for an EntandoApp called\n"my-app" the "portdb" datasource will have a corresponding Kubernetes\nSecret called "my-app-portdb-secret". The EntandoOperator will never\noverwrite or update an existing database secret. We generate a random\nstring for the password which is generally considered the safest\napproach. If you do however wish to change the password in for the\nresulting user, please remember to update the password on the Kubernetes\nSecret too. Such an operation is however error prone and could result in\nsubsequent deployments failing. \n The EntandoOperator’s schema creation logic is idempotent. If it\ntherefore finds that the generated schema/user combination found in the\nassociated Kuberentes Secret already exists, it won’t do anything.\nHowever, it will attempt to log in, and if it fails to log in, it will\nattempt to create the user. If the user already exists, but with a\ndifferent password than the one in the Kubernetes Secret, all subsequent\ndeployment operations will fail. \n Vendor specific notes \n Oracle \n Example \n   EntandoDatabaseService\n    metadata:\n      name:oracle-service\n    spec:\n      dbms: oracle\n      host: 10.0.0.13\n      port: 1521\n      databaseName: ORCLPDB1.localdomain\n      secretName: oracle-secret\n      tablespace: entando_ts\n      jdbcParameters: {}\n  Secret:\n    metadata:\n      name: oracle-secret\n    stringData:\n      username: admin\n      password: admin123\n Resulting connection string: \n jdbc:oracle:thin:@//10.0.0.13:1521/ORCLPDB1.localdomain \n Notes \n Oracle has some rather complicated rules in building the correct\nconnection string. Please note that for the sake of portability and\nlightweight image we are limited to the thin driver. The  databaseName \ncould also be an Oracle service as opposed to an Oracle  SID . Please\ncoordinate with your Oracle DB Admin to determine exactly what value to\nuse here. We strongly recommend testing your settings with some code or\na tool that constructs JDBC connection. \n When the EntandoOperator prepares the schemas for your EntandoApp or\nEntandoPlugin, it will create a user for every datasource required, and\nas is standard behaviour for Oracle, that user will have its own schema\nwith the same name. Permissions are set up to ensure that one user\ncannot access tables from another user’s schema. Please note that Oracle\nlimits schema names to 30 characters. If you intend to use Oracle,\nplease keep the name of your apps and plugins short enough. The suffixes\nthat we append to the app or plugin name to ensure the resulting schema\nname is unique are usually shorter than 8 characters, so names of about\n20 characters should be safe. \n You can specify which tablespace Entando should use to create the\nschemas in using the  spec.tablespace  property \n ORA-01704: string literal too long \n Entando requires extended datatypes to be activated in Oracle 12c and\nhigher\n( https://oracle-base.com/articles/12c/extended-data-types-12cR1 ) \n MySQL \n Example \n EntandoDatabaseService\n  metadata:\n    name:mysql-service\n  spec:\n    dbms: mysql\n    host: 10.0.0.13\n    port: 3306\n    databaseName:\n    secretName: mysql-secret\n    jdbcParameters:\n       useSSL: "true"\nSecret:\n  metadata:\n    name: mysql-secret\n  stringData:\n    username: admin\n    password: admin123\n Resulting Connection String \n jdbc:mysql://10.0.0.13:3306 \n Notes \n MySQL doesn’t really support schemas, or more accurately, it doesn’t\ndistinguish between schemas and databases. For this reason, no\ndatabaseName is required. The EntandoOperator will therefore create an\nentirely new database for each datasource your EntandoApp or\nEntandoPlugin requires. It will also create a user with the same name as\nthe database with permission set up to ensure one user cannot access the\ndatabase of another user. Please note that MySQL limits database names\nto 63 characters. Keep this in mind when defining the names of your\nEntandoApps and EntandoPlugins \n PostgreSQL \n Example \n   EntandoDatabaseService\n    metadata:\n      name:postgresql-service\n    spec:\n      dbms: postgresql\n      host: 10.0.0.13\n      port: 5432\n      databaseName: my_db\n      secretName: postgresql-secret\n      jdbcParameters: {}\n\n  Secret:\n    metadata:\n      name: postgresql-secret\n    stringData:\n      username: admin\n      password: admin123\n Resulting Connection String \n jdbc:postgresql://10.0.0.13:5432/my_db \n Notes \n PostgreSQL behaves very similar to Oracle when it comes to how it\nassociates a user with its own schema. The current username is used as a\ndefault schema/prefix to resolve tables. As with Oracle, Entando ensures\nthat two users don’t have access to each other’s schemas. \n Skipping database preparation \n When an Entando App is being deployed, there is an operator responsible for the entire deployment process. It takes care also of DB creation and preparation.\nIf you have an already prepared DB (schemas, tables, and all other stuff), you could skip schemas creation and DB preparation of the EntandoApp in order to speed up the deploy process. \n You can achieve this by specifying some properties for the EntandoApp component present in the helm generated file. Look at  this  for more info. \n For  spec.dbms  property you should choose  none , then you should add all needed DB connection parameters.\nAfter updating parameters with the one you need, you should end with a yaml like this: \n - kind: "EntandoApp"\n  metadata:\n    annotations: {}\n    labels: {}\n    name: "example-qs"\n  spec:\n    dbms: "none"\n    replicas: 1\n    standardServerImage: wildfly\n    ingressPath: /entando-de-app\n    environmentVariables:\n      - name: SPRING_DATASOURCE_USERNAME\n        value: admin\n      - name: SPRING_DATASOURCE_PASSWORD\n        value: adminadmin\n      - name: SPRING_DATASOURCE_URL\n        value: "jdbc:postgresql://192.168.1.82:5432/testdb?currentSchema=admin_qs_dedb"\n      - name: SPRING_JPA_DATABASE_PLATFORM\n        value: org.hibernate.dialect.PostgreSQLDialect\n      - name: PORTDB_URL\n        value: "jdbc:postgresql://192.168.1.82:5432/testdb?currentSchema=admin_qs_portdb"\n      - name: PORTDB_USERNAME\n        value: admin\n      - name: PORTDB_PASSWORD\n        value: adminadmin\n      - name: PORTDB_CONNECTION_CHECKER\n        value: org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLValidConnectionChecker\n      - name: PORTDB_EXCEPTION_SORTER\n        value: org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLExceptionSorter\n      - name: SERVDB_URL\n        value: "jdbc:postgresql://192.168.1.82:5432/testdb?currentSchema=admin_qs_servdb"\n      - name: SERVDB_USERNAME\n        value: admin\n      - name: SERVDB_PASSWORD\n        value: adminadmin\n      - name: SERVDB_CONNECTION_CHECKER\n        value: org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLValidConnectionChecker\n      - name: SERVDB_EXCEPTION_SORTER\n        value: org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLExceptionSorter\n How it works \n Using  spec.dbms: "none"  will cause the operator to skip that initial schema/user creation step entirely.\nThen adding those variables under the  spec.environmentVariables  section will supply connection parameters that will be used by EntandoApp.\nKeep in mind that all these parameters will be applied to each of the containers in the EntandoApp pod and that they will also override existing values. \n'},{title:"Entando Deployment Structure",frontmatter:{},regularPath:"/v6.3/docs/reference/deployment-structure.html",relativePath:"v6.3/docs/reference/deployment-structure.md",key:"v-2e9dbc86",path:"/v6.3/docs/reference/deployment-structure.html",headers:[{level:2,title:"entando-operator",slug:"entando-operator"},{level:2,title:"database init containers",slug:"database-init-containers"},{level:2,title:"entando-de-app",slug:"entando-de-app"},{level:2,title:"app-builder",slug:"app-builder"},{level:2,title:"component-manager",slug:"component-manager"},{level:2,title:"entando-k8s-service",slug:"entando-k8s-service"},{level:2,title:"keycloak",slug:"keycloak"},{level:2,title:"Other Key Repositories",slug:"other-key-repositories"},{level:3,title:"entando-core",slug:"entando-core"},{level:3,title:"entando-cms",slug:"entando-cms"},{level:3,title:"entando-components",slug:"entando-components"},{level:3,title:"Entando Kubernetes Controllers",slug:"entando-kubernetes-controllers"}],lastUpdated:"12/15/2021, 2:22:26 PM",lastUpdatedTimestamp:1639596146e3,content:" Entando Deployment Structure \n This page provides a high level overview of the key Entando GitHub repositories along with a brief description\nof how those repositories are realized in a running Entando deployment. The descriptions provided here are meant\nas a guide for identifying opportunities to dig deeper into the architecture and how things are structured\nrather than a panacea for understanding the architecture. \n entando-operator \n The Entando operator coordinates the installation and configuration of all of the components of an Entando\nCluster. The operator can be installed once per Entando Cluster and used to coordinate the plugin lifecycle for\nmultiple Entando applications across many namespaces. \n \n GitHub:  https://github.com/entando-k8s/entando-k8s-controller-coordinator/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-k8s-controller-coordinator \n Customization \n It is unlikely that the operator will be customized as part of an Entando implementation. It is not built to\nbe extended inside the codebase. The most common pattern will be to use the existing custom resources that the\noperator knows how to deploy to extend the Entando platform. \n database init containers \n During installation an Entando application needs to create several databases and also to initialize those\ndatabases with information when deploying from a backup in your images. At initialization the  entando-k8s-dbjob \nwill be run 5 times in total. Once for keycloak, twice for the entando application (port and serv dbs), once to\npopulate the Entando application database, and once to create the Component Repository database. \n \n GitHub:  https://github.com/entando-k8s/entando-k8s-dbjob \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-k8s-dbjob \n \n The screenshot below highlights the init containers for the Entando application schema creation, db\ninitialization, and component repository database. \n \n Many managed kubernetes instances like OpenShift won’t show init containers in their dashboards. So if you’re\ntroubleshooting you may need to look deeper. When fetching logs for an init container using kubectl you must\npass the container name as an argument to the call. For example, \n     kubectl logs <pod> -c <container> -n <namespace>        \n    kubectl logs quickstart-kc-db-preparation-job-ddbdbddb-a  -c quickstart-kc-db-schema-creation-job -n sprint1-rc\n Customization \n It is unlikely that the init containers will be customized as part of an Entando project. The init containers\nwill automatically restore a backup included in your application so that you can create custom images that\ninclude your application setup.\nSee  Backing Up and Restoring Your Environment . \n entando-de-app \n The  entando-de-app  is a J2EE application and is an instance of the  entando-core  (see a description of the\n entando-core  repo below). Reviewing the dependencies of this application in the pom.xml will reveal the\ndependencies on the  entando-core ,  entando-engine , and  admin-console  which encompass the core\nfunctionality in versions of Entando prior to Entando 6. In a quickstart deployment the  entando-de-app  is deployed as part of the  entando-composite-app  multi\ncontainer pod. \n \n GitHub:  https://github.com/entando/entando-de-app/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-de-app-eap , https://hub.docker.com/repository/docker/entando/entando-de-app-wildfly \n Customization \n The  entando-de-app  is very likely to be customized as part of an Entando implementation. This image can be\ncustomized with new APIs, legacy Entando plugins, new database tables, or other extensions to the  entando-core .\nIt is highly recommended that most extensions to the platform in Entando 6 occur in microservices. However, legacy\nintegrations, extensions to the CMS, and migrations from earlier Entando versions may require changes to the  entando-de-app . \n app-builder \n The  app-builder  is the front end of the  entando-de-app . It communicates with the  entando-de-app  via  REST\nAPIs . The  app-builder  is a React JS application and is served via node in the default\ndeployment. In a quickstart deployment the  app-builder  container is deployed in the  entando-composite-app \nmultiple container pod. The  app-builder  also communicates with the Component Manager via REST API to fetch\ninformation about Entando bundles deployed to the Entando Component Repository (ECR). \n \n GitHub:  https://github.com/entando/app-builder/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/app-builder/ \n Customization \n The  app-builder  is built to be customized and will be customized as part of many Entando implementations.\nThe  app-builder  can be customized at runtime via micro frontends\n widget configuration . The  app-builder  can also be\ncustomized via the integration of custom modules that are added at\n build time . \n component-manager \n The  component-manager  provides the link between the entando-de-app (or your custom core instance) and the\nEntando Component Repository (ECR). The  component-manager  queries the entando-k8s service to fetch available\nbundles that have been deployed as custom resources inside of an Entando cluster.\nThe  component-manager  also manages the relationships between an Entando application and the\ninstalled plugins. This can be seen in the plugin link custom resources in Kubernetes. \n \n GitHub:  https://github.com/entando-k8s/entando-component-manager/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-component-manager/ \n Customization \n It is unlikely that the  component-manager  will be customized as part of an Entando implementation. \n entando-k8s-service \n The  entando-k8s-service  acts as an abstraction layer to fetch data from kubernetes APIs. The primary\nfunctionality is in discovering and making available for installation Entando plugins. The\n entando-k8s-service  is invoked by the  component-manager . \n \n GitHub:  https://github.com/entando-k8s/entando-k8s-service/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-k8s-service/ \n Customization \n It is very unlikely that the  entando-k8s-service  will be customized as part of an Entando implementation. \n keycloak \n The  entando-keycloak  project is an extension of the base Keycloak images. The extension provides the default\nthemes for Entando, a customized realm and clients, and adds the Oracle ojdbc jars for connection to Oracle\ndatabases. \n \n GitHub:  https://github.com/entando/entando-keycloak/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-keycloak/ \n Customization \n The keycloak image will often be customized as part of an Entando implementation. Common extensions will\ninclude changing the theme, adding default connections, adding default social logins, adding default clients,\nor other changes. \n Other Key Repositories \n entando-core \n The entando-core project is a J2EE application that exposes APIs for the Entando CMS, includes the legacy\nadmin console, and includes the portal-ui project that performs the server side composition for pages\nrendered via an Entando application. Note that only the composition is performed server side.\nJavascript code is rendered on the client. The entando-core is realized via an instance that includes the\nWAR files generated from a core build as dependencies. In a default deployment this is the  entando-de-app . \n \n GitHub:  https://github.com/entando/entando-core/ \n DockerHub: None (deployed to maven central) \n Customization \n For users familiar with versions prior to Entando 6 there will be cases where the  entando-core  is customized.\nIn most cases these customizations will be delivered via WAR overlay in the instance project.\nUsing WAR overlay is a functional approach for users already  familiar with the process but it is highly\nrecommended to extend the platform using microservices for new projects. \n entando-cms \n The  entando-cms  project is the  app-builder  (React JS) side of the Entando WCMS. It is bundled into the\n app-builder  at build time and will be included in the default deployment of the  app-builder  in almost all cases. \n \n GitHub:  https://github.com/entando/entando-cms/ \n DockerHub: None (deployed to npm) \n Customization \n In some cases the  entando-cms  may be customized if new custom features are added to CMS specific\nfunctionality. However, most cases will use the more general  app-builder  extension points noted above.\nThe  entando-cms  does not expose any dedicated extension interfaces outside of those already provided by the\n app-builder . \n entando-components \n The entando-components project is a collection of legacy plugins for Entando 5 and earlier. These plugins are deployed as WAR dependencies in an entando-core instance. \n \n GitHub:  https://github.com/entando/entando-components/ \n DockerHub: None (deployed to maven central) \n Entando Kubernetes Controllers \n There are a number of controllers that are available to the Entando operator to manage installations and\ncomponents in an Entando Cluster. Those controllers are small and lightweight images that are executed as\nrun to completion pods to manage the installation flow for different parts of the infrastructure. The\ncontrollers are implemented using Quarkus. For more information on the controllers, the Entando custom\nresources, and configuring your Entando deployment see also:\n Custom Resources . \n GitHub: \n \n https://github.com/entando-k8s/entando-k8s-composite-app-controller/ \n https://github.com/entando-k8s/entando-k8s-plugin-controller/ \n https://github.com/entando-k8s/entando-k8s-cluster-infrastructure-controller/ \n https://github.com/entando-k8s/entando-k8s-app-controller/ \n https://github.com/entando-k8s/entando-k8s-app-plugin-link-controller/ \n \n DockerHub: \n \n https://hub.docker.com/repository/docker/entando/entando-k8s-composite-app-controller/ \n https://hub.docker.com/repository/docker/entando/entando-k8s-plugin-controller/ \n https://hub.docker.com/repository/docker/entando/entando-k8s-cluster-infrastructure-controller/ \n https://hub.docker.com/repository/docker/entando/entando-k8s-app-controller/ \n https://hub.docker.com/repository/docker/entando/entando-k8s-app-plugin-link-controller/ \n Customization \n It is unlikely that the controllers will be customized as part of an Entando implementation. \n"},{title:"Accessing Entando APIs",frontmatter:{sidebarDepth:2},regularPath:"/v6.3/docs/reference/entando-apis.html",relativePath:"v6.3/docs/reference/entando-apis.md",key:"v-438781d6",path:"/v6.3/docs/reference/entando-apis.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:3,title:"Enable or disable the Swagger UI in a running container",slug:"enable-or-disable-the-swagger-ui-in-a-running-container"},{level:2,title:"How to find your client secret",slug:"how-to-find-your-client-secret"},{level:2,title:"Setup in local environment",slug:"setup-in-local-environment"},{level:3,title:"Configure Keycloak",slug:"configure-keycloak"},{level:3,title:"Start the Entando Application",slug:"start-the-entando-application"},{level:2,title:"APIs Overview",slug:"apis-overview"},{level:3,title:"API structure",slug:"api-structure"},{level:3,title:"Models",slug:"models"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"12/15/2021, 2:22:26 PM",lastUpdatedTimestamp:1639596146e3,content:" Accessing Entando APIs \n Overview \n Entando includes the Swagger UI in a quickstart environment and is reachable at  /entando-de-app/api/swagger-ui.html : \n http://[your-host-name]/entando-de-app/api/swagger-ui.html\n Enable or disable the Swagger UI in a running container \n The Swagger UI can be enabled or disabled in a running container by modifying the SPRING_PROFILES_ACTIVE environment variable for the entando-de-app container. \n \n Edit the deployment. The name may be different outside of a quickstart environment. \n \n sudo kubectl -n entando edit deployment/quickstart-server-deployment\n \n \n \n (Optional) Scale the deployment  spec.replicas  to 0 before updating the deployment. This is necessary if you're using an in-memory database, e.g. the default quickstart configuration, and will prevent database errors that can happen on an immediate restart after the profile is changed. Save the deployment to apply the change. \n \n \n Find the entando-de-app env variables section under  spec.template.spec.containers.env[image: entando-de-app] \n \n \n 4a. To enable the swagger UI, add the SPRING_PROFILES_ACTIVE environment variable, if it's missing, or add  swagger  to its comma-delimited list. \n         - name: SPRING_PROFILES_ACTIVE\n          value: default,swagger\n \n 4b. To disable the swagger UI, remove  swagger  from the value. \n \n \n (Optional) Reset the deployment  spec.replicas  back to 1. \n \n \n Save the deployment to apply the change. \n How to find your client secret \n You'll need your client credentials to execute the Entando APIs. \n \n \n Login into your Keycloak instance \n \n \n Go to  Administration → Clients \n \n \n Select the desired client (e.g. in a quickstart environment this is  quickstart-server ) \n \n \n Click on the  Credentials  tab to get the secret \n Setup in local environment \n You may prefer to run a local standalone Entando application for some tasks. You'll need Java 11, maven, and Keycloak for authentication. See  these instructions  to setup a standalone Keycloak. \n Configure Keycloak \n Configure your Keycloak client in order to support Swagger UI. A quickstart environment has this pre-configured. \n \n \n Login to your Keycloak instance \n \n \n Access the Administration console \n \n \n Click on  Clients  on the left bar and select your client (e.g.  quickstart-server ) \n \n \n Update the following values under  Settings : \n \n Set  Valid Redirect URIs  to  http://localhost:[your port]/entando-de-app/*  or  *  to allow all redirect URIs. \n Set  Web Origins  to  http://localhost:[your port]  or  *  to accept all origins. \n Start the Entando Application \n \n \n Clone the Entando reference application: \n git clone https://github.com/entando/entando-de-app\n \n \n \n Start the application with the following options: \n \n Enable the Swagger profile via  -Dspring.profiles.active=swagger \n Enable the Keycloak profile via  -Pkeycloak \n Configure the application connection to Keycloak itself. For simplicity this uses the same client credentials you'll use to try out the APIs.\n \n Set  -Dkeycloak.auth.url  to your Keycloak endpoint (including  /auth ), e.g.  -Dkeycloak.auth.url=http://my-keycloak-server/auth \n Set  -Dkeycloak.client.id  to your client id, e.g.  -Dkeycloak.client.id=quickstart-server \n Set  -Dkeycloak.client.secret  to your client secret, e.g.  -Dkeycloak.client.secret=my-secret . See  How to find your client secret  above. \n \n \n (Optional) Set -Djetty.port=8085  if the default port 8080 is already in use. \n (Optional) To skip the docker steps (or if you don't have docker installed/running), add  -DskipDocker=true \n \n Here's a full example: \n mvn clean package jetty:run-war -Pjetty-local -Pderby -Pkeycloak -Dspring.profiles.active=swagger -Djetty.port=8085 -Dorg.slf4j.simpleLogger.log.org.eclipse.jetty.annotations.AnnotationParser=error -Dkeycloak.auth.url=http://my-keycloak-host/auth -Dkeycloak.client.id=quickstart-server -Dkeycloak.client.secret=my-client-secret -DskipDocker=true\n \n \n \n Wait for the application to start. \n [INFO] Started ServerConnector@1355c8be{HTTP/1.1, (http/1.1)}{0.0.0.0:8085}\n[INFO] Started @66257ms\n[INFO] Started Jetty Server\n \n \n \n Navigate to the Swagger UI in a browser at  /entando-de-app/api/swagger-ui.html \n  http://localhost:[your port]/entando-de-app/api/swagger-ui.html\n APIs Overview \n The Entando core exposes REST APIs for every action that can be taken in\nthe App Builder environment. For example, you can use\nthese APIs to create pages, create page templates or to add widgets to\npages. The APIs can be used to support automation, testing, or\nintegrations with external systems. \n API structure \n All of the APIs share a common top level structure. Each response will\ncontain a top level entry for  errors ,  metadata , and  payload . \n The  errors  will always contain code and a message string indicating an\nerror condition in the request. The  metadata  section is used for\npaging, sorting, filtering and data that is distinct from the body. The\nbody of each response is included in the  payload  section of the\nresponse and varies according to each API. \n Models \n All of the model classes returned by the Entando core are annotated so that the model definition is included in the Swagger documentation. At the bottom of the Swagger page all of the model classes returned by the API endpoints can be found. \n Tutorial \n \n \n Access your application Swagger UI as discussed above \n \n \n Click on the  Authorize  button in the upper right corner \n \n \n Enter the client id and client secret in the open window and click  Authorize \n \n \n If you are redirected to the Entando login page, log in with your credentials (default are  admin / adminadmin ) \n \n \n You will be redirected to the Swagger UI page, now authenticated \n \n \n Use the  Try it out  button on the APIs \n \n \n Scroll to  widget-controller \n \n \n Select the blue GET row \n \n \n Select  Try it out \n \n \n Look at the results in the window. You should see a Server response with Code 200 and full response body. \n \n \n \n \n"},{title:"Entando CLI",frontmatter:{sidebarDepth:2},regularPath:"/v6.3/docs/reference/entando-cli.html",relativePath:"v6.3/docs/reference/entando-cli.md",key:"v-98694d68",path:"/v6.3/docs/reference/entando-cli.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Installation",slug:"installation"},{level:3,title:"Prerequisites",slug:"prerequisites"},{level:3,title:"Install the CLI",slug:"install-the-cli"},{level:3,title:"Check Environment",slug:"check-environment"},{level:3,title:"Update the CLI",slug:"update-the-cli"},{level:2,title:"Available Commands",slug:"available-commands"},{level:2,title:"Project Management",slug:"project-management"},{level:3,title:"Project Setup",slug:"project-setup"},{level:3,title:"Prepare and Publish a Bundle",slug:"prepare-and-publish-a-bundle"},{level:3,title:"Run a Project locally",slug:"run-a-project-locally"},{level:2,title:"Bundle Commands",slug:"bundle-commands"},{level:2,title:"Diagnostic Commands",slug:"diagnostic-commands"},{level:2,title:"Reference",slug:"reference"}],lastUpdated:"2/3/2022, 5:40:38 PM",lastUpdatedTimestamp:1643928038e3,content:' Entando CLI \n Overview \n The Entando Command Line Interface (CLI) provides a set of commands that accelerate the developer experience by assisting the developer with common tasks such as quickly installing a new copy of Entando, generating an Entando project via JHipster, deploying an Entando Bundle, etc. \n Installation \n Prerequisites \n The basic requirements for the CLI vary depending on the category of developer tasks. The Entando CLI is able to install secondary dependencies using the  ent check-env  command as described  here . \n \n \n \n Category \n Prerequisite \n \n \n \n \n Basic Development \n git or  git for windows \n \n \n \n nvm or  nvm for windows \n \n \n Install Entando in a local VM \n multipass \n \n \n Build and publish Entando Bundles \n docker and docker-compose \n \n \n \n a git repository for the bundle artifacts \n \n \n \n a Docker Hub account (or organization) for microservice Docker images \n \n \n Deploy an Entando Bundle \n a Kubernetes cluster with admin access. This could be a local cluster (created via the CLI or manually) or a shared remote cluster. \n \n \n \n TIP \n If you follow the automated option in  Getting Started , then the CLI will be  installed for you along with an Ubuntu VM containing k3s Kubernetes and a quickstart Entando application. \n Install the CLI \n Install the current offical release of the CLI via the following command. \n curl  -L https://get.entando.org/cli  |   bash \n Check Environment \n Use the  check-env  command to prepare your environment for development. This will verify the presence of additional dependencies (such as git, curl, java, JHipster, etc.) as well as the appropriate versions for your specific Entando instance. In most cases  check-env  will automatically install those dependencies and will prompt the developer for guidance or approval as needed. \n ent check-env develop\n Update the CLI \n The CLI can be updated to the latest version (corresponding to your Entando version) using the following command. You should run  ent check-env develop  after updating the CLI in case any dependency versions have changed. \n bash   < ( curl  -L  "https://get.entando.org/cli" )  --update\n Available Commands \n Use  ent help  to review the list of available commands. \n ~~~~~~~~~~~~~~~~~~~\n Entando CLI\n~~~~~~~~~~~~~~~~~~~\n\n> Essentials:\n  - Activate using:  ~/.entando/ent/quickstart/cli/v6.3.0/activate\n  - Dectivate using: ~/.entando/ent/quickstart/cli/v6.3.0/deactivate\n\n> Available commands:\n  - app                  => Helps managing an EntandoApp\n  - app-info             => Displays information about an entando app\n  - bundler              => Wrapper for the ENT private installation of the entando bundle tool.\n  - check-env            => Checks the environment for required dependencies and settings\n  - diag                 => Runs some diagnostic and collects the related info in a tgz file\n  - help                 => Helps in having help\n  - host                 => Helps managing the system that hosts the quickstart VM\n  - jhipster             => Wrapper for the ENT private installation of jhipster.\n  - kubectl              => Helper for using kubectl in ent managed scenarios\n  - npm                  => Wrapper for the ENT private installation of npm. This is mostly for internal use\n  - pod                  => Displays information related to a set of pods\n  - prj                  => Helps managing Entando bundle projects\n  - quickstart           => Helps locally installing entando instances\n  - run-tests            => Run the internal tests\n\n> Further info about entando:\n  - ~/.entando/ent/quickstart/cli/v6.3.0/README.md\n  - https://www.entando.com/\n  - https://developer.entando.com/\n\n> ⚠ RECOMMENDED FIRST STEP ⚠ :\n  - Check the dependencies (ent check-env --help)\n \n Check the help text ( --help ) for any command to see its specific options, e.g.  ent check-env --help . \n Project Management \n These are common sequences for an Entando project. \n Project Setup \n \n Setup a project directory \n \n mkdir  testProject  &&   cd  testProject\n \n \n Generate the project skeleton using the JHipster-based Entando Blueprint. \n \n ent jhipster --blueprints entando\n \n \n Generate an entity and MFEs. \n \n ent jhipster entity Conference\n \n \n Build the new project. Using the  ent-prj  wrapper saves having to build each part of the project individually. The first run can be slower due to node downloads for any MFEs. \n \n ent prj build\n \n See  this tutorial  for more details. \n Prepare and Publish a Bundle \n Use the publication system (pbs) to assemble your Entando project into a bundle that can be loaded into Kubernetes. You\'ll need your github credentials, a github repository to hold your bundle artifacts, and a Docker Hub account or organization. \n \n Initialize the bundle directory \n \n ent prj pbs-init\n \n \n Publish the build artifacts to github and Docker Hub \n \n ent prj pbs-publish\n \n \n Create a Kubernetes Custom Resource and apply it to your Entando instance. You can modify the target namespace parameter ( -n ) if you changed it from the default. \n \n ent prj generate-cr  |  ent kubectl apply -n entando -f -\n \n See  this tutorial  for more details. \n Run a Project locally \n \n Startup Keycloak. This uses docker-compose under the hood. \n \n ent prj ext-keycloak start\n \n \n Startup the backend microservices \n \n ent prj be-test-run\n \n \n Startup one or more of the frontend widgets, each from its own shell. \n \n ent prj fe-test-run\n \n See  this tutorial  for more details. \n Alternatively, you can perform a completely clean install of the CLI by removing your  ~/.entando  directory and then reinstalling the CLI per the instructions above. This will also remove the private copies of JHipster, Entando Blueprint, etc. \n rm  -rf ~/.entando.\n Bundle Commands \n Use the  ent bundler  command to prepare a bundle for publication or extract a bundle from an application. \n \n Prepare a bundle custom resource from a Git repository. The project command ( ent prj generate-cr ) provides a wrapped version of this command. See the help for options including the bundle name, description, repository, etc. The output of this command is a yaml file which can be piped to a file or directly to  ent kubectl  for application to Kubernetes. \n \n   ent bundler from-git\n \n See  this tutorial  for an example using this command. \n \n Point the bundler to an existing Entando application and extract its components (pages, content, etc.) and static assets into a custom bundle. You can use this bundle to migrate Entando components from one environment to another (e.g. Dev to QA), to provide a template for building a new Entando application, or as the skeleton of an Entando solution. The bundler provides an interactive mode which allows you to identify the components to be exported from the application. The output of this command is the same bundle folder structure created by an Entando project including a top-level descriptor file. \n \n   ent bundler from-env  \n \n You will need to provide an  env.json  file in the same directory where the bundler is run. This is used to configure the application URLs and client credentials. \n { \n    "coreBaseApi" :   "http://<YOUR-DOMAIN-OR-IP>/entando-de-app" , \n    "k8ssvcApi" :   "http://<YOUR-DOMAIN-OR-IP>/k8s" , \n    "clientId" :   "<YOUR-CLIENT-ID>" , \n    "clientSecret" :   "<YOUR-CLIENT-SECRET>" \n } \n \n See  this tutorial  for more instructions on exporting a bundle including how to setup your  env.json . \n Diagnostic Commands \n The following commands can be useful to more quickly understand what is happening with an Entando Application. If you followed the Getting Started steps to setup Entando then the CLI was automatically installed in the Multipass VM and you can run these commands from there. \n \n ent app-info  display basic information about Kubernetes and the Entando resources (e.g. namespace, pods, ingresses) \n \n ent app-info\n \n \n ent pod-info  display the  kubectl describe  and  kubectl logs  for each of the major Entando pods in a given namespace. \n \n ent pod-info\n \n \n ent diag  list the current pods in a given Entando namespace and prepare a diagnostic tar.gz containing  kubectl describe  and  kubectl logs  for each of the major Entando pods. This can be highly useful when working with Entando Support. \n \n ent diag\n \n Output: \n ubuntu@entando:~$ ent diag\nPlease provide the namespace (entando):\n## DNS rebinding protection TEST\n## LOCAL INFO\n## K8S INFO\n> POD: quickstart-kc-deployer-pbyjdp1dom\n>       CONTAINER: deployer\n> POD: quickstart-eci-deployer-smectg3hxy\n>       CONTAINER: deployer\n> POD: quickstart-deployer-9ul8cyjtiq\n>       CONTAINER: deployer\n> POD: quickstart-composite-app-deployer-nlz9lxc6do\n>       CONTAINER: deployer\n> POD: quickstart-eci-k8s-svc-deployment-79c4894767-5p85d\n>       CONTAINER: k8s-svc-container\n> POD: quickstart-kc-server-deployment-85987fc84c-flrlw\n>       CONTAINER: server-container\n> POD: quickstart-operator-7bfd7fc8cd-gd774\n>       CONTAINER: operator\n> POD: quickstart-server-deployment-f69f84798-g6lx5\n>       CONTAINER: server-container\n>       CONTAINER: de-container\n>       CONTAINER: appbuilder-container\n> Collected diagdata available under "~/.entando/reports/entando-diagdata-2020-11-19T02:58:47+0000" for consultation\n> Collected diagdata available in archive "~/.entando/reports/entando-diagdata-2020-11-19T02:58:47+0000.tgz"\n Reference \n \n Source repository:  https://github.com/entando/entando-cli/tree/develop \n \n'},{title:"jACMS Aps Core Tag Library",frontmatter:{},regularPath:"/v6.3/docs/reference/freemarker-tags/freemarker-JACMS-tags.html",relativePath:"v6.3/docs/reference/freemarker-tags/freemarker-JACMS-tags.md",key:"v-1c5b09bf",path:"/v6.3/docs/reference/freemarker-tags/freemarker-JACMS-tags.html",headers:[{level:2,title:"Tag content",slug:"tag-content"},{level:3,title:"Tag Class com.agiletec.plugins.jacms.aps.tags.ContentTag",slug:"tag-class-com-agiletec-plugins-jacms-aps-tags-contenttag"},{level:3,title:"Description",slug:"description"},{level:3,title:"Attributes",slug:"attributes"},{level:2,title:"Tag contentInfo",slug:"tag-contentinfo"},{level:3,title:"Tag Class com.agiletec.plugins.jacms.aps.tags.ContentInfoTag",slug:"tag-class-com-agiletec-plugins-jacms-aps-tags-contentinfotag"},{level:3,title:"Description",slug:"description-2"},{level:3,title:"Attributes",slug:"attributes-2"},{level:2,title:"Tag contentList",slug:"tag-contentlist"},{level:3,title:"Tag Class com.agiletec.plugins.jacms.aps.tags.ContentListTag",slug:"tag-class-com-agiletec-plugins-jacms-aps-tags-contentlisttag"},{level:3,title:"Description",slug:"description-3"},{level:3,title:"Attributes",slug:"attributes-3"},{level:2,title:"Tag contentListFilter",slug:"tag-contentlistfilter"},{level:3,title:"Tag Class Tag class: com.agiletec.plugins.jacms.aps.tags.ContentListFilterTag",slug:"tag-class-tag-class-com-agiletec-plugins-jacms-aps-tags-contentlistfiltertag"},{level:3,title:"Description",slug:"description-4"},{level:3,title:"Attributes",slug:"attributes-4"},{level:2,title:"Tag contentListUserFilterOption",slug:"tag-contentlistuserfilteroption"},{level:3,title:"Tag Class Tag class: com.agiletec.plugins.jacms.aps.tags.ContentListUserFilterOptionTag=",slug:"tag-class-tag-class-com-agiletec-plugins-jacms-aps-tags-contentlistuserfilteroptiontag"},{level:3,title:"Description",slug:"description-5"},{level:3,title:"Attributes",slug:"attributes-5"},{level:2,title:"Tag searcher",slug:"tag-searcher"},{level:3,title:"Tag Class com.agiletec.plugins.jacms.aps.tags.SearcherTag",slug:"tag-class-com-agiletec-plugins-jacms-aps-tags-searchertag"},{level:3,title:"Description",slug:"description-6"},{level:3,title:"Attributes",slug:"attributes-6"},{level:2,title:"Tag rowContentList",slug:"tag-rowcontentlist"},{level:2,title:"Tag Class Tag class: com.agiletec.plugins.jacms.aps.tags.RowContentListTag",slug:"tag-class-tag-class-com-agiletec-plugins-jacms-aps-tags-rowcontentlisttag"},{level:3,title:"Description",slug:"description-7"},{level:3,title:"Attributes",slug:"attributes-7"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:' jACMS Aps Core Tag Library \n \n \n Version: 2.3 \n \n \n Short Name: jacmsaps \n \n \n URI: /jacms-aps-core \n Tag  content \n Tag Class  com.agiletec.plugins.jacms.aps.tags.ContentTag \n Description \n Displays the content given its ID. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n contentId \n false \n ID of the content to display. It can accept "expression language". \n \n \n modelId \n false \n Id of the model to use to display the content. The model ID can be either specified explicitly (the model must match the content to serve) or the type name ("list" or "default"); in the latter case the model specified in the configuration will be used. The model must adhere to the content being returned. "Expression language" is accepted. \n \n publishExtraTitle \n false \n Toggles the insertion of the values of the titles in the Request Context. The title values are extracted from the attribute marked with the role "jacms:title". Admitted values are (true, false), default \'false\'. \n \n \n var \n false \n Inserts the rendered content in a variable of the page context with the name provided. \n \n \n attributeValuesByRoleVar \n false \n Inserts the map of the attribute values indexed by the attribute role, in a variable of the page context with the name provided. \n Tag  contentInfo \n Tag Class  com.agiletec.plugins.jacms.aps.tags.ContentInfoTag \n Description \n Return information of a specified content. The content can will be extracted by id from widget parameters or from request parameter. The tag extract any specific parameter (by "param" attribute) or entire ContentAuthorizationInfo object (setting "var" attribute and anything on "param" attribute). \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n contentId \n false \n ID of the content \n \n \n param \n false \n Admitted values for "param" attribute are: \'contentId\' (returns the code of content id), \'mainGroup\' (returns the code of owner group), \'authToEdit\' (returns true if the current user can edit the content, else false). \n \n \n var \n false \n Inserts the required parameter (or the entire authorization info object) in a variable of the page context with the name provided. \n Tag  contentList \n Tag Class  com.agiletec.plugins.jacms.aps.tags.ContentListTag \n Description \n Loads a list of contents IDs by applying the filters (if any). Only the IDs of the contents accessible in the portal can be loaded. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n listName \n true \n Name of the variable in the page context that holds the search result. \n \n \n contentType \n false \n Sets the code of the content types to search. The name must match the configured one, respecting capital letters and spaces. \n \n \n category \n false \n Identifier string of the category of the content to search. \n \n \n cacheable \n false \n Toggles the system caching usage when retrieving the list. Admitted values (true, false), default "true". \n \n \n titleVar \n false \n Inserts the title on a variable of the page context with the name provided. \n \n \n pageLinkVar \n false \n Inserts the code of the page to link on a variable of the page context with the name provided. \n \n \n pageLinkDescriptionVar \n false \n Inserts the description of the page to link on a variable of the page context with the name provided. \n \n \n userFilterOptionsVar \n false \n Name of the variable in the page context that holds the user filter options \n Tag  contentListFilter \n Tag Class  Tag class: com.agiletec.plugins.jacms.aps.tags.ContentListFilterTag \n Description \n "ContentListTag" sub-tag, it creates a filter to restrict the result of the content search. Please note that the filters will be applied in the same order they are declared and the result of the search will reflect this fact. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n key \n true \n String used to filter and sort the contents. This string can be: - the name of a content attribute compatible with the type declared in the "contentListTag" (it requires the "attributeFilter" attribute to be "true") - the ID of one of the content metadata (the "attributeFilter" must be false) The allowed filter key that can be applied to content metadata are: - "created" allows sorting by date of creation of content - "modified" allows sorting by date of modification of content. \n \n \n attributeFilter \n true \n Decides whether the filter must be applied to an attribute or to a content metadata, admitted values are (true, false). The "key" attribute will be checked for validity if the filter is going to be applied to a metadata \n \n \n value \n false \n The filtering value. \n \n \n start \n false \n Filters the contents by attribute type or by the field specified with the key (respect the following matches): Text field -→ start Text Text attribute type -→ start Text Numeric attribute type -→ start Numeric date attribute type -→ start data If the data filter is used: - today, oggi or odierna will select all the contents with a date greater or equal to the system date - using date with the pattern "dd/MM/yyyy" will select all the contents with a date greater or equal to the one inserted. \n \n \n end \n false \n Similar the the "start" attribute but with the opposite behavior. \n \n \n order \n false \n Specifies the sorting behavior of the IDs found: "ASC"ending or "DESC"ending. By default no ordering is performed. \n \n \n likeOption \n false \n Toggles the \'like\' functionality. Admitted values: (true, false). Default: false. The option is available for metadata and on Text Content attributes. \n Tag  contentListUserFilterOption \n Tag Class  Tag class: com.agiletec.plugins.jacms.aps.tags.ContentListUserFilterOptionTag = \n Description \n "ContentListTag" sub-tag, it creates a custom user filter to restrict the result of the content search by front-end user. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n key \n true \n The key of the filter. This string can be: - the name of a content attribute compatible with the type declared in the "contentListTag" (it requires the "attributeFilter" attribute to be "true") - the ID of one of the content metadata (the "attributeFilter" must be false) The allowed filter key that can be applied to content metadata are: - "fulltext" allows filter by full-text search<br /> - "category" allows filter by a system category. \n \n \n attributeFilter \n true \n Decides whether the filter must be applied to an attribute or to a content metadata, admitted values are (true, false). The "key" attribute will be checked for validity if the filter is going to be applied to a metadata. \n Tag  searcher \n Tag Class  com.agiletec.plugins.jacms.aps.tags.SearcherTag \n Description \n Generates a list of content IDs, restricting them to the key word contained in the "search" parameter of the http request. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n listName \n yes \n Name of the variable, stored in the page context, containing the list of content IDs. \n Tag  rowContentList \n Tag Class  Tag class: com.agiletec.plugins.jacms.aps.tags.RowContentListTag \n Description \n Publish a list of contents. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n listName \n true \n Name of the variable in the page context that holds the contents (list of properties of key "contentId" and "modelId"). \n \n \n titleVar \n false \n Inserts the title on a variable of the page context with the name provided. \n \n \n pageLinkVar \n false \n Inserts the code of the page to link on a variable of the page context with the name provided. \n \n \n pageLinkDescriptionVar \n false \n Inserts the description of the page to link on a variable of the page context with the name provided. \n \n \n \n'},{title:"Entando 6.3.0 Release Notes",frontmatter:{sidebarDepth:2},regularPath:"/v6.3/docs/releases/",relativePath:"v6.3/docs/releases/README.md",key:"v-55ae2236",path:"/v6.3/docs/releases/",headers:[{level:2,title:"New Features and Major Fixes",slug:"new-features-and-major-fixes"},{level:3,title:"Infrastructure",slug:"infrastructure"},{level:3,title:"New Use Cases",slug:"new-use-cases"},{level:3,title:"Security Fixes",slug:"security-fixes"},{level:3,title:"Entando Component Repository (ECR)",slug:"entando-component-repository-ecr"},{level:3,title:"Developer Experience",slug:"developer-experience"},{level:3,title:"Quickstart Installs",slug:"quickstart-installs"},{level:3,title:"AppBuilder",slug:"appbuilder"},{level:2,title:"Deprecation Warnings",slug:"deprecation-warnings"},{level:2,title:"Open Issues",slug:"open-issues"},{level:2,title:"Previous Releases",slug:"previous-releases"}],lastUpdated:"12/18/2020, 5:25:51 PM",lastUpdatedTimestamp:1608330351e3,content:' Entando 6.3.0 Release Notes \n New Features and Major Fixes \n Infrastructure \n \n \n Enhanced the Entando Operator so it can run on a dedicated namespace and support multiple Entando Applications in different namespaces. \n \n This enables a separation of privileges so the operator can be managed by Kubernetes administrators and an Entando Application can be managed by users with access to a specific namespace. \n \n \n \n Upgraded to Java 11 for all core Entando docker images \n \n \n Improved support for Google GKE, Azure AKS, and Amazon EKS cloud deployments \n \n \n Added support for OpenShift 4.X via quickstart templates \n \n \n Added configuration options so the Entando Component Repository can deploy bundles based on private registries and repositories \n \n \n Improved support for more complex topologies of TLS enabled ingresses \n \n \n Added support for single domain configurations \n \n In previous versions Entando used subdomains to expose subsystems and bundle microservices. Entando 6.3 can now operate under a single domain using the url path for routing. This can simplify infrastructure and certificate management. \n \n \n \n Enabled tuning the resource requirements of the core service pods \n \n \n Made Jboss EAP and Wildfly cache configuration available on the default docker images for the core services \n \n \n Added support for using Kubernetes secrets for external database \n \n \n Added options to preserve persistent volumes when a related Entando custom resource is deleted \n \n \n Simplified propagation of environment parameters \n \n \n Supported clustered caching based on Redis, including using the Redis client frontend for node-local caching \n New Use Cases \n \n \n Added capability to integrate with an external OIDC identity provider \n \n \n Added integration with Azure WAF \n \n \n Supported GKE installation in development configurations \n Security Fixes \n \n \n XSS: Added a default, mandatory Content Security Policy (CSP) to cover cases outside the scope of input sanitization \n \n \n This policy increases the security of all modules deployed within Entando, whether developed by Entando, clients, or 3rd parties. \n \n \n The CSP can be customized via Entando system parameters. \n \n \n The authorization data required by CSP (the "nonce") is automatically applied to elements developed within AppBuilder or installed via Entando Bundles. \n \n \n Developers should be aware of the constraints imposed by CSP, in particular with regard to code dynamic evaluation and event management. See Google’s CSP guide for more details:  https://developers.google.com/web/fundamentals/security/csp \n \n \n \n \n Applied fixes for sanitization/path traversal indicated by static code analysis \n \n \n Updated encryption algorithms (to AES and SHA256) for two cases of token generation \n \n These changes are not compatible with older versions of Java 8. \n \n \n \n Fixed XXE cases by updating and configuring the XML object factories \n \n These fixes are not compatible with older versions of Java 8. \n \n \n \n Removed support for weak encryption algorithms, including MD5, Argon, 3DES \n \n \n Updated to recent and more secure versions of spring-boot, Apache CXF, Keycloak engine and client libraries \n \n \n Improved log sanitization \n Entando Component Repository (ECR) \n \n \n Upgraded to Java 11 for all Entando Bundles \n \n \n Renamed  entando-bundle-cli  repository and tool to  entando-bundler  (or just  bundler ) to avoid confusion with the new  entando-cli  command line tool \n \n \n Added the ability to export all content in an Entando Application via the  entando-bundler \n \n \n This does not include users but does include groups and permissions. \n \n \n In some cases, an exported bundle may need to be manually updated before importing it into another Entando application (e.g. if the css for a widget is pointing to a root resource) \n \n \n \n \n Added a  forced overwrite  installation strategy for Entando Bundles that creates new objects or updates existing objects in order to allow business cases like: \n \n \n \n continuous deployment in development scenarios \n \n \n \n \n continuous deployment of staging to production \n \n \n \n \n migration of Entando Applications. The developer/admin will still be responsible for the update of data structures, as appropriate. \n \n \n \n \n develop a component, export as a bundle, import to a QA or test instance, then import into a production instance \n \n \n \n \n \n Improved the bundle plugin descriptor to provide new capabilities. New properties: \n \n \n \n deploymentBaseName : The base name to assign to the Kubernetes pods. If not present the base name will be generated from the docker organization, image name and image version. If the generated name is too long it will be truncated in order to respect Kubernetes constraints. \n \n \n \n \n ingressPath : the ingress path to assign to the plugin deployment \n \n \n \n \n permissions : a list of Keycloak clientId / role mappings \n Developer Experience \n \n \n Entando 6.3 now includes a Command Line Interface,  entando-cli  or simply  ent , intended to accelerate Entando development by automating common development tasks. The CLI can been used to do the following: \n \n \n Simplify the quickstart install process via a one line script leveraging a multipass VM for direct install via  ent quickstart \n \n \n Prepare a developer environment via  ent check-env  which installs tools such as npm, git, jhipster. The correct version of each dependency is installed based on the Entando version configured in the developer environment and uses private installs of npm-based tools to avoid conflicts across projects. \n \n \n Create, build, and publish bundles via project-level commands such as  ent jhipster  and  ent prj . \n \n \n Use the  ent bundler  command to help prepare bundle custom resources or to export a complete bundle from an existing Entando Application. \n \n \n Use helper commands such as  ent app-info ,  ent pod-info , and  ent diag  to collect diagnostic information related to an Entando application and which can be shared with Entando Support. \n \n \n (experimental) Use helper commands such as  ent attach-vm  and  ent kubectl  to interact with an Entando application. \n \n \n For more information on the CLI see  this page . \n \n \n \n \n Added compatibility fixes when running Entando tools on Linux, MacOS, and Windows 10. \n Quickstart Installs \n \n \n Enabled the one step HTTP installer for use on Linux, MacOS, and Windows 10 to set up a fully functional Entando Application in Kubernetes. \n \n \n Added support for Windows 10 mshome.net-based addresses when installing a quickstart via the Entando CLI. \n \n \n Provided a new template for deploying the Entando operator into a dedicated namespace \n \n \n Enhanced the quickstart so base docker images can be specified. This is required for scenarios where only private registries are allowed. \n AppBuilder \n \n \n Streamlined and simplified the Page and Content creation workflow \n \n \n Improved the Page Management and Page Designer UX to ease page design and configuration \n \n \n Added Welcome Wizard guided tutorial to help new users create a fully functional page in a new Application and introduce them to the main features of the App Builder interface \n \n \n Added Profile → Preferences options to allow users to customize their App Builder experience. Current settings include the Welcome Wizard, Missing Translation Warning, and Load on Page Select. \n Deprecation Warnings \n \n ECR: The format of the Bundle Plugin descriptor has been updated. The format used in Entando 6.2 has been deprecated. \n Open Issues \n \n \n ECR: The  forced overwrite  scenario when installing an Entando Bundle can only be utilized via API calls. A user interface will be provided in a future release. \n \n \n MySQL support will be restored in a patch release \n Previous Releases \n Please see the  Versions  list in the main navigation menu above to access documentation and release notes for previous versions of Entando. \n'},{title:"Aps Core Tag Library",frontmatter:{},regularPath:"/v6.3/docs/reference/freemarker-tags/freemarker-core-tags.html",relativePath:"v6.3/docs/reference/freemarker-tags/freemarker-core-tags.md",key:"v-47f57e71",path:"/v6.3/docs/reference/freemarker-tags/freemarker-core-tags.html",headers:[{level:2,title:"Tag action",slug:"tag-action"},{level:3,title:"Description",slug:"description"},{level:3,title:"Example",slug:"example"},{level:3,title:"Attributes",slug:"attributes"},{level:3,title:"Tag class",slug:"tag-class"},{level:2,title:"Tag categories",slug:"tag-categories"},{level:3,title:"Description",slug:"description-2"},{level:3,title:"Example",slug:"example-2"},{level:3,title:"Attributes",slug:"attributes-2"},{level:3,title:"Tag class",slug:"tag-class-2"},{level:2,title:"Tag checkHeadInfoOuputter",slug:"tag-checkheadinfoouputter"},{level:3,title:"Description",slug:"description-3"},{level:3,title:"Attributes",slug:"attributes-3"},{level:3,title:"Tag class",slug:"tag-class-3"},{level:2,title:"Tag cssURL",slug:"tag-cssurl"},{level:3,title:"Description",slug:"description-4"},{level:3,title:"Example",slug:"example-3"},{level:3,title:"Attributes",slug:"attributes-4"},{level:3,title:"Tag class",slug:"tag-class-4"},{level:2,title:"Tag currentPage",slug:"tag-currentpage"},{level:3,title:"Description",slug:"description-5"},{level:3,title:"Example",slug:"example-4"},{level:3,title:"Attributes",slug:"attributes-5"},{level:3,title:"Tag class",slug:"tag-class-5"},{level:2,title:"Tag currentWidget",slug:"tag-currentwidget"},{level:3,title:"Description",slug:"description-6"},{level:3,title:"Example",slug:"example-5"},{level:3,title:"Attributes",slug:"attributes-6"},{level:3,title:"Tag class",slug:"tag-class-6"},{level:2,title:"Tag fragment",slug:"tag-fragment"},{level:3,title:"Description",slug:"description-7"},{level:3,title:"Attributes",slug:"attributes-7"},{level:3,title:"Tag class",slug:"tag-class-7"},{level:2,title:"Tag freemarkerTemplateParameter",slug:"tag-freemarkertemplateparameter"},{level:3,title:"Description",slug:"description-8"},{level:3,title:"Attributes",slug:"attributes-8"},{level:3,title:"Tag class",slug:"tag-class-8"},{level:2,title:"Tag headInfo",slug:"tag-headinfo"},{level:3,title:"Description",slug:"description-9"},{level:3,title:"Example",slug:"example-6"},{level:3,title:"Attributes",slug:"attributes-9"},{level:3,title:"Tag class",slug:"tag-class-9"},{level:2,title:"Tag i18n",slug:"tag-i18n"},{level:3,title:"Description",slug:"description-10"},{level:3,title:"Example",slug:"example-7"},{level:3,title:"Attributes",slug:"attributes-10"},{level:3,title:"Tag class",slug:"tag-class-10"},{level:2,title:"Tag ifauthorized",slug:"tag-ifauthorized"},{level:3,title:"Description",slug:"description-11"},{level:3,title:"Example",slug:"example-8"},{level:3,title:"Attributes",slug:"attributes-11"},{level:3,title:"Tag class",slug:"tag-class-11"},{level:2,title:"Tag imgURL",slug:"tag-imgurl"},{level:3,title:"Description",slug:"description-12"},{level:3,title:"Example",slug:"example-9"},{level:3,title:"Attributes",slug:"attributes-12"},{level:3,title:"Tag class",slug:"tag-class-12"},{level:2,title:"Tag info",slug:"tag-info"},{level:3,title:"Description",slug:"description-13"},{level:3,title:"Example",slug:"example-10"},{level:3,title:"Attributes",slug:"attributes-13"},{level:3,title:"Tag class",slug:"tag-class-13"},{level:2,title:"Tag internalServlet",slug:"tag-internalservlet"},{level:3,title:"Description",slug:"description-14"},{level:3,title:"Example",slug:"example-11"},{level:3,title:"Attributes",slug:"attributes-14"},{level:3,title:"Tag class",slug:"tag-class-14"},{level:2,title:"Tag nav",slug:"tag-nav"},{level:3,title:"Description",slug:"description-15"},{level:3,title:"Example",slug:"example-12"},{level:3,title:"Attributes",slug:"attributes-15"},{level:3,title:"Tag class",slug:"tag-class-15"},{level:2,title:"Tag outputHeadInfo",slug:"tag-outputheadinfo"},{level:3,title:"Description",slug:"description-16"},{level:3,title:"Attributes",slug:"attributes-16"},{level:3,title:"Tag class",slug:"tag-class-16"},{level:2,title:"Tag pageInfo",slug:"tag-pageinfo"},{level:3,title:"Description",slug:"description-17"},{level:3,title:"Attributes",slug:"attributes-17"},{level:3,title:"Tag class",slug:"tag-class-17"},{level:2,title:"Tag pager",slug:"tag-pager"},{level:3,title:"Description",slug:"description-18"},{level:3,title:"Example",slug:"example-13"},{level:3,title:"Attributes",slug:"attributes-18"},{level:3,title:"Tag class",slug:"tag-class-18"},{level:2,title:"Tag parameter",slug:"tag-parameter"},{level:2,title:"Tag pager",slug:"tag-pager-2"},{level:3,title:"Description",slug:"description-19"},{level:3,title:"Example",slug:"example-14"},{level:3,title:"Attributes",slug:"attributes-19"},{level:3,title:"Tag class",slug:"tag-class-19"},{level:2,title:"Tag printHeadInfo",slug:"tag-printheadinfo"},{level:3,title:"Description",slug:"description-20"},{level:3,title:"Attributes",slug:"attributes-20"},{level:3,title:"Tag class",slug:"tag-class-20"},{level:2,title:"Tag resourceURL",slug:"tag-resourceurl"},{level:3,title:"Description",slug:"description-21"},{level:3,title:"Example",slug:"example-15"},{level:3,title:"Attributes",slug:"attributes-21"},{level:3,title:"Tag class",slug:"tag-class-21"},{level:2,title:"Tag show",slug:"tag-show"},{level:3,title:"Description",slug:"description-22"},{level:3,title:"Example",slug:"example-16"},{level:3,title:"Attributes",slug:"attributes-22"},{level:3,title:"Tag class",slug:"tag-class-22"},{level:2,title:"Tag url",slug:"tag-url"},{level:3,title:"Description",slug:"description-23"},{level:3,title:"Example",slug:"example-17"},{level:3,title:"Attributes",slug:"attributes-23"},{level:3,title:"Tag class",slug:"tag-class-23"},{level:2,title:"Tag pageWithWidget",slug:"tag-pagewithwidget"},{level:3,title:"Description",slug:"description-24"},{level:3,title:"Example",slug:"example-18"},{level:3,title:"Attributes",slug:"attributes-24"},{level:3,title:"Tag class",slug:"tag-class-24"},{level:2,title:"Tag currentUserProfileAttribute",slug:"tag-currentuserprofileattribute"},{level:3,title:"Description",slug:"description-25"},{level:3,title:"Attributes",slug:"attributes-25"},{level:3,title:"Tag class",slug:"tag-class-25"},{level:2,title:"Tag userProfileAttribute",slug:"tag-userprofileattribute"},{level:3,title:"Description",slug:"description-26"},{level:3,title:"Attributes",slug:"attributes-26"},{level:3,title:"Tag class",slug:"tag-class-26"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:' Aps Core Tag Library \n \n \n Version: 2.3 \n \n \n Short Name: wp \n \n \n URI: /aps-core \n Tag  action \n Description \n Build the URL to call a jsp or a functionality of a servlet defined\nwithin the system. This tag can use the ParameterTag sub-tag to add url\nparameters. \n Example \n (<@wp.action path="/do/my.action" var="myaction" />)  or\n (<@wp.action path="/JSP/my.jsp" var="my.jsp"/>) \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n path \n no \n The relative path of jsp or servlet to invoke, relative to the context of web-application \n \n \n var \n no \n Name of the page-scoped variable where to place the URL. \n Tag class \n com.agiletec.aps.tags.ActionURLTag \n Tag  categories \n Description \n Return the list of the system categories on SelectItem objects. \n Example \n <@wp.categories var="systemCategories" titleStyle="prettyFull" root="$\\{userFilterOptionVar.userFilterCategoryCode}" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n titleStyle \n no \n The style of the single select item. Currently it can be \'default\' (single title node), \'full\' (title with all parents) or \'prettyFull\' (title with all parents in form of \'..\'). The default when none is given is \'default\'. \n \n \n fullTitleSeparator \n no \n The separator beetwen the titles when \'titleStyle\' is \'full\' or \'prettyFull\'. \n \n \n var \n no \n Name of the page-scoped variable where to place the list of categories. \n \n \n root \n no \n The root of the categories to show. The default is the system root categories \n Tag class \n com.agiletec.aps.tags.CategoriesTag \n Tag  checkHeadInfoOuputter \n Description \n This sub-tag verifies the availability of the information to display.\nThis sub-tag can be used only in a page template, in conjunction with\n\'outputHeadInfo\'. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n type \n yes \n Specifies the type of information to analyse. \n Tag class \n com.agiletec.aps.tags.CheckHeadInfoOutputterTag \n Tag  cssURL \n Description \n Extension of the ResourceURL tag. It returns the URL of the css files. \n Example \n <@wp.cssURL />href="<@wp.cssURL />myportal.css" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n Tag class \n com.agiletec.aps.tags.CssURLTag \n Tag  currentPage \n Description \n Returns the requested information held by the current page bean. \n Example \n <@wp.currentPage param="code" var="currentViewCode" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n param \n false \n The wanted parameter: actually can be either "title", "owner" (group), "code", "hasChild" or "childOf" (with attribute "targetPage"). The default when none is given is "title". \n \n \n langCode \n no \n Code of the language to use for the page information being returned. \n \n \n var \n no \n Name of the page context variable where the information are placed. Please note that the in this case the special characters will not be escaped. \n \n \n targetPage \n no \n Target page when "param" is "childOf". \n \n \n escapeXml \n no \n Decides whether to escape the special characters in the information retrieved or not. Value admitted (true, false), the default is true. \n Tag class \n com.agiletec.aps.tags.CurrentPageTag \n Tag  currentWidget \n Description \n Returns information about the widget where the tag resides. To obtain\ninformation about a widget placed in a frame other than the current, use\nthe "frame" attribute. \n Example \n <@wp.currentWidget param="config" configParam="name" var="configName" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n param \n yes \n The requested parameter. It can assume one of the following values: - "code" returns the code of the associated widget type (empty if none associated) - "title" returns the name of the associated widget type (empty if none associated) - "config" returns the value of the configuration parameter declared in the "configParam" attribute. The default is "title". \n \n \n configParam \n no \n Name of the configuration parameter request. This attribute is mandatory when the attribute "param" is set to "config". \n \n \n var \n no \n Name of the page context variable where the requested information is pushed. In this case the special characters will not be escaped. \n \n \n frame \n false \n Id of the frame hosting the widget with the desired information. \n \n \n escapeXml \n no \n Toggles the escape of the special characters. Admitted value are (true, false), the default is "true". \n Tag class \n com.agiletec.aps.tags.CurrentWidgetTag \n Tag  fragment \n Description \n Print a gui fragment by the given code. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n code \n true \n The code of the fragment to return. \n \n \n var \n false \n Name of the page context variable where the requested information is pushed. In this case the special characters will not be escaped. \n \n \n escapeXml \n false \n Toggles the escape of the special characters. Admitted value are (true, false), the default is "true". \n Tag class \n org.entando.entando.aps.tags.GuiFragmentTag \n Tag  freemarkerTemplateParameter \n Description \n Add a parameter into the Freemarker’s TemplateModel Map. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n var \n true \n Name of the variable where the requested information is pushed. \n \n \n valueName \n true \n Name of the variable of the page context where extract the information. \n \n \n removeOnEndTag \n false \n Whether to remove the parameter on end of Tag. Possible entries (true, false). Default value: false. \n Tag class \n org.entando.entando.aps.tags.FreemarkerTemplateParameterTag \n Tag  headInfo \n Description \n Declares the information to insert in the header of the HTML page. The\ninformation can be passed as an attribute or, in an indirect manner,\nthrough a variable of the page context. It is mandatory to specify the\ntype of the information. \n Example \n <@wp.headInfo type="JS" info="entando-misc-bootstrap/bootstrap.min.js" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n type \n yes \n Declaration of the information type. Currently only "CSS" is currently supported. \n \n \n info \n no \n Information to declare. This is an alternative of the "var" attribute. \n \n \n var \n no \n Name of the variable holding the information to declare. This attribute is the alternative of the "info" one. This variable can be used for those types of information that cannot be held by an attribute. \n Tag class \n com.agiletec.aps.tags.HeadInfoTag \n Tag  i18n \n Description \n Return the string associated to the given key in the specified language.\nThis string is either returned (and rendered) or can be optionally\nplaced in a page context variable. This tag can use the ParameterTag\nsub-tag to add label parameters. \n Example \n <@wp.i18n key="COPYRIGHT" escapeXml="false" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n key \n yes \n Key of the label to return. \n \n \n lang \n no \n Code of the language requested for the lable. \n \n \n var \n no \n Name of the variable (page scope) where to store the wanted information. In this case the special characters will not be escaped. \n \n \n escapeXml \n no \n Toggles the escape of the special characters of the returned label. Admitted values (true, false), the default is true. \n Tag class \n com.agiletec.aps.tags.I18nTag \n Tag  ifauthorized \n Description \n Toggles the visibility of the elements contained in its body, depending\non user permissions. \n Example \n <@wp.ifauthorized permission="enterBackend"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n permission \n no \n The code of the permission required. \n \n \n groupName \n no \n The name of the group membership required. \n \n \n var \n no \n The name of the (boolean) page context parameter where the result of the authorization check is placed. \n Tag class \n com.agiletec.aps.tags.CheckPermissionTag \n Tag  imgURL \n Description \n Extension of the ResourceURL tag. It returns the URL of the images to\ndisplay as static content outside the cms. \n Example \n <@wp.imgURL />entando-logo.png" alt="Entando - Access. Build. Connect." /> \n Attributes \n Tag class \n com.agiletec.aps.tags.ImgURLTag \n Tag  info \n Description \n Returns the information of the desired system parameter. \n Example \n <@wp.info key="systemParam" paramName="applicationBaseURL" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n key \n yes \n Key of the desired system parameter, admitted values are: "startLang" returns the code of start language of web browsing "defaultLang" returns the code of default language "currentLang" returns the code of current language "langs" returns the list of the languages defined in the system "systemParam" returns the value of the system param specified in the "paramName" attribute. \n \n \n var \n no \n Name of the variable where to store the retrieved information (page scope). In this case the special characters will not be escaped. \n \n \n paramName \n no \n Name of the wanted system parameter; it is mandatory if the "key" attribute is "systemParam", otherwise it is ignored. \n \n \n escapeXml \n no \n Toggles the escape of the special characters in the information returned. Admitted values are (true,false), the former being the default value. \n Tag class \n com.agiletec.aps.tags.InfoTag \n Tag  internalServlet \n Description \n Tag for the "Internal Servlet" functionality. Publishes a function\nserved by an internal Servlet; the servlet is invoked from a path\nspecified in the attribute "actionPath" or by the widget parameter\nsharing the same name. This tag can be used only in a widgets. \n Example \n <@wp.internalServlet actionPath="/ExtStr2/do/jpuserreg/UserReg/initRegistration" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n actionPath \n false \n The init action path. \n \n \n staticAction \n false \n Whether to execute only the given action path. Possible entries (true, false). Default value: false. \n Tag class \n com.agiletec.aps.tags.InternalServletTag \n Tag  nav \n Description \n Generates through successive iterations the so called "navigation" list.\nFor every target/page being iterated (inserted in the page context) are\nmade available the page code, the title (in the current language) and\nthe link. Is it also possible to check whether the target page is empty\n-that is, with no configured positions- or not. \n Example \n <@wp.nav var="page"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n spec \n no \n Declares the set of the pages to generate. \n \n \n var \n yes \n Name of the page context variable where the data of target being iterated are made available. \n Tag class \n com.agiletec.aps.tags.NavigatorTag \n Tag  outputHeadInfo \n Description \n Iterates over various information in HTML header displaying them; this\ntag works in conjunction with other specific sub-tags. Please note that\nthe body can contain only a sub-tag, or information, at once. This tag\nmust be used only in a page template. E.g (<@wp.outputHeadInfo\ntype="CSS">) \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n type \n yes \n Specifies the type of information to return, in accordance with the sub-tag to use. \n Tag class \n com.agiletec.aps.tags.HeadInfoOutputterTag \n Tag  pageInfo \n Description \n Returns the information of the specified page. This tag can use the\nsub-tag "ParameterTag" to add url parameters if the info attribute is\nset to \'url\'. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n pageCode \n true \n The code of the page. \n \n \n info \n false \n Code of required page parameter. Possible entries: "code" (default value) , "title", "owner" (group), "url", "hasChild" or "childOf" (with attribute "targetPage"). \n \n \n langCode \n false \n Code of the language to use for the returned information. \n \n \n var \n false \n Name used to reference the value pushed into the pageContext. In this case, the system will not escape the special characters in the value entered in pageContext. \n \n \n targetPage \n no \n Target page when "param" is "childOf". \n \n \n escapeXml \n false \n Whether to escape HTML. Possible entries (true, false). Default value: true. \n Tag class \n com.agiletec.aps.tags.PageInfoTag \n Tag  pager \n Description \n List pager. \n Example \n <@wp.pager listName="result" objectName="groupContent" max="10" pagerIdFromFrame="true" advanced="true" offset="5"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n max \n no \n The maximum value for each object group. \n \n \n listName \n yes \n Name of the list as found in the request. \n \n \n objectName \n yes \n Name of the object currently iterated. The following methods are exposed:  getMax, getPrevItem, getNextItem, getCurrItem, getSize, getBegin, getEnd, getMaxItem, getPagerId. \n \n \n pagerId \n no \n Sets the ID of the pager itself, it has to be used when two or more pagers exist in the same page. This attributes overrides "pagerIdFromFrame". \n \n \n pagerIdFromFrame \n no \n Sets the ID of the pager (mandatory when two or more pagers share the same page) based upon the frame where the tag is placed. Admitted values are (true, false), the latter being the default. Please note that the "pagerId" attribute takes precedence over this one. \n \n \n advanced \n no \n Toggles the pager in advanced mode. Admitted values are (true, false). the advanced mode of the tag is used when the list to iterate over is huge. \n \n \n offset \n no \n This attribute is considered only when the pager is in advanced mode. This is the numeric value of the single step increment (or decrement) when iterating over the list \n Tag class \n com.agiletec.aps.tags.PagerTag \n Tag  parameter \n Tag  pager \n Description \n This tag can be used to parameterise other tags. The parameter value can\nbe added through the \'value\' attribute or the body tag. When you declare\nthe param tag, the value can be defined in either a value attribute or\nas text between the start and the ending of the tag. \n Example \n <@wp.parameter name="resourceName"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n name \n true \n The name of the parameter. \n \n \n value \n false \n The value of the parameter. \n Tag class \n com.agiletec.aps.tags.ParameterTag \n Tag  printHeadInfo \n Description \n Returns the information to display. This sub-tag must be used only in a\npage template, in conjunction with \'outputHeadInfo\'. \n Attributes \n Tag class \n com.agiletec.aps.tags.HeadInfoPrinterTag \n Tag  resourceURL \n Description \n Returns URL of the resources. \n Example \n <@wp.resourceURL />static/js/entando-misc-html5-essentials/html5shiv.js"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n root \n no \n Declares the resource root. If not otherwise specified, the value of SystemConstants.PAR_RESOURCES_ROOT_URL is used. \n \n \n folder \n no \n Declares a specific directory for the desired resources. Unless specified, the value "" (empty string) is used in the generation of the URL. \n Tag class \n com.agiletec.aps.tags.ResourceURLTag \n Tag  show \n Description \n Defines the position of inclusion of a widget. This tag can be used only\nin a page template. \n Example \n <@wp.show frame="0" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n frame \n yes \n The positional number of the frame, starting from 0. \n Tag class \n com.agiletec.aps.tags.WidgetTag \n Tag  url \n Description \n Generates the complete URL of a portal page. The URL returned is either\nreturned (and rendered) or placed in the given variable. To insert\nparameters in the query string the sub-tag "ParameterTag" is provided. \n Example \n <@wp.url paramRepeat="true" > \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n page \n no \n Code of the destination page. The default is the current page. \n \n \n lang \n no \n Code of the language to use in the destination page. \n \n \n var \n no \n Name of the page-scoped variable where to place the URL. \n \n \n paramRepeat \n no \n Repeats in the URL all the parameters of the actual request. \n \n \n excludeParameters \n no \n Sets the list of parameter names (comma separated) to exclude from repeating. By default, this attribute excludes only the password parameter of the login form. Used only when paramRepeat="true". \n Tag class \n com.agiletec.aps.tags.URLTag \n Tag  pageWithWidget \n Description \n Search and return the page (or the list of pages) with the given widget\ntype. When "filterParamName" and "filterParamValue" attributes are\npresent, the returned list will be filtered by a specific widget\nconfiguration. \n Example \n <@wp.pageWithWidget widgetTypeCode="userprofile_editCurrentUser" var="userprofileEditingPageVar" listResult="false" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n var \n true \n Attribute_description: \n \n \n widgetTypeCode \n true \n The code of the widget to search \n \n \n filterParamName \n false \n Optional widget config param name \n \n \n filterParamValue \n false \n Optional widget config param value \n \n \n listResult \n false \n Optional, dafault false. When true the result is a list of pages, when false the returned page is the first occurence \n Tag class \n com.agiletec.aps.tags.PageWithWidgetTag \n Tag  currentUserProfileAttribute \n Description \n Current User Profile tag. Return a attribute value of the current user\nprofile. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n attributeName \n false \n the name of the attribute from which extract the value. \n \n \n attributeRoleName \n false \n the name of the attribute role from which extract the value. \n \n \n var \n false \n Name used to reference the value pushed into the pageContext. \n \n \n escapeXml \n false \n Decides whether to escape the special characters in the information retrieved or not. Value admitted (true, false), the default is true. \n Tag class \n org.entando.entando.aps.tags.CurrentUserProfileAttributeTag \n Tag  userProfileAttribute \n Description \n User Profile tag. Return a attribute value from the profile givea an\nusername. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n username \n true \n the username \n \n \n attributeName \n false \n the name of the attribute from which extract the value. \n \n \n attributeRoleName \n false \n the name of the attribute role from which extract the value. \n \n \n var \n false \n Name used to reference the value pushed into the pageContext. \n \n \n escapeXml \n false \n Decides whether to escape the special characters in the information retrieved or not. Value admitted (true, false), the default is true. \n Tag class \n org.entando.entando.aps.tags.UserProfileAttributeTag \n'},{title:"Development Tips and Tricks",frontmatter:{sidebarDepth:2,redirectFrom:"/v6.3/tutorials/devops/local-tips-and-tricks.html"},regularPath:"/v6.3/docs/reference/local-tips-and-tricks.html",relativePath:"v6.3/docs/reference/local-tips-and-tricks.md",key:"v-6a6e256c",path:"/v6.3/docs/reference/local-tips-and-tricks.html",headers:[{level:2,title:"Quickstart Management",slug:"quickstart-management"},{level:3,title:"General",slug:"general"},{level:3,title:"Multipass",slug:"multipass"},{level:3,title:"Entando in Kubernetes",slug:"entando-in-kubernetes"},{level:2,title:"Shared Servers",slug:"shared-servers"},{level:2,title:"Network Issues",slug:"network-issues"},{level:3,title:".nip.io isn't allowed",slug:"nip-io-isn-t-allowed"},{level:3,title:"The IP address changed after the initial install",slug:"the-ip-address-changed-after-the-initial-install"},{level:2,title:"Windows Development",slug:"windows-development"},{level:3,title:"Multipass loses control of VMs",slug:"multipass-loses-control-of-vms"},{level:3,title:"Hyper-V IP Changes",slug:"hyper-v-ip-changes"},{level:3,title:"JHipster",slug:"jhipster"},{level:3,title:"Multipass with VirtualBox",slug:"multipass-with-virtualbox"}],lastUpdated:"5/28/2021, 2:12:34 PM",lastUpdatedTimestamp:1622225554e3,content:" Development Tips and Tricks \n We've collected a list of tips and tricks for optimizing your local quickstart or  Getting Started  development environment. We invite you to ask questions, collaborate with the community, and share your own favorite\npractices over on the  Entando forum . \n Quickstart Management \n Here are a few common questions about the quickstart environment which uses Multipass to launch an Ubuntu VM, install K3s Kubernetes into it, and then deploy Entando. \n General \n \n How can I remove a quickstart environment? . If you want to completely remove the VM created by Multipass then you can use  multipass delete <VM-NAME>  (where the default VM-NAME for a quickstart is  entando ) and then  multipass purge  to recover the resources. If you just want to shutdown Entando but keep the VM you can use  multipass shell <VM-NAME>  to shell into the VM and then remove the namespace via  sudo kubectl delete namespace entando . \n Multipass \n \n How can I shell into a Multipass VM?   multipass shell <VM-NAME> . If you don't provide a VM-NAME, multipass will use the default name  primary  and even launch it for you if it doesn't exist. \n What do I need to do after restarting my laptop?  By default Multipass is installed as a service and will restart automatically. If Multipass isn't running, you'll need to first start the service, and then you can start your VM via  multipass start <VM-NAME> . Kubernetes will start automatically along with any installed pods, including Entando. It can take a few minutes for all of the pods to start completely but you can use  sudo kubectl -n entando get pods --watch  to observe the progress. \n How can I idle or pause my Entando instance?  You can use either  multipass stop <VM-NAME>  or  multipass suspend <VM-NAME> , if you'd rather preserve the VM state. You can then use  multipass start <VM-NAME>  to start the VM. \n What else can Multipass do?  You can run  multipass help  or refer to the  Multipass docs  for more information on Multipass. \n Entando in Kubernetes \n \n How can I install a new copy of Entando into an existing VM?  The quickstart deploys Kubernetes resources into a dedicated namespace,  entando  by default. You can simply delete the namespace,  sudo kubectl delete namespace entando , if you want to delete all of its resources. You can then re-create the namespace and re-install by applying the Helm template for your environment. Alternatively, you can use  ent quickstart --vm-reuse=true  but you'll need to set other  ent quickstart  options so check the  ent  help. \n How can I shell into a running pod or view its logs?  You can use the standard Kubernetes commands, e.g.  sudo kubectl exec -it <POD-NAME> -c <CONTAINER-NAME -- bash  or  sudo kubectl logs <POD-NAME> <CONTAINER-NAME> \n What do I if Entando doesn't start completely?  The most common cause for this is a networking problem. See the  Network issues  section below for details. If all else fails reach out to the Entando team on Slack or in the Forums. \n Shared Servers \n We've recommended using Multipass as a way to quickly spin up an Ubuntu VM to host a local Kubernetes cluster for test purposes. There are many times when a local environment is useful but most teams utilize a shared Kubernetes cluster managed by an operations team and installed either on premise or with a cloud provider for full integration testing, CI/CD, DevOps, etc. \n Network Issues \n A local Entando 6.3 quickstart installation (e.g. what you'll get if you follow the  Getting Started  guide) may use a set of local domain names to enable accessing Entando services. Your IP address will vary but may look something like this: \n quickstart-entando.192.168.99.1.nip.io\nquickstart-kc-entando.192.168.99.1.nip.io\nquickstart-eci-entando.192.168.99.1.nip.io\n \n The base domain configured via the ENTANDO_DEFAULT_ROUTING_SUFFIX (e.g. in your entando.yaml) is based on a fixed IP address and that address is configured during the initial installation. That setting is used to generate ingress routes to map incoming URLs to individual services. In production environments there's generally a dedicated network layer to manage IPs/routing (both on premise and cloud) but those options are often not readily available in a local setup. Here are a couple common issues that can prevent Entando from starting in a local environment: \n  .nip.io isn't allowed \n \n This could be because of firewall settings or corporate security policies. The simplest workaround is to manually edit your /etc/hosts file and map the necessary domains to the IP of your local virtual machine. \n \n  192.168.99.1 quickstart-kc-entando.192.168.99.1.nip.io\n 192.168.99.1 quickstart-eci-entando.192.168.99.1.nip.io\n 192.168.99.1 quickstart-entando.192.168.99.1.nip.io\n \n \n If you add microservices to your installation, you may need to add additional mappings for the new ingresses. \n See  this section below  for detailed steps on Windows. \n  The IP address changed after the initial install \n \n The workaround noted above (e.g. update your /etc/hosts file) can also be used here. Simply update the IP address in the first column to use the current IP of your virtual machine. \n On Windows this can happen simply because your laptop restarted. See  Windows Hyper-V IP Changes  below. \n Windows Development \n Multipass loses control of VMs \n Q: What do I do if Multipass cannot access my VMs? \n A:  The most common symptoms include an  IP=UNKNOWN  entry when issuing a  multipass list  and any attempts to stop or shell into the VM will fail. \n Internet Connection Sharing (ICS) is a Windows service that provides Internet connectivity to virtual machines and its  hosts.ics  file can occasionally get corrupted. Restarting the host laptop or desktop should remedy this but a quicker and simpler fix is to shutdown any VMs using the hypervisor (Hyper-V or VirtualBox), remove the  hosts.ics  file from  Windows/System32/drivers/etc  using elevated privileges, and then restart the VM(s). You can examine the  hosts.ics  file first to check if it is well-formed or if it contains spurious numbers or letters rather than clean IP to VM-NAME mappings. \n Hyper-V IP Changes \n Q: My Entando installation stops working when I restart Windows. How can I fix this? \n A:  The basic issue is that Windows Hyper-V makes it difficult to set a static IP for a VM. (See this  forum post  for details.) As discussed  above , Entando's ingress routes rely on an fixed IP address and will break if the IP address changes after initial installation. Here are a few options to solve this issue, short of modifying your router or network switch settings: \n Option 1: Single host routing \n The simplest way to deal with the peculiarities of Hyper-V IP assignments is to avoid it by using the Windows-specific mshome.net addresses. This allows you to access a VM by using an address like  <VM-NAME>.mshome.net . If you set up your enviroment using the  Automatic Install  instructions, then the ent CLI will select the single host option for you and the address will be  entando.mshome.net . You can accomplish the same thing yourself using the  ent quickstart  script but see its  --help  for the current set of options. \n Option 2: Manually update your hosts file \n The next simplest option to re-enable external access to your cluster is to update your hosts file after each Windows restart. \n You need two pieces of information for this workaround and you'll need administrator access to do this. \n \n Determine the original IP used for your VM. This is included in the  ENTANDO_DEFAULT_ROUTING_SUFFIX  or you can see it included in the ingress names. Run   kubectl -n entando get ingress  and you should see something like this: \n \n NAME                          CLASS    HOSTS                                           \nquickstart-kc-ingress         <none>   quickstart-kc-entando.192.168.235.100.nip.io  \nquickstart-eci-ingress        <none>   quickstart-eci-entando.192.168.235.100.nip.io  \nquickstart-ingress            <none>   quickstart-entando.192.168.235.100.nip.io    \n \n \n Determine the current IP using  hostname -I  in the VM or by running  multipass list  from Windows: \n \n $ multipass list\nName                    State             IPv4             Image\nprimary                 Running           172.31.118.12   Ubuntu 18.04 LTS\n \n \n As a Windows administrator, edit your hosts file  (C:\\Windows\\System32\\drivers\\etc\\hosts)  to map any needed URLs from the old IP to the new IP. This will bypass .nip.io lookups. \n \n 172.31.118.12 quickstart-kc-entando.192.168.235.100.nip.io\n172.31.118.12 quickstart-eci-entando.192.168.235.100.nip.io\n172.31.118.12 quickstart-entando.192.168.235.100.nip.io\n \n \n You should now be able to access your Entando URLs via the new IP. If your Entando installation stalled during startup, it should continue starting up as soon as the external address is functional again. \n Option 3: Add a Windows route \n This option is a little more involved the first time but it means repairing your network settings can be done very easily later. In this case you'll pick a static IP, configure a Windows route to map it to the Hyper-V interface, and claim the IP in the Ubuntu VM via a netplan entry. \n You'll need to run all of these steps before installing Entando the first time but then just steps #1 and #2 after subsequent Windows restarts. \n \n \n Determine an IP that is unused on your local network. You can use ping or other tools for this but in the following steps we assume that your selected IP is 192.168.99.1. \n \n \n Determine the interface address to Hyper-V, e.g. 32 below. Use cmd  route print  and look for the Interface entry for Hyper-V: \n \n \n Interface List\n 32...00 15 5d 86 45 20 ......Hyper-V Virtual Ethernet Adapter\n \n \n Using elevated privileges, add a persistent route to map your IP to the Hyper-V interface: \n \n route -p add [YOUR-IP] mask 255.255.255.255 0.0.0.0 IF [HYPER-V-INTERFACE]\nroute -p add 192.168.99.1 mask 255.255.255.255 0.0.0.0 IF 32\n \n \n \n Verify the route was added by using  route print 192.168.99.1 . This command is useful after restart to check if the route needs to be created again. \n \n \n Next, configure your VM to claim the same address. Shell into the VM using  winpty multipass shell [YOUR-VM-NAME] . \n \n \n Change to the root user to make the following steps simpler:  sudo -i \n \n \n Determine your network adapter via  ip link , e.g. eth0. You just need the name. It's often second in the list after the loopback adapter. \n \n \n ubuntu@primary:~$  ip   link \n 1 : lo:  < LOOPBACK,UP,LOWER_UP >  mtu  65536  qdisc noqueue state UNKNOWN mode DEFAULT group default qlen  1000 \n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n 2 : eth0:  < BROADCAST,MULTICAST,UP,LOWER_UP >  mtu  1500  qdisc mq state UP mode DEFAULT group default qlen  1000 \n    link/ether 00:15:5d:00:1a:0c brd ff:ff:ff:ff:ff:ff\n \n \n \n cd /etc/netplan \n \n \n Create a netplan entry starting with 0 so it's loaded first:  vi 0-entando.yaml \n \n \n network : \n   version :   2 \n   renderer :  networkd\n   ethernets : \n     [ YOUR - NETWORK - ADAPTER ] : \n       dhcp4 :  no\n       addresses :  \n         -   [ YOUR - IP ] /24\n \n Example: \n network : \n   version :   2 \n   renderer :  networkd\n   ethernets : \n     eth0 : \n       dhcp4 :  no\n       addresses :  \n         -  192.168.99.1/24\n \n \n \n Apply the changes via  netplan apply \n \n \n Verify connectivity via  ping 192.168.99.1  from the VM. You should get a response rather than a timeout. \n \n \n (Optional) Run a python server to verify you can access the VM from the host at  http://192.168.99.1:8000.  It may take a minute or so before the server is ready. \n \n \n python3 -m http.server 8000\n \n \n You should now be able to install Entando using the static IP. If your Entando installation stalled during startup and was previously configured using the static IP, it should continue starting up as soon as the external address is functional again. \n Option 4: Reinstall Entando \n We're including this option because it works and requires no additional configuration. If you plan to regularly work with Entando we recommend developing against a centralized and shared Kubernetes instance rather than running a full stack locally. If you need a cluster locally we recommend using option 1 or 2. \n JHipster \n Q: How can I run JHipster on Windows? \n A:  JHipster requires a TTY interface for its menus to function correctly. Here are a few options to satisfy that requirement on Windows: \n \n Run  jhipster  under cmd or Powershell \n Using Git Bash, run  winpty jhipster.cmd \n Use Ubuntu bash via WSL (1 or 2) or within the Multipass VM \n Multipass with VirtualBox \n Multipass supports the use of VirtualBox on Windows as an alternative to using Hyper-V, say if you're using Windows Home. See the Multipass documentation on how to configure it to work with VirtualBox. \n In order to get Entando working correctly with this setup you will need to add a port forwarding rule so you can access Entando from your host system. \n \n \n Create your VM within Multipass. \n \n \n Go to the Oracle VM VirtualBox Manager and edit the  Network  settings for the VM. \n \n \n Go to the  Advanced  options and click  Port Forwarding Rules \n \n \n Add a new rule. \n \n Name : your choice \n Protocol : TCP \n Host IP : leave this blank \n Host Port : 80 \n Guest IP : leave this blank \n Guest Port : 80 \n Click OK \n \n \n \n At this point any requests to port 80 on your localhost should be forwarded to the VM. \n \n \n You can now identify the IP of your host and use that to configure the  ENTANDO_DEFAULT_ROUTING_SUFFIX  in your yaml file, e.g.  192.168.64.25.nip.io . You should not use the non-routable address (e.g. 10.0.2.15) identified from within the guest VM itself, but rather use the IP of the host. \n \n \n"},{title:"Entando Identity Management -- Keycloak",frontmatter:{},regularPath:"/v6.3/docs/reference/identity-management.html",relativePath:"v6.3/docs/reference/identity-management.md",key:"v-4fd3bacc",path:"/v6.3/docs/reference/identity-management.html",headers:[{level:2,title:"Logging into your Keycloak Instance",slug:"logging-into-your-keycloak-instance"},{level:2,title:"Authentication",slug:"authentication"},{level:2,title:"Authorization",slug:"authorization"},{level:3,title:"Plugins/Microservices",slug:"plugins-microservices"},{level:3,title:"Core",slug:"core"},{level:2,title:"Social Login",slug:"social-login"},{level:2,title:"One Time Passwords",slug:"one-time-passwords"},{level:2,title:"Themes and Look and Feel",slug:"themes-and-look-and-feel"}],lastUpdated:"3/19/2021, 11:11:23 AM",lastUpdatedTimestamp:1616166683e3,content:' Entando Identity Management -- Keycloak \n Entando Identity Management is powered by Keycloak. The Keycloak instance used for your Entando apps\ncan be  externally installed  or you can use a dedicated instance on a per application basis. The sections below details the architecture and documentation required to customize your Keycloak instance. \n Logging into your Keycloak Instance \n In an Entando deployment Keycloak is protected by a Secret deployed in your Kubernetes instance. To get the default admin credentials you can query Kubernetes for the secret with this command: \n kubectl get secret <project-name>kc-admin-secret -n <namespace> -o go-template="{{println}}Username: {{.data.username | base64decode}}{{println}}Password: {{.data.password | base64decode}}{{println}}{{println}}"\n \n Replace  <project-name>  and  <namespace>  with your values. If you\'re not sure of the secret name you can run \n kubectl get secrets -n <namespace>\n \n And search for the secret that ends in  kc-admin-secret \n Authentication \n In Entando 6 all authentication goes through Keycloak. This ensures that a micro frontend can call a microservice with a token that is available on the client. \n \n By using Keycloak as a central point of authentication the Entando architecture is able to provide a single unified view of identity to the entire architecture. With this architecture Entando becomes more portable and can be integrated into other IDPs without changes to the source. Keycloak acts as an  abstraction to the underlying IDP. \n Authorization \n Plugins/Microservices \n Authorization for the microservices comes from clients and roles in keycloak. The authorizations are stored in the JWT token and are available to the services when invoked. \n Core \n Authorization for the entando-core and WCMS is provided by the Entando user management database. When a user is authenticated to the entando-core  a copy of that user is added to the Entando user management database.  That copy is made in support of the authorization flow noted below. \n As noted above when a user is authenticated to the entando-core via keycloak a copy of that user is added to the entando-core user management database in support of WCMS functionality.  Using the App Builder WCMS roles and groups can be assigned to a user for access to functions in the App Builder or for portal-ui based content access in the runtime application The code that copies the user into the entando-core can be customized to automatically create groups and roles as needed for an application but it is something that must be done on a per implementation basis. \n For more details on the code that copies users and data to the WCMS database see the  entando-keycloak-plugin . The readme in that project includes properties that are available to your Entando app. \n For a deeper look See:  KeycloakAuthorizationManager.java  in the plugin for an example of adding attributes programatically. In particular, the  processNewUser  method. \n Social Login \n Keycloak allows Entando to provide social login as an out of the box capability. See the  Keycloak Social Identity Providers  for documentation on enabling and configuring social logins in your Entando apps. \n One Time Passwords \n Keycloak enables Entando applications to provide login via One Time Passwords (OTP) as well. See the  Keycloak OTP Policies  for more details on configuring and enabling OTP in your application. \n Themes and Look and Feel \n Developers can also customize the look and feel of the login page and all of the identity management system that ships with Entando. The  Keycloak Theme Documentation  provides a lot of details on creating your own theme. \n You can also review the code for the  Entando Theme  as an example Keycloak theme to start from. \n'},{title:"Tutorials",frontmatter:{sidebarDepth:2},regularPath:"/v6.3/tutorials/",relativePath:"v6.3/tutorials/README.md",key:"v-08b0f4d8",path:"/v6.3/tutorials/",headers:[{level:2,title:"Learning Paths",slug:"learning-paths"},{level:3,title:"Frontend Development",slug:"frontend-development"},{level:3,title:"Backend Development",slug:"backend-development"},{level:3,title:"Operations",slug:"operations"}],lastUpdated:"5/13/2021, 2:33:52 PM",lastUpdatedTimestamp:1620930832e3,content:" Tutorials \n Entando simplifies the development of modern apps: \n \n Built using modern JavaScript frameworks \n Backed by microservices deployed in containers, and \n Orchestrated by Kubernetes for fully automated DevOps lifecycles \n \n \n Entando supports full stack micro frontend and microservice architectures for codebases that are easier to understand, maintain, and debug across large, distributed teams, and comes with a private component repository that makes it easy for teams to share and reuse components. \n Use the navigation on the left to find step-by-step tutorials for common tasks or check out our learning paths below for a more structured approach. \n Learning Paths \n Frontend Development \n \n \n \n Basic \n Intermediate \n Advanced \n \n \n \n \n Build a Basic Widget \n Add Configuration to a Widget \n Generate Micro Frontends and Microservices Based on a Database Entity \n \n \n Create a React Micro Frontend \n Enable Communication between MFEs \n \n \n \n Create an Angular Micro Frontend \n Add Access Controls to your MFEs \n \n \n \n Create and Manage Content \n Backend Development \n \n \n \n Basic \n Intermediate \n Advanced \n \n \n \n \n Build and Publish a Simple Bundle \n Build and Publish a Project Bundle \n Export a Bundle from an Existing Application \n \n \n Generate Micro Frontends and Microservices Based on a Database Entity \n Use JDL Studio to Create a Complex Database Entity \n \n \n \n Run Micro Frontends and Microservices in Your Local Environment \n Add Access Controls to Your Microservices \n Operations \n \n \n \n Basic \n Intermediate \n Advanced \n \n \n \n \n Set Up Entando on a Local Kubernetes Cluster \n Backing Up and Restoring Your Entando Environment \n Install Bundle Microservices from a Private Registry \n \n \n Set Up Entando on Amazon Elastic Kubernetes Service (EKS) \n Customize the base Entando Application via a Docker Image \n Automate Integration Testing With a CI/CD Pipeline   (Coming Soon) \n \n \n Set Up Entando on Azure Kubernetes Service (AKS) \n Connect Your Entando Application to an External Database \n \n \n \n Set Up Entando on Google Kubernetes Engine (GKE) \n Install the Standard Demo Application \n \n \n \n Set Up Entando on Red Hat OpenShift \n \n \n \n \n \n"},{title:"Generate Microservices and Micro Frontends",frontmatter:{sidebarDepth:2},regularPath:"/v6.3/tutorials/backend-developers/generate-microservices-and-micro-frontends.html",relativePath:"v6.3/tutorials/backend-developers/generate-microservices-and-micro-frontends.md",key:"v-6e996aa2",path:"/v6.3/tutorials/backend-developers/generate-microservices-and-micro-frontends.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:3,title:"Manual Setup",slug:"manual-setup"},{level:2,title:"Generate the Project",slug:"generate-the-project"},{level:3,title:"Project Structure",slug:"project-structure"},{level:2,title:"Next Steps",slug:"next-steps"}],lastUpdated:"3/19/2021, 4:22:12 PM",lastUpdatedTimestamp:1616185332e3,content:" Generate Microservices and Micro Frontends \n Overview \n This tutorial shows you how to use the Entando Component Generator powered by  JHipster  to create microservices and micro frontends for eventual deployment to the  Entando Component Repository  and Entando applications. \n \n The general flow of the component generation is: \n \n Run the Entando Blueprint to create your components (Spring Boot microservice and optionally React micro frontends) \n Customize and enhance your generated code \n Build an Entando bundle from your components \n Deploy a custom resource for your bundle into Kubernetes \n Install your Entando bundle into your Entando Application(s) \n Prerequisites \n Use the  Entando CLI  to verify you have the prerequisites in place for this tutorial (e.g. Java, npm, git, JHipster, Entando Blueprint). \n ent check-env develop\n Manual Setup \n The  ent jhipster  command is the recommended way to generate microservices and micro frontends but you can also setup JHipster and the Entando Blueprint yourself. You should then use the  jhipster  command instead of  ent jhipster  for the tutorial. \n \n Install JHipster \n \n npm   install  -g generator-jhipster@6.9.1 \n \n \n Install the Entando Blueprint \n \n npm   install  -g generator-jhipster-entando@6.3.0\n Generate the Project \n \n Setup a new project directory \n \n mkdir  testProject  &&   cd  testProject\n \n \n Use  ent jhipster  to generate the project skeleton using the Entando Blueprint \n \n ent jhipster --blueprints entando\n \n \n You'll be presented with a series of prompts to configure your project. The list below provides a set of choices.  You can select the defaults in every step of the tutorial. Just hit Enter at each step. \n \n \n If you want to go through the choices follow this guide. Except where noted below in bold you can choose what works best for you. Base values for the tutorial are in parentheses.\n \n What is the base name of your application?  (Up to you) \n As you are running in a microservice architecture, on which port would like your server to run? It should be unique to avoid port conflicts.  (8081) \n What is your default Java package name?  (Up to you) \n Which *type* of database would you like to use?  (SQL)\n \n If you pick no database here you'll be building a stateless microservice which is a valid choice but the rest of this tutorial won't work) \n \n \n Which *production* database would you like to use?  (PostgreSQL or MySQL) \n Which *development* database would you like to use?  (H2 with disk-based persistence ) \n Do you want to use the Spring cache abstraction?  (Yes, with the Caffeine implementation) \n  Do you want to use Hibernate 2nd level cache?  (Yes) \n Would you like to use Maven or Gradle for building the backend?   Maven  <-- this is required for Entando and is the default \n Which other technologies would you like to use?  (Don't select any other technologies) \n What name would you give to the bundle to share on an Entando digital-exchange?  Enter a name for your Entando bundle or accept the default \n Which is the organization name to use when publishing the docker image?   At this point enter the name of the organization where you are going to push your docker image. If you're using your own docker hub account you should enter your username here.  (this can be changed later as needed) \n Would you like to generate micro frontends when creating entities?  (Always) \n Would you like to enable internationalization support  (Up to you) \n Please choose the native language of the application  (Up to you) \n Please choose additional languages to install  (if you picked internationalization) \n Besides JUnit and Jest, which testing frameworks would you like to use?  (Up to you) \n Would you like to install other generators from the JHipster Marketplace?  (No) \n \n \n \n \n Next, add an Entity to your microservice and create the corresponding Micro Frontends. For the tutorial,  Conference  is the name of the entity that will be added to the application. \n \n ent jhipster entity Conference \n \n \n Add Fields \n \n Do you want to add a field to your entity?  (Yes) \n What is the name of your field?  (Enter  name ) \n What is the type of your field?  (Select  String ) \n Do you want to add validation rules to your field?  (No) \n Do you want to add a field to your entity?  (Yes) \n What is the name of your field?  (Enter  location ) \n What is the type of your field?  (Select  String ) \n Do you want to add validation rules to your field?  (No) \n Do you want to add a field to your entity?  (No) \n Do you want to add a relationship to another entity?  (No) \n Do you want to use separate service class for your business logic?  (Up to you) \n Do you want to add filtering?  (Up to you or  Not Needed  if you're unsure) \n Do you want pagination on your entity?  (Yes, with infinite scroll) \n At this point the blueprint will generate controllers, repositories, services, and micro frontends for your entity generation. \n \n \n Overwrite src/main/resources/config/liquibase/master.xml?  When prompted with a conflict at this stage enter  a  for All. This will override existing files with the configuration changes needed for your new entity. \n \n \n \n \n \n You now have a Entando project including a Spring Boot microservice with database integration and React-based micro frontends. \n Project Structure \n \n /src/main/docker  contains Docker files to help with local development environments \n /src/main/java  and  src/main/resources  contain the microservice codebase and configuration \n /ui  holds the React-based micro frontends. By default each entity gets an MFE for details, form, and table. \n /bundle  is used to assemble the project code into an Entando bundle. \n Next Steps \n You now have a choice: \n \n Build your Entando bundle and deploy your microservice and micro frontends to the Entando Component Repository. \n Go to the Running Locally tutorial to run your micro frontends and microservice in your local dev environment. \n Learn about the key elements included in the Blueprint generated widgets \n Iterate on your data model using the JHipster Domain Language (JDL) \n \n"},{title:"Role Based Access Controls",frontmatter:{sidebarDepth:2},regularPath:"/v6.3/tutorials/backend-developers/add-access-controls.html",relativePath:"v6.3/tutorials/backend-developers/add-access-controls.md",key:"v-5076a886",path:"/v6.3/tutorials/backend-developers/add-access-controls.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Tutorial",slug:"tutorial"},{level:2,title:"Notes",slug:"notes"},{level:3,title:"Realm Roles versus Client Authorities",slug:"realm-roles-versus-client-authorities"},{level:3,title:"Local versus Kubernetes Testing",slug:"local-versus-kubernetes-testing"},{level:3,title:"Debugging",slug:"debugging"}],lastUpdated:"3/25/2021, 5:39:39 PM",lastUpdatedTimestamp:1616708379e3,content:" Role Based Access Controls \n Overview \n This tutorial guides you through adding access controls to your existing Entando project. Security experts recommend following a practice known as  Defense in Depth  where security controls are placed in each layer of an architecture. This tutorial will help you setup such controls in both the frontend and backend of your Entando application. \n For the purpose of this tutorial we'll use the simple Conference application from  this tutorial  as a starting point. Please work through that tutorial if you have not already. \n The basic security setup for a blueprint-generated application allows any authenticated user to access the functionality contained in the MFEs and/or microservices. Our business requirement for this tutorial is to define two kinds of users in our application -  Conference Users  who can view the Conferences in the tableWidget, and  Conference Admins  who can view and also delete Conferences from the tableWidget. \n Tutorial \n Let's start by securing the list of Conferences so only our two user roles can view the list. \n \n Edit  ConferenceResource.java  located in the  src/main/java/com/<ORG>/<NAME>.web.rest  directory. Modify the REST API  Conference:getAllConferences  method by adding the following annotation. \n \n     @PreAuthorize(\"hasAnyAuthority('conference-user','conference-admin')\")\n    public List<Conference> getAllConferences() {\n \n See the  Spring Security documentation  for more details but this restricts use of the  getConference  method to users who have been assigned either the  conference-user  or the  conference-admin  role on the Keycloak client configured for the microservice. In local testing this defaults to the  internal  client but see notes below on how that works in production. \n Now we should verify this security check is working. \n \n Start up your Keycloak, tableWidget MFE, and microservice. See  these instructions  if you need a refresher but these are the basic commands using the ent CLI and Docker for keycloak. \n \n ent prj ext-keycloak start\nent prj be-test-run\n \n Using a separate cmdline: \n ent prj fe-test-run\n \n \n Access the tableWidget MFE, typically on  http://localhost:3000 , using the default admin/admin account. \n \n Once authenticated, you'll get the message \"No conferences are available\" and, if you check your browser console, you should see a  403 (Forbidden)  error for the request made to  localhost:8080/services/conference/api/conferences . This is expected because we have not yet granted the new role to the admin user. \n Now let's give the admin user the correct role. \n \n Login to keycloak on  http://localhost:9080  using the  admin/admin  credentials. \n \n First we need to create the two roles per our requirements. We're going to add the roles to the  internal  client because it's the one configured by default in the Spring Boot application.yml. \n \n Go to  Clients → internal → Roles  and click  Add Role \n Fill in the  Role Name  with  conference-admin  and click  Save \n Repeat steps 5-6 to create the  conference-user  role. \n \n Now we need to map this role to our user. \n \n Go to  Users → View all users → admin → Role Mappings \n Select  internal  for the  Client Roles  and then move  conference-user  from  Available Roles  to  Assigned Roles \n Go back to the MFE and you should now see the full list of Conferences. \n \n We've now successfully secured the  getAllConferences  API but we have more to do. The admin user was granted just the  conference-user  role but still has access to delete Conferences. We need to lock that down. \n \n Go back into the  ConferenceResource.java  file and add this annotation to the  deleteConference  method: \n \n     @PreAuthorize(\"hasAuthority('conference-admin')\")\n    public ResponseEntity<Void> deleteConference(@PathVariable Long id) {\n \n Here we're restricting the delete method to only the  conference-admin  role. \n \n Restart the microservice. By default this will include rebuilding any changed source files. \n Once the microservice is available, go back to the MFE and try deleting one of the Conferences in the list. You should be able to attempt the delete in the UI but you'll get a 403 error in the browser console and an error like this in the service logs: \n \n 2021-03-22 15:56:16.205  WARN 3208 --- [  XNIO-1 task-3] o.z.problem.spring.common.AdviceTraits   : Forbidden: Access is denied\n \n That's exactly what we wanted! This demonstrates that a user without  conference-admin  is unable to call the delete API. \n Next, let's update the MFE so a user without the  conference-admin  authority cannot even see the delete button in the UI. \n \n Edit the  ConferenceTableContainer.js  under  ui/widgets/conference/tableWidget/src/components . Replace the onDelete logic with an additional check on the user's authorities. \n \n     const isAdmin = (keycloak && keycloak.authenticate) ? keycloak.hasResourceRole(\"conference-admin\", \"internal\"): false;\n    const showDelete = onDelete && isAdmin;\n\n    const Actions = ({ item }) =>\n      showDelete ? (\n \n The key logic there is the hasResourceRole call which checks whether the  internal  client role  conference-admin  was mapped to the current user. \n \n View the MFE (whch should have automatically reloaded) and you should see that the delete icon is no longer visible, matching the admin's current permissions.  We've now verified that a user with just  conference-user  can neither see the delete action in the UI nor call its corresponding API. \n \n Next, let's promote the admin user to a full  conference-admin  so they can delete Conferences. \n \n \n Go back into Keycloak at  http://localhost:9080 , then go to  Users → View all users → admin → Role Mappings , and also give the user the  conference-admin  role. \n \n \n Reload the MFE. The delete icons should now be visible and you should be able to successfully delete a Conference from the list. This satisfies our original business requirement. \n Notes \n Realm Roles versus Client Authorities \n This tutorial made use of authorities which in Keycloak are Roles mapped to a User for a specific Client. You could also make use of higher-level Realm Roles assigned directly to users, e.g.  ROLE_ADMIN . That will work but can result in collisions between applications if they happen to use the same roles. \n If you choose to use Realm-assigned roles then the code above would need to change. In the backend, use the following annotations:  @Secured('ROLE_ADMIN)  or  @PreAuthorize(hasRole('ROLE_ADMIN')) . In the frontend, use  keycloak.hasRealmRole  instead of  keycloak.hasResourceRole . See the  Spring Security page  for more examples. \n Local versus Kubernetes Testing \n This tutorial also makes use of the  internal  client configured in the microservice via the application.yml with roles manually created and assigned in Keycloak. In Kubernetes, Entando will automatically create client roles per the bundle plugin definition (see the plugin definition  here  for more information). Those roles will be created for the client specific to the microservice itself, e.g.  <docker username>-conference-server . This client name will be injected as an environment variable into the plugin container itself so the annotations noted above will work both in local and Kubernetes environments. \n The MFE authorization checks in the tutorial explicitly note the client id,  e.g.  internal , which won't work in Kubernetes. There are a couple options here: \n \n Change the application.yml clientId under  security.oauth2.client.registration.oidc  to match the Kubernetes clientId. That's the most secure and allows the MFE checks to work the same in both local and Kubernetes environments. However, you not be be able to use the same clientId depending on how the microservice is deployed \n An alternative is to broaden the MFE authorization check to look for a named role on any client. This could result in overlap with other clients but with appropriately named roles (e.g. prefixed by feature, e.g.  conference-admin ) this could be the most flexible option. This can be provided via a helper function, e.g. in  api/helpers.js : \n \n //Check if the authenticated user has the clientRole for any keycloak clients\nexport const hasKeycloakClientRole = clientRole => {\n  if (getKeycloakToken()) {\n    const { resourceAccess } = window.entando.keycloak;\n    if (resourceAccess) {\n      for (const client in resourceAccess) {\n        // eslint-disable-line no-unused-vars\n        const roles = resourceAccess[client].roles;\n        if (roles && roles.includes(clientRole)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\n \n This would result in a simpler role check: \n     const isAdmin = hasKeycloakClientRole('conference-admin');\n Debugging \n In both local and Kubernetes environments, the default blueprint javascript will make a global variable available in the browser, e.g.  window.entando.keycloak . Examining this variable can help diagnose issues with assigned roles and authorities. In some cases you may need to logout of Entando and re-authenticate in order to get the latest role assignments. \n"},{title:"Update the Project Data Model",frontmatter:{sidebarDepth:2},regularPath:"/v6.3/tutorials/backend-developers/update-data-model.html",relativePath:"v6.3/tutorials/backend-developers/update-data-model.md",key:"v-346e3ce6",path:"/v6.3/tutorials/backend-developers/update-data-model.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"3/23/2021, 2:54:02 PM",lastUpdatedTimestamp:1616525642e3,content:" Update the Project Data Model \n Overview \n This tutorial shows how you can use the Entando Component Generator powered by  JHipster  to quickly update the data model for your Entando project. \n Prerequisites \n The steps below assume you already have an existing project and are working in the top-level project directory. If you don't have a project yet, please see  this tutorial . \n Tutorial \n \n Start by extracting the current application description using JHipster. The resulting JHIpster Domain Language (JDL) file includes the entity definitions that will be used as a starting point for your design work. \n \n ent jhipster export-jdl export.jdl\n \n \n This file contains the application configuration as well as entity definitions for your project. For simplicity, we'll create a new file containing just the elements describing the entities. If you followed the tutorial above, that section could be as simple as this: \n \n entity Conference {\n  name String\n}\n \n \n You can now take this definition and enhance it by adding fields, additional entities, mappings between tables, field validation, etc. The easiest way to do this is by using the online JDL-Studio or corresponding JHipster IDE plugins/extensions. See  the JHipster docs  for more information on those options. Once you're done enhancing your data model, you should create a new file containing it, e.g.  conference.jdl. \n \n entity Conference {\n  name String required\n  location String\n  date ZonedDateTime\n}\n\nentity Session {\n  name String required\n  track Track required\n}\n\nenum Track {\n  BUSINESS, TECHNICAL\n}\n\nrelationship OneToMany {\n   Conference to Session\n}\n \n In this case we've added two fields to the Conference entity, introduced the Session entity plus an enum, and added a mapping between the two entities. This is the view you'll get in JDL-Studio for the updated data model. \n \n \n Now import the jdl file into your application. You may be asked if you want to generate MFEs depended on your options when first generating the project. \n \n ent jhipster import-jdl conference.jdl\n \n If you kept the original project structure, this step will update your data model, add entries to Liquibase so the database schema can be upgraded at deploy time, add new service methods to your microservice, add fields to your MFEs, etc. \n \n You can now build your updated project and  run it locally  or  deploy it to Entando . For a full local test you can use the following commands to build the project, then start Keycloak, the microservices, and one of the MFEs. \n \n ent prj build\nent prj xk start\nent prj be-test-run\nent prj fe-test-run\n \n You can repeat steps 3-5 as many times as needed throughout the life of your project. \n"},{title:"Run Blueprint-generated Microservices and Micro Frontends in Dev Mode",frontmatter:{sidebarDepth:2},regularPath:"/v6.3/tutorials/backend-developers/run-local.html",relativePath:"v6.3/tutorials/backend-developers/run-local.md",key:"v-037f6074",path:"/v6.3/tutorials/backend-developers/run-local.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"CLI Steps",slug:"cli-steps"},{level:2,title:"Manual Steps",slug:"manual-steps"},{level:3,title:"Start Keycloak using docker-compose",slug:"start-keycloak-using-docker-compose"},{level:3,title:"Start the microservice",slug:"start-the-microservice"},{level:3,title:"Start the table widget",slug:"start-the-table-widget"},{level:3,title:"Start the form widget",slug:"start-the-form-widget"},{level:3,title:"Start the details widget",slug:"start-the-details-widget"},{level:3,title:"Widget Details notes:",slug:"widget-details-notes"},{level:2,title:"Notes",slug:"notes-3"},{level:3,title:"Change Keycloak dev settings",slug:"change-keycloak-dev-settings"},{level:3,title:"The service-url Variable",slug:"the-service-url-variable"},{level:3,title:"User is not authenticated message",slug:"user-is-not-authenticated-message"}],lastUpdated:"5/13/2021, 2:59:04 PM",lastUpdatedTimestamp:1620932344e3,content:' Run Blueprint-generated Microservices and Micro Frontends in Dev Mode \n Overview \n This tutorial will take you through running an Entando project (microservice and micro frontends) in a local development environment. If you haven\'t generated your Entando project yet, start with the  Generate Microservices and Micro Frontend  tutorial first. \n The steps below assume you are working in the top-level project directory. \n CLI Steps \n The following steps make use of the Entando  ent prj  command. See the  Manual Steps  section below for a more detailed description of what the individual commands do. \n \n Startup Keycloak. This uses docker-compose under the hood. Since this is using Docker it will continue to run in the background until you stop it via  ent prj ext-keycloak stop . You can also view its logs using  ent prj ext-keycloak logs . \n \n ent prj ext-keycloak start\n \n \n Startup the Spring Boot application containing your microservices. The logs will be shown on the console and you can stop the application via  CTRL+C . \n \n ent prj be-test-run\n \n \n Startup one or more of the frontend widgets, each from its own shell. You can stop the application using  CTRL+C . This command runs React in development mode so any changes you make to the source files should be immediately seen in the browser. \n \n ent prj fe-test-run\n Manual Steps \n Start Keycloak using docker-compose \n \n Startup the Keycloak server: \n \n    docker-compose  -f src/main/docker/keycloak.yml up\n Notes: \n \n If you have to install docker-compose you can follow this guide:\n https://docs.docker.com/compose/install/ \n By default docker-compose will recreate the Keycloak container (and reset the H2 database) each time it is started. You can make the following changes to persist Keycloak changes across restarts:\n \n Modify the following line in your  src/main/docker/keycloak.yml \n \n \n \n \'-Dkeycloak.migration.strategy=OVERWRITE_EXISTING\',\n \n and replace it with this \n \'-Dkeycloak.migration.strategy=IGNORE_EXISTING\',\n \n \n In the same file, add a persistent volume under  volumes : \n \n  - ./keycloak-db:/opt/jboss/keycloak/standalone/data\n \n Keycloak changes should now be persistent. You can reset your Keycloak database by emptying the  src/main/docker/keycloak-db  directory and restarting the container. \n Start the microservice \n \n \n Start the generated Microservice executing the command: \n ./mvnw\n Notes: \n If you want to reset the widget data (as example if you deleted all rows from the table widget) if during the generation of the microservice you selected "H2 with disk-based persistence" you can delete the target folder, restart the microservice and the data will be regenerated. \n Start the table widget \n Now you can start your generated table widget: \n \n \n Go to the table widget folder in your project: \n cd ui/widgets/<your-entity-name>/tableWidget\n \n \n \n Then install and start your widget executing the command: \n npm install && npm start\n \n \n \n When the widget is started a browser window is opened and the widget URL is loaded \n \n \n If you’re not logged in you’re redirected to the login page. \n \n \n Log in using: \n Username: user\nPassword: user\n \n \n \n After the login process you’ll be redirected to the widget page and you can see the table widget with some generated data. \n Start the form widget \n Now you can start your generated form widget: \n \n \n If you are running another widget, stop it clicking  Ctrl+C  in your widget command line window \n \n \n Go to the form widget folder in your project: \n cd ui/widgets/<your-entity-name>/formWidget\n \n \n \n Then install and start your widget executing the command: \n npm install && npm start\n \n \n \n When the widget is started a browser window is opened with and the widget URL is loaded \n \n \n If you’re not logged in you’re redirected to the login page. \n \n \n Log in using: \n Username: user\nPassword: user\n \n \n \n You’ll be redirected to the widget page and you can see the widget form with the ID 1 loaded. \n Form widget notes: \n If you want to load other data you have to change the index.html file in the folder: \n cd ui/widgets/<your-entity-name>/formWidget/public\n \n and change the id attribute in this line: \n <my-entity-form service-url="%REACT_APP_SERVICE_URL%" id="1" />\n Start the details widget \n You can also start your generated details widget: \n \n \n If you are running another widget, stop it clicking  Ctrl+C  in your widget command line window \n \n \n Go to the details widget folder in your project: \n cd ui/widgets/<your-entity-name>/detailsWidget\n \n \n \n Then install and start your widget executing the command: \n npm install && npm start\n \n \n \n When the widget is started a browser window is opened with and the widget URL is loaded \n \n \n If you’re not logged in you’re redirected to the login page. \n \n \n Log in using: \n Username: user\nPassword: user\n \n \n \n You’ll be redirected to the widget page and you can see the widget form with the ID 1 loaded. \n Widget Details notes: \n If you want to load other data you have to change the index.html file in the public folder: \n cd ui/widgets/<your-entity-name>/detailsWidget/public\n \n and change the "id" attribute in this line: \n <my-entity-details service-url="%REACT_APP_SERVICE_URL%" id="1" />\n Notes \n Change Keycloak dev settings \n If you want to change your Keycloak settings to use another keycloak installation (not the docker-compose pre-configured one) or if you want to change the service-url of your widget you can change the parameters set in the  .env.local  file that was generated by the entando-blueprint in the root folder of your react widgets: \n cd ui/widgets/<your-entity-name>/tableWidget\n \n then edit the file  .env.local \n By default this variables are set to: \n REACT_APP_SERVICE_URL=http://localhost:8081/services/<your-application-name>/api\nREACT_APP_KEYCLOAK_URL=http://localhost:9080/auth\nREACT_APP_KEYCLOAK_REALM=jhipster\nREACT_APP_KEYCLOAK_CLIENT_ID=web_app\n The service-url Variable \n The  service-url  variable is the Microservice API URL. \n User is not authenticated message \n When you run the widgets if you see the message:  User is not authenticated . This means that probably your keycloak application is not running so please check if the docker-compose command is still in execution. \n'},{title:"Widgets and Fragments",frontmatter:{},regularPath:"/v6.3/tutorials/cms/app-builder/hello-world.html",relativePath:"v6.3/tutorials/cms/app-builder/hello-world.md",key:"v-95ff1c02",path:"/v6.3/tutorials/cms/app-builder/hello-world.html",headers:[{level:2,title:"Create a Widget",slug:"create-a-widget"},{level:2,title:"Create a UX Fragment",slug:"create-a-ux-fragment"},{level:2,title:"FreeMarker Basics in Entando",slug:"freemarker-basics-in-entando"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:' Widgets and Fragments \n This tutorial will take you through the basics of creating an Entando\nwidget and placing it on a page. This document will also review the\nbasics of fragments which are re-usable pieces of a user interface. \n Create a Widget \n For this example you will use the Entando App Builder to build and\ndisplay a widget on a page. In a production system or a larger\ndevelopment environment you would build and deploy widgets differently,\nhowever this example provides a quick idea of the building blocks. \n \n \n In the App Builder menu, go to:  Components → Micro frontends & Widgets \n \n At bottom of the page, select ADD \n \n \n \n Now create a widget with the sample HTML code.  Enter into the following fields: \n \n Code:  MyHelloWorld \n en Title:  Hello World \n it Title:  Ciao Mondo \n Custom UI field:  <h2>Hello World</h2> \n Select SAVE \n Note: the Custom UI Field is a freemarker template where you can put raw html and include freemarker logic. This allows you to import javascript, css, or any normal HTML. \n \n \n \n Select a new Home Page \n \n Go To:  Pages → Settings \n From the “Home Page” dropdown menu, select “Home / Service” and select SAVE \n \n \n \n Place the widget on the page \n \n Go To:  Pages → Management \n On the row that says "Service", on the far right side, select the Kebab button and select CONFIGURE \n From the right hand column, drag and drop the new widget into an open frame in the page \n From the top of the page, select PREVIEW \n You should see "Hello World" on the page \n \n \n \n Publish the updated page \n \n Go To:  Pages → Management \n Note for the row showing the Services page, the Status is now yellow \n Select the Kebab button and select PUBLISH \n Create a UX Fragment \n A UX Fragment is a way to take a common piece of front end code and reuse\nit across multiple pages or widgets. Common elements such as basic HTML,\njavascript, or freemarker logic can be stored as fragments and\nreferenced via the  <@wp.fragment …  tag. \n Starting from the simple widget tutorial above: \n \n \n Create a new fragment: \n \n In the App Builder Go To:  Components → UX Fragments \n At bottom of page, select ADD, and enter the following fields \n Code:  test \n Gui Code:  <h2>Hello World</h2> \n Select SAVE \n \n \n \n Place the fragment in a template: \n \n Go To:  Pages → Page Templates \n On the row for service, select EDIT \n In the  Template  text box, add   <@wp.fragment code="test"/>  on a new line between the  <body>  and   </body>  tags \n SAVE the page template \n \n \n \n View the page with the new fragment: \n \n Go To:  Pages → Management \n On the row that says "Service", on the far right side, select the Kebab button and select CONFIGURE \n From the top of the page, select PREVIEW \n Note: You will see the fragment  <h2> This is a fragment. </h2>  which includes the HTML tags. By default html embedded via a fragment tag is escaped so you get it rendered exactly as you enter it. You’ll need to un-escape it to get it to render correctly. \n \n \n \n Update the Fragment: \n \n Go To:  Pages → Page Templates \n On the row for service, select EDIT \n Change the tag to:  <@wp.fragment code="test" escapeXml=false/> \n \n \n \n View the page with the updated fragment: \n \n Go To:  Pages → Management \n On the row that says "Service", on the far right side, select the Kebab button and select CONFIGURE \n From the top of the page, select PREVIEW \n See correctly rendered fragment \n FreeMarker Basics in Entando \n The FreeMarker templating language gives you a lot of flexibility and\npower in how pages are rendered. You can include conditional logic,\ninject information from the backend, check for query parameters and\nroute to different pages. \n For example, to check for a query parameter you can use:\n <#if RequestParameters.myParam?exists > … \n To check the current username, use:\n <#if (Session.currentUser.username != "guest") > \n When you need dynamic behavior in your widgets consider using the power\nof FreeMarker. \n https://freemarker.apache.org \n'},{title:"Content Templates",frontmatter:{},regularPath:"/v6.3/tutorials/cms/content-templates-tutorial.html",relativePath:"v6.3/tutorials/cms/content-templates-tutorial.md",key:"v-77ce6300",path:"/v6.3/tutorials/cms/content-templates-tutorial.html",headers:[{level:2,title:"Create a Content Template",slug:"create-a-content-template"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:" Content Templates \n Content Templates define how the information in a Content item is displayed to an end user once published. Content Templates provide styling and layout for Contents Type and can be used to show the same content in different ways. Content Templates can be managed within the App Builder. \n Create a Content Template \n Creating a Content Template is fairly simple. From the App Builder\napplication \n \n \n Go to  Content → Templates \n \n \n Click on the  Add content template  to create a new Content\nTemplate. \n \n \n \n \n \n Access the  Add Content Template  page, where you can \n \n \n Edit the  Code . It is the unique identifier of the content template.\nYou can insert up to 10 numbers. It’s mandatory. \n \n \n Edit the  Name . It is the name or description of the content\ntemplate. \n \n \n Choose the  Content Type  in the dropdown list. \n \n \n Edit the  HTML Model  based on Velocity language \n \n \n (Optional) Define the CSS  Style Sheet  to be applied to the  HTML Model \n \n \n Press the Save button \n \n \n \n \n \n"},{title:"Content Creation",frontmatter:{},regularPath:"/v6.3/tutorials/cms/content-tutorial.html",relativePath:"v6.3/tutorials/cms/content-tutorial.md",key:"v-72927900",path:"/v6.3/tutorials/cms/content-tutorial.html",headers:[{level:2,title:"Creating Content",slug:"creating-content"},{level:2,title:"Finding Content",slug:"finding-content"},{level:2,title:"Content Actions",slug:"content-actions"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:" Content Creation \n This document provides an overview of Content Management and how to create Content that can be displayed in an application. The App Builder is used to create, edit and publish content stored in the web content management system (WCMS). \n Creating Content \n To see the list of Content in the WCMS: \n \n Go to  Content → Management . All existing\ncontent is displayed in a table list. \n \n \n To create a new Content item and add it to the list \n \n Select the  Add Content  button. A drop-down list will let you\nchoose which Content Type the content will be based on. \n \n \n You will be asked to provide the following information: \n \n \n Info \n \n \n Content Type . This information is pre-defined, and lists the\ncontent type for the content. \n \n \n Description . The specific Content's name or description. This field\nis mandatory. \n \n \n \n \n Groups \n \n \n Owner Group.  Use the drop-down list to choose the\navailable user group that can manage the content.\nThis field is mandatory and may be predefined. \n \n \n Join Group.  Use the drop-down list to choose the\navailable user group to share the content with and select +. The group\nselected will only be able to share and can not\nadministrate this content. This field is not mandatory. \n \n \n Categories.  Select the category(s) and select + to add a classification to the\ncontent to use for searching and sorting.  This field is not mandatory. \n \n \n Content Attributes.  Define each required attributes field and any optional fields\ndefined by the content types used for this Content. This field is mandatory. \n \n \n \n \n \n Save the new content by selecting: \n \n \n Save : The content will be saved in a draft version. \n \n \n Save and Continue : The content will be saved and the editable form will be displayed. \n \n \n Save and Approve : The content will be saved, approved and published. \n Finding Content \n You can list specific Content by using the filters: \n \n \n All : All created Content is displayed (Draft, To Approve and\nApproved/Published) \n \n \n Pending Changes : All created Content that was saved by only clicking on the\n Save  or  Save and Continue  button. The content is not\napproved and therefore is not ready to be published. \n \n \n Ready for Approval : All created Content that is in  Ready  status,\nand saved by clicking on the  Save  or  Save and Continue  button.\nThe content is ready for review but has not yet been approved and\ntherefore has not been published. \n \n \n Published : All created Content that has been saved and approved\nby clicking on the  Save and Approve  button. This content has been\npublished. \n \n \n \n In the table list, contents are listed with several parameters: Name,\nCreated by, Last Edited, Type, Created Date, Owner Group, Join Group,\nStatus, Restrictions, Code, Actions. Fields can be added or deleted from view by selecting or unselecting them\nin the Columns drop-down menu. \n Content Actions \n For all Content in the list, you have access to a set of actions\nthrough the  Actions  kebab button, such as: \n \n \n Edit : update the data fields in the content definition \n \n \n Delete : remove the content \n \n \n Clone : replicate the content \n \n \n Publish : make the content visible \n \n \n Unpublish : hide the content \n \n \n \n All Content in the list can be saved to your local file system by clicking the\n Download  button and selecting either CSV or XLS format. \n \n"},{title:"Content Attributes",frontmatter:{},regularPath:"/v6.3/tutorials/cms/content-attributes.html",relativePath:"v6.3/tutorials/cms/content-attributes.md",key:"v-7b427e40",path:"/v6.3/tutorials/cms/content-attributes.html",headers:[{level:2,title:"Simple Attribute Types",slug:"simple-attribute-types"},{level:2,title:"Composed Attribute Types",slug:"composed-attribute-types"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:" Content Attributes \n Attributes can be seen as the smallest elements that compose a Content\nType. In other words, a Content Type is just a collection of different\nattributes. Attributes are responsible for carrying the actual\ninformation inside a Content in Entando and could be of different types.\nIn this chapter, we will review and describe the different attribute\ntypes. \n Firstly, we can distinguish simple attribute types from composite\nattribute types. In the first case, the attribute type carries a single\npiece of information (for example, an image), while the latter is an\naggregation of simple attribute types (for example, a set of images). \n Simple Attribute Types \n Attach \n This represents the information carried by a file, which is attached to\nthe content. \n It consists of an URL corresponding to the desired file present in the\nsystem’s resources, and a text which can either indicate the description\nor the name of the file. \n This attribute type is rendered as a button named “Add”. By pushing that\nbutton, the user is prompted to select a desired file present in the\nsystem’s Digital Assets Attachments list. \n Boolean \n This attribute type represents a boolean value which can either be true\nor false. This attribute type is rendered as two radio buttons labeled\n“Yes” and “No”. \n Checkbox \n This attribute type behaves in the same way as a Boolean does – it is\nactually an alternative to the Boolean attribute type - but it is\nrendered with a checkbox labeled “Yes” or “No”. \n Date \n This attribute type represents a date, tracking time within a content;\nit is often used to filter contents appearing in lists by publication\ndate, etc. \n It is rendered as a datepicker. \n Timestamp \n This attribute type is specialized for the Date attribute, allowing you\nto also specify the hour, minute and second. \n It is rendered as a datepicker for the date, and a select for hours,\nminutes and seconds. \n Enumerator \n The enumerator attribute type represents textual information with a\npredefined set of choices; it is defined by: \n \n \n Elements which are mandatory and declares the set of available\nchoices; \n \n \n Separator, which is optional and declares the character to use to\nseparate the arguments of the enumerator. By default the comma “,”\nis used. \n \n \n ExtractorBean: this parameter represents the name of the Spring bean\nto use to process the values of the enumerator. The name must\nexactly match the id of the bean as defined in the Spring\nconfiguration file. \n \n \n It is rendered as a select list. \n Enumerator Map \n The enumerator map attribute type represent textual information with a\npredefined set of choices; it is defined by: \n \n \n Elements in the form of a separated list of key=value pairs, (i.e.\nkey1=value1,key2=value2) \n \n \n Separator, which is optional and declares the character to use to\nseparate the key, values pairs. By default the comma is used. \n \n \n It is rendered as a select list which shows the available values. \n Hypertext \n This attribute type holds HTML tagged text; it retains a single value\nfor all languages. \n Even if this attribute type could support all HTML tags, we strongly\nrecommend using only tags which provide meaning and avoid those which\ndecorate or add graphics. \n Hypertext attributes are rendered as a text area in the content edit\npage; if the CKEditor is active, the user has access to a set of\nadditional functionalities from a dedicated editor’s toolbar. Such as\ntable insertion and table manipulation, special characters insertion,\nstring formatting, links creation. \n Image \n This attribute type binds an image resource to the content. \n The image is always taken from the Digital Assets images list. The user\nwill need to specify the description accompanying the image. \n Usually attributes of type Image are not indexed and are not used to\nfilter contents. \n It is rendered as a button named “Add” that, when pushed, allows the\nuser to select an image from the Digital Assets images list. Once\nselected the user is presented with a preview, as a thumbnail, of the\nimage and has the possibility to define some parameters: \n \n \n Text which is mandatory and by default takes the name of the\nselected image \n \n \n legend (optional) \n \n \n alt (optional) \n \n \n description (optional) \n \n \n title (optional) \n \n \n Link \n This attribute type represents an hypertext link; it is normally used to\ninclude a link in your content: it is possible to define up to three\ndifferent types of links: \n \n \n external links: a link pointing to a location external to the Entando\nportal \n \n \n link to page: a link which points to a page of the portal \n \n \n link to a content: a link to another content \n \n \n It is rendered as a button named “Add” that when pushed opens up a modal\nwindow from which the user can select the link type. \n Longtext \n This attribute type represents a simple unformatted text; it supports\nseveral languages and is normally used for small descriptions, when a\nshort string won’t suffice. \n It supports minimum length , maximal length and regular expressions as\noptional parameters. \n It is rendered as a textarea. \n Monotext \n Monotext represents the information in textual form, but supports only a\nlanguage; it is used for all \n those fields which do not require localization. \n It supports minimum length, maximal length, and regular expressions as\noptional parameters. \n It is rendered as a textfield. \n Number \n This attribute type holds an integer number; it retains a single value\nfor all languages. \n Supports the optional parameters: From, To, and Equal to. \n It is rendered as a textfield. \n Text \n This attribute type holds a string; it retains a single value for all\nlanguages. \n It supports minimum length, maximal length, and regular expressions as\noptional parameters. \n It is rendered as a textfield. \n ThreeState \n Conceptually similar to the Boolean attribute, this attribute type\nallows a third status “Both” to be present. \n It is rendered as a radio button with “Yes”, “No”, “Both” options. \n Composed Attribute Types \n All the attributes types of the previous chapter can only retain a\nsingle type of information, but sometimes it is desirable to aggregate\ndifferent types of attributes into one attribute: this is where composed\nattributes are used. \n From a functional point of view, it would be perfectly legal to build a\ncontent type specifying all the attributes back to back: the content\nwould be formally complete, but from a logical point of view the\nattributes would appear mutually unrelated and, worse, the relationship\nbetween them would not be explicit. \n Entando offers three types of composed attributes: List, Monolist,\nComposite. \n List \n This Attribute Type represents a set of independent and homogeneous\nelementary Attribute types, each associated with one of the languages\ndefined in the system. \n An immediate consequence is that this kind of list can handle only\nmono-language basic attributes. \n It is rendered with a button named “Add” that if pushed presents the\nuser a prompt to select or define the single elements which compose the\nlist. \n Monolist \n This attribute type is a list that is common to all the system\nlanguages; this kind of list handles multi-language and mono-language\nattributes. \n It is rendered with a button named “Add” that, if pushed, presents the\nuser with a prompt to select or define the single elements that compose\nthe monolist. \n Composite \n This attribute type is an aggregate of different, non-homogeneous,\nsimple attributes types. The aggregation of different types is treated\nas a single unit. \n It is rendered as a combination of the elementary attribute types, where\neach attribute type presents the proper rendering. \n"},{title:"Content Types",frontmatter:{},regularPath:"/v6.3/tutorials/cms/content-types-tutorial.html",relativePath:"v6.3/tutorials/cms/content-types-tutorial.md",key:"v-a2fb3f00",path:"/v6.3/tutorials/cms/content-types-tutorial.html",headers:[{level:2,title:"Create a Content Type",slug:"create-a-content-type"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:" Content Types \n A Content Type is used to represent or to model a Content.\nIt is characterized by a set of  Attribute Types , each of which defines the value of their properties, called Attributes. A Content is\nan instance or specialization of the Content Type. \n Create a Content Type \n Creating Contents Types is fairly simple. The Content Types are managed\nthrough the Web CMS, its user interface is made available in the App\nBuilder application. \n \n \n Go to  Content → Types \n \n \n Click on the  Add Content Type  button to create a new Content\nType. \n \n \n \n \n \n You be asked to provide \n \n \n Code . The code is the unique identifier of the content type,\nthat must be 3 uppercase letters, (e.g. CNN). It’s mandatory. \n \n \n Name.  The name must be max 50 characters uppercase and\nlowercase letters, including numbers and special characters,\n(e.g. Conference_News). It’s mandatory. \n \n \n \n \n \n \n \n Select the  Save  button, then you’ll see \n \n \n Content Type Information : \n \n \n Code . The value is pre-filled. \n \n \n Name . The name is pre-filled. \n \n \n \n \n Metadata \n \n \n Page for on-the-fly publishing \n \n \n Default content template \n \n \n Default content template for lists \n \n \n \n \n \n \n Default content template  and  Default content template for lists  are used\nrespectively to show the detailed view of the Content and its\nrepresentation as an element in a list. \n \n Attributes \n \n In the Attributes section, select the  Type  from the drop-down list.\nThe list contains all the available attributes types that define which\nproperties/attributes will characterize the Content. \n \n The Add button will start the configuration of the single attribute\ntype. Every attribute type has its own configuration. \n For example, to configure the  Text  Attribute Type, choose Text from\nthe Types drop-down menu and then press the Add button. \n \n \n \n You should specify the following fields \n \n \n Type:  the value is pre-filled. It represents the selected\nattribute type. \n \n \n Code : You should insert the name of the attribute. (You\ncan insert max 10 characters uppercase and lowercase letters,\nnumbers, and special characters _ ). (e.g. title) \n \n \n Name : You should insert the description of the attribute.\n(You can insert max 50 characters uppercase and lowercase letters,\nincluding numbers and special characters). (e.g. Title). \n \n \n You should declare if the attribute is  mandatory ,\n searchable , and  to be used as a filter in the list. \n \n \n The  Roles  section it is possible to assign the  jacms:title\nAttribute Role  to this attribute; in this way other plugins or\nservices will know that within the CNG entity this attribute is a\ntitle, whatever the key is; however, for sake of clarity, the Code\nof the attribute is Title. \n \n \n The remaining fields related to  Sections  and  Validation -\nOGNL  sections are not mandatory and can be left empty. \n \n \n Press the  Continue  button. The Text attribute type requires no\nadditional configuration step. \n \n \n You can add other Attributes Types. \n \n \n Press the  Save  button. The Content type will be saved and displayed\nin the table list \n \n"},{title:"Page and Content Protection",frontmatter:{},regularPath:"/v6.3/tutorials/cms/creating-protected-resources.html",relativePath:"v6.3/tutorials/cms/creating-protected-resources.md",key:"v-d071ee00",path:"/v6.3/tutorials/cms/creating-protected-resources.html",headers:[{level:2,title:"Create a Group",slug:"create-a-group"},{level:2,title:"Protect a Page",slug:"protect-a-page"},{level:2,title:"Protect Content",slug:"protect-content"},{level:2,title:"Protect Images and Attachments",slug:"protect-images-and-attachments"},{level:2,title:"Freemarker Tags and Consuming Protected Resources",slug:"freemarker-tags-and-consuming-protected-resources"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:" Page and Content Protection \n In the Entando Web Content Management System (WCMS) you have the ability to protect pages, content, and digital assets (images and files) by assigning groups that have the authorization to view those assets. If users without the correct authorization attempt to view those assets the platform will return an error. You can handle those errors as required for your application with dedicated error pages or by adding logic to your widgets or freemarker templates. \n Create a Group \n Protected pages, content, and digital assets in the WCMS are protected by assigning groups to the resource that is being created. You can add new groups in the Entando App Builder as follows: \n \n Go to  Users → Groups  from the left navigation \n Select  Add \n Enter a  Name  and a  Code  for your group` \n \n The groups you create here can be utilized to protect pages, content, images, and attachments in the CMS. Groups can be assigned to individual users in the  Users  section of the app builder or as part of a customization of your entando-core-app using APIs or custom code. \n Pages and Content have settings for an  Owner Group  as well as a set of optional  Join Groups . The  Owner Group  indicates the team within the  App Builder  who owns and can modify the page. Additional groups can be given access to the item via the  Join Group  setting. Note: the default App Builder configuration prevents the  Owner Group  from being changed after the item is created. \n Protect a Page \n \n Select  Pages → Management  from the left navigation \n Create a new page. Assign values as you see fit \n To protect a page, assign the  Owner Group  to any group other than  Free Access \n (Optional) Add groups via  Join Group \n Finish configuring the page and select  Save \n \n At this point only users assigned to either the  Owner Group  or  Join Group  will have the ability to view that page. They can also manage the Page if they have the appropriate App Builder role. \n If you would like to test this, navigate to the page URL in a private or incognito browser window and you will be redirected to the  Sign in to Proceed Further  page of your application.\nThe  Sign in to Proceed Further  page can be changed by going to  Pages → Settings  and picking the page you would like to render to users who need to sign in. \n Protect Content \n \n Select  Content → Management  from the left navigation \n Select the  Add Content  button and pick the content type to be created \n To protect a content item, assign the  Owner Group  to any group other than  Free Access \n (Optional) Add groups via  Join Group \n Finish configuring the page and select  Save \n \n The content you are creating will only be available to users assigned to the  Owner Group  of  Join Group . The default WCMS widgets will only return content authorized for a given user. See the  freemarker tags  section below for information on creating custom widgets that utilize protected content. \n Images and Attachments and Groups \n When creating content the  Owner Group  of the content and the  Group  assigned to the digital asset must match. For example, when creating content with an  Owner Group  of  Administrators  the content creator will be unable to select images and attachments that are assigned a different group. The exception to this is assets with a group of  Free Access . Assets with  Free Access  can be added to protected content. \n Protect Images and Attachments \n Images and attachments uploaded to the CMS can be protected by assigning groups. \n \n Select  Content → Assets  from the left navigation \n Upload your file(s) \n In the provided modal window select the  Group  that you would like to own the asset \n Only users with the assigned  Group  will have the ability to view the asset you've created\n \n The asset will only be available to content with the same  Group  unless the attachment or image has been given a group of  Free Access \n Freemarker Tags and Consuming Protected Resources \n The WCMS provides a set of freemarker tags to assist in consuming protected assets in widgets and pages. The  if-authorized  and  tag-nav  tags can help in rendering page lists and fetching assets. \n The  content  and  content-list  tags also provide the ability to fetch and render protected content and protected lists of content. \n Additionally, the   REST APIs  allow clients to fetch protected pages and assets by group via query parameters. The content REST APIs also include the ability to filter by group and access level. \n"},{title:"Digital Assets",frontmatter:{},regularPath:"/v6.3/tutorials/cms/digital-assets-tutorial.html",relativePath:"v6.3/tutorials/cms/digital-assets-tutorial.md",key:"v-16fa72cc",path:"/v6.3/tutorials/cms/digital-assets-tutorial.html",headers:[{level:2,title:"Create a Digital Asset",slug:"create-a-digital-asset"},{level:2,title:"Editing Assets",slug:"editing-assets"},{level:3,title:"Cropping Images",slug:"cropping-images"},{level:2,title:"Embedding an Asset in a Page",slug:"embedding-an-asset-in-a-page"},{level:2,title:"Including an Asset in a Content",slug:"including-an-asset-in-a-content"},{level:2,title:"Configuring Allowed File Extensions for Upload",slug:"configuring-allowed-file-extensions-for-upload"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:" Digital Assets \n The Web Content Management System (WCMS) includes capabilities that let you manage contents and digital assets. Digital Assets are images, documents, and other media\nfiles in specific formats. \n Default Supported Document Formats:  The Entando WCMS can be\nconfigured to allow you to load or exclude any type of file extension\nfrom being loaded to your site. For the app builder you should also include the MIME type of the asset you want to allow. The default set of extensions are:\n pdf,xls,doc,ppt,txt,rtf,sxw,sxc,odt,ods,odp,tar,gz,zip,rar,flv,swf,avi,wmv,ogg, \n mp3,wav,ogm,mov,iso,nrg,docx,docm,xlsx,xlsm,xlsb,pptx,pptm,ppsx,ppsm,sldx,sldm \n Default Supported Image Formats :  jpg, jpeg, png, svg,svg+xml \n Create a Digital Asset \n To manage the Digital Assets through the WCMS: \n \n Go to  Content → Types \n \n Add a new image or a new document file \n \n Press the  Drag and Drop or Browse your computer  button and\nchoose, from your file system, images and documents files that you\nwould like to upload \n \n \n \n From the  Add file  modal window, you must choose one of the\navailable Groups and then the  Upload  button. If categories have\nbeen defined, you can apply them to the asset in this step. \n \n \n \n \n The image file that you just uploaded is displayed in the list; a\nstatistical overview of the number of the uploaded resources (images\nand documents) is provided. The App Builder’s interface allows the\nusers to choose grid and list view; most of the time, users prefer\nto use list view when they are searching with specific requirements,\nwhile they love grid view for exploring. For every resource, image,\nor document, the list shows the following information: \n \n \n Preview \n \n \n Name \n \n \n Type \n \n \n Uploaded By \n \n \n Uploaded At \n \n \n Group \n \n \n Categories \n \n \n Actions \n \n \n \n \n Furthermore, the interface lets you perform all management actions, as: \n \n \n Edit:  update the information data related to every single\nresource (image and document) \n \n \n Duplicate:  copy identically the resource from the original \n \n \n Download:  transfer the resource to your local machine \n \n \n Delete:  remove the resource \n \n \n You can list the contents by filtering with: \n \n \n All : All added files are displayed, images and documents both. \n \n \n Images : All added images are displayed \n \n \n Documents : All added documents are displayed. \n Editing Assets \n Once you have a digital asset in place, you have several editing and viewing options. Click the asset's  Actions  button and select  Edit  to update the asset's name/description, categories, and the file represented. \n Cropping Images \n You can crop images newly uploaded via Digital Assets. You can either crop the image dynamically or by using pre-configured crop ratios. \n To set pre-configured crop ratios: \n \n Select  CMS → Content Settings \n Under  Settings Image Crop Dimensions,  click  Add crop dimension . \n Enter a crop ratio, using numeric values separated by a colon. \n Click  Save . \n \n To dynamically crop an image: \n \n Edit the asset by opening  Actions  menu > Edit.\n \n Buttons representing your pre-defined crop ratios are below the image. Clicking any of those buttons changes the selected crop area based on the chosen ratio. \n You can create multiple crops of a single image as part of the upload process. The right side of the screen displays the list of crops created during the current session. \n \n \n \n \n \n Use your mouse or the buttons below the image to move or change the crop area, then click  Save  to crop the selected area. Repeat the process as many times as needed.\n \n Click  Close  to return to the Digital Assets screen. \n Embedding an Asset in a Page \n The uploaded asset can be embedded in a page by using  <@wp.resourceUrl path/to/asset . The path can be found in the CMS Configuration > File Browser page. \n \n Example usage:\n <img src=\"<@wp.resourceUrl cms/images/butterfly_d0_d3.jpg\" \n Including an Asset in a Content \n The asset can be included in a content of a type that has an  Attach  or  Image  attribute. \n \n Create a content type with an image attribute.\n \n Create a content based on the created  type.\n \n Under the  Content Attributes  section at the bottom of the page, click the  Add  button beside the image attribute. It will then open a modal that allows you to select an asset by clicking the  Use  action.\n Configuring Allowed File Extensions for Upload \n The types of files that can be uploaded to an Entando application are controlled by\nconfiguration in the server side of the app builder. If you're using the quickstart this will be the\n entando-de-app . \n There are two properties that control these settings and they are set in  src/main/conf/systemParams.properties  and are a comma delimitted list of values. The property keys are \n \n jacms.imageResource.allowedExtensions= \n jacms.attachResource.allowedExtensions= \n \n If you are configuring the upload for both the App Builder and the legacy Admin Console you should include\nboth the MIME type of the asset and the file extension. The APIs that support resources will check MIME type of the uploaded asset. \n An example configuration for images. \n \n jacms.imageResource.allowedExtensions=jpg,jpeg,png,svg,svg+xml \n \n Where  svg+xml  is the MIME type for an svg image. \n The  systemParams.properties  file is bundled into the WAR and the image for the application so you will need to create and deploy image to reflect changes for these properties in your application. \n"},{title:"Page Management",frontmatter:{},regularPath:"/v6.3/tutorials/cms/page-management.html",relativePath:"v6.3/tutorials/cms/page-management.md",key:"v-0980427e",path:"/v6.3/tutorials/cms/page-management.html",headers:[{level:2,title:"Create a Page",slug:"create-a-page"},{level:2,title:"Create a Page Template",slug:"create-a-page-template"}],lastUpdated:"3/11/2021, 2:36:21 PM",lastUpdatedTimestamp:1615491381e3,content:' Page Management \n The App Builder provides the capability to publish application pages containing content as well as other Entando components. Page Templates are used to layout the available frames on a page. \n Create a Page \n \n Go to  Pages → Management \n Click  Add \n \n \n You will need to supply at least the following fields: \n \n Title : used for SEO \n Code : must be unique \n Page placement : the location of the Page in the Page Tree \n Owner Group : the Group that has access to the Page \n Page Template : the structure and presentation of the Page \n \n \n \n Click the green  Save and Design  button. This brings you to the Designer section which lets you place widgets into the Page Template frames. \n \n \n \n Add widgets by dragging them from the right column into the desired frame. \n If you select the  Content  widget, its corresponding settings page will be shown. \n \n \n \n Click  Add existing content  to bring up the Content selection view. \n \n \n \n \n In the Search field, you can type the name of the content that you\nwould like to publish. Remember\nthat in order to publish the content on your page, it must first be saved\nand approved. \n \n \n Select the appropriate content item from the list. \n \n \n Press the  Save  button. \n \n \n \n \n \n The title of the selected content item will now be displayed in the widget settings. \n \n \n Press the  Save  button. \n \n \n Click on the  Preview  button to show the page preview with the updated settings. \n \n \n Click on the  Publish  button to publish the page. \n \n \n Click on the  View published page  button to view the published page in your application. \n Create a Page Template \n Page Templates provide the scaffolding of a Page and are constructed using two main elements: \n \n A  JSON configuration  field which lists the set of frames that can be used on a page.\n \n Each item in the frames array represents a frame or slot in the page, characterized by the following values:\n \n pos  - a zero-based position index (starts from zero). This value is used in\nAPIs to address a specific widget on the page. \n descr  - the frame description displayed on Page Design view \n mainFrame  - designates the primary frame in the Page Template \n defaultWidget  - widget code for a default widget to use in this frame. Page Template developers can use this field to provide suggestions on common widgets, e.g. header and footer widgets. \n sketch  - an object with 4 coordinates (x1,x2,y1,y2) to allow the developer to place the widgets in the Page preview. Sketch’s x and y values go from 0 to 11 (similar to columns in Bootstrap), so if you want to place a 2x2 frame at the top left corner of the page, the values would be  x1: 0, x2: 1 y1: 0 y2: 1 . \n \n \n \n \n A  Template  field which uses Freemarker code to setup the HTML page itself.\n \n To add a frame in a specific place of the page, add  <@wp.show frame=0 /> , where frame is the pos variable from the  JSON configuration .  <#assign wp=JspTaglibs["/aps-core"]>  is required at the top of the template to setup the  wp  variable. \n Common code can be shared across pages by using  UX Fragments  and  <@wp.fragment code="\\<FRAGMENT\\_CODE\\>" escapeXml=false /\\> . \n \n \n \n This tutorial prepares a Page Template with two frames on it. \n \n \n Go to  Pages → Templates → Add \n \n \n Enter the following: \n \n \n \n Code: double_frame \n \n Note: dashes are not allowed \n \n \n Name: Double Frame \n JSON Configuration: \n \n { \n   "frames" :   [ \n     { \n       "pos" :   0 , \n       "descr" :   "Frame 1" , \n       "mainFrame" :   false , \n       "defaultWidget" :   null , \n       "sketch" :   { "x1" :   0 ,   "y1" :   0 ,   "x2" :   11 ,   "y2" :   1 } \n     } , \n     { \n       "pos" :   1 , \n       "descr" :   "Frame 2" , \n       "mainFrame" :   false , \n       "defaultWidget" :   null , \n       "sketch" :   { "x1" :   0 ,   "y1" :   2 ,   "x2" :   11 ,   "y2" :   3 } \n     } \n   ] \n } \n \n \n Template: \n \n < #assign  wp = JspTaglibs [ "/aps-core" ] > \n <! DOCTYPE   HTML   PUBLIC   "-//W3C//DTD HTML 4.0 Transitional//EN" > \n < html > \n   < head > \n       < title > < @wp . currentPage param = "title"   /> </ title > \n   </ head > \n   < body > \n     < h1 > < @wp . currentPage param = "title"   /> </ h1 > \n     < div > < @wp . show frame = 0   /> </ div > \n     < div > < @wp . show frame = 1   /> </ div > \n   </ body > \n </ html > \n \n Include the following fragment in the  head  section if you want to make use of the user\'s identity information from Keycloak. \n < @wp . fragment code = "keycloak_auth"  escapeXml = false   /> \n \n \n You should see the  Template preview  reflecting the desired two frame layout. \n Click  Save  to save your template. \n \n'},{title:"Tutorial: Connecting to an External Database",frontmatter:{},regularPath:"/v6.3/tutorials/customize-the-platform/connecting-external-db.html",relativePath:"v6.3/tutorials/customize-the-platform/connecting-external-db.md",key:"v-f24c0590",path:"/v6.3/tutorials/customize-the-platform/connecting-external-db.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:" Tutorial: Connecting to an External Database \n Overview \n This document provides a guide to connecting to an external database. In\nmany (not all) production configurations it is recommended to use a DBMS\noutside of the cluster where your Entando applicaiton is running to\nsimplify maintenance, duplication of resources, and to establish a\nbackup workflow that will scale with your application. \n See  Databases  for other details on Entando databases. \n Prerequisites \n \n \n An environment to install your Entando applicaiton \n \n \n A running PostgreSQL, MySQL, or Oracle environment \n \n \n Administrator access to the database \n \n \n Network access from your Kubernetes cluster to your database \n Tutorial \n \n In the helm quickstart define a db for your deployment that includes\nthe admin credentials for your database \n \n \n db:\n  vendor: postgresql | mysql | oracle\n  host: <yourhost>\n  port: <yourport>\n  adminUser: <youradmin>\n  adminPassword: <youradminpassword>\n  name: <yourdbname>\n \n \n \n Run the helm quickstart or create a deployment for your Entando\nenvironment manually \n \n Note: The quickstart creates a default configuration for the\ndeployment. This isn’t to suggest that it is the only\nconfiguration or that it matches with every use case. It is\nrecommended to think about your desired deployment Architecture\nand to configure for that environment using the CRDs as building\nblocks. This also isn’t to suggest that if it isn’t directly\nsupported by the quickstart template that you can’t change it.\nThe deployment is editable. Treat the helm template as a\nbootstrapping environment and edit your deployments to match\nyour needs and requirements. \n \n \n \n Open the yaml file generated from the deployment and review the\nsettings for the deployment \n \n The Entando Operator will create a secret for the database\nautomatically and use the DB initializers to create the DB for\nthe Entando app and any services that use it \n \n \n \n Deploy your app \n \n \n"},{title:"Adding a new API to the core app",frontmatter:{},regularPath:"/v6.3/tutorials/customize-the-platform/add-rest-api.html",relativePath:"v6.3/tutorials/customize-the-platform/add-rest-api.md",key:"v-f53df298",path:"/v6.3/tutorials/customize-the-platform/add-rest-api.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:" Adding a new API to the core app \n Prerequisites \n \n \n Java 11 \n \n \n maven \n Overview \n This guide will take you through adding a new REST API to the Entando\ncore app. In some cases it is better to add new APIs to the core rather\nthan creating a new microservice. Some example cases where adding new\nAPIs to the core is recommended are: \n \n \n When extending or adding functionality to the WCMS \n \n \n When you have a simple use case requiring persistence that is\nspecific to only the application you’re working within \n \n \n When exposing configurations that are needed by the portal-ui during\npage rendering \n \n \n For small changes that don’t warrant a full stand-alone microservice \n \n \n You can build widgets and micro frontends that take advantage of these\nAPIs in the same way that your micro-frontends can invoke APIs exposed\nby other services. \n Tutorial \n Creating a controller and services \n \n \n Create a new java package in the project using your favorite IDE at\nthe path  org.entando.training . \n \n \n Under that package add packages for  controllers  and  services . \n \n \n Create a class called  DemoController.java  from the\ntraining package into the controllers package. \n \n This is a normal Spring rest controller and it will be\ndiscovered by annotations. \n \n \n \n Copy  DemoService.java  from the\ntraining package into the services package. \n \n This is a normal Spring service that will be autowired into the\ncontroller. The data in this service is hardcoded but this is\nwhere you can wire in external services or other parts of the\nEntando architecture to fetch the data. \n \n \n \n Copy  commonConfig.xml  to\n src/main/resources/spring/aps/managers . \n \n \n The goal is to enable package scanning for annotation driven\nspring services. This includes the package scan for your package\ndefined above. If you want to scan another package, then you\nneed to add another path to this file. This is the only spring\nXML you will need to change if you want to build annotation\ndriven beans in Entando. \n \n \n See also web.xml for deeper details. \n \n \n \n \n Review the code and annotations in the controller to understand how\nthe APIs are protected and integrated. \n \n \n @RestAccessControl  is a custom Entando annotation that can be used\nto restrict APIs by role. \n \n The rest of the annotations are normal Spring annotations. \n \n \n \n Restart your app using jetty. \n \n \n if you get an error add the entries below to\n src/main/conf/systemParams.properties  This is temporary \nParameters for Argon2 algorithm encryption\nalgo.argon2.type=ARGON2i\nalgo.argon2.hash.length=32\nalgo.argon2.salt.length=16\nalgo.argon2.iterations=4\nalgo.argon2.memory=65536\nalgo.argon2.parallelism=4\nalgo.default.key=changeit\n \n \n \n \n \n Go to Swagger \n \n \n Find the demo-controller and try your new endpoints out using\nswagger \n \n \n"},{title:"Change Default Datasources and Connections",frontmatter:{},regularPath:"/v6.3/tutorials/customize-the-platform/change-default-datasources-and-connections/",relativePath:"v6.3/tutorials/customize-the-platform/change-default-datasources-and-connections/README.md",key:"v-712e7cb8",path:"/v6.3/tutorials/customize-the-platform/change-default-datasources-and-connections/",headers:[{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Create a Docker project for your own base image to Entando's standard base image(s)",slug:"_1-create-a-docker-project-for-your-own-base-image-to-entando-s-standard-base-image-s"},{level:3,title:"2. Customize the standalone.xml/standalone-openshift.xml file using environment variables.",slug:"_2-customize-the-standalone-xml-standalone-openshift-xml-file-using-environment-variables"},{level:3,title:"3. Build your own Docker base image",slug:"_3-build-your-own-docker-base-image"},{level:3,title:"4. Modify your Entando App project to use the new Docker base image",slug:"_4-modify-your-entando-app-project-to-use-the-new-docker-base-image"},{level:3,title:"5. Build and push your custom Docker image",slug:"_5-build-and-push-your-custom-docker-image"},{level:3,title:"6. Deploy your EntandoApp with the correct environment variables",slug:"_6-deploy-your-entandoapp-with-the-correct-environment-variables"}],lastUpdated:"3/24/2021, 9:59:27 AM",lastUpdatedTimestamp:1616594367e3,content:' Change Default Datasources and Connections \n Purpose \n This tutorial explains how to customize our EAP and Wildfly base Docker images, and then configure the EntandoApp custom resource to use these customizations. \n Requirements \n \n \n The Entando Operator is running in the target names \n \n \n Keycloak and the Entando Cluster Infrastructure have been deployed \n \n \n The required external databases and other services are up and running. \n \n \n Your own custom project as described in  the tutorial \n Steps \n 1. Create a Docker project for your own base image to Entando\'s standard base image(s) \n Create a project, ideally in Git repository, and put the following files in the folder \n 1.1. The standalone.xml/standalone-openshift.xml file of choice \n It is essential for your custom Docker image to use a file from one of the official Entando Docker base images. \n If you intend to use provide your own EAP based image, please use this\n standalone-openshift.xml \nfile. \n If you intend to use provide your own Wildfly based image, please use this\n standalone.xml \nfile. \n Please note that if you create your own base image with a different version of EAP or Wildfly, using these files\nmay have unintended consequences. \n 1.2. Any modules that may be required for your datasource or other connection resource \n If the resource you need to connect to requires some custom classes, such as JDBC drivers, please add these as \na module to Wildfly/EAP. As an example, you can look at our\n Derby database module \nthat Entando uses for embedded databases. Please ensure that the path of the folder containing the jar files reflects\nthe fully qualified name of the module in the module.xml file. \n 1.3 Dockerfile \n In your Dockerfile, please be sure to extend the correct base image, and add the correct configuration file to\nthe correct location in the target image. \n For EAP, a most basic Dockerfile would look like this: \n FROM entando/entando-eap71-clustered-base:6.1.2\nCOPY --chown=185:0 ./standalone-openshift.xml /opt/eap/standalone/configuration\n \n For Wildfly, a most basic Dockerfile would look like this: \n FROM entando/entando-eap71-clustered-base:6.1.2\nCOPY --chown=1001:0 ./standalone.xml /wildfly/standalone/configuration\n \n Please take note of the user ownership in these different Dockerfiles. This is quite important as Openshift will\nexpect the user/group ownership to be respected. \n 2. Customize the standalone.xml/standalone-openshift.xml file using environment variables. \n You can now modify your Wildfly/EAP configuration to meet your requirements. Where the configuration could differ\nfrom one environment to a next, we strongly advise using environment variable expressions ( ${env.VAR_NAME} ). The most likely change\nthat would be required in this file is the addition of a datasource. Here is an example of how to add a datasource\nto the datasources subsystem. All the environment variables starting with \'YOURDB\' can be specified from the Docker\ncontainer. \n    ...\n    <subsystem xmlns="urn:jboss:domain:datasources:5.0">\n      <datasources>\n        <datasource jndi-name="${env.YOURDB_JNDI}" enabled="true" use-java-context="true" pool-name="yourDbDataSource" use-ccm="true">\n          <connection-url>${env.YOURDB_URL}</connection-url>\n          <driver>${env.YOURDB_DRIVER}</driver>\n          <security>\n            <user-name>${env.YOURDB_USERNAME}</user-name>\n            <password>${env.YOURDB_PASSWORD}</password>\n          </security>\n        </datasource>\n \n Please take extra care not to remove any lines from these files. This is of particular importance in the case of the\nEAP image as, on startup, scripts in the official EAP look for certain placeholders in this file and populates them\nfrom other environment variables. \n 3. Build your own Docker base image \n You can now build your Docker base image. It is highly recommended that you consider using a dedicated CI/CD build\ntool such as Jenkins X to build the base image and maintain traceability between your source code and the resulting\nDocker image. One possible build command could look like this: \n docker build . -t your-docker-registry.com/your-org/your-base-image:1.0.0 \n 4. Modify your Entando App project to use the new Docker base image \n You can now modify your Entando App project that you have forked as described in the\n relevant tutorial . You would require two changes to the pom.xml file\nof the sample project. \n \n Firstly, you would need to change the variable  server.base.image  to reflect the fully\nqualified URI of your Docker image for EAP and/or Wildfly. For example, if you decided to extend the Wildfly image,\ngo to the Maven profile with the id  wildfly  and change the   server.base.image  to look like this: \n \n <server.base.image>your-docker-registry.com/your-org/your-base-image:1.0.0</server.base.image> \n \n Then you need to change the  <from>  element in the Fabric8 Maven Docker Plugin to reflect this variable.\nNavigate to the first  <image>  element in the pom.xml file. You have found the correct one\nif it contains the following xml: \n \n <from>entando/${server.base.image}:${entando.version}</from> \n Delete the  entando/  prefix and the  :${entando.version}  suffix: \n <from>${server.base.image}</from> \n Please note that, should you still require support for both Wildfly and EAP in your Maven pom, you may need to\nrepeat this exercise for both the  eap  and  wildfly  profiles. \n 5. Build and push your custom Docker image \n Before building your Docker image, it would be a good idea to change the name of the image you want to build. Navigate\nto the previously modified  <image>  element in the Fabric8 Maven Docker Plugin.You can change the  <name>  element\nto reflect your preferred name, e.g. \n <name>your-docker-registry.com/your-org/your-entando-app:1.0.0</name> \n Run: \n mvn clean package -Pwildfly -Pderby \n A new Docker image should now be available named  your-docker-registry.com/your-org/your-entando-app:1.0.0 \n Log into the Docker registry in question and then push the image: \n docker push your-docker-registry.com/your-org/your-entando-app:1.0.0 \n You are now ready to deploy this image. \n 6. Deploy your EntandoApp with the correct environment variables \n The final step is to configure your EntandoApp deployment with the correct environment variables. As is the case with\nall the Entando Custom Resources that result in actual deployments, the property  spec.environmentVariables  will be translated\ninto environment variables on each of the Containers in the Deployment\'s Pod. For an EntandoApp named \'my-app\',\nthe new state of the EntandoApp would could be placed in a file named  my-app.yaml  that would look something like this: \n       kind: "EntandoApp"\n      metadata:\n        name: "my-app"\n      spec:\n        dbms: postgresql\n        replicas: 1\n        customServerImage: your-docker-registry.com/your-org/your-entando-app:1.0.0\n        ingressPath: /your-entando-app\n        environmentVariables:\n          - name: YOURDB_JNDI\n            value: java/your-ds\n          - name: YOURDB_URL\n            value: "jdbc:postgresql://somehost.com:5432/mydb"\n          - name: YOURDB_DRIVER\n            value: postgresql\n          - name: YOURDB_USERNAME\n            value: my_user\n          - name: YOURDB_PASSWORD\n            value: mypassword\n      entandoStatus:\n        entandoDeploymentPhase: requested\n\n \n Notice how this Custom Resource specifies a  parameter  for each environment variable that was referenced from the\n standalone.xml  file referenced earlier. \n To apply the changes to your deployment, change the  entandoStatus.entandoDeploymentPhase  property to requested and\napply the file: \n kubectl apply -f my-app.yaml\n \n '},{title:"Tutorial: Extending the App Builder",frontmatter:{},regularPath:"/v6.3/tutorials/customize-the-platform/extend-app-builder.html",relativePath:"v6.3/tutorials/customize-the-platform/extend-app-builder.md",key:"v-9ab51f54",path:"/v6.3/tutorials/customize-the-platform/extend-app-builder.html",headers:[{level:2,title:"Creating a Basic Application",slug:"creating-a-basic-application"},{level:2,title:"Understanding the Stand Alone Environment",slug:"understanding-the-stand-alone-environment"},{level:2,title:"Customizing the Menu",slug:"customizing-the-menu"},{level:2,title:"Customizing the menu labels",slug:"customizing-the-menu-labels"},{level:2,title:"Customizing the Routes",slug:"customizing-the-routes"},{level:2,title:"state",slug:"state"},{level:2,title:"Customizing the Reducers",slug:"customizing-the-reducers"},{level:2,title:"userList",slug:"userlist"},{level:3,title:"connecting to the store",slug:"connecting-to-the-store"},{level:2,title:"Page Models",slug:"page-models"},{level:3,title:"Connecting to the Store",slug:"connecting-to-the-store-2"},{level:2,title:"Adding the API Calls",slug:"adding-the-api-calls"},{level:2,title:"Creating the Thunk",slug:"creating-the-thunk"},{level:2,title:"changing the mapDispatchToProps in the containers",slug:"changing-the-mapdispatchtoprops-in-the-containers"},{level:2,title:"Updating the List components",slug:"updating-the-list-components"},{level:2,title:"clear the default value of the reducer",slug:"clear-the-default-value-of-the-reducer"}],lastUpdated:"12/16/2021, 9:55:53 AM",lastUpdatedTimestamp:1639666553e3,content:" Tutorial: Extending the App Builder \n Apps for the Entando App Builder are developed as standalone\napplications which can be run using  npm start  in standalone mode. \n Each application should be deployed in npm using the  @entando \nnamespace and will export into their dist folder several items used by\nthe App Builder when integrating it into the full application. \n Creating a Basic Application \n To create a basic application, use the  entando\nfpg  running the\n npx @entando/fpg ab-app <appName>  command. \n the  appName  should only contain alphanumeric characters and\nunderscores, and should begin with a letter. \n This will create inside the working directory, a boilerplate app-builder\napp in a directory named  <appName>  argument. \n i.e. \n using the command  npx @entando/fpg ab-app testing  inside your home\ndirectory, a directory named  testing  will be created containing the\napp. \n All dependencies will already be installed allowing you to  cd  inside\nthe project directory and run  npm start  to start the app running. \n Understanding the Stand Alone Environment \n Each app for the App Builder, can run in both a stand alone mode and an\nintegrated mode. Using  npm start  will use standalone mode. \n In this environment you’ll be looking at the user interface of the app\ninside a default page. This page, which includes a default menu, will\nnot be exported and therefore can be customized. \n To better understand which elements and components are being exported to\nApp Builder, it is best to understand the anatomy of the app. \n Exports \n Each app will have a  babel.js  export file similar to: \n      import  menu  from   'ui/common/LinkMenu' ; \n     import   {  cms  as  state  }   from   'state/rootReducer' ; \n     import   {  routes ,  routesDir  }   from   'ui/App' ; \n     import  en  from   'locales/en' ; \n     import  it  from   'locales/it' ; \n\n     const  testing  =   { \n       id :   'testing' , \n      menu , \n      state , \n      routes , \n      routesDir , \n       locales :   { \n        en , \n        it , \n       } , \n     } ; \n\n     export   default  testing ; \n id: is the app id. \n This parameter is used by App Builder to differentiate all integrated\napps. \n menu: is a React component containing all the menu elements. \n These elements are used inside the standalone environment and inside the\nintegrated environment as a second level menu. The boilerplate app\ncontains a basic menu. \n      import  React  from   'react' ; \n     import   {  LinkMenuItem  }   from   '@entando/menu' ; \n     import   {  FormattedMessage  }   from   'react-intl' ; \n\n     const   LinkMenu   =   ( )   =>   ( \n       < > \n         < LinkMenuItem\n          id = \"menu-SECTION_ID\" \n          label = { < FormattedMessage id = \"testing.menu.SECTION_NAME\"  defaultMessage = \"SECTION_NAME\"   / > } \n          to = '/use/const/here/imported/from/routes' \n         / > \n       < / > \n     ) ; \n\n     export   default  LinkMenu ; \n Customizing the Menu \n For this exercise, we will create two links inside the menu. The first\nwill link to a page listing all the users inside the entando instance.\nThe second will list all the existing page templates inside the Entando\ninstance. \n For this example we’re using existing APIs from the Entando core just\nfor simplicity, you can instead call any API or data source. \n In your app project, open  src/ui/common/LinkMenu.js  and update the\nconst to the code below. \n      const   LinkMenu   =   ( )   =>   ( \n       < > \n         < LinkMenuItem\n          id = \"menu-userList\" \n          label = { < FormattedMessage id = \"testing.menu.userList\"  defaultMessage = \"User List\"   / > } \n          to = '/use/const/here/imported/from/routes' \n         / > \n         < LinkMenuItem\n          id = \"menu-pageModelList\" \n          label = { < FormattedMessage id = \"testing.menu.pageModelList\"  defaultMessage = \"Page Model List\"   / > } \n          to = '/use/const/here/imported/from/routes' \n         / > \n       < / > \n     ) ; \n \n it is important that both the  <LinkMenuItem>  id property and the\n`<FormattedMessage>`properties inside label have the correct values\nassigned, i.e.: \n the LinkMenuItem id will be  menu-userList  while the FormattedMessage\nid will be  testing.menu.userList  and the defaultMessage will be\n User List . \n locales \n The locales files are objects that contain all of the i18n locales of\nthe app. \n By default the boilerplate contains both the english and italian i18n\nfiles. \n In your app project in  src/locales/en.js  and  src/locales/it.js  you\ncan see your labels. \n      export   default   { \n       locale :   'en' , \n       messages :   { \n         'testing.title' :   '' , \n         'testing.label.errors' :   '' , \n         'testing.label.cancel' :   '' , \n         'testing.chooseAnOption' :   '' , \n         'testing.tip' :   '' , \n         'testing.new' :   '' , \n         'testing.save' :   '' , \n         'testing.saveAndApprove' :   '' , \n         'testing.unpublish' :   '' , \n         'testing.setContentAs' :   '' , \n         'testing.cancel' :   '' , \n         'testing.saveAndContinue' :   '' , \n         'testing.stickySave.status' :   '' , \n         'testing.stickySave.lastAutoSave' :   '' , \n       } , \n     } ; \n \n While running in standalone mode the boilerplate does not offer a way\nfor the user pick a locale, but both will be loaded inside app-builder\nand will be consumed as intended by it, using the correct one based on\nthe user-picked language. \n It is of course possible to change the standalone app to give the user\nthe option to choose the locale in here as well, but this is not\nsomething will be covering in this tutorial. \n Customizing the menu labels \n To customize the existing menu labels, we’ll add the new label ids\ninside both the english and Italian locale files: \n \n Note \n If you named your app something besides  testing  you’ll need to fix\nthese tags to match the name of your app. \n \n      ... \n     messages :   { \n         ... \n         'testing.menu.userList' :   'List of Users' , \n         'testing.menu.pageModelList' :   'Page Models' , \n         ... \n     } , \n     ... \n \n The key in the messages object matches the id of the\n`<FormattedMessage>`component we placed inside the menu, while its\nvalue is the actual string that will be displayed depending on the\ncurrently active language. \n Routes and RoutesDir \n Both of these elements are imported from  src/ui/App.js . The first one\nis a collection of actual  <Route>  components, and the second one is an\nobject containing each route data, i.e.: \n      export   const  routesDir  =   [ \n       { \n         path :   ROUTE_TESTING , \n         component :   < > app component < / > , \n       } , \n     ] ; \n \n The constant  ROUTE_TESTING  is imported from  src/app-init/routes.js \n Customizing the Routes \n Next we will create the two routes for the two links we have created by\ncreating first the two constants needed. \n In your IDE open  src/app-init/routes.js \n      export   const   ROUTE_TESTING   =   '/testing' ; \n     export   const   ROUTE_USER_LIST   =   '/testing/user-list' ; \n     export   const   ROUTE_PAGE_MODELS   =   '/testing/page-models' ; \n \n \n Note \n Change the value of  testing  to what you selected for the name of\nyour App extension. \n \n The value of each constant will be the path of the route. It is\nimportant that each route is a subroute of the id of the app itself,\notherwise this may cause name collision when running inside the\nintegrated environment of app-builder. \n Both routes are next imported inside  App.js : \n Update the imports with your new ROUTE tags. \n      import   { \n       ROUTE_TESTING , \n       ROUTE_USER_LIST , \n       ROUTE_PAGE_MODELS , \n     }   from   'app-init/routes' ; \n \n and then add to the  routesDir  constant: \n      export   const  routesDir  =   [ \n       { \n         path :   ROUTE_TESTING , \n         component :   < > app component < / > , \n       } , \n       { \n         path :   ROUTE_USER_LIST , \n         render :   ( )   =>   < > user list < / > , \n       } , \n       { \n         path :   ROUTE_PAGE_MODELS , \n         render :   ( )   =>   < > page models < / > , \n       } , \n     ] ; \n \n Next, import the routes constants inside  LinkMenu.js  and change\naccordingly the  to  property of the  <LinkMenuItem>  component: \n      ... \n     import   { \n       ROUTE_USER_LIST , \n       ROUTE_PAGE_MODELS , \n     }   from   'app-init/routes' ; \n\n     const   LinkMenu   =   ( )   =>   ( \n       < > \n         < LinkMenuItem\n          id = \"menu-userList\" \n          label = { < FormattedMessage id = \"tatata.menu.userList\"  defaultMessage = \"User List\"   / > } \n          to = { ROUTE_USER_LIST } \n         / > \n         < LinkMenuItem\n          id = \"menu-pageModelList\" \n          label = { < FormattedMessage id = \"tatata.menu.pageModelList\"  defaultMessage = \"Page Model List\"   / > } \n          to = { ROUTE_PAGE_MODELS } \n         / > \n       < / > \n     ) ; \n     ... \n \n Next clicks on the links in the menu will change the routes and display\nthe content defined in the  App.js  file. \n state \n The state in src/babel.js is the combined reducer of the app, the\nrootReducer.js contains the combined reducer of the app and exports it,\nbut also contains the entire reducer of the app when running in\nstandalone mode. \n      export   const  testing  =   combineReducers ( { \n       // implement here your app specific reducers \n     } ) ; \n\n     export   default   combineReducers ( { \n       apps :   combineReducers ( {  testing  } ) , \n      api , \n      currentUser , \n      form , \n      loading , \n      locale , \n      messages , \n      modal , \n      pagination , \n     } ) ; \n \n The app specific reducers are stored inside the  apps  object, this is\ndone to avoid possible name collisions with any reducer stored inside\napp-builder when running the app in integrated mode. \n Customizing the Reducers \n Next we will be creating the two reducers for the user list and page\nmodels. They will be created inside two new directories\n src/state/apps/testing/userList/  and\n src/state/apps/testing/pageModels . The  types.js  files will contain\nthe two action types that we’ll need. \n userList/types.js \n // eslint-disable-next-line import/prefer-default-export\nexport const ADD_USERS = 'apps/testing/add-users';\n \n pageModels/types.js \n // eslint-disable-next-line import/prefer-default-export\nexport const ADD_PAGE_MODELS = 'apps/testing/page-models/add-page-models';\n \n The value of both constants contain the whole namespace\n apps/testing/REDUCER  this is done to avoid any possible name collision\nwhen running the app in integrated mode. \n Next create both actions files: \n userList/actions.js \n      import   { \n       ADD_USERS , \n     }   from   'state/apps/testing/userList/types' ; \n\n     // eslint-disable-next-line import/prefer-default-export \n     export   const   addUsers   =   users   =>   ( { \n       type :   ADD_USERS , \n       payload :  users , \n     } ) ; \n \n pageModels/actions.js \n      import   { \n       ADD_PAGE_MODELS , \n     }   from   'state/apps/testing/pageModels/types' ; \n\n     // eslint-disable-next-line import/prefer-default-export \n     export   const   addPageModels   =   pageModels   =>   ( { \n       type :   ADD_PAGE_MODELS , \n       payload :  pageModels , \n     } ) ; \n \n then the selectors: \n userList/selectors.js \n      import   {  createSelector  }   from   'reselect' ; \n\n     export   const   getUserList   =   state   =>  state . apps . testing . userList ; \n     export   const  getList  =   createSelector ( getUserList ,   userList   =>  userList . list ) ; \n \n pageModels/selectors.js \n      import   {  createSelector  }   from   'reselect' ; \n\n     export   const   getPageModels   =   state   =>  state . apps . testing . pageModels ; \n     export   const  getList  =   createSelector ( getPageModels ,   pageModels   =>  pageModels . list ) ; \n \n And finally the reducers. The default state is going to contain some\nsample data for us to display. \n userList/reducer.js \n      import   {   ADD_USERS   }   from   'state/apps/testing/userList/types' ; \n\n     const  defaultState  =   { \n       list :   [ \n         { \n           username :   'admin' , \n           registration :   '2018-01-08 00:00:00' , \n           lastLogin :   '2018-01-08 00:00:00' , \n           lastPasswordChange :   '2018-01-08 00:00:00' , \n           status :   'active' , \n           passwordChangeRequired :   true , \n           profileAttributes :   { \n             fullName :   'admin' , \n             email :   'admin@entando.com' , \n           } , \n         } , \n         { \n           username :   'user1' , \n           registration :   '2018-01-08 00:00:00' , \n           lastLogin :   '2018-01-08 00:00:00' , \n           lastPasswordChange :   '2018-01-08 00:00:00' , \n           status :   'disabled' , \n           passwordChangeRequired :   true , \n           profileAttributes :   { \n             fullName :   'User Name' , \n             email :   'user1@entando.com' , \n           } , \n         } , \n       ] , \n     } ; \n\n     const   reducer   =   ( state  =  defaultState ,  action  =   { } )   =>   { \n       switch   ( action . type )   { \n         case   ADD_USERS :   { \n           return   {   ... state ,   list :  action . payload  } ; \n         } \n\n         default :   return  state ; \n       } \n     } ; \n\n     export   default  reducer ; \n \n pageModels/reducer.js \n      import   {   ADD_PAGE_MODELS   }   from   'state/apps/testing/pageModels/types' ; \n\n     const  defaultState  =   { \n       list :   [ \n         { \n           code :   'home' , \n           descr :   'Home Page' , \n           configuration :   { \n             frames :   [ \n               { \n                 pos :   0 , \n                 descr :   'Navbar' , \n                 sketch :   { \n                   x1 :   0 , \n                   y1 :   0 , \n                   x2 :   2 , \n                   y2 :   0 , \n                 } , \n               } , \n               { \n                 pos :   1 , \n                 descr :   'Navbar 2' , \n                 sketch :   { \n                   x1 :   3 , \n                   y1 :   0 , \n                   x2 :   5 , \n                   y2 :   0 , \n                 } , \n               } , \n             ] , \n           } , \n           template :   '<html></html>' , \n         } , \n         { \n           code :   'service' , \n           descr :   'Service Page' , \n           configuration :   { \n             frames :   [ \n               { \n                 pos :   0 , \n                 descr :   'Navbar' , \n                 sketch :   { \n                   x1 :   0 , \n                   y1 :   0 , \n                   x2 :   2 , \n                   y2 :   0 , \n                 } , \n               } , \n               { \n                 pos :   1 , \n                 descr :   'Navbar 2' , \n                 sketch :   { \n                   x1 :   3 , \n                   y1 :   0 , \n                   x2 :   5 , \n                   y2 :   0 , \n                 } , \n               } , \n             ] , \n           } , \n           template :   '<html></html>' , \n         } , \n       ] , \n     } ; \n\n     const   reducer   =   ( state  =  defaultState ,  action  =   { } )   =>   { \n       switch   ( action . type )   { \n         case   ADD_PAGE_MODELS :   { \n           return   {   ... state ,   list :  action . payload  } ; \n         } \n\n         default :   return  state ; \n       } \n     } ; \n\n     export   default  reducer ; \n \n Last, we can add the two reducers just created to the\n src/state/rootReducer.js \n      ... \n     import  userList  from   'state/apps/testing/userList/reducer' ; \n     import  pageModels  from   'state/apps/testing/pageModels/reducer' ; \n\n     export   const  testing  =   combineReducers ( { \n      pageModels , \n      userList , \n     } ) ; \n     ... \n \n we will now be able to see with the  reduxDevTools  in our browser. To\nview this state in your reduxDevTools go to: \n State -→ apps -→ testing -→ pageModels  and\n State -→ apps -→ testing -→ userList \n Creating the UI Components \n At this point, both routes created should be rendering a simple string.\nWe will next create the actual component that will be rendered inside\nthe page. \n userList \n Inside  src/ui/userList/  create the  List  component. Create the\n userList  directory and  List.js  file in that directory. \n      import  React  from   'react' ; \n\n     import   { \n      Grid , \n      TablePfProvider , \n     }   from   'patternfly-react' ; \n\n     const   List   =   ( )   =>   { \n       const  data  =   [ \n         { \n           username :   'admin' , \n           registration :   '2018-01-08 00:00:00' , \n         } , \n         { \n           username :   'user1' , \n           registration :   '2018-01-08 00:00:00' , \n         } , \n       ] ; \n\n       const  tr  =  data . map ( row   =>   ( \n         < tr > \n           < td > { row . username } < / td > \n           < td > { row . registration } < / td > \n         < / tr > \n       ) ) ; \n\n       return   ( \n         < Grid fluid > \n           < TablePfProvider\n            striped\n            bordered\n            hover\n           > \n             < thead > \n               < tr > \n                 < td > username < / td > \n                 < td > registration < / td > \n               < / tr > \n             < / thead > \n             < tbody > \n               { tr } \n             < / tbody > \n           < / TablePfProvider > \n         < / Grid > \n       ) ; \n     } ; \n\n     export   default  List ; \n \n Next, change the route inside  src/ui/App.js . Add the import below and\nupdate the component to reference the List component created in the\nprior step. \n      ... \n     import  List  from   'ui/userList/List' ; \n     ... \n       { \n         path :   ROUTE_USER_LIST , \n         component :  List , \n       } , \n     ... \n \n The table will now display correctly when clicking on the menu item. \n connecting to the store \n Next let’s connect the component to the store to get the data from the\nreducer. \n The first step is creating the  ListContainer.js  next to the  List \ncomponent file. \n      import   {  connect  }   from   'react-redux' ; \n     import   {  getList  }   from   'state/apps/testing/userList/selectors' ; \n\n     import  List  from   'ui/userList/List' ; \n\n     export   const   mapStateToProps   =   state   =>   ( { \n       data :   getList ( state ) , \n     } ) ; \n\n     export   default   connect ( \n      mapStateToProps , \n       null , \n     ) ( List ) ; \n \n And then update the List component to receive the property. The List\nfile should now look like this: \n      import  React  from   'react' ; \n     import  PropTypes  from   'prop-types' ; \n\n     import   { \n      Grid , \n      TablePfProvider , \n     }   from   'patternfly-react' ; \n\n     const   List   =   ( {  data  } )   =>   { \n       const  tr  =  data . map ( row   =>   ( \n         < tr > \n           < td > { row . username } < / td > \n           < td > { row . registration } < / td > \n         < / tr > \n       ) ) ; \n\n       return   ( \n         < Grid fluid > \n           < TablePfProvider\n            striped\n            bordered\n            hover\n           > \n             < thead > \n             < tr > \n               < td > username < / td > \n               < td > registration < / td > \n             < / tr > \n             < / thead > \n             < tbody > \n             { tr } \n             < / tbody > \n           < / TablePfProvider > \n         < / Grid > \n       ) ; \n     } ; \n\n     export   default  List ; \n \n Make sure that you remove the predefined  data  const since the data\nwill now be coming from the reducer, on top of defining PropTypes rules\nfor validating and giving a default for the injected property  data . \n Once complete, update the component used in the route inside  App.js .\nUpdate the import to the container and update the component in\n ROUTE_USER_LIST  to the new ListContainer. \n      ... \n     import  ListContainer  from   'ui/userList/ListContainer' ; \n     ... \n       { \n         path :   ROUTE_USER_LIST , \n         component :  ListContainer , \n       } , \n     ... \n \n Go back to your app. We will now see the data inside the table\nreflecting the content of the storage. \n Page Models \n inside  src/ui/pageModels/  we are going to create the  List  component \n      import  React  from   'react' ; \n     import  PropTypes  from   'prop-types' ; \n\n     import   { \n      Grid , \n      TablePfProvider , \n     }   from   'patternfly-react' ; \n\n     const   List   =   ( {  data  } )   =>   { \n       const  tr  =  data . map ( row   =>   ( \n         < tr > \n           < td > { row . username } < / td > \n           < td > { row . registration } < / td > \n         < / tr > \n       ) ) ; \n\n       return   ( \n         < Grid fluid > \n           < TablePfProvider\n            striped\n            bordered\n            hover\n           > \n             < thead > \n             < tr > \n               < td > username < / td > \n               < td > registration < / td > \n             < / tr > \n             < / thead > \n             < tbody > \n             { tr } \n             < / tbody > \n           < / TablePfProvider > \n         < / Grid > \n       ) ; \n     } ; \n\n    List . propTypes  =   { \n       data :  PropTypes . arrayOf ( PropTypes . shape ( { } ) ) , \n     } ; \n\n    List . defaultProps  =   { \n       data :   [ ] , \n     } ; \n\n     export   default  List ; \n \n Next change the route inside  src/ui/App.js \n      ... \n     import  ListPageModels  from   'ui/pageModels/List' ; \n     ... \n       { \n         path :   ROUTE_PAGE_MODELS , \n         component :  ListPageModels , \n       } , \n     ... \n \n The table will now be displayed correctly when clicking on the menu\nitem. \n Connecting to the Store \n Next, connect the component to the store to get the data from the\nreducer. \n The very first thing we’ll do is create the  ListContainer.js  next to\nthe  List  component file. \n      import   {  connect  }   from   'react-redux' ; \n     import   {  getList  }   from   'state/apps/testing/pageModels/selectors' ; \n\n     import  List  from   'ui/pageModels/List' ; \n\n     export   const   mapStateToProps   =   state   =>   ( { \n       data :   getList ( state ) , \n     } ) ; \n\n     export   default   connect ( \n      mapStateToProps , \n       null , \n     ) ( List ) ; \n \n And then update the List component to receive the property. The whole\nList component will have this content: \n      import  React  from   'react' ; \n     import  PropTypes  from   'prop-types' ; \n\n     import   { \n      Grid , \n      TablePfProvider , \n     }   from   'patternfly-react' ; \n\n     const   List   =   ( {  data  } )   =>   { \n       const  tr  =  data . map ( row   =>   ( \n         < tr > \n           < td > { row . code } < / td > \n           < td > { row . descr } < / td > \n         < / tr > \n       ) ) ; \n\n\n       return   ( \n         < Grid fluid > \n           < TablePfProvider\n            striped\n            bordered\n            hover\n           > \n             < thead > \n             < tr > \n               < td > code < / td > \n               < td > descr < / td > \n             < / tr > \n             < / thead > \n             < tbody > \n             { tr } \n             < / tbody > \n           < / TablePfProvider > \n         < / Grid > \n       ) ; \n     } ; \n\n    List . propTypes  =   { \n       data :  PropTypes . arrayOf ( PropTypes . shape ( { } ) ) , \n     } ; \n\n    List . defaultProps  =   { \n       data :   [ ] , \n     } ; \n     export   default  List ; \n \n Next make sure that you remove the predefined  data  const since the\ndata will be coming from the reducer, on top of defining PropTypes rules\nfor validating and giving a default for the injected property  data . \n Once complete, update the component used in the route inside  App.js \n      ... \n     import  PageModelsListContainer  from   'ui/pageModels/ListContainer' ; \n     ... \n       { \n         path :   ROUTE_PAGE_MODELS , \n         component :  PageModelsListContainer , \n       } , \n     ... \n \n You will now see the data inside the table reflecting the content of the\nstorage. \n Connecting the app to an Entando core instance \n By default the app is using mocks and not connecting to any Entando core\ninstance. \n Because the app is making use of  @entando/apimanager  we can easily\nchange this by setting up two  .env  variables inside the  .env  file in\nthe project root: \n     REACT_APP_DOMAIN=http://localhost:8080/entando-app\n    REACT_APP_USE_MOCKS=false\n \n The  REACT_APP_DOMAIN  must pointing towards the domain and container\nwhere the Entando instance is running and  must not  contain trailing\nslashes. \n Once this is done to make the change happen we will have to stop the app\nusing  ctrl + c  and re run it with  npm start . \n Now the toast stating  This application is using mocks  won’t be popping\nup anymore. \n You can make sure that the configuration is correct by looking at the\nnetwork section in the browser dev tools. By default the app\nautomatically makes an admin login against a plain Entando instance to\nauthenticate the user and to be able to consume any protected api. \n This is not an ideal scenario and it is meant to be used only for\ndebugging purposes for many reasons: \n \n \n the username and password should never be hardcoded in your app \n \n \n if authentication is required the user should be the one performing\nthe login action \n \n \n the plain default passwords in use won’t be useful against a proper\nproduction instance of Entando \n Adding the API Calls \n We are now going to add api calls for both users and page models to\nretrieve the data live instead of relying on our store’s default state. \n Inside  src/api  create the  users.js  file: \n      import   {  makeRequest ,   METHODS   }   from   '@entando/apimanager' ; \n\n     // eslint-disable-next-line import/prefer-default-export \n     export   const  getUsers  =   ( page  =   {   page :   1 ,   pageSize :   10   } ,  params  =   '' )   =>   ( \n       makeRequest ( \n         { \n           uri :   ` /api/users ${ params } ` , \n           method :   METHODS . GET , \n           mockResponse :   { } , \n           useAuthentication :   true , \n         } , \n        page , \n       ) \n     ) ; \n \n and then create the  pageModels.js  file: \n      import   {  makeRequest ,   METHODS   }   from   '@entando/apimanager' ; \n\n     // eslint-disable-next-line import/prefer-default-export \n     export   const  getPageModels  =   ( page  =   {   page :   1 ,   pageSize :   10   } ,  params  =   '' )   =>   makeRequest ( { \n       uri :   ` /api/pageModels ${ params } ` , \n       method :   METHODS . GET , \n       mockResponse :   { } , \n       useAuthentication :   true , \n     } ,  page ) ; \n Creating the Thunk \n In order to use the api call we next create a thunk action, which is a\nredux action with side effects, like an API call. \n inside the  src/state/apps/testing/userList/actions.js  file we are\ngoing to add the new action: \n      ... \n     import   {  addErrors  }   from   '@entando/messages' ; \n     import   { \n      getUsers , \n     }   from   'api/users' ; \n     ... \n\n     // thunks \n\n     export   const  fetchUsers  =   ( page  =   {   page :   1 ,   pageSize :   10   } ,  params  =   '' )   =>   dispatch   =>   ( \n       new   Promise ( ( resolve )   =>   { \n         getUsers ( page ,  params ) . then ( ( response )   =>   { \n          response . json ( ) . then ( ( json )   =>   { \n             if   ( response . ok )   { \n               dispatch ( addUsers ( json . payload ) ) ; \n             }   else   { \n               dispatch ( addErrors ( json . errors . map ( err   =>  err . message ) ) ) ; \n             } \n             resolve ( ) ; \n           } ) ; \n         } ) . catch ( ( )   =>   { } ) ; \n       } ) \n     ) ; \n \n Next do the same inside  src/state/apps/testing/pageModels/actions.js : \n      ... \n     import   {  addErrors  }   from   '@entando/messages' ; \n     import   { \n      getPageModels , \n     }   from   'api/pageModels' ; \n     ... \n\n     // thunks \n\n     export   const  fetchPageModels  =   ( page  =   {   page :   1 ,   pageSize :   10   } ,  params  =   '' )   =>   dispatch   =>   ( \n       new   Promise ( ( resolve )   =>   { \n         getPageModels ( page ,  params ) . then ( ( response )   =>   { \n          response . json ( ) . then ( ( data )   =>   { \n             if   ( response . ok )   { \n               dispatch ( addPageModels ( data . payload ) ) ; \n               resolve ( ) ; \n             }   else   { \n               dispatch ( addErrors ( data . errors . map ( err   =>  err . message ) ) ) ; \n               resolve ( ) ; \n             } \n           } ) ; \n         } ) . catch ( ( )   =>   { } ) ; \n       } ) \n     ) ; \n \n Now with two exports, it is safe to remove the\n eslint-disable-next-line  comment on line 5 of both files. \n changing the mapDispatchToProps in the containers \n Next, in order to pass the newly created thunk to both List components,\nwe’ll update the containers accordingly, as: \n src/ui/userList/ListContainer.js \n      ... \n     import   {  fetchUsers  }   from   'state/apps/testing/userList/actions' ; \n     ... \n     export   const   mapDispatchToProps   =   dispatch   =>   ( { \n       fetch :   ( )   =>   dispatch ( fetchUsers ( ) ) , \n     } ) ; \n\n     export   default   connect ( \n      mapStateToProps , \n      mapDispatchToProps , \n     ) ( List ) ; \n \n src/ui/pageModels/ListContainer.js \n      ... \n     import   {  fetchPageModels  }   from   'state/apps/testing/pageModels/actions' ; \n     ... \n     export   const   mapDispatchToProps   =   dispatch   =>   ( { \n       fetch :   ( )   =>   dispatch ( fetchPageModels ( ) ) , \n     } ) ; \n\n     export   default   connect ( \n      mapStateToProps , \n      mapDispatchToProps , \n     ) ( List ) ; \n Updating the List components \n Both List components were simple components with only a  render  method,\ntherefore could be declared as simple constants. \n Next we will fetch data during the  componentDidMount  life cycle event\nwhich will require we turn the constant into a class on top of changing\nthe PropTypes to add the new fetch method passed down to the component. \n src/ui/userList/List.js \n      import  React ,   {  Component  }   from   'react' ; \n     ... \n     class   List   extends   Component   { \n       componentDidMount ( )   { \n         const   {  fetch  }   =   this . props ; \n         fetch ( ) ; \n       } \n\n       render ( )   { \n         const   {  data  }   =   this . props ; \n         const  tr  =  data . map ( row   =>   ( \n           < tr > \n             < td > { row . username } < / td > \n             < td > { row . registration } < / td > \n           < / tr > \n         ) ) ; \n\n         return   ( \n           < Grid fluid > \n             < TablePfProvider\n              striped\n              bordered\n              hover\n             > \n               < thead > \n                 < tr > \n                   < td > username < / td > \n                   < td > registration < / td > \n                 < / tr > \n               < / thead > \n               < tbody > \n                 { tr } \n               < / tbody > \n             < / TablePfProvider > \n           < / Grid > \n         ) ; \n       } \n     } \n\n    List . propTypes  =   { \n       data :  PropTypes . arrayOf ( PropTypes . shape ( { } ) ) , \n       fetch :  PropTypes . func , \n     } ; \n\n    List . defaultProps  =   { \n       data :   [ ] , \n       fetch :   ( )   =>   { } , \n     } ; \n \n src/ui/pageModels/List.js \n      import  React ,   {  Component  }   from   'react' ; \n     ... \n     class   List   extends   Component   { \n       componentDidMount ( )   { \n         const   {  fetch  }   =   this . props ; \n         fetch ( ) ; \n       } \n\n       render ( )   { \n         const   {  data  }   =   this . props ; \n         const  tr  =  data . map ( row   =>   ( \n           < tr > \n             < td > { row . code } < / td > \n             < td > { row . descr } < / td > \n           < / tr > \n         ) ) ; \n\n         return   ( \n           < Grid fluid > \n             < TablePfProvider\n              striped\n              bordered\n              hover\n             > \n               < thead > \n                 < tr > \n                   < td > code < / td > \n                   < td > descr < / td > \n                 < / tr > \n               < / thead > \n               < tbody > \n                 { tr } \n               < / tbody > \n             < / TablePfProvider > \n           < / Grid > \n         ) ; \n       } \n     } \n\n    List . propTypes  =   { \n       data :  PropTypes . arrayOf ( PropTypes . shape ( { } ) ) , \n       fetch :  PropTypes . func , \n     } ; \n\n    List . defaultProps  =   { \n       data :   [ ] , \n       fetch :   ( )   =>   { } , \n     } ; \n clear the default value of the reducer \n Now we should be fetching data from the server, therefore we can safely\nmake the list key in the  defaultState  object an empty array: \n src/state/apps/testing/userList/reducer.js \n      ... \n     const  defaultState  =   { \n       list :   [ ] , \n     } ; \n     ... \n \n src/state/apps/testing/pageModels/reducer.js \n      ... \n     const  defaultState  =   { \n       list :   [ ] , \n     } ; \n     ... \n adding additional dependencies \n It may be necessary to set additional dependencies for your project. If\nthe need arises, it is important to remember a few rules: \n Only actual dependencies that are not already included in  app-builder \ncan be added as pure dependencies. Every other dependency must either be\na  devDependency  or  peerDependency . \n If you are not careful you may end up with duplicated dependencies that\n will  result in errors manifesting themselves when running the app\ninside App Builder. \n running the app in integrated mode within App Builder \n After running  npm install  in the App Builder, the user can run the\n npm run app-install <appId>  command to install the app. \n This command will trigger a download of the app from npm and the\ninstallation of its component within App Builder. After the installation\nprocess is complete, it will be possible to either  npm start  or\n npm build  App Builder. \n To install a dev app, like the one developed in this tutorial which have\nnot been previously published on npm, you will need to use additional\nflags and will have to run a few additional commands. \n Before running the Install command  make sure that you have\nuninstalled all existing peer and dev dependencies to avoid collision\nwith app builder. To do so, from the app builder app directory\n( testing , in this tutorial) just run in the correct order the\nfollowing commands: \n npm run babel \n npm i --only=production \n The first will create the dist directory that will be needed by App\nBuilder while the second one will uninstall anything but production\ndependencies. \n Next, from the App Builder directory, run the install command with these\nadditional flags: \n \n \n -d  specify the relative path where the app is installed. When\nusing this flag the appId should be the normalized app name, without\nthe  @entando/  prefix. \n \n \n -p  specify the package name if it is different from the appId \n \n \n to use flags you will have to use the double dash in the command: \n npm run app-install —  cms -d ../testing -p @entando/testing \n the value in the  -p  flag should always match the actual name of the\napp that is going to be installed inside App Builder . You can check\nyour app name inside the  package.json  file of your app. \n If you experience problems after running the build command delete the\n node_modules  directory before running the second command. \n"},{title:"Tutorial: Invoking Entando Core APIs",frontmatter:{},regularPath:"/v6.3/tutorials/customize-the-platform/invoking-api.html",relativePath:"v6.3/tutorials/customize-the-platform/invoking-api.md",key:"v-04fefc4a",path:"/v6.3/tutorials/customize-the-platform/invoking-api.html",headers:[{level:2,title:"General Overview",slug:"general-overview"},{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Set up a Postman environment",slug:"_1-set-up-a-postman-environment"},{level:3,title:"2. Get an access token",slug:"_2-get-an-access-token"},{level:3,title:"2. Prepare a generic API request",slug:"_2-prepare-a-generic-api-request"},{level:2,title:"QE ready APIs",slug:"qe-ready-apis"},{level:2,title:"Notes on QE requests collections structure",slug:"notes-on-qe-requests-collections-structure"},{level:2,title:"Conclusion",slug:"conclusion"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:' Tutorial: Invoking Entando Core APIs \n General Overview \n Entando supports Swagger and it is accessible, if activated, from its\nweb interface from the base application URL at /api/swagger-ui.html. A\ncomplete list of all available core APIs can be obtained from Swagger. \n Core APIs can be invoked directly from Swagger or from any other\nsuitable tool, i.e., curl or Postman are two common ones. Postman has\nbeen extensively used in API testing and automated API testing because\nof the possibilities it offers and it is the suggested tool. \n All Entando core APIs are accessible from the base URL, for example:\nlocalhost:8080/entando-de-app/api. For example, the Page Controller will\nbe available under /pages from the Base URL (i.e.\nlocalhost:8080/entando-de-app/api/pages), or the Page Template Controller\nwill available under /pageModels (i.e.\nlocalhost:8080/entando-de-app/api/pageModels) and so on. \n Before being able to perform any API request, we will first need to\nobtain an  authorization token , that is achieved with a specific POST\nrequest sent to the oauth/token endpoint, after successful\nauthentication, an access token is returned which grants access to all\nAPI endpoints and actions for which the authenticated user has defined\nprivileges. \n (Refer to User Management Roles for details) \n The best way to proceed in case of extensive testing with APIs with\nPostman, is to set up an environment and define a variable that will\nkeep the access token saved from the POST request to /oauth/token. \n Purpose \n Set up an environment ready to invoke Entando core APIs \n Requirements \n To complete this tutorial you will need: \n \n \n Postman \n \n \n A running Entando 6 instance \n Steps \n 1. Set up a Postman environment \n Create a new Postman environment and define the following variables: \n access_token: (no value)\nrefresh_token: (no value)\nurl: URL of your application (i.e. http://localhost:8080/entando-de-app)\n \n Be careful with the URL variable and make sure you do not have a\ntrailing slash. \n Set Postman to use this environment. \n 2. Get an access token \n Getting an access token is a prerequisite to be able to invoke any API.\nThe following is the required activity. \n \n \n create a Postman collection, name it for example "Access Token" \n \n \n create a new POST request with the following parameters: \n \n \n \n URL field\n{{url}}/api/oauth/token\n \n Note that we are calling the "url" environmental variable for\nconvenience. \n Autorization section\n   Type: Basic Auth\n   Username: (a valid Entando consumer must be defined in Entando) (Refer to appropriate documentation on how to do that) (i.e. appbuilder)\n   Password: (password of the defined consumer) (i.e. appbuilder_secret)\n\nHeaders section\n    Content-Type: application/x-www-form-urlencoded\n\nBody section\nSelect from the radio button the option: x-www-form-urlencoded\n    username: (valid Entando user (i.e. admin))\n    password: (password of the valid user)\n    grant_type: password\n \n The tests section is convenient as we can then set any new API request\nin such a way to make use of that access token. The first line of code\ndefines a variable called "data", which hosts the JSON parsed\nresponseBody from the POST request just sent to /oauth/token; The second\nline sets the environment variable "access_token" to the value returned\nby the POST request. \n Tests section\n    var data = JSON.parse(responseBody);\n    postman.setEnvironmentVariable("access_token", data.access_token);\n \n Launch the POST request to test it, and if successful, you should get a\nresponse like this: \n {\n    "access_token": "b96096493a40b1a7364bd54a6ffb609b",\n    "token_type": "bearer",\n    "refresh_token": "79ff84062b5dc13663961a833b0788f9",\n    "expires_in": 3599\n}\n \n also if you open in edit the Postman environment, you should see that\nthe access_token and the refresh_token variables values have been\nupdated. \n 2. Prepare a generic API request \n Create a new request with the following parameters: \n Authorization section: Inherit auth from parent\n\nHeaders section:\n create the key Authorization with Value: Bearer{{access_token}}\n create the key Content-Type with Value: application/json\n \n Select the appropriate method (GET, DELETE, POST etc.) for your request\nand fill up the URL with appropriate values i.e.\n(localhost:8080/entando-de-app/api/pages) then add to the Body section,\nif needed, the appropriate payload in JSON format, remember to select\nraw and JSON (application/json). \n QE ready APIs \n QE has developed a set of collection requests to automate API testing,\nexamples of that are available on github at\n https://github.com/entando/entando-QE/tree/master/postman_API . \n To use them ,first git clone the project and use the built in Postman\nimporting features. \n Import first the Postman Environment file which can be found under the\nenvironment folder. When imported, from Postman, open in edit that\nenvironment and change the "url" variable to the appropriate value for\nyour specific installation, i.e  http://localhost:8080/entando-de-app/ \nand save it. \n Import from Postman the collections you would like to use and they will\nbecome available in the Postman collections Panel ready to be run. \n Notes on QE requests collections structure \n Each collection is so designed to test a particular use case i.e.\n"Delete an existent page", "Delete a page which has children" etc. \n By design each QE Postman collection is: \n \n \n indipendent (does not require other collections) \n \n \n general (does not make any assumption on the specific Entando\napplication) \n \n \n can be run automatically, with newman, please refer to\n https://github.com/entando/entando-QE  for details \n \n \n Following those requirements, each collection will need to "prepare" the\nenvironment for the actual test. That is achieved by using specific\nrequests, called "helpers", and their only purpose is to create/delete\nall the needed objects. \n Another class of helpers is used to check the persistence of the actions\nperformed by the APIs, i.e. check that after a DELETE, something really\nhas been deleted. \n The request that implements the use case, we can call it main request,\ndoes not contain the word "HELPER" in its name, and it is the only one\ninside a given collection. \n Because collections are designed primarily to run automatically, we have\ndone extensive use of collection variables, so variables like the API\nURL, object names, object codes or payloads are usually defined as a\ncollection variable and can be accessed by all requests inside the\ncollection. \n Conclusion \n This guide let you start invoking Entando 6 APIs \n'},{title:"Business Objective",frontmatter:{},regularPath:"/v6.3/tutorials/customize-the-platform/pda-tutorial.html",relativePath:"v6.3/tutorials/customize-the-platform/pda-tutorial.md",key:"v-d9a24a5c",path:"/v6.3/tutorials/customize-the-platform/pda-tutorial.html",headers:[{level:2,title:"Micro Frontend",slug:"micro-frontend"},{level:2,title:"Process Automation Manager (PAM)",slug:"process-automation-manager-pam"},{level:2,title:"Business Process Modeling Notation (bpmn)",slug:"business-process-modeling-notation-bpmn"},{level:2,title:"Decision Model and Notation (dmn)",slug:"decision-model-and-notation-dmn"},{level:2,title:"Back End for Front End (BFF)",slug:"back-end-for-front-end-bff"},{level:2,title:"Task List",slug:"task-list"},{level:3,title:"PAM Implementation",slug:"pam-implementation"},{level:2,title:"Task Details",slug:"task-details"},{level:3,title:"PAM Implementation",slug:"pam-implementation-2"},{level:2,title:"Task Comments",slug:"task-comments"},{level:3,title:"PAM Implementation",slug:"pam-implementation-3"},{level:2,title:"Task Forms",slug:"task-forms"},{level:3,title:"PAM Implementation",slug:"pam-implementation-4"},{level:2,title:"Attachments",slug:"attachments"},{level:3,title:"PAM Implementation",slug:"pam-implementation-5"},{level:2,title:"New Process Form",slug:"new-process-form"},{level:2,title:"Summary Card",slug:"summary-card"},{level:3,title:"PAM Implementation",slug:"pam-implementation-6"},{level:2,title:"Totals Over Time",slug:"totals-over-time"},{level:3,title:"PAM Implementation",slug:"pam-implementation-7"},{level:2,title:"Styling",slug:"styling"},{level:2,title:"Implementing a New Engine or Integrating a New Task Source",slug:"implementing-a-new-engine-or-integrating-a-new-task-source"},{level:2,title:"Creating a new PDA MFE",slug:"creating-a-new-pda-mfe"},{level:2,title:"Communication between MFEs",slug:"communication-between-mfes"},{level:2,title:"Micro Frontend Overview",slug:"micro-frontend-overview"},{level:3,title:"Task forms",slug:"task-forms-2"},{level:2,title:"Widgets",slug:"widgets"},{level:2,title:"Building From source",slug:"building-from-source"},{level:2,title:"Code Style",slug:"code-style"},{level:2,title:"Sonar",slug:"sonar"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:' Business Objective \n The Entando Process Driven Applications plugin is built to provide a\nrich and full featured user experience to allow for the management and\ncompletion of business processes and automation. The UX is delivered a\ngeneral purpose UX layer built using micro frontends that can be\nutilized for any business process or task engine. Customers drive the UX\nlayer by utilizing a pre-developed Entando integration or by\nimplementing a set of interfaces on the server side. The backend is a\nSpring Boot microservice that provides a pluggable interface allowing\nfor the injection of any underlying process or automation toolkit. The\ninterfaces and steps for creating a new PDA backend implementation are\nprovided below. This document provides an overview of the Entando\nProcess Driven Apps (PDA) plugin. The initial section covers the\nbusiness functionality and user facing micro frontends. The second\nsection covers the architecture and the points of extension for the PDA\nplugin. The third provides a detailed technical overview for developers\nto add new functionality to a PDA implementation. \n Terminology \n Micro Frontend \n A Micro frontend architecture is an approach to developing web\napplication as a composition of small frontend apps. Instead of writing\na large monolith frontend application, the application is broken down\ninto domain specific micro frontends, which are self-contained and can\nbe developed and deployed independently. \n Process Automation Manager (PAM) \n A business process automation engine built and maintained by Red Hat \n Business Process Modeling Notation (bpmn) \n Business Process Model and Notation (BPMN) is a graphical representation\nfor specifying business processes in a business process model. \n Decision Model and Notation (dmn) \n Decision Model and Notation is a standard published by the Object\nManagement Group. It is a standard approach for describing and modeling\nrepeatable decisions within organizations to ensure that decision models\nare interchangeable across organizations. \n Back End for Front End (BFF) \n A microservice architecture allows teams to iterate quickly and to\ndevelop technology to scale rapidly. The Backend for Frontend (BFF)\narchitecture is a type of pattern built with microservices. The key\ncomponent of this pattern is an application that connects the front-end\nof your application with the backend. This BFF Code Pattern will help\nyou build that component according to IBM’s best practices. \n PDA Micro Frontends \n This section provides an overview of each of the micro frontends (MFE)\nthat are available as part of the Entando PDA plugin. In cases below\nwhere there are details specific to the PAM implementation they are\nprovided for that MFE. When extending the integration layer to other\nengines or custom implementations it will be up to the integrating team\nto define behavior and datasource for each MFE. \n Task List \n The task list MFE provides a user with a list of visible tasks that are\neither assigned to that user or that are potentially ownable by that\nuser. In the default implementation the visible tasks are limited to a\nsingle process instance. At configuration time the application designer\nis given the option to select a set of columns that will be visible in\nthe task list for that page. \n PAM Implementation \n The default PAM implementation makes the top level task fields available\nin the task list for selection. It is possible to fetch task and process\nvariables for rendering in the task list but these values are excluded\nby default due to the additional API call overhead required. \n Task Details \n The task details MFE renders detailed information about a given task.\nThe task details widget is intended to give the final user processing a\ntask the information necessary to complete the task at hand. The task\ndetails are rendered in a read only grid. See the styling section below\nfor changing and customizing the layout. \n PAM Implementation \n The PAM integration renders task variables in the task details widget. \n Task Comments \n The task comments MFE gives the user the ability to view notes attached\nto a given task and to add new notes to a task. \n PAM Implementation \n The PAM implementation reads and publishes notes to the comments\nendpoint \n Task Forms \n The task form implementation renders a form specific to a task and gives\nthe user the ability to complete that form. The form implementation is a\nwrapper around a JSON schema that describes the layout, style and\ncontent of the form. It is up to the backend implementation to transform\nto the schema and default ux layout needed to render the form. See the\ntechnical documentation below for more on the JSON schema based\nimplementation. \n PAM Implementation \n The PAM implementation of forms depends on the presence of a form\ndefinition being present on the PAM task. The Entando PAM engine\nimplementation transforms from the PAM format to the JSON schema to\nrender the form. And it transforms the API format back to the PAM format\nbased on the form definition in PAM. There are some limitations on form\ncustomization due to the format required to return data to PAM. See the\nforms section in the technical documentation for more information. \n Attachments \n The attachments MFE gives the user to view documents attached to a\ntask/case/process and to add new documents to a task/case/process. \n PAM Implementation \n The PAM implementation posts the documents to the PAM endpoints for\nstorage. Future features will include using Entando document storage for\nstoring documents and a pluggable document management interface. \n New Process Form \n The new process form renders a form that allows the final user to\nprovide the information necessary to instantiate a new business process\ninstance. The technology for generating the process form is the same as\nthe JSON schema definition used for task forms. === PAM Implementation\nThe PAM implementation depends on a form definition being attached to\nthe process definition. Entando transforms the PAM representation into a\nJSON schema form that can be rendered to the final user. \n Summary Card \n The summary card MFE provides a view into aggregate data for the process\nimplementation. The rendered information includes a total value, a trend\nvalue, and a selector for timeframe. The summary card allows the\napplication developer to select a request for rendering the requested\ninformation which maps to a call in the underlying engine to provide the\nsummarized data. \n PAM Implementation \n The PAM implementation of the summary card widget relies on the PAM\ncustom query functionality. The PAM PDA engine exposes configuration\nthat allows users/developers to define a custom query in a config file\nthat will be executed to render the summary card. This implementation\nallows the data rendered on the summary cards to be changed via\nconfiguration. In the application there is a properties file that allows\nthe implementer to provide a custom query for each of the cards. \n Totals Over Time \n The totals over time MFE provides a dual axis line/bar graph providing\ntrend information about the process environment. The MFE also provides\nthree summary values for comparison over the same time period. \n PAM Implementation \n The PAM implementation of the totals over time MFE utilizes custom\nqueries to fetch the summary data rendered in the chart. The queries\nused in the implementation are defined in configuration files in the MFE\nand can be updated to render data specific to a given implementation. \n Customizing the Process Driven Application \n Styling \n The Entando PDA MFEs are styled via a material UI theme. That theme can\nbe downloaded and updated here:\n https://github.com/entando/frontend-libraries/tree/master/packages/entando-ui \n Implementing a New Engine or Integrating a New Task Source \n Implementing a new Engine for Process Driven Applications means to\ncreate a new Java Project and implement the interfaces defined in the\npda-core-engine project. So, the new project should include the\npda-core-engine as a dependency. To see an implementation in action,\ntake a look at the pda-redhatpam-engine project, which implements the\nRed Hat PAM engine integration. After the engine is implemented, the JAR\nfile resulting from the implementation should be available in the\nclasspath for entando-process-driven-plugin, which is the project that\nis ultimately executed and exposes the Rest APIs for the frontend\napplication. One way to do that is by publishing the engine\nimplementation to a Maven repository and adding it as a dependency to\nthe entando-process-driven-plugin project. Below are the descriptions of\nthe key classes and interfaces in the pda-core-engine project that need\nto be inherited or implemented when creating a new engine\nimplementation: \n \n \n Engine: This class represents a BPM engine and exposes the services\nthat are available for that specific implementation. It is intended\nto be inherited and the subclass should provide the real\nimplementation for each service by calling the superclass\nconstructor with the service implementations as arguments. If any\nservice is not supported, a null value should be passed to the\ncorresponding constructor argument. The engine can provide\nimplementations for the the following service interfaces: \n \n \n TaskService: defines service methods for task retrieval from the\nBPM engine. \n \n \n TaskDefinitionService: defines service methods related to task\ndefinition. A task definition specifies which fields or columns\nare available for all task instances. \n \n \n TaskCommentService: defines service methods related to task\ncomment manipulation. It should be implemented if the task\ncomment is supported by the engine. \n \n \n TaskAttachmentService: defines service methods to operate on\ntask attachments. It should be implemented if the engine\nsupports file attachment on the task. \n \n \n TaskFormService: defines service methods for task form\noperations, like retrieving the form definition and submitting a\nform. The Form object can be used to render a form dynamically. \n \n \n TaskLifecycleService: defines service methods related to the\ntask lifecycle. The lifecycle operations move the task from one\nstate to another. \n \n \n TaskLifecycleBulkService: defines methods for bulk lifecycle\noperations. Like the TaskLifecycleService, methods here move the\ntask from one state to another, but this interface works with\nmultiple tasks at a time. \n \n \n ProcessService: defines service methods for process definitions\noperations. \n \n \n ProcessFormService: defines service methods for process form\noperations, like retrieving the form definition and submitting a\nform. The Form object can be used to render a form dynamically. \n \n \n GroupService: define service methods related to groups from the\nBPM engine. \n Creating a new PDA MFE \n There are no limitations on the stack that could be used to create PDA\nMFEs. Custom Elements are a great way to hide implementation details\nwhile providing a neutral interface to others. To create a simple PDA\nMFE, implement your solution using technologies you are familiar with\nand wrap it in a custom element. Build your solution with a custom\nelement and upload the built files (Settings > File Browser) in\n/public/ folder. Go to  UX Pattern > Widget  section of the admin panel\nand press “Add” to add a new widget. Enter widget code, titles, select\ngroup (for free access to everybody, select “Free Access”), and fill the\nCustom UI: \n <#assign wp=JspTaglibs["/aps-core"]>\n<script src="<@wp.resourceURL />path/from/static/bundle.js"><\/script>\n<your-custom-element parameter=”value” />\n \n <#assign wp=JspTaglibs["/aps-core"]>  - provides access to wp variable\nthat is used to get resource URL. After you add the widget, go to the\npage tree, select a page where you would like to use the widget and\nconfigure it. Drag and drop the widget into a frame and publish the\npage. \n Communication between MFEs \n Communication between MFEs can be achieved using Custom Events. Each\nwidget can define events that it will emit and register to events that\nare important to it. \n const createWidgetEvent = eventType => {\n  return payload => {\n    const widgetEvent = new CustomEvent(eventType, { payload });\n    window.dispatchEvent(widgetEvent);\n  };\n};\n\n\nconst subscribeToWidgetEvent = (eventType, eventHandler) => {\n  window.addEventListener(eventType, eventHandler);\n  return () => {\n    window.removeEventListener(eventType, eventHandler);\n  };\n};\n \n Custom element then creates the events it emits and registers to the\nevents that it wants to react to \n constructor(props) {\n  super(props);\n\n  // other code\n\n  this.onClickSubmit = createWidgetEvent(‘myWidget.onSubmit’);\n}\n\nconnectedCallback() {\n\n  // other code\n\n  this.unsubscribeFromWidgetEvents = subscribeToWidgetEvent(\n    ‘otherWidget.onClickClear’,\n    () => {\n      // callback function when otherWidget fires the onClickClear custom event\n    }\n  }\n}\n Technical Documentation \n Micro Frontend Overview \n Task forms \n Widgets containing form (e.g., task completion form widget) use JSON\nschema to dynamically create forms. Widget implementation uses\nreact-jsonshema-form library that converts forms’ JSON schemas into\nReact components. Our initial implementation uses Material UI components\nvia Material UI theme library rjsf-material-ui as baseline and has\nEntando specific templates, widgets and fields (which are\nreact-jsonshema-form terms for parts of forms). In this section you will\nlearn about basic setup of the form, but if you would like to learn\nmore, please refer to react-jsonshema-form documentation. Themed JSON\nform is created using the withTheme() method from the\nreact-jsonschema-form package \n import { withTheme } from \'react-jsonschema-form\';\nimport { Theme as MuiRJSForm } from \'rjsf-material-ui\';\n\nconst JSONForm = props => {\n\n  const ThemedForm = withTheme(MuiRJSForm);\n\n  // ...\n\n  return (\n    <ThemedForm\n    schema={formSchema}\n    uiSchema={uiSchema}\n    {...customTemplates}\n    widgets={customWidgets}\n    formData={formData}\n    onSubmit={e => onSubmitForm(e)}\n    >\n  );\n};\n\nexport default JSONForm;\n \n For JSON Form to work, the form schema is mandatory. It’s a JSON\ndefinition of the form’s structure. Users can also provide form data via\nformData variable, which should follow the structure of JSON schema; and\nUI schema using uiSchema variable, which allows users to customise the\nform’s UI (components, rules, types, etc.) To test JSON schema, UI\nschema and form data, you can use react-jsonschema-form sandbox\nenvironment. Custom Entando templates, widgets, and fields provide a\npossibility to customise the layout of the form using Grid components.\nTo specify what area a field or subform should fill, users can provide\nsize parameter in UI schema’s ui:options object. Size refers to Material\nUI’s grid column widths (Material UI documentation) where the area the\nfrom can take up is divided into 12 columns and value 12 (a default\nvalue if size is not provided) means the field or subform should take up\nall 12 columns. That means that size should be a value from 1 to 12. If\ntwo fields that are next to each other have size values 8 and 4\nrespectively - they will fit into one row, first field being 2 times\nwider than the second field. User can also provide innerSize parameter\nto size the input inside the field. This helps with formatting - if user\nwants a two column layout and have smaller input fields inside these\ncolumns. Multicolumn layout can also be achieved using\ngenerateColumnedOFT(columnSize) functionality, basically providing the\ndefault columnSize to the created form. generateColumnedOFT returns an\nObjectFieldTemplate that is used as a template for all object fields\n(fields that contain properties inside of them). To help us understand\nthe mapping between JSON schema and UI schema lets define an example\nschema: \n {\n  "$schema": "http://json-schema.org/draft-07/schema#",\n  "$id": "http://entando.org/schemas/pda-form.json",\n  "title": "Mortgage Application Form",\n  "type": "object",\n  "properties": {\n    "Application": {\n      "title": "Application",\n    "type": "object",\n    "required": [],\n    "properties": {\n        "mortgageamount": {\n          "type": "integer",\n          "title": "Mortgage amount",\n          "description": "Mortgage amount"\n        },\n        "downpayment": {\n          "type": "integer",\n          "title": "Down Payment",\n          "description": "Down Payment"\n        },\n        "applicant": {\n          "title": "Applicant",\n          "type": "object",\n          "required": [],\n          "properties": {\n            "name": {\n              "type": "string",\n              "title": "Name",\n              "description": "Name",\n              "maxLength": 100\n            },\n            "annualincome": {\n              "type": "integer",\n              "title": "Annual Income",\n              "description": "Annual Income"\n            }\n          }\n        },\n        "property": {\n          "title": "Property",\n          "type": "object",\n          "required": [],\n          "properties": {\n            "age": {\n              "type": "integer",\n              "title": "Age of property",\n              "description": "Age of property"\n            },\n            "address": {\n              "type": "string",\n              "title": "Address of property",\n              "description": "Address of property",\n              "maxLength": 100\n               }\n          }\n        }\n      }\n    },\n    "inlimit": {\n      "type": "boolean",\n    "title": "Is mortgage application in limit?"\n    }\n  }\n}\n \n From this JSON (you can copy & paste it into the react-jsonschema-form\nsandbox) we can see that there is a main form with a title “Mortgage\nApplication Form”. Root “Mortgage Application Form” form has two\nproperties - one is a subform  Application  and the second one is just a\ncheckbox field (field ID is inlimit). Application subform contains 2\nfields: Mortgage amount (field ID is mortgageamount) and Down Payment\n(field ID is downpayment); and two subforms - Applicant (field ID is\napplicant) and Property (field ID is property). Applicant subform\ncontains 2 fields - Name (field ID is name) and Annual Income (field ID\nis annualincome). Property subform contains 2 fields - Age of property\n(field ID is age) and Address of property (field ID is address) By\ndefault (without providing UI schema) they are all listed one field per\nrow. To use Entando’s implementation of Grid layout, users have to\nprovide UI schema with details about each field. For example, if we\nwould like to have a layout that looks like this (fields are marked\n [ field name ] ): \n +----------------------------------------------------------------------------+\n| Mortgage Application Form                                                  |\n+----------------------------------------------------------------------------+\n| Application                                                                |\n+----------------------------------+-----------------------------------------+\n| [Mortgage amount]                | [Down Payment]                          |\n+----------------------------------+-----------------+-----------------------+\n| Applicant                                          | Property              |\n+----------------------------------+-----------------+-----------------------+\n| [Name]                           | [Annual Income] | [Age of property]     |\n+----------------------------------+-----------------+-----------------------+\n|                                                    | [Address of property] |\n+----------------------------------------------------+-----------------------+\n \n To set up the UI schema you have to define each field you want to\ncustomise by addressing using the field IDs - to add options to\nApplicant’s Name field, you will have to create an object tree going\nfrom root object through Application —> Applicant —> Name (using IDs\nit’s Application.applicant.name). UI schema for the table layout defined\nabove would look like this: \n {\n  Application: {\n    \'ui:options\': {\n      size: 12, // <-- this value is not mandatory as size is 12 columns-wide by default\n    },\n    mortgageamount: {\n      \'ui:disabled\': true, // <-- user can define fields disabled at UI schema level\n      \'ui:options\': {\n        size: 6, // <-- Mortgage amount field should take up half of the row\n      },\n    },\n    downpayment: {\n      \'ui:options\': {\n        size: 4, // <-- Down payment field should take up the other half of the row\n      },\n    },\n    applicant: {\n      \'ui:options\': {\n        size: 8, // <-- Applicant subform should take up 8 out of 12 columns\n      },\n      name: {\n        \'ui:options\': {\n          size: 8, // <-- Applicant name field should take up 8 columns in the 8 columns that Applicant subform occupies\n        },\n      },\n      annualincome: {\n        \'ui:options\': {\n          size: 4, // <-- Annual Income field taking up the remaining 4 columns\n        },\n      },\n    },\n    property: {\n      \'ui:options\': {\n        size: 4, // <-- Property subform should take up the remaining 4 out of 12 columns\n      },\n      // note that property\'s fields are not mentioned - defaulting them to 12 columns in are that is available to them\n    },\n  },\n};\n\nAs Material UI components are used for field templates, there might be a need to pass some Material UI options into the field. You can do that by adding muiProps object to the ui:options.\nFor example, if you would like to make the Down payment field resizable, you can add multiline: true to muiProps option. If you want to make the field take up multiple rows by default, add rows and rowsMax fields. The latter limits how many rows should be added until the scroll bar is shown.\ndownpayment: {\n  \'ui:options\': {\n    size: 4,\n    muiProps: {\n      multiline: true,\n      rows: 2,\n      rowsMax: 4\n    }\n  }\n}\n Widgets \n Different types of widgets can be applied by passing the type via\n"ui:widget". Property tells the form which UI widget should be used to\nrender a field. You can read about react-jsonschema-form supported\nwidgets here. \n Building From source \n Reference the component projects for instructions to build from source.\n https://github.com/entando/entando-process-driven-plugin \n https://github.com/entando/entando-process-driven-plugin/tree/master/widgets \n https://github.com/entando/pda-redhatpam-engine \n https://github.com/entando/pda-core-engine \n Code Style \n See:  https://github.com/entando/entando-code-style \n Sonar \n https://sonarcloud.io/organizations/entando/projects \n'},{title:"Backing Up and Restoring an Entando Application",frontmatter:{},regularPath:"/v6.3/tutorials/devops/backing-up-and-restoring-your-environment.html",relativePath:"v6.3/tutorials/devops/backing-up-and-restoring-your-environment.md",key:"v-9833fbb4",path:"/v6.3/tutorials/devops/backing-up-and-restoring-your-environment.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Create a Backup",slug:"create-a-backup"},{level:2,title:"Restore a Backup",slug:"restore-a-backup"}],lastUpdated:"12/15/2021, 2:22:26 PM",lastUpdatedTimestamp:1639596146e3,content:' Backing Up and Restoring an Entando Application \n Prerequisites \n \n \n Java 11 \n \n \n Docker installed locally\n( https://docs.docker.com/docker-for-windows/install/ ) \n \n \n maven \n \n \n Access to a docker repository (docker.io or other) \n \n \n This tutorial will show you how you can use an Entando application that\nyou have built as a launching point for creating new applications. \n Create a Backup \n This step requires using a running Entando environment to take an application backup.\nThe output of this step is a local directory with the files (database and static assets) you can use to restore the application later. \n \n \n Log into  App Builder \n \n \n Go to  Configuration → Database \n \n \n Click on  Create A Backup  and wait for the process to complete. All of the static assets and database backups are persisted to a PVC in /entando-data on the server pod. \n \n \n Transfer the files from the server-container. The details will vary depending on your kubernetes environment. \n \n \n \n \n \n kubectl \n OpenShift \n \n \n \n \n kubectl cp <pod>:<path> <local-path> \n oc rsync <pod>:<path> <localPath> \n \n \n e.g. kubectl cp quickstart-server-deployment-7b8c699599-f84zq:/entando-data backup \n e.g. oc rsync app-entando-server-deployment-67fd5b9954-s72mb:/entando-data \n \n \n \n \n You should see 3 directories -  databases ,  protected , and  resources .\nThe  protected  directory contains the timestamped backup you triggered from the  App Builder . \n Restore a Backup \n In this tutorial you’ll create a custom copy of an Entando Application, install the\nbackup files, build a Docker image from the updated app, and deploy it as a new application. Steps 3 and 4 can be skipped if you simply want to create a custom application. \n \n \n Clone the application at:\n https://github.com/entando/entando-de-app  using \n git clone https://github.com/entando/entando-de-app\n \n \n \n On a command line, cd into the  entando-de-app  you just cloned: \n cd entando-de-app\n \n \n \n Take the backup file and unzip it in a location of your choice. \n \n \n This zip contains all of the assets, content, and metadata\nneeded to launch an Entando application. We are going to package\nthe static assets and database backup into a Docker image. \n \n \n Entando will automatically instantiate and populate the app from\nthe most recent backup \n \n \n \n \n Move the resources and protected folders from your Entando backup into your\n entando-de-app  application under  src/main/webapp  replacing any content that is\nalready there. \n \n \n Build a docker image from the core app replacing the value of the tag in the  -t  argument with the tag you want to use for your image \n mvn clean package\ndocker build . -f Dockerfile.wildfly -t <YOUR-USER>/<YOUR-REPO-NAME>:<YOUR-VERSION>\n \n \n \n Push the Image to your Repository \n docker push <YOUR-USER>/<YOUR-REPO-NAME>:<YOUR-VERSION>\n \n \n \n Now we need to generate a new application for deployment to\nKubernetes using the helm chart \n \n \n If you have an output from helm from before you can re-use it\nand just apply the changes to the config map. In this case skip to step 12. \n \n \n Or you can re-run helm and change the output \n \n \n \n \n Re-run the helm command for your environment \n \n \n Open the output yaml file from the helm command in the text editor\nof your choice \n \n For example:  vi training-alpha.yaml \n \n \n \n In that file look for the  ConfigMap \n \n \n The config map defines all of the images that are available as\npart of the deployment. They aren’t all used concurrently. \n \n \n You can also view this config map in  kubernetes/OpenShift \n \n \n \n \n Now you need to update the deployment to use your customized Wildfly\nimage. Find  entando-de-app-wildfly  in the config map \n \n Note that we are changing the de-app but you could create a\ncustom version of any of the included images \n \n \n \n Change the version to match the version you used for your image \n \n \n Change the "organization" to the name of your main image repository\norganization and if you aren’t using docker.io (DockerHub) then\nchange the registry as well. \n \n \n Save the file \n \n \n Follow the deployment steps you went through when you originally\ndeployed your Entando application to your Kubernetes instance \n \n \n Once deployed go to the  App Builder  in your app \n \n \n Click  Go To Homepage  and you should see your restored application. \n \n \n'},{title:"Caching and Clustering",frontmatter:{},regularPath:"/v6.3/tutorials/devops/clustering-caching/caching-and-clustering.html",relativePath:"v6.3/tutorials/devops/clustering-caching/caching-and-clustering.md",key:"v-846210da",path:"/v6.3/tutorials/devops/clustering-caching/caching-and-clustering.html",headers:[{level:2,title:"Storage Requirements for Clustered Entando Apps",slug:"storage-requirements-for-clustered-entando-apps"},{level:2,title:"Clustering",slug:"clustering"},{level:3,title:"Prerequisites",slug:"prerequisites"},{level:3,title:"Creating a Clustered App Instance",slug:"creating-a-clustered-app-instance"},{level:3,title:"Validating the Clustered Instances",slug:"validating-the-clustered-instances"},{level:3,title:"Caching Validation",slug:"caching-validation"},{level:2,title:"Configuring and Deploying with Redis",slug:"configuring-and-deploying-with-redis"},{level:3,title:"Deploy Redis to Kubernetes",slug:"deploy-redis-to-kubernetes"},{level:3,title:"Configure implementation",slug:"configure-implementation"},{level:2,title:"Appendix A - Creating Separately Deployed App Engine Instances",slug:"appendix-a-creating-separately-deployed-app-engine-instances"}],lastUpdated:"12/15/2021, 2:22:26 PM",lastUpdatedTimestamp:1639596146e3,content:' Caching and Clustering \n The tutorials below cover the basic steps to setup and validate a clustered instance of the Entando App Engine. \n \n NOTE \n When building your deployment architecture it is important to review your goals, hardware, networking, and application specific setup and to optimize your App Engine deployment for your environment. None of the configurations or deployments below will address every type of application or every type of deployment. The configuration and testing examples below can be used as building blocks to create a deployment architecture that works for your application. \n Storage Requirements for Clustered Entando Apps \n In order to scale an Entando Application across multiple nodes you must provide a storage class that supports\na  ReadWriteMany  access policy. There are many ways to accomplish this including using dedicated storage providers\nlike GlusterFS. The cloud Kubernetes providers also provide clustered storage options specific to their implementation like Google Cloud File in GKE or Azure Files in AKS. \n The storage class that supports  ReadWriteMany  must be marked as the default storage class in the deployment \n TIP \n You can also scale an Entando Application without clustered storage using a  ReadWriteOnce (RWO)  policy by ensuring that the\ninstances are all scheduled to the same node. This can be accomplished using taints on other nodes. Be aware of the pros and cons of scheduling\ninstances to the same node. This will give you protection if the application instance itself dies or becomes unreachable and will help\nyou get the most utilization of node resources. However, if the node dies or is shutdown you will have to wait for Kubernetes to reschedule the pods to a different node and your application will be down. \n Clustering \n This tutorial reviews setting up a clustered Entando App Engine using the default Infinispan Library Mode deployment that ships with the quickstart App Engine in the  entando-de-app . The goal of the tutorial is to deploy a clustered instance of the App Engine and verify that we have a high availability and scalable deployment of the application. \n Prerequisites \n \n An existing deployment of an Entando App or the ability to create a new one\n \n If you haven\'t created a deployment yet or don\'t have a yaml file for an Entando deployment follow the quickstart  here . \n \n \n The Entando deployment must use an RDBMS. Clustered instances will not work correctly with in memory databases and a  dbms: none  configuration. \n Creating a Clustered App Instance \n \n Create an Entando deployment via the helm template or edit an existing deployment yaml file. \n Edit the deployment and find the  EntandoApp  in the yaml file (towards the bottom).\n \n If you\'re editing an existing deployment you can use  kubectl edit <deployment>  or you can edit the deployment prior to kicking off the installation. \n \n \n \n - kind: "EntandoApp"\n      metadata:\n        annotations: {}\n        labels: {}\n        name: "quickstart"\n      spec:\n        dbms: postgresql\n        replicas: 1\n        standardServerImage: wildfly\n        ingressPath: /entando-de-app\n \n \n In the  EntandoApp  change the number of replicas to 2 (or more as desired) \n Save the file \n Deploy the application or wait for the application to update if editing an existing deployment \n Run  kubectl get pods -n <your namespace>  to view the pods in your deployment \n You should have two  server-deployment  pods in your namespace with three containers each. See the screenshot below: \n \n \n \n Finally, you can look in the logs of the  server-container  in either pod and you will see logging related to different instance joining the cluster and balancing the data between the instances. See the screenshot for an example. Your actual logs will vary: \n \n \n The tutorials below will take you through validating and testing the clustered and cached instances. \n \n NOTE \n If you are on OpenShift you can use the Scale Up arrows and other settings available in the OpenShift console if you prefer \n Validating the Clustered Instances \n This is an advanced tutorial and is not required or recommended for most deployment scenarios or users. \n This tutorial will walk you through steps to validate that the clustered instances are working in your environment and that you have created a high availability deployment. There are many ways to validate your clustering. \n \n Complete the  creating a clustered instance tutorial  above or have an existing clustered Entando App instance available for testing \n Get the URL for your  entando-de-app  with  kubectl get ingress -n <your namespace> \n Open the URL in a browser of your choice and ensure that the application is working \n Open a new browser window in an incognito or private browsing mode.  do not navigate to the app\n \n The only reason for private mode is to ensure that no data is cached and you\'re receiving a copy of the running application \n \n \n In the next steps you\'ll delete a pod in your cluster and verify that your application is still getting served. Kubernetes will automatically restore the desired number of replicas so you\'ll need to perform the validation test before the new replica is launched. In most environments this will be around one minute but it will vary. \n Delete one of the server deployment pods in your clustered instances with  kubectl delete <pod-name> -n <your namespace> \n \n There are other ways to do this. You could also shell into the server-container and manually kill the running app process with  kill -9 357 . \n If you wanted to test at the hardware level you could manually terminate a node in your cluster (ensuring that the pods are scheduled to different nodes) \n \n \n In your private/incognito browser window open the URL to your  entando-de-app \n See that the application continues to render while the pod you deleted is no longer present \n Wait for Kubernetes to restore your deleted pod \n Check that the application continues to render after the pods are restored \n Caching Validation \n Validating the shared cache can be done in a similar fashion to the clustered instance validation. The high level steps are: \n \n Deploy a clustered instance (see  creating a clustered instance tutorial ) \n Create data using the app builder (pages, page templates, content etc.) using the external route for the application \n Take note in the logs of which instance processed the request \n Terminate that instance \n Fetch the data created and ensure that the recently created data is returned \n \n Another option for validating the shared cache involves creating a custom deployment with two distinct Entando App instances. In this scenario you would not use the  replicas  option in the deployment. This has the benefit of keeping all of the instances running and validating the configuration by creating distinct pods for the Entando App Engine so that each instance can be exposed on endpoints separately. \n The high level steps for this setup are reviewed in  Appendix A \n Configuring and Deploying with Redis \n This tutorial covers deploying an Entando App Engine instance using Redis as a cache for data served by the app engine. For more information on the cache\nconfiguration for the App Engine checkout the  reference documentation \n Deploy Redis to Kubernetes \n \n Create the redis deployment and expose the endpoints \n \n kubectl create deployment redis –-image = redis:6\n \n kubectl expose replicaset.apps/redis-687488bdd4 --port = 6379  --target-port = 6379  -n  < your namespace > \n \n \n Install the Redis CLI for your environment per  https://redis.io/topics/rediscli \n Get the IP for your Redis deployment \n \n kubectl get  service  -n  < your namespace > \n \n \n Validate your deployment \n \n Should respond PONG \n redis-cli -h  10.43 .99.198 -p  6379   ping \n \n Should increment each time \n redis-cli -h  10.43 .99.198 -p  6379  incr mycounter\n Configure implementation \n \n Use git to clone the  entando-de-app  repository \n \n git  clone https://github.com/entando/entando-de-app\n \n \n Fetch the tags and checkout the release tag and create a branch for your customization \n \n git  fetch --tags\n \n git  checkout tags/v6.3.22 -b  6.3 -redis\n \n \n Open the pom.xml file of the  entando-de-app \n Remove the Infinispan dependencies from the pom \n \n \x3c!-- infinispan --\x3e\n <dependency>\n     <groupId>org.infinispan</groupId>\n     <artifactId>infinispan-core</artifactId>\n     <version>9.4.8.Final</version>\n </dependency>\n <dependency>\n     <groupId>org.infinispan</groupId>\n     <artifactId>infinispan-commons</artifactId>\n     <version>9.4.8.Final</version>\n </dependency>\n \n \n Add the Redis caching plugin to the pom \n \n <dependency>\n    <groupId>org.entando.entando.plugins</groupId>\n    <artifactId>entando-plugin-jpredis</artifactId>\n    <type>war</type>\n</dependency>\n \n \n Save the pom \n Build and push a custom image for the  entando-de-app  following  these steps \n Create or download a deployment file. For example, use the  entando.yaml \n \n curl  -L -C - -O https://raw.githubusercontent.com/entando/entando-releases/v6.3.0/dist/qs/entando.yaml\n \n \n Update the image in the deployment yaml file to point to your custom  entando-de-app  image with Redis. The line to change is in the  ConfigMap  and is noted below \n \n entando-de-app-wildfly: >-\n    {"version":"6.3.10","executable-type":"jvm","registry":"docker.io","organization":"entando"}\n \n \n Add environment variables to the  EntandoApp  in the deployment yaml file for the Redis address and Redis password for your deployed Redis instance. The variables to create are: \n \n REDIS_ADDRESS\n \n REDIS_PASSWORD\n \n For example, \n \n NOTE \n This example uses a secret for the  REDIS_PASSWORD  which is recommended. You can also hardcode the password in the yaml for testing, however, creating passwords in clear text in your deployment files is not recommended. Create and use a secret for the password as a best practice. \n \n This is a reference example for the EntandoCompositeApp and is not a complete deployment. Utilize this as an example to create your configuration in a complete deployment. \n kind: "EntandoCompositeApp"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "quickstart-apps"\n  namespace: test\nentandoStatus:\n  serverStatuses: {}\n  entandoDeploymentPhase: "requested"\nspec:\n  components:\n    - kind: "EntandoApp"\n      metadata:\n        annotations: {}\n        labels: {}\n        name: "quickstart1"\n      spec:\n        dbms: none\n        replicas: 2\n        standardServerImage: wildfly\n        ingressPath: /entando-de-app\n        ingressHostName: quickstart1.test.dynu.net\n        environmentVariables:\n          - name: REDIS_ADDRESS\n            value: <your redis URI. For example redis://localhost:6379)\n          - name: REDIS_PASSWORD\n            valueFrom:\n              secretKeyRef:\n                key: password\n                name: quickstart1-redis-secret\n                optional: false\n        ....\n Appendix A - Creating Separately Deployed App Engine Instances \n This appendix provides a high level example of creating a deployment with two distinct Entando App Engine instances. This type of deployment can be used to create pods that can be separately accessed and managed. It is  not recommended  to use this type of deployment for typical development or production environments. Utilize the ability of Kubernetes and the Entando infrastructure to manage your replicas automatically. \n \n Create two different instances of the  EntandoApp  component inside of the  EntandoCompositeApp  in your deployment yaml \n Configure both EntandoApp instances to use the same database and JGroups configuration if using Infinispan. If using Redis configure both instances to point to the same Redis instance \n Deploy the application \n Expose the separately deployed  EntandoApp  instances with distinct endpoints \n Create data in one instance via the App Builder or via API \n Validate that the App Builder returns the same data in the other instance \n \n A partial example of that deployment: \n kind: "EntandoCompositeApp"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "quickstart-apps"\n  namespace: test\nentandoStatus:\n  serverStatuses: {}\n  entandoDeploymentPhase: "requested"\nspec:\n  components:\n    - kind: "EntandoApp"\n      metadata:\n        annotations: {}\n        labels: {}\n        name: "quickstart1"\n      spec:\n        dbms: none\n        replicas: 1\n        standardServerImage: wildfly\n        ingressPath: /entando-de-app\n        ingressHostName: quickstart1.test.dynu.net\n        environmentVariables:\n          - name: PORTDB_URL\n            value: jdbc:postgresql://quickstart-postgresql-db-service.test.svc.cluster.local:5432/quickstart_postgresql_db\n          - name: PORTDB_USERNAME\n            valueFrom:\n              secretKeyRef:\n                key: username\n                name: quickstart1-portdb-secret\n                optional: false\n          - name: PORTDB_PASSWORD\n            valueFrom:\n              secretKeyRef:\n                key: password\n                name: quickstart1-portdb-secret\n                optional: false\n          - name: PORTDB_CONNECTION_CHECKER\n            value: org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLValidConnectionChecker\n          - name: PORTDB_EXCEPTION_SORTER\n            value: org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLExceptionSorter\n          - name: SERVDB_URL\n            value: jdbc:postgresql://quickstart-postgresql-db-service.test.svc.cluster.local:5432/quickstart_postgresql_db\n          - name: SERVDB_USERNAME\n            valueFrom:\n              secretKeyRef:\n                key: username\n                name: quickstart1-servdb-secret\n                optional: false\n          - name: SERVDB_PASSWORD\n            valueFrom:\n              secretKeyRef:\n                key: password\n                name: quickstart1-servdb-secret\n                optional: false\n          - name: SERVDB_CONNECTION_CHECKER\n            value: org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLValidConnectionChecker\n          - name: SERVDB_EXCEPTION_SORTER\n            value: org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLExceptionSorter\n          - name: JGROUPS_CLUSTER_PASSWORD\n            value: xxxxxxxx\n          - name: OPENSHIFT_KUBE_PING_LABELS\n            value: EntandoResourceKind=EntandoApp\n          - name: KUBERNETES_LABELS\n            value: EntandoResourceKind=EntandoApp\n          - name: POD_IP\n            valueFrom:\n              fieldRef:\n                fieldPath: status.podIP\n    - kind: "EntandoApp"\n      metadata:\n        annotations: {}\n        labels: {}\n        name: "quickstart2"\n      spec:\n        dbms: none\n        replicas: 1\n        standardServerImage: wildfly\n        ingressPath: /entando-de-app\n        ingressHostName: my.host.name\n        environmentVariables:\n          - name: SPRING_PROFILES_ACTIVE\n            value: "default,swagger"\n          - name: PORTDB_URL\n            value: jdbc:postgresql://quickstart-postgresql-db-service.test.svc.cluster.local:5432/quickstart_postgresql_db\n          - name: PORTDB_USERNAME\n            valueFrom:\n              secretKeyRef:\n                key: username\n                name: quickstart1-portdb-secret\n                optional: false\n          - name: PORTDB_PASSWORD\n            valueFrom:\n              secretKeyRef:\n                key: password\n                name: quickstart1-portdb-secret\n                optional: false\n          - name: PORTDB_CONNECTION_CHECKER\n            value: org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLValidConnectionChecker\n          - name: PORTDB_EXCEPTION_SORTER\n            value: org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLExceptionSorter\n          - name: SERVDB_URL\n            value: jdbc:postgresql://quickstart-postgresql-db-service.test.svc.cluster.local:5432/quickstart_postgresql_db\n          - name: SERVDB_USERNAME\n            valueFrom:\n              secretKeyRef:\n                key: username\n                name: quickstart1-servdb-secret\n                optional: false\n          - name: SERVDB_PASSWORD\n            valueFrom:\n              secretKeyRef:\n                key: password\n                name: quickstart1-servdb-secret\n                optional: false\n          - name: SERVDB_CONNECTION_CHECKER\n            value: org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLValidConnectionChecker\n          - name: SERVDB_EXCEPTION_SORTER\n            value: org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLExceptionSorter\n          - name: JGROUPS_CLUSTER_PASSWORD\n            value: xxxxxxxx\n          - name: OPENSHIFT_KUBE_PING_LABELS\n            value: EntandoResourceKind=EntandoApp\n          - name: POD_IP\n            valueFrom:\n              fieldRef:\n                fieldPath: status.podIP\n \n '},{title:"Building a Docker Image for the Entando Core",frontmatter:{},regularPath:"/v6.3/tutorials/devops/build-core-image.html",relativePath:"v6.3/tutorials/devops/build-core-image.md",key:"v-a7ad4b84",path:"/v6.3/tutorials/devops/build-core-image.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Introduction",slug:"introduction"},{level:2,title:"Setup",slug:"setup"}],lastUpdated:"12/15/2021, 2:22:26 PM",lastUpdatedTimestamp:1639596146e3,content:" Building a Docker Image for the Entando Core \n Prerequisites \n \n \n Java 11 \n \n \n Docker installed locally\n( https://docs.docker.com/docker-for-windows/install/ ) \n \n \n maven \n \n \n Access to a docker repository (docker.io or other) \n Introduction \n This tutorial will take you through the basic steps to create a docker\nimage from an Entando core application. A more detailed guide with\nadditional commands and configuration can be found here: \n https://github.com/entando/entando-de-app \n Setup \n \n \n Clone the application at:\n https://github.com/entando/entando-de-app  using \n git clone https://github.com/entando/entando-de-app\n \n \n \n On a command line, cd into the entando-de-app you just cloned: \n cd entando-de-app\n \n \n \n Build a docker image from the core app replacing the value of the tag in the  -t   with the tag you want to use for your image. \n mvn clean package\ndocker build . -f Dockerfile.wildfly -t <YOUR-USER>/<YOUR-REPO-NAME>:<YOUR-VERSION>\n \n \n \n Create a repository on your docker repository to house your new\napplication \n \n \n Push the Image to your Repository \n docker push <YOUR-USER>/<YOUR-REPO-NAME>:<YOUR-VERSION>\n \n \n \n"},{title:"Tutorial: Connecting to an External Database",frontmatter:{},regularPath:"/v6.3/tutorials/devops/external-database/",relativePath:"v6.3/tutorials/devops/external-database/README.md",key:"v-10c1b3bc",path:"/v6.3/tutorials/devops/external-database/",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"4/26/2021, 9:36:02 AM",lastUpdatedTimestamp:1619444162e3,content:" Tutorial: Connecting to an External Database \n Overview \n This document provides a guide to connecting an Entando Application to an external database. In\nmany (not all) production configurations it is recommended to use a DBMS\noutside of the cluster where your Entando application is running to\nsimplify maintenance, duplication of resources, and to establish a\nbackup workflow that will scale with your application. \n Prerequisites \n \n \n An environment to install your Entando applicaiton \n \n \n A running PostgreSQL, MySQL, or Oracle environment \n \n \n Administrator access to the database \n \n \n Network access from your Kubernetes cluster to your database \n Tutorial \n \n Create and install a secret or secrets for your database credentials \n Edit the deployment template generated from running the helm command or the helm template you used to deploy your Entando application \n Find the entry for the  EntandoCompositeApp \n Set the value for  dbms  to  none \n Under  environmentVariables  you will need to provide database connection information for two Entando Server databases and one connection for the Entando Component Repository. Example connection information for each of those databases is provided below: \n ECR \n - name: SPRING_DATASOURCE_URL\n  value: {ECRDB_URL}\n- name: SPRING_DATASOURCE_USERNAME\n  valueFrom:\n    secretKeyRef:\n      name: {ECRDB_DBMS_SECRET_NAME}\n      key: username\n      optional: false\n- name: SPRING_DATASOURCE_PASSWORD\n  valueFrom:\n    secretKeyRef:\n      name: {ECRDB_DBMS_SECRET_NAME}\n      key: password\n      optional: false\n- name: SPRING_JPA_DATABASE_PLATFORM\n  value: org.hibernate.dialect.PostgreSQLDialect\n Portal DB \n - name: PORTDB_URL\n  value: {PORTDB_URL}\n- name: PORTDB_USERNAME\n  valueFrom:\n    secretKeyRef:\n      name: {PORTDB_DBMS_SECRET_NAME}\n      key: username\n      optional: false\n- name: PORTDB_PASSWORD\n  valueFrom:\n    secretKeyRef:\n      name: {PORTDB_DBMS_SECRET_NAME}\n      key: password\n      optional: false\n- name: PORTDB_CONNECTION_CHECKER\n  value: {PORTDB_CONNECTION_CHECKER}\n- name: PORTDB_EXCEPTION_SORTER\n  value: {PORTDB_EXCEPTION_SORTER}\n Server DB \n - name: SERVDB_URL\n  value: {SERVDB_URL}\n- name: SERVDB_USERNAME\n  valueFrom:\n    secretKeyRef:\n      name: {SERVDB_DBMS_SECRET_NAME}\n      key: username\n      optional: false\n- name: SERVDB_PASSWORD\n  valueFrom:\n    secretKeyRef:\n      name: {SERVDB_DBMS_SECRET_NAME}\n      key: password\n      optional: false\n- name: SERVDB_CONNECTION_CHECKER\n  value: {SERVDB_CONNECTION_CHECKER}\n- name: SERVDB_EXCEPTION_SORTER\n  value: {SERVDB_EXCEPTION_SORTER}\n \n Set the values for placeholders in the templates above based on your database configuration. Here are examples: \n Postgresql \n XXX_URL:                      jdbc:postgresql://{DBMS_ADDRESS}:{DBMS_PORT}/{DBMS_DBNAME}\nXXX_CONNECTON_CHECKER:        org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLValidConnectionChecker\nXXX_EXCEPTION_SORTER:         org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLExceptionSorter\nSPRING_JPA_DATABASE_PLATFORM: org.hibernate.dialect.PostgreSQLDialect\n MySql \n XXX_URL:                      jdbc:mysql://{DBMS_ADDRESS}:{DBMS_PORT}/{DBMS_DBNAME}\nXXX_CONNECTON_CHECKER:        org.jboss.jca.adapters.jdbc.extensions.mysql.MySQLValidConnectionChecker\nXXX_EXCEPTION_SORTER:         org.jboss.jca.adapters.jdbc.extensions.mysql.MySQLExceptionSorter\nSPRING_JPA_DATABASE_PLATFORM: org.hibernate.dialect.MySQLDialect\n Oracle \n XXX_URL:                      jdbc:oracle:{driver_type}:@//{DBMS_ADDRESS}:{DBMS_PORT}/{DBMS_SERVICE_NAME}\nXXX_CONNECTON_CHECKER:        org.jboss.jca.adapters.jdbc.extensions.oracle.OracleValidConnectionChecker\nXXX_EXCEPTION_SORTER:         org.jboss.jca.adapters.jdbc.extensions.oracle.OracleExceptionSorter\nSPRING_JPA_DATABASE_PLATFORM: org.hibernate.dialect.Oracle\n \n "},{title:"Entando 6 Azure Kubernetes Installation Instructions",frontmatter:{sidebarDepth:2},regularPath:"/v6.3/tutorials/devops/installation/azure-kubernetes-service/azure-install.html",relativePath:"v6.3/tutorials/devops/installation/azure-kubernetes-service/azure-install.md",key:"v-1b846906",path:"/v6.3/tutorials/devops/installation/azure-kubernetes-service/azure-install.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"Cluster Setup",slug:"cluster-setup"},{level:3,title:"Setup and Connect to the Cluster",slug:"setup-and-connect-to-the-cluster"},{level:3,title:"Deploy NGINX Ingress Controller",slug:"deploy-nginx-ingress-controller"},{level:3,title:"Verify the NGINX Ingress Install",slug:"verify-the-nginx-ingress-install"},{level:3,title:"Install the Entando Custom Resource Definitions (CRDs)",slug:"install-the-entando-custom-resource-definitions-crds"},{level:2,title:"Deploy Your Entando Application",slug:"deploy-your-entando-application"},{level:2,title:"Appendix A - Example values.yaml file for Helm Quickstart",slug:"appendix-a-example-values-yaml-file-for-helm-quickstart"},{level:2,title:"Appendix B - Troubleshooting",slug:"appendix-b-troubleshooting"}],lastUpdated:"1/4/2021, 4:09:52 AM",lastUpdatedTimestamp:1609751392e3,content:' Entando 6 Azure Kubernetes Installation Instructions \n Prerequisites \n \n Azure account\n \n \n \n Note: If you\'re using an Azure free account, you may need to upgrade your account first to enable pay-as-you-go billing. The Azure free account default quota includes just 1-4 vCPU which is not sufficient for this tutorial. There may be a delay before the quotas are updated when you upgrade your account. \n \n \n \n \n If you\'re not using Azure Cloud Shell:\n \n Azure command line tool \n Helm2 client \n Overview \n The steps below walk you through installing the Entando platform in an Azure Kubernetes Services (AKS) cluster. Generally the steps are: \n \n Create an AKS cluster with 5 nodes (to allow expansion for microservices) \n Install nginx as an ingress controller in the cluster \n Install Entando \n \n If you\'re already comfortable setting up an AKS cluster and installing nginx then you may be able to skip to  setting up Entando . \n Cluster Setup \n Setup and Connect to the Cluster \n \n Login to Azure ( https://portal.azure.com/ ) \n Select the  Kubernetes services  icon\n \n If not listed click  More services  on the right and search for Kubernetes \n \n \n Click  Add  in upper left corner \n Select  Kubernetes cluster . You\'ll start with the  Basics  tab. \n Select a  Resource group  or create one with the  Create new  link if it you don’t have one, e.g.  resource-group-1 \n Enter a name of your choice in Kubernetes cluster name, e.g.  cluster-1 \n Pick your  Region  if it wasn\'t automatically selected for you. \n In the  Availability zones  dropdown pick  one and only one  availability zone\n \n Generally, you could pick more than one but it will result in a failure in a quickstart environment. If you chose more than one availability zone you will have to provision storage, manage node affinity, and ensure correct network configuration to ensure your application deploys. We recommend only doing this for production clusters. \n \n \n Select   1.18.10  for the  Kubernetes version \n Keep the default  Node size , e.g.  Standard DS2 v2 \n Change the  Node count  to  5 \n Click  Next: Node Pools  to move to the next tab. \n Keep the default values here\n \n If you\'re familiar with AKS your can change as desired based on your objectives/knowledge \n \n \n Click  Next: Authentication \n For  Authentication method  select  System-assigned managed identity \n \n You can pick a  Service principal  instead and Azure will automatically generate one for you. If you use an existing principal it is up to you to configure it and ensure you have the access you need. \n \n \n Click  Next: Networking \n Enter a value for DNS name prefix, e.g.  cluster-1-dns \n Click  Review + Create \n \n Note: There are many other configuration options available for an AKS cluster. Generally, you can change these based on your experience and comfort level with the AKS platform. Entando uses base Kubernetes APIs so as long as you follow the Entando configuration instructions below you can tune your cluster infrastructure to meet your goals \n \n \n Select  Create \n Wait for your cluster to initialize.\n \n This may take a few minutes \n Deploy NGINX Ingress Controller \n \n Navigate to your cluster by clicking  Go to Resource  from the results page or by the top navigation  Home - Kubernetes service  and clicking on your cluster. \n Select  Connect \n Select  Bash \n Run the first two commands (e.g.  az account set...  and  az aks get-credentials...  to connect to your cluster. This should only be needed the first time you run the Azure Cloud Shell.\n \n The Cloud Shell times out after 20 minutes of inactivity. \n The following instructions assume you\'ll use the Azure Cloud Shell but you can also run the commands in a local environment if you have  kubectl \n \n \n Deploy nginx with the commands below. See  nginx instructions  for more details. \n \n kubectl create namespace ingress-basic\n \n helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx\nhelm repo add stable https://kubernetes-charts.storage.googleapis.com/\nhelm repo update\n \n helm install nginx-ingress ingress-nginx/ingress-nginx \\\n    --namespace ingress-basic \\\n    --set controller.replicaCount=2 \\\n    --set controller.nodeSelector."beta\\.kubernetes\\.io/os"=linux \\\n  --set defaultBackend.nodeSelector."beta\\.kubernetes\\.io/os"=linux\n \n \n Get the external IP address for your ingress controller. Record the value of EXTERNAL-IP for  nginx-ingress-controller  from the command below. \n \n kubectl get service -n ingress-basic\n Verify the NGINX Ingress Install \n We recommend setting up a test application so you can easily verify the ingress is working in your cluster. See  this page  for those steps. You can use either Azure Cloud Shell or your local  kubectl . \n Install the Entando Custom Resource Definitions (CRDs) \n Once per cluster you need to deploy the  Entando Custom Resources . \n \n Download the Custom Resource Definitions (CRDs) and unpack them \n \n curl -L -C - https://raw.githubusercontent.com/entando/entando-releases/v6.3.0/dist/qs/custom-resources.tar.gz | tar -xz\n \n \n Install the Entando CRDs: \n \n kubectl create -f dist/crd\n Deploy Your Entando Application \n You can now deploy your application to Azure Kubernetes Service. \n \n Download and unpack the entando-helm-quickstart: \n \n curl -sfL https://github.com/entando-k8s/entando-helm-quickstart/archive/v6.3.0.tar.gz | tar xvz\n \n \n See the included README file for more information on subsequent steps. \n \n \n Change into the new directory \n \n cd entando-helm-quickstart-6.3.0\n \n \n \n Edit the  values.yaml \n \n Set  supportOpenshift: false \n Set  ENTANDO_DEFAULT_ROUTING_SUFFIX  to the EXTERNAL-IP of your ingress controller and add nip.io to the end\n \n For example:  ENTANDO_DEFAULT_ROUTING_SUFFIX: 52.188.177.248.nip.io \n \n \n Configure nginx as the ingress controller and enable file system groups for persistent volume access:\n \n ENTANDO_INGRESS_CLASS: "nginx" \n ENTANDO_REQUIRES_FILESYSTEM_GROUP_OVERRIDE: "true" \n \n \n See  Appendix A  for an example values.yaml \n \n \n \n Create the Entando namespace: \n \n \n kubectl create namespace entando\n \n \n Run helm to generate the template file: \n \n helm template my-aks-app --namespace=entando ./ > my-aks-app.yaml\n \n \n Deploy Entando via \n \n kubectl create -f my-aks-app.yaml\n \n \n Watch Entando startup. The application will be available when the quickstart-server-deployment pod shows 3/3 in the READY column and RUNNING in the STATUS column. \n \n kubectl get pods -n entando --watch\n \n \n Check for the Entando ingresses using \n \n kubectl describe ingress -n entando\n \n \n Access your app on the url for the ingress of the app builder, e.g.  http://quickstart-entando.EXTERNAL-IP.nip.io/entando-de-app \n Appendix A - Example values.yaml file for Helm Quickstart \n In the example below the application will deploy with embedded databases and will use  nginx \nas the ingress controller. Replace  <YOUR-IP>  with the EXTERNAL-IP address of your nginx controller \n app:\n name: quickstart\n dbms: none\noperator:\n supportOpenshift: false\n env:\n   ENTANDO_DOCKER_IMAGE_VERSION_FALLBACK: 6.0.0\n   #ENTANDO_DOCKER_REGISTRY_OVERRIDE: docker.io # Remove comment if you want to always use a specific docker registry\n   #ENTANDO_DOCKER_IMAGE_ORG_OVERRIDE: entando # Remove the comment if you want to always use a specific docker organization\n   ENTANDO_DEFAULT_ROUTING_SUFFIX: <YOUR-IP>.nip.io\n   ENTANDO_POD_READINESS_TIMEOUT_SECONDS: "1000"\n   ENTANDO_POD_COMPLETION_TIMEOUT_SECONDS: "1000"\n   ENTANDO_DISABLE_KEYCLOAK_SSL_REQUIREMENT: "true"\n   ENTANDO_K8S_OPERATOR_IMPOSE_DEFAULT_LIMITS: "false"\n   ENTANDO_INGRESS_CLASS: "nginx"\n   ENTANDO_REQUIRES_FILESYSTEM_GROUP_OVERRIDE: "true"\n tls:\n   caCrt:\n   tlsCrt:\n   tlsKey:\ndeployPDA: false\n Appendix B - Troubleshooting \n If you get an error like:  0/5 nodes are available: 5 node(s) had volume node affinity conflict.  or if your deployment hangs in a situation like this from  kubectl get pods -n entando \n NAME                                                 READY   STATUS      RESTARTS   AGE\nmy-aks-app-operator-644697776f-sxtq2                 1/1     Running     0          13m\nquickstart-composite-app-deployer-2guz0n42pc         1/1     Running     0          13m\nquickstart-deployer-jj4njqk4bg                       1/1     Running     0          10m\nquickstart-eci-deployer-t0xktqsonk                   0/1     Completed   0          11m\nquickstart-eci-k8s-svc-deployment-78f64c8d89-7c578   1/1     Running     0          11m\nquickstart-kc-deployer-16gzv3clsj                    0/1     Completed   0          13m\nquickstart-kc-server-deployment-7c9bc65744-g52nx     1/1     Running     0          13m\nquickstart-server-deployment-55fcfc6b68-szvkl        0/3     Pending     0          10m\n \n Double check your availability zones. By default an Azure cluster will include nodes from multiple zones but it will not provision storage\nfor all of those nodes so you can\'t deploy your application. \n You can confirm this error in the AKS console as well: \n \n In your cluster select  Workloads  in the left nav \n Click on the deployment for your server application. This is  quickstart-server-deployment  by default \n Click on the deployment name inside that application. There will be one \n Click on the tab labeled  Conditions \n If you see an error that says  0/5 nodes are available: 5 node(s) had volume node affinity conflict.  Then you need to reconfigure\nyour cluster to have nodes in one zone or work with your Azure operations team to provision storage to match node affinity. \n \n'},{title:"Tutorial: Selecting the default databases",frontmatter:{},regularPath:"/v6.3/tutorials/devops/default-database.html",relativePath:"v6.3/tutorials/devops/default-database.md",key:"v-151998f0",path:"/v6.3/tutorials/devops/default-database.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:" Tutorial: Selecting the default databases \n Overview \n This document provides a guide to changing an Entando environment by selecting the default databases used.\nSee  External Database  to connect to a database outside of the cluster. \n Prerequisites \n \n An environment to install your Entando applicaiton \n Network access from your Kubernetes cluster to your database \n Tutorial \n If needed you can set the desired component to use a specific DBMS by updating the Helm-generated yaml file (e.g. 'entando.yaml' from  Getting Started  as follows: \n \n open the chosen file and search for  EntandoCompositeApp  custom resource \n identify the component to update in the related list \n update the  spec.dbms  property with the desired value (you can specify different DBMS for different components) \n \n Repeat previous steps for all components you need to change used DBMS on. \n Valid values for  spec.dbms  property are:  none ,  postgresql ,  mysql ,  oracle . \n none  value will result in using an embedded database with in-file persistence strategy. \n Please note that using embedded databases into distributed systems forces to have only 1 replica per pod.\nThis happens because the volume claimed by each replica points to the same files,\nso the first container locking the files will prevent next replicas to obtain access to the DB files.\nNote that this affects also deployments rolling updates \n If you need to update your deployment, there is a known workaround consisting in setting the replicas number to 0, waiting for pod shutdown completion, update the deployment yaml file, then updating again to 1 the replicas value. In this way, the newly created containers will be able to startup correctly and access the embedded database files on the filesystem. \n These considerations lead us to discourage embedded database use into production environments. \n"},{title:"Installation on Amazon Elastic Kubernetes Service (EKS)",frontmatter:{sidebarDepth:2},regularPath:"/v6.3/tutorials/devops/installation/elastic-kubernetes-service/eks-install.html",relativePath:"v6.3/tutorials/devops/installation/elastic-kubernetes-service/eks-install.md",key:"v-80e5c274",path:"/v6.3/tutorials/devops/installation/elastic-kubernetes-service/eks-install.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"Cluster Setup",slug:"cluster-setup"},{level:3,title:"Setup and Connect to the Cluster",slug:"setup-and-connect-to-the-cluster"},{level:3,title:"Install the NGINX Ingress Controller",slug:"install-the-nginx-ingress-controller"},{level:3,title:"Verify the NGINX Ingress Install",slug:"verify-the-nginx-ingress-install"},{level:3,title:"Install the Entando Custom Resource Definitions (CRDs)",slug:"install-the-entando-custom-resource-definitions-crds"},{level:2,title:"Deploy Your Entando Application",slug:"deploy-your-entando-application"},{level:2,title:"Appendix A - Troubleshooting",slug:"appendix-a-troubleshooting"},{level:2,title:"Appendix B - Example values.yaml file for Helm Quickstart",slug:"appendix-b-example-values-yaml-file-for-helm-quickstart"}],lastUpdated:"1/4/2021, 4:09:52 AM",lastUpdatedTimestamp:1609751392e3,content:' Installation on Amazon Elastic Kubernetes Service (EKS) \n Prerequisites \n \n AWS CLI \n AWS account \n kubectl \n A domain or the ability to purchase one. Can use route 53 for this inside AWS if doing it all inline \n helm2 client \n Overview \n The steps below walk you though installing the Entando platform in an EKS cluster. Generally the steps are: \n \n Configure an IAM role to allow kubernetes to manage the cluster \n Create an EKS cluster with 5 nodes (to allow expansion for microservices) \n Install nginx as an ingress controller in the cluster \n Register a domain (if you don\'t already have one) and configure it for wildcard subdomains. \n Install Entando \n \n If you\'re already comfortable setting up an EKS cluster and installing nginx then you may be able to skip to  setting up Entando . \n Cluster Setup \n These steps will use the AWS console to create the cluster. If you’re already familiar with creating an EKS cluster and assigning nodes to it via the AWS cli then you can use the cli process for cluster creation as well. \n Setup and Connect to the Cluster \n \n \n Login to AWS as a non-super admin user \n \n If you don’t have a user besides the super admin it is recommended that you create one. Clusters created using the super admin for your account will have some restrictions that may complicate your installation. \n Your user will need access to EKS and at least the ability to create a cluster. You may need additional policies for Route53 and other services depending on your exact configuration. \n \n \n \n Create an IAM role for the cluster so that AWS can provision assets. See  https://docs.aws.amazon.com/eks/latest/userguide/worker_node_IAM_role.html  for more details. \n \n Select  IAM  from services \n Select  Create role \n Select  AWS Service  box at the top for the type of trusted entity \n Click  EKS  from the main list \n Click  EKS - Cluster  under  Select your use case \n Click  Next:Permissions \n A Policy of  AmazonEKSClusterPolicy  should already be present \n Click  Next: Tags \n (Optional) Add tags if you want \n Click  Next: Review \n Name your role (you’ll need this later), e.g.  my-eks-role \n \n \n \n Refine the role to enable Nodegroup management and to add ELB access so that the cluster can deploy a load balancer for nginx. \n \n Go to  IAM → Roles → your role \n Under permissions click  Attach policies \n Add a policy of  AmazonEKSWorkerNodePolicy \n Add a policy of  AmazonEKS_CNI_Policy \n Add a policy of  AmazonEC2ContainerRegistryReadOnly \n Add a policy of  ElasticLoadBalancingFullAccess \n \n \n \n Go to  Services  and select  Elastic Kubernetes Service \n \n \n Create an EKS Cluster \n \n Add a cluster name (e.g.  cluster-1 ) and click  Create EKS cluster \n Select  1.18  for the Kubernetes version \n For  Cluster Service Role , select the role you created above, e.g.  my-eks-role . If you choose a different role it must have ELB permissions so the cluster can create a load balancer in  Networking  (Step 2). \n Click  Next \n Use the defaults for  Networking  (Step 2) and click  Next \n Use the defaults for  Configure Logging  (Step 3) and click  Next . \n Review your settings and then click  Create . Cluster provisioning usually takes between 10 and 15 minutes. \n See  https://docs.aws.amazon.com/eks/latest/userguide/create-cluster.html  for more information on cluster creation. \n \n \n \n Add a node group to the cluster \n \n Go to  Services → Elastic Kubernetes Service → Clusters  → Click on your cluster name. \n Go to the  Compute  tab \n Click  Add Node Group \n Name : give your group a name, e.g.  node-1 \n Node IAM Role : Select the cluster role you created above. If the role doesn\'t appear, verify that you added the extra policies to the role. \n Subnets  - VPC subnets should already be setup and selected. \n Select  Allow remote access to nodes .  Follow the links to create a new SSH key pair if you don\'t already have one. \n Click  Next \n AMI type:  Amazon Linux 2 \n Instance type:  t3.medium \n Click  Next \n Set  Maximum size  to 5. This will be over-resourced for a  Getting Started  experience but will leave capacity for adding microservices to your cluster without modifying the Nodegroup. \n Click  Next \n Review your settings and then click  Create \n \n \n \n Connect  kubectl  to the cluster \n \n Note:  If this is a brand new setup you will need to login using the user you used to create your cluster in the console in the steps above. Make sure the users match.\n \n aws-configure  (and then provide the Access key, etc.) \n \n \n aws eks --region region-code update-kubeconfig --name cluster_name \n More details and troubleshooting  https://docs.aws.amazon.com/eks/latest/userguide/create-kubeconfig.html \n Your current context should now be configured for your AWS cluster. Run the command below to check: \n \n $  kubectl config current-context\n \n Your output should look something like this: \n arn:aws:eks:us-east-2:483173223614:cluster/cluster-1\n Install the NGINX Ingress Controller \n \n Add the NGINX controller for ingress. This depends on your role having permissions for ELB.\n \n For basic nginx ingress install run this command \n \n kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.41.2/deploy/static/provider/aws/deploy.yaml\n \n \n See  https://kubernetes.github.io/ingress-nginx/deploy/#aws  as well as  this  for more detailed install steps. \n \n \n Get the ELB external URL for your nginx install\n \n Run:  kubectl get services -n ingress-nginx \n Get the value of the external address (EXTERNAL-IP) for the ingress-nginx-controller: \n \n \n \n NAME                                 TYPE           CLUSTER-IP       EXTERNAL-IP                        \ningress-nginx-controller             LoadBalancer   10.100.102.83    ad234bd11a1ff4dadb44639a6bbf707e-0e0a483d966405ee.elb.us-east-2.amazonaws.com\n Verify the NGINX Ingress Install \n We recommend setting up a test application so you can easily verify the ingress is working in your cluster. See  this page  for those steps. You can use your local  kubectl . \n Install the Entando Custom Resource Definitions (CRDs) \n Once per cluster you need to deploy the  Entando Custom Resources . \n \n Download the Custom Resource Definitions (CRDs) and unpack them \n \n curl -L -C - https://raw.githubusercontent.com/entando/entando-releases/v6.3.0/dist/qs/custom-resources.tar.gz | tar -xz\n \n \n Install the Entando CRDs:  kubectl create -f dist/crd \n Deploy Your Entando Application \n You can now deploy your application to Amazon EKS. \n \n Download and unpack the  entando-helm-quickstart  release: \n \n curl -sfL https://github.com/entando-k8s/entando-helm-quickstart/archive/v6.3.0.tar.gz | tar xvz\n \n \n See the included README file for more information on the following steps. \n \n \n Go to the downloaded directory \n \n cd entando-helm-quickstart-6.3.0\n \n \n \n Edit  values.yaml  in the root directory: \n \n Set  supportOpenshift: false \n Set  singleHostName  to the value of the  EXTERNAL-IP  of your  ingress-nginx-controller :\n \n For example:  singleHostName: ad234bd11a1ff4dadb44639a6bbf707e-0e0a483d966405ee.elb.us-east-2.amazonaws.com \n \n \n Configure nginx as the ingress controller and enable file system groups for persistent volume access:\n \n ENTANDO_INGRESS_CLASS: "nginx" \n ENTANDO_REQUIRES_FILESYSTEM_GROUP_OVERRIDE: "true" \n \n \n See  Appendix B  for an example values.yaml \n \n \n \n Create the Entando namespace:  kubectl create namespace entando \n \n \n Run helm to generate the template file: \n \n \n helm template my-eks-app --namespace=entando ./ > my-eks-app.yaml\n \n \n Deploy Entando via  kubectl create -f my-eks-app.yaml \n Watch Entando startup  kubectl get pods -n entando --watch \n Check for the Entando ingresses using  kubectl describe ingress -n entando \n Access your app on the url for the ingress of the app builder. This will be the URL of your load balancer followed by  /app-builder  or  /entando-de-app  for the deployed application, e.g.  http://ad234bd11a1ff4dadb44639a6bbf707e-0e0a483d966405ee.elb.us-east-2.amazonaws.com/app-builder \n Appendix A - Troubleshooting \n IAM And Roles \n \n https://docs.aws.amazon.com/eks/latest/userguide/install-aws-iam-authenticator.html \n https://stackoverflow.com/questions/56863539/getting-error-an-error-occurred-accessdenied-when-calling-the-assumerole-oper \n \n NGINX \n \n https://docs.nginx.com/nginx/deployment-guides/amazon-web-services/ingress-controller-elastic-kubernetes-services/ \n Issue with permissions for NGINX ingress: \n \n  Warning  SyncLoadBalancerFailed   38m                 service-controller  (combined from similar events): Error syncing load balancer: failed to ensure load balancer: error creating\n Appendix B - Example values.yaml file for Helm Quickstart \n In the example below the application will deploy with embedded databases and will use  nginx \nas the ingress controller. Replace  <YOUR-DOMAIN>  with the domain you\'ve configured for your cluster. \n app:\n name: quickstart\n dbms: none\noperator:\n supportOpenshift: false\n env:\n   ENTANDO_DOCKER_IMAGE_VERSION_FALLBACK: 6.0.0\n   #ENTANDO_DOCKER_REGISTRY_OVERRIDE: docker.io # Remove comment if you want to always use a specific docker registry\n   #ENTANDO_DOCKER_IMAGE_ORG_OVERRIDE: entando # Remove the comment if you want to always use a specific docker organization\n   ENTANDO_DEFAULT_ROUTING_SUFFIX: <YOUR-DOMAIN>\n   ENTANDO_POD_READINESS_TIMEOUT_SECONDS: "1000"\n   ENTANDO_POD_COMPLETION_TIMEOUT_SECONDS: "1000"\n   ENTANDO_DISABLE_KEYCLOAK_SSL_REQUIREMENT: "true"\n   ENTANDO_K8S_OPERATOR_IMPOSE_DEFAULT_LIMITS: "false"\n   ENTANDO_REQUIRES_FILESYSTEM_GROUP_OVERRIDE: "true"\n   ENTANDO_INGRESS_CLASS: "nginx"\n tls:\n   caCrt:\n   tlsCrt:\n   tlsKey:\ndeployPDA: false\n\n \n '},{title:"Connect to an External Keycloak Instance",frontmatter:{},regularPath:"/v6.3/tutorials/devops/external-keycloak/",relativePath:"v6.3/tutorials/devops/external-keycloak/README.md",key:"v-483bee76",path:"/v6.3/tutorials/devops/external-keycloak/",headers:[{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Get keycloak information",slug:"_1-get-keycloak-information"},{level:3,title:"2. Generate the secret",slug:"_2-generate-the-secret"},{level:3,title:"3. Upload the secret",slug:"_3-upload-the-secret"},{level:3,title:"4. Deploy the Entando6 application",slug:"_4-deploy-the-entando6-application"},{level:2,title:"Conclusion",slug:"conclusion"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:' Connect to an External Keycloak Instance \n Purpose \n This tutorial enables the Entando administrator to leverage an existing\nKeycloak instance. \n Requirements \n \n \n A Keycloak instance \n \n \n A realm named "entando" on that instance \n \n \n An admin user for the "entando" realm \n Steps \n 1. Get keycloak information \n Retrieve the relevant information from the Keycloak instance you want to\nuse. \n Specifically you will need: \n \n \n The username of the Keycloak admin that has admin rights to the\n"entando" realm, e.g entando-keycloak-admin \n \n \n The Keycloak admin password, e.g. password123 \n \n \n The base url for the Keycloak server, including the auth value, e.g.\n https://my-keycloak-instance.com/auth \n 2. Generate the secret \n You now need to generate a secret with name  keycloak-admin-secret \nusing the information retrieved from step 1. The Entando administrator\nwill automatically detect this secret by name, and use it to log onto\nthe provided Keycloak server. \n Here is an example of the secret you will need to construct: \n ---\napiVersion: v1\nstringData:\n    username: <the username of the Keycloak admin user for the "entando" realm>\n    password: <the password of this Keycloak admin user>\n    url: <the base url of the Keycloak service, typically ending with the path /auth>\nkind: Secret\nmetadata\n    name: keycloak-admin-secret\n    namespace: <your-app-namespace>\ntype: Opaque\n \n \n Note \n To encode your values, in bash, you can do\n echo <your-value> | base64 \n 3. Upload the secret \n Next upload the secret to the namespace where you want to deploy your\nEntando 6 instance. \n oc create -f my-secret.yaml -n <my-app-namespace>\n 4. Deploy the Entando6 application \n Now you are ready to deploy your Entando 6 application and the\nadministrator will reuse the  keycloak-admin-secret  secret to populate\nthe environment correctly. \n Conclusion \n You should now have a working Entando 6 instance using an external\nKeycloak server. \n'},{title:"Installation on Google Kubernetes Engine (GKE)",frontmatter:{sidebarDepth:2},regularPath:"/v6.3/tutorials/devops/installation/google-cloud-platform/",relativePath:"v6.3/tutorials/devops/installation/google-cloud-platform/README.md",key:"v-b6142aea",path:"/v6.3/tutorials/devops/installation/google-cloud-platform/",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Cluster Setup",slug:"cluster-setup"},{level:3,title:"Setup and Connect to the Cluster",slug:"setup-and-connect-to-the-cluster"},{level:3,title:"Install the NGINX Ingress Controller",slug:"install-the-nginx-ingress-controller"},{level:3,title:"Verify the NGINX Ingress install",slug:"verify-the-nginx-ingress-install"},{level:3,title:"Install the Entando Custom Resource Definitions (CRDs)",slug:"install-the-entando-custom-resource-definitions-crds"},{level:2,title:"Deploy Your Entando Application",slug:"deploy-your-entando-application"},{level:3,title:"Setup and Deploy",slug:"setup-and-deploy"},{level:3,title:"Quickstart with Embedded Databases",slug:"quickstart-with-embedded-databases"},{level:3,title:"External Database",slug:"external-database"},{level:2,title:"Appendix A - Cluster Sizing",slug:"appendix-a-cluster-sizing"},{level:3,title:"Updating the Nodes in Your Cluster",slug:"updating-the-nodes-in-your-cluster"},{level:2,title:"Appendix B - Example values.yaml file for Helm Quickstart",slug:"appendix-b-example-values-yaml-file-for-helm-quickstart"}],lastUpdated:"4/23/2021, 4:16:15 AM",lastUpdatedTimestamp:1619165775e3,content:' Installation on Google Kubernetes Engine (GKE) \n Prerequisites \n \n Google Cloud account:  http://cloud.google.com/ \n Install these tools locally if you\'re not using the Google Cloud Shell steps below:\n \n Google Cloud SDK  including gcloud \n kubectl  command line tool \n Cluster Setup \n These steps only need to be completed once per cluster. \n Setup and Connect to the Cluster \n \n Login to your Google Cloud account:  https://cloud.google.com/ \n Go to  Kubernetes Engine → Clusters → Create Cluster \n Select the  Configure  button under the  Standard  option \n Enter a name and select a  Location type \n \n The  Location type  settings are up to you. The defaults are fine for an initial test. \n \n \n Select  1.18.16-gke.502  for the  Master version \n On the left menu select  default-pool \n Under  Size  set the  Number of nodes  entry to 5.  (See  Appendix A  for details.) \n Click  Create \n Wait for the cluster to initialize. This will take a few minutes. There will be a green check mark when complete. \n Click  Connect  for your new cluster. \n Click  Run in Cloud Shell \n \n Alternatively, copy the provided command and execute it in your local environment to connect your local  kubectl  to your GKE cluster. \n \n \n Run  kubectl get namespaces  to verify your connection: \n \n a_user@cs-6000-devshell-vm-c34ef644-5584-4c5d-aa14-6e41af4a5c9a:~$ kubectl get namespaces\nNAME              STATUS   AGE\ndefault           Active   6m11s\nkube-node-lease   Active   6m12s\nkube-public       Active   6m12s\nkube-system       Active   6m13s\n Install the NGINX Ingress Controller \n Entando isn’t compatible out of the box  with the default ingress controller provided in GKE.\nSee here for more if you’re interested in GKE ingress:  https://cloud.google.com/kubernetes-engine/docs/concepts/ingress \n We’re going to install the NGINX ingress controller to manage the ingresses for Entando services\ndeployed by the operator. This will be a simpler and more adaptable configuration for most users and\nenvironments. Users who really need the GKE ingress controller (rare) could integrate it following\nthe instructions provided by GKE and then customize the service definition created by the Entando\noperator. \n These are the minimal instructions to prepare NGINX ingress using the Google Cloud Shell. To install it\nusing your local  kubectl  or to vary other settings please see the more detailed documents here:\n https://cloud.google.com/community/tutorials/nginx-ingress-gke  and  https://kubernetes.github.io/ingress-nginx/deploy/#gce-gke . \n \n Initialize your user as a cluster-admin: \n \n kubectl create clusterrolebinding cluster-admin-binding --clusterrole cluster-admin \\\n--user $(gcloud config get-value account)\n \n \n Install the ingress controller pods: \n \n kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/provider/cloud/deploy.yaml\n \n \n To check if the ingress controller pods have started, run the following command: \n \n    kubectl get pods -n ingress-nginx \\\n     -l app.kubernetes.io/name=ingress-nginx --watch\n \n \n Wait until the ingress-nginx-controller status changes to  Running : \n \n NAME                                        READY   STATUS      RESTARTS   AGE\ningress-nginx-admission-create-27tgt        0/1     Completed   0          65s\ningress-nginx-admission-patch-7wmgl         0/1     Completed   1          65s\ningress-nginx-controller-7656c59dc4-7xgmc   1/1     Running     0          75s\n \n \n Get the external IP address for your ingress controller. Record the value of EXTERNAL-IP for  nginx-ingress-controller  from the command below. \n \n kubectl get service -n ingress-nginx\n Verify the NGINX Ingress install \n We recommend setting up a test application so you can easily verify the ingress is working. \n \n From the  Cloud Shell,  create a simple application by running the following command: \n \n kubectl run hello-app --generator=run-pod/v1 --image=gcr.io/google-samples/hello-app:1.0 --port=8080\n \n \n Expose the  hello-app  Pod as a Service: \n \n kubectl expose pod hello-app\n \n \n Create an  ingress-resource.yaml  file with this content: \n \n apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: ingress-resource\n  annotations:\n    kubernetes.io/ingress.class: nginx\n    nginx.ingress.kubernetes.io/ssl-redirect: "false"\nspec:\n  rules:\n  - http:\n      paths:\n      - path: /hello\n        backend:\n          serviceName: hello-app\n          servicePort: 8080\n \n \n Now create the Ingress Resource using  kubectl apply -f ingress-resource.yaml \n Verify that the Ingress Resource has been created using  kubectl get ingress ingress-resource .\nIt may take a few minutes for the  Address  to be populated. \n Verify you can access the web application by going to the  EXTERNAL-IP/hello  address, using the\n Address  from the previous nginx-ingress-controller. You should see the following: \n \n Hello, world!\nVersion: 1.0.0\nHostname: hello-app\n \n Note the external IP address of your ingress controller since you’ll need it for the application configuration.\nThe Entando deployment exposes an environment variable to set the ingress controller to be used as part of the deployment. That variable is  ENTANDO_INGRESS_CLASS  and should be set to  nginx  in deployments to GKE (this is documented in the application instructions below as well) \n Install the Entando Custom Resource Definitions (CRDs) \n Once per cluster you need to deploy the  Entando Custom Resources . \n \n Download the Custom Resource Definitions (CRDs) and unpack them: \n \n curl -L -C - https://raw.githubusercontent.com/entando/entando-releases/v6.3.0/dist/qs/custom-resources.tar.gz | tar -xz\n \n \n Install the Entando CRDs:  kubectl create -f dist/crd \n Deploy Your Entando Application \n You can now deploy your Entando applications to GKE. \n Setup and Deploy \n \n Download and unpack the entando-helm-quickstart: \n \n curl -sfL https://github.com/entando-k8s/entando-helm-quickstart/archive/v6.3.0.tar.gz | tar xvz\n \n \n Change into the new directory \n \n cd entando-helm-quickstart-6.3.0\n \n \n Edit  values.yaml in the root directory:\n \n Set  supportOpenshift: false \n Set  ENTANDO_DEFAULT_ROUTING_SUFFIX  to the IP value of your  nginx  controller plus .nip.io\n \n For example:  ENTANDO_DEFAULT_ROUTING_SUFFIX: 35.223.161.214.nip.io \n We’re using  https://nip.io  because we need wildcard dns address resolution however nip.io is not required. If your enterprise has a different internal dns resolution scheme for development instances you can use that or other alternative dns services like xip.io. \n \n \n If not already present, set these values to utilize nginx as the ingress controller and file system groups for persistent volume access:\n \n ENTANDO_INGRESS_CLASS: "nginx" \n ENTANDO_REQUIRES_FILESYSTEM_GROUP_OVERRIDE: "true" \n \n \n See  Appendix B  for an example values.yaml \n \n \n Create the Entando namespace: \n \n kubectl create namespace entando\n \n \n Update helm dependencies: \n \n helm dependency update\n \n \n Run helm to generate the template file: \n \n helm template my-app --namespace=entando ./ > my-app.yaml\n \n \n Deploy Entando via \n \n kubectl create -f my-app.yaml\n \n \n Watch Entando startup \n \n kubectl get pods -n entando --watch\n \n \n Check for the Entando ingresses using \n \n kubectl describe ingress -n entando\n \n This is a snippet: \n quickstart-entando.34.71.130.61.nip.io\n                                          /entando-de-app     quickstart-server-service:8080 (10.44.2.3:8080)\n                                          /digital-exchange   quickstart-server-service:8083 (10.44.2.3:8083)\n                                          /app-builder/       quickstart-server-service:8081 (10.44.2.3:8081)\n \n \n Access Entando at the app-builder endpoint, e.g.  http://quickstart-entando.34.71.130.61.nip.io/app-builder/ \n Quickstart with Embedded Databases \n The lightest weight and fastest to deploy option for evaluation and getting started uses embedded databases for the application and Keycloak.\nTo deploy quickstart with embedded databases at the top of values.yaml add  dbms: none  under the app section in the file. See Appendix B for an example. \n External Database \n You can also use an external database instance for your application.\nThis is recommended for projects that will be developed for delivery to customers or stakeholders.\nAny dbms that is reachable from the cluster can be used. \n Example: Deploy Postgres to a Namespace on Your Cluster \n These instructions will deploy a postgres instance to a namespace in your kubernetes cluster. \n https://github.com/GoogleCloudPlatform/postgresql-docker/blob/master/9/README.md#run-a-postgresql-server-kubernetes \n \n Note: If deployed this way the address you use for the database in the helm template must be a full address rather than an IP address alone. Use the database IP plus nip.io for a dev instances \n \n Once deployed you can use the  external database instructions  to\nconnect your Entando application to your instance., \n Connect CloudSQL to GKE \n \n This link describes creating a PG instances using the GCP Cloud SQL\n \n https://cloud.google.com/sql/docs/postgres/create-instance \n \n \n Connecting from GKE to Cloud SQL\n \n https://cloud.google.com/sql/docs/postgres/connect-kubernetes-engine \n Appendix A - Cluster Sizing \n In the cluster setup instructions you set the number of nodes in your cluster to 5. This setting\nassumes the default node type with a single VCPU per instance and 3.8 GB of RAM. The kubernetes\nsystem and nginx will request approximately 1 CPU in total. The Entando application will deploy\non the remaining 4. This configuration is suitable for a development team but may need to be\nexpanded as microservices are added to the architecture. \n If you’re running other applications (like a postgres instance) in your cluster you may need\nmore nodes. \n Updating the Nodes in Your Cluster \n \n Select Kubernetes Engine from the left nav in GCP \n Select Clusters \n Hit the Edit button (pencil on the right) \n Scroll to bottom \n Click the link labeled default-pool \n Edit button at the top \n Change the nodes to the number you\'d like to include \n Save \n Wait until updated on clusters page (green checkmark on cluster) \n Appendix B - Example values.yaml file for Helm Quickstart \n In the example below the application will deploy with embedded databases and will use  nginx \nas the ingress controller. Replace  <YOUR-NGINX-IP>  with the ip address where your  nginx \ninstance is exposed on your cluster. \n app:\n name: quickstart\n dbms: none\noperator:\n supportOpenshift: false\n env:\n   ENTANDO_DOCKER_IMAGE_VERSION_FALLBACK: 6.0.0\n   #ENTANDO_DOCKER_REGISTRY_OVERRIDE: docker.io # Remove comment if you want to always use a specific docker registry\n   #ENTANDO_DOCKER_IMAGE_ORG_OVERRIDE: entando # Remove the comment if you want to always use a specific docker organization\n   ENTANDO_DEFAULT_ROUTING_SUFFIX: <YOUR-NGINX-IP>.nip.io\n   ENTANDO_POD_READINESS_TIMEOUT_SECONDS: "1000"\n   ENTANDO_POD_COMPLETION_TIMEOUT_SECONDS: "1000"\n   ENTANDO_DISABLE_KEYCLOAK_SSL_REQUIREMENT: "true"\n   ENTANDO_REQUIRES_FILESYSTEM_GROUP_OVERRIDE: "true"\n   ENTANDO_INGRESS_CLASS: "nginx"\n   ENTANDO_K8S_OPERATOR_IMPOSE_DEFAULT_LIMITS: "false"\n tls:\n   caCrt:\n   tlsCrt:\n   tlsKey:\ndeployPDA: false\n\n \n '},{title:"Installation on Red Hat OpenShift using the OperatorHub",frontmatter:{sidebarDepth:2},regularPath:"/v6.3/tutorials/devops/installation/open-shift/openshift-install-by-operator-hub.html",relativePath:"v6.3/tutorials/devops/installation/open-shift/openshift-install-by-operator-hub.md",key:"v-a2a432b4",path:"/v6.3/tutorials/devops/installation/open-shift/openshift-install-by-operator-hub.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Scenario 1.1 - Embedded Database",slug:"scenario-1-1-embedded-database"},{level:2,title:"Scenario 1.2 - PostgreSQL",slug:"scenario-1-2-postgresql"},{level:2,title:"Scenario 1.3 - PostgreSQL plus OpenShift SSL",slug:"scenario-1-3-postgresql-plus-openshift-ssl"},{level:2,title:"Scenario 1.4 - PostgreSQL plus self-signed SSL",slug:"scenario-1-4-postgresql-plus-self-signed-ssl"},{level:2,title:"Scenario 1.5 - Cluster-scoped operator with wildcard SSL",slug:"scenario-1-5-cluster-scoped-operator-with-wildcard-ssl"},{level:2,title:"Scenario 2.1 - Developer Project",slug:"scenario-2-1-developer-project"},{level:2,title:"Next Steps",slug:"next-steps"}],lastUpdated:"4/5/2021, 5:21:23 PM",lastUpdatedTimestamp:1617657683e3,content:" Installation on Red Hat OpenShift using the OperatorHub \n Overview \n The following tutorial shows how to install an Entando application using the Red Hat-certified  Entando Operator  and covers a few common enterprise configurations. If you're working with an OpenShift version prior to 4.6 then you may require the alternative  manual instructions . \n We have two sets of scenarios listed below: \n \n Scenario 1.1-1.5 for cluster admins who can create projects and operators \n Scenario 2.1 for a user with access to administer a project. \n \n Scenario 1.1 is similar to the Entando quickstart style of deployment which can be applied in many environments, including on local developer laptops. The subsequent scenarios (1.2-1.5) build on that initial setup but can be performed independently if desired. Unless otherwise noted, you have the freedom to keep or modify the default options when installing the  Entando Operator  and other resources in the tutorials. \n Prerequisites \n \n A 4.6 (or higher) OpenShift installation\n \n For simplicity the tutorial instructions are for a local Code Ready Containers (CRC) instance but this will require significant dedicated resources, e.g. at least 4 vCPU and 10GB RAM. In some environments you may need to start CRC using  crc start -n 8.8.8.8  in order to install operators. \n \n \n (For scenarios 1.x) cluster-admin access to OpenShift for initial installation of the Entando Operator \n (For scenarios 2.x) namepace-level access to a specific OpenShift project for installation of an Entando application using an Entando Operator installed in the cluster \n Familiarity with the OpenShift console and operation \n Scenario 1.1 - Embedded Database \n The initial scenario is to deploy the operator and Entando application in a single namespace. We'll start with the smallest application footprint which uses an embedded database. \n \n Locate the  Entando Operator  in the  Operators → OperatorHub  using the Filter feature. \n Click  Install  to view the  Entando Operator  install options. \n Select  A specific namespace on the cluster  for the  Installation mode . \n Choose an empty namespace for  Installed Namespace . You can create one from  Home → Projects  first, if needed, e.g.  entando-one . \n Click  Install  to install the operator into your target namespace. \n The install may take a few minutes to complete after which you can click  View Operator  to see the operator in your namespace, or you can go to  Operators → Installed Operators  at any point and select it from there. \n Now go to  Entando Composite Application  and click  Create instance \n Change the  Dbms Override  to  embedded . This is the lightest and quickest way to test a full Entando application but you'll need to modify the YAML as well in step 10. \n (Optional) If you're working in anything but a single project environment, you'll need to provide an  Ingress Host Name Override  specific to your namespace, e.g.  entando-one.<my-base-openshift-url>.  In CRC you can keep the default  entando.apps-crc.testing  for your first project. \n Switch to the YAML view and remove the following section since it isn't needed with an embedded database. \n \n     - kind: EntandoDatabaseService\n      metadata:\n        name: inline-entando-database-service\n      spec:\n        createDeployment: true\n \n \n (Optional) Feel free to edit the YAML to customize the names of the components deployed by the EntandoCompositeApp, e.g.  inline-entando-database-service \n Click  Create . The  Entando Operator  will now proceed to deploy the appropriate resources. \n Go to  Entando Composite Application → my-entando-composite-app  to check the status of the deploy or its  Events  tab to follow its progress. \n \n See the  Next Steps  below to continue your work with Entando. \n Scenario 1.2 - PostgreSQL \n For this scenario we'll prepare a more production-like configuration. Here we'll switch from an embedded on-disk database to a dedicated PostgreSQL database. For this scenario we'll start where step 6 ends in the previous scenario. If you already ran Scenario 1.1 you can either go to that project and remove the Composite App via  Installed Operators → Entando Operator → Entando Composite Application  or prepare a new project using steps 1-5 above. \n Now let's create a new application, this time using PostgreSQL. \n \n Go to  Entando Composite Application  and click  Create instance \n Keep the default  Dbms Override  as  postgresql . You should not remove the EntandoDatabaseService in this case. \n (Optional) Set the  Ingress Host Name Override  as in step 9 above. \n Click  Create . The  Entando Operator  will now proceed to deploy the appropriate resources just as in Scenario 1.1 but with the addition of a PostgreSQL database deployment. \n \n See the  Next Steps  below to continue your work with Entando. \n Scenario 1.3 - PostgreSQL plus OpenShift SSL \n For this scenario we'll build on Scenario 1.2 but enable SSL using OpenShift's internal Certificate Authority. As a starting point, you can either remove the Composite App from the previous scenarios or prepare a new project per steps 1-5 in Scenario 1.1. \n \n Using your browser, examine and save the SSL certificate for your environment. For example, in Chrome, go to any OpenShift console page, click on  View Site Information  next to the URL (it may be labeled  Not secure  ) then go to  Details -> Copy to File  and save the certificate as a Base-64 encoded X.509 file, e.g.  openshift.cer. \n Go to  Workflows → Secrets → Create  and select  Key/value secret \n Set the  Secret Name , e.g.  entando-ca-cert-secret \n Set the  Key , e.g.  openshift.cer \n Set the  Value  by clicking  Browse...  and loading the file you saved in Step 1. \n Click  Create \n Next go to  Workloads → ConfigMaps  and create a ConfigMap named  entando-operator-config  This is the ConfigMap used by the Operator to configure the deployments. You'll need to supply your own project name for the namespace. \n \n kind: ConfigMap\napiVersion: v1\nmetadata:\n name: entando-operator-config\n namespace: entando-one\ndata:\n entando.ca.secret.name: entando-ca-cert-secret\n entando.use.auto.cert.generation: 'true'\n \n \n Click  Create \n \n Now let's create a new application, just like in Scenario 1.2 but with OpenShift SSL in place. \n \n Go to  Entando Composite Application  and click  Create instance \n Keep the default  Dbms Override  as  postgresql . \n (Optional) Set the  Ingress Host Name Override  as in Scenario 1 step 9. \n You don't need to set the  TLS Secret Name Override  since it will be taken from the  entando-operator-config  ConfigMap. \n Click  Create . The  Entando Operator  will now proceed to deploy the appropriate resources. \n \n Once the deployment is complete you can confirm that all routes use https with OpenShift's CA. You will likely still see security warnings in the browser. \n See the  Next Steps  below to continue your work with Entando. \n Scenario 1.4 - PostgreSQL plus self-signed SSL \n This scenario is similar to Scenario 1.3 but here we'll use a self-signed certificate rather than using OpenShift's Certificate Authority. As a starting point, you can either remove the Composite App from the previous scenarios or prepare a new project per steps 1-5 in Scenario 1.1. \n We'll start by creating a self-signed certificate and then preparing the Secrets and ConfigMap to match. There are various ways to create an X.509 self-signed certificate and you can use your own preferred mechanism. \n \n Using  OpenSSL  create a certificate for your application. You'll need to adjust the CN value to match your project. \n \n openssl req -nodes -x509 -newkey rsa:4096 -keyout tls.key -out tls.crt -days 365 -subj \"/CN=entando.apps-crc.testing\"\n \n You should see output similar to this: \n Generating a RSA private key\n.....................................................................++++\n........................................................................................................................................................................................++++\nwriting new private key to 'tls.key'\n-----\n \n Now we can create a TLS Secret using the generated files. \n \n Go to  Workloads → Secrets → Create  and select  From YAML . \n Enter this  YAML , update the namespace to match your project, and click  Create : \n \n kind: Secret\napiVersion: v1\nmetadata:\n  name: entando-tls-secret\n  namespace: entando-one\ndata:\n  tls.key: ''\n  tls.crt: ''\ntype: kubernetes.io/tls\n \n \n Click on  Actions → Edit Secret  and use the  Browse...  buttons to upload the key and cert files. \n \n Now we'll also create the  entando-ca-cert-secret  Secret, similar to what was done in Scenario 1.3 but now using the self-signed certificate. \n \n Go to  Workflows → Secrets → Create  and select  Key/value secret \n Set the  Secret Name , e.g.  entando-ca-cert-secret \n Set the  Key , e.g.  cert1.crt \n Set the  Value  by clicking  Browse...  and loading the cert file from Step 1, e.g.  tls.crt \n Click  Create \n Next go to  Workloads → ConfigMaps  and create a ConfigMap named  entando-operator-config.  This is the ConfigMap used by the Operator to configure the deployments. You'll need to supply your own project name for the namespace. \n \n kind: ConfigMap\napiVersion: v1\nmetadata:\n name: entando-operator-config\n namespace: entando-one\ndata:\n entando.ca.secret.name: entando-ca-cert-secret\n entando.tls.secret.name: entando-tls-secret\n \n \n Click  Create \n \n Now let's create a new application, just like in Scenario 1.3 but with the self-signed SSL certificate. \n \n Go to  Entando Composite Application  and click  Create instance \n Keep the default  Dbms Override  as  postgresql . \n (Optional) Set the  Ingress Host Name Override  as in Scenario 1.1 step 9. \n You don't need to set the  TLS Secret Name Override  since it will be taken from the  entando-operator-config  ConfigMap. \n Click  Create . The  Entando Operator  will now proceed to deploy the appropriate resources. \n \n Once the deployment is complete you can confirm that all routes use https with the self-signed certificate. You will still see security warnings in the browser. \n See the  Next Steps  below to continue your work with Entando. \n Scenario 1.5 - Cluster-scoped operator with wildcard SSL \n For this scenario we'll install the Entando Operator so the same operator instance can manage applications across namespaces. \n \n Locate the  Entando Operator  in the  Operators → OperatorHub  using the Filter feature. \n Click  Install  to view the  Entando Operator  install options. \n Select  All namespaces on the cluster  for the  Installation mode . \n Keep the default  openshift-operators  for the  Installed Namespace . \n Click  Install  to install the operator into the cluster. \n \n Now, similar to Scenario 1.4, we'll setup a self-signed certificate but this time as a wildcard certificate and then configure the Secrets and ConfigMap to match. There are various ways to create an X.509 self-signed certificate and you can use your own preferred mechanism. \n \n Using  OpenSSL  create a certificate for your application. You'll need to adjust the CN value to match your environment but make sure to include the leading  *.  for the wildcard designation. \n \n openssl req -nodes -x509 -newkey rsa:4096 -keyout tls.key -out tls.crt -days 365 -subj \"/CN=*.apps-crc.testing\"\n \n You should see output similar to this: \n Generating a RSA private key\n.....................................................................++++\n........................................................................................................................................................................................++++\nwriting new private key to 'tls.key'\n-----\n \n Now we can go to the  openshift-operators  project and create a TLS Secret using the generated files. \n \n Go to  Workloads → Secrets → Create  and select  From YAML . \n Enter this  YAML  and click  Create : \n \n kind: Secret\napiVersion: v1\nmetadata:\n  name: entando-tls-secret\n  namespace: openshift-operators\ndata:\n  tls.key: ''\n  tls.crt: ''\ntype: kubernetes.io/tls\n \n \n Click on  Actions → Edit Secret  and use the  Browse...  buttons to upload the key and cert files. \n \n Now we'll also create the  entando-ca-cert-secret  Secret using the self-signed wildcard certificate. \n \n Go to  Workflows → Secrets → Create  and select  Key/value secret \n Set the  Secret Name , e.g.  entando-ca-cert-secret \n Set the  Key , e.g.  cert1.crt \n Set the  Value  by clicking  Browse...  and loading the cert file from Step 1, e.g.  tls.crt \n Click  Create \n Next go to  Workloads → ConfigMaps  and create a ConfigMap named  entando-operator-config.  This is the ConfigMap used by the Operator to configure the deployments. You'll need to supply the routing suffix for your environment. Don't include a leading  *.  since this is just the suffix. \n \n kind: ConfigMap\napiVersion: v1\nmetadata:\n name: entando-operator-config\n namespace: openshift-operators\ndata:\n entando.ca.secret.name: entando-ca-cert-secret\n entando.tls.secret.name: entando-tls-secret\n entando.default.routing.suffix: apps-crc.testing \n \n \n Click  Create \n You can now proceed to create one or more Entando applications in their own namespaces, e.g. using the steps for Scenario 1.1 starting from Step 7 or as a different user in Scenario 2.1. You can leave out the  Ingress Host Name Override  since the cluster-scoped operator will provide it for you based on the routing.suffix. \n \n See the  Next Steps  below to continue your work with Entando. \n Scenario 2.1 - Developer Project \n For this scenario we'll use the cluster-installed Entando Operator to install an Entando application by individually creating each of its elements. This is much like what is done in Scenarios 1.1-1.2 but gives you greater control of the overall setup of the application. The prerequisites are that the Operator was installed in the cluster and that you have access to your own project. \n First we'll start by creating the database for the application. \n \n Go to  Installed Operators , make sure you've selected your own Project, e.g.  entando-two , and and then go to  Provided APIs → Entando Database Service  and click  Create EntandoDatabaseService. \n \n The default settings work fine for this step. They include creating the deployment and using PostgresSQL for the DBMS. If you examine the YAML it looks something like this: \n apiVersion: entando.org/v1\nkind: EntandoDatabaseService\nmetadata:\n  namespace: entando-two\n  name: my-entando-database-service\nspec:\n  createDeployment: true\n  dbms: postgresql\n  databaseName: my_database\n \n \n Click  Create.  The operator will now create the deployment and resources needed for the database. \n \n Next let's setup the Keycloak server for identity management. \n \n Similar to Step 1, go to  Installed Operators -> Select your project (if needed) → Provided APIs → Entando Keycloak Server  and click  Create EntandoKeycloakServer. \n (Optional) Select a  TLS Secret  to secure the service, e.g  entando-tls-secret  per Scenario 1.5. \n (Optional) Set the  Ingress Host Name  for your project, e.g.  entando-two.<my-base-openshift-url> \n Click  Create \n \n Once the deployment is complete you can check  Networking → Routes  to find the URL for the new Keycloak if you didn't specify the  Ingress Host Name , e.g.  my-keycloak-entando-two.apps-crc.testing/auth/ . The generated admin credentials can be found under  Workloads → Secrets , e.g.  my-keycloak-admin-secret \n Next we'll prepare the infrastructure service. \n \n Go to  Installed Operators -> Select your project (if needed) → Provided APIs → Entando Cluster Infrastructure  and click  Create EntandoClusterInfrastructure. \n (Optional) Set the  Ingress Host Name , e.g.  entando-two.<my-base-openshift-url> \n (Optional) If you chose to apply a  TLS Secret  in Step 4 then you'll want to do the same here by setting the  TLS Secret Name , e.g.  entando-tls-secret. \n Click  Create \n \n Now we'll create the application itself. \n \n Go to  Installed Operators -> Select your project (if needed) → Provided APIs → CLick on View more (if needed) -> EntandoApp  and click  Create instance. \n (Optional) Set the  Ingress Host Name , e.g.  entando-two.<my-base-openshift-url> \n (Optional) If you chose to apply a  TLS Secret  in Step 4 then you'll want to do the same here by setting the  TLS Secret Name , e.g.  entando-tls-secret. \n \n See the  Next Steps  below to continue your work with Entando. \n Next Steps \n Once you've completed any of the scenarios above, you have several options. \n \n Check out  Networking → Routes  to see the URLs for the running services. Common starting points include the  Entando App Builder  (e.g.  http://entando.apps-crc.testing/app-builder/ ) or  Entando application  itself (e.g.  http://entando.apps-crc.testing/entando-de-app/ ). \n This suggested  list of next steps  could also be useful. \n \n"},{title:"Installation on OpenShift",frontmatter:{sidebarDepth:2},regularPath:"/v6.3/tutorials/devops/installation/open-shift/openshift-install.html",relativePath:"v6.3/tutorials/devops/installation/open-shift/openshift-install.md",key:"v-1f0dbe86",path:"/v6.3/tutorials/devops/installation/open-shift/openshift-install.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Local Installation",slug:"local-installation"},{level:3,title:"Install the Entando Custom Resource Definitions (CRDs)",slug:"install-the-entando-custom-resource-definitions-crds"},{level:3,title:"Get your Cluster Default Ingress",slug:"get-your-cluster-default-ingress"},{level:3,title:"Setup and Deploy",slug:"setup-and-deploy"},{level:2,title:"Appendix A - Troubleshooting and Common Errors",slug:"appendix-a-troubleshooting-and-common-errors"},{level:3,title:"Permission Errors",slug:"permission-errors"},{level:3,title:"Forbidden Error installing Entando Custom Resource Definitions in Minishift or CRC",slug:"forbidden-error-installing-entando-custom-resource-definitions-in-minishift-or-crc"},{level:3,title:"Application is not available when accessing app builder",slug:"application-is-not-available-when-accessing-app-builder"},{level:3,title:"Network Issues",slug:"network-issues"},{level:2,title:"Appendix B - Example values.yaml file for Helm Quickstart",slug:"appendix-b-example-values-yaml-file-for-helm-quickstart"}],lastUpdated:"3/31/2021, 10:45:23 AM",lastUpdatedTimestamp:1617201923e3,content:' Installation on OpenShift \n Overview \n This tutorial shows how to manually install Entando into OpenShift 3.11 or 4.x. If you\'re working with OpenShift 4.6+ then you also have the option of using the Red Hat-certified Entando Operator which should be available in your OperatorHub thanks to the Red Hat Marketplace. See  this tutorial  for instructions specific to the  Entando Operator. \n Prerequisites \n \n An OpenShift installation (3.11 or 4.x) \n oc  command line tool \n A helm 3 client \n Local Installation \n If you want to run OpenShift in your local development environment you can run Minishift (OpenShift 3.11) or Code Ready Containers (OpenShift 4). Use the local development version that matches the cluster where you intend to deploy your application. \n For Minishift:  https://docs.okd.io/3.11/minishift/getting-started/installing.html \n For CRC:  https://developers.redhat.com/products/codeready-containers/download \n Once you\'ve completed the installation above capture the local IP address of your development instance using  minishift ip  or  crc ip . You\'ll need it when configuring your Entando application. \n Login to your OpenShift environment from the command line with  oc login  using the URL and credentials for your cluster. \n Install the Entando Custom Resource Definitions (CRDs) \n Once per cluster you need to deploy the  Entando Custom Resources . This is the only step in this guide that requires cluster level access. If you are running on Minishift or CRC make sure you are connected using the administrator login provided when you started your local instance. \n \n Download the Custom Resource Definitions (CRDs) and unpack them: \n \n curl -L -C - https://raw.githubusercontent.com/entando/entando-releases/v6.3.0/dist/qs/custom-resources.tar.gz | tar -xz\n \n \n Install the Entando CRDs: \n \n oc create -f dist/crd\n Get your Cluster Default Ingress \n If you\'re deploying on a managed cluster get the default hostname from your cluster administrator. Entando uses wildcard addressing to connect different parts of your Entando application and the default route for applications exposed on your cluster is needed. You\'ll set this value in step 3 below. \n Setup and Deploy \n \n Download and unpack the entando-helm-quickstart release you want to use from here:\n https://github.com/entando-k8s/entando-helm-quickstart/releases \n \n \n See the included README file for more information on the following steps. \n \n curl -sfL https://github.com/entando-k8s/entando-helm-quickstart/archive/v6.3.0.tar.gz | tar xvz\n \n \n Change into the new directory \n \n cd entando-helm-quickstart-6.3.0\n \n \n Edit  values.yaml in the root directory:\n \n Set  supportOpenshift: true \n If you\'re deploying to a managed cluster:\n \n Set  ENTANDO_DEFAULT_ROUTING_SUFFIX  to the default URL of applications deployed in your OpenShift cluster. If you\'re unsure of this value, please check with your cluster administrator for this URL. \n Entando will create applications using that default URL and relies on wildcard DNS resolution. \n \n \n If you\'re using Minishift or CRC:\n \n Set  ENTANDO_DEFAULT_ROUTING_SUFFIX  to the value from  minishift ip  or  crc ip  plus  nip.io . For example,  ENTANDO_DEFAULT_ROUTING_SUFFIX: 192.168.64.10.nip.io \n \n \n See  Appendix B  for an example values.yaml \n \n \n Create the Entando namespace: \n \n oc new-project entando\n \n \n Update helm dependencies: \n \n helm dependency update\n \n \n Run helm to generate the template file: \n \n helm template my-app --namespace=entando ./ > my-app.yaml\n \n \n If you\'re using Helm 2 instead of Helm 3, then replace  helm template my-app  with  helm template --name=my-app \n \n \n Deploy Entando via \n \n oc create -f my-app.yaml\n \n \n If you see this error  no matches for kind "Deployment" in version "extensions/v1beta1" , then you\'ll need to edit my-app.yaml and set  apiVersion: "apps/v1"  for the Deployment. \n \n \n Watch Entando startup \n \n oc get pods -n entando --watch\n \n \n This step is complete when the  quickstart-server  pod shows 3/3 running. For example, \n \n quickstart-server-deployment-6c89fb49f7-gpmqc   3/3   Running   0     72s\n \n \n The full pod name will differ but by default will start with  quickstart-server-deployment . \n \n \n Check for the Entando ingresses using  oc describe ingress -n entando . This is a snippet: \n \n Name:             quickstart-ingress\nNamespace:        entando\nAddress:          \nDefault backend:  default-http-backend:80 (<none>)\nRules:\n  Host                                 Path  Backends\n  ----                                 ----  --------\n  quickstart-entando.192.168.64.10.nip.io  \n                                       /entando-de-app     quickstart-server-service:8080 (<none>)\n                                       /digital-exchange   quickstart-server-service:8083 (<none>)\n                                       /app-builder/       quickstart-server-service:8081 (<none>)\n \n The host path in the configuration above plus  /app-builder/  (trailing slash is important) will allow you to log into your environment. For example,\n http://quickstart-entando.192.168.64.10.nip.io/app-builder/ \n Appendix A - Troubleshooting and Common Errors \n Permission Errors \n If you get OpenShift permission errors deploying your Entando application into your OpenShift namespace make sure your user has the  escalate  and  bind  verbs on Roles in the namespace you\'re deploying to. Ultimately you need this command to  oc auth can-i escalate role  to return  yes . That access is only required in the namespace where you are deploying your Entando application. No cluster level access is required. \n Check with your cluster administrator if you need help assigning these roles. Generally this requires the creation of a role with those permissions, preferably a ClusterRole, and then depending on how administrators manage security your Entando installer needs to be given that role in the target namespace. So let\'s assume the clusterRole we create is  entando-installer  and the user\'s name is john, on OpenShift creating the rolebinding would be:\n oc policy add-role-to-user entando-installer john -n <your-namespace> \n Before installing, we suggest running  oc auth can-i escalate role  with your given user in the targeted namespace. If it says "yes" you should be able to install. \n Forbidden Error installing Entando Custom Resource Definitions in Minishift or CRC \n If you get an error like the one below installing the CRDs in your local instance you need to login using the administrator role. \n /opt/ocInstallLocal$ oc create -f dist/crd/\nError from server (Forbidden): error when creating "dist/crd/EntandoAppCRD.yaml": customresourcedefinitions.apiextensions.k8s.io is forbidden: User "developer" cannot create resource "customresourcedefinitions" in API group "apiextensions.k8s.io" at the cluster scope\n \n The administrator credentials are printed when you started your local cluster in a message like this one: \n To access the cluster, first set up your environment by following \'crc oc-env\' instructions\nINFO Then you can access it by running \'oc login -u developer -p developer https://api.crc.testing:6443\'\nINFO To login as an admin, username is \'kubeadmin\' and password is xxxx-xxxx-xxxx-xxxx\n Application is not available when accessing app builder \n If you get the message "Application is not available" when accessing the app-builder make sure to include a trailing slash in the URL. For example,\nhttp://quickstart-entando.192.168.64.10.nip.io/app-builder/ \n Network Issues \n If you see errors when images are being retrieved (resulting in errors like ErrImagePull or ImagePullBackOff), you may want to start crc using  crc start -n "8.8.8.8  or configure the nameserver using  crc config set nameserver 8.8.8.8  before running  crc start . This will allow the cluster to perform DNS lookups via Google\'s public DNS server. \n If you\'re on Windows, you should also check out the notes  here  since Minishift and CRC rely on Windows Hyper-V by default. This can result in network issues when the host computer is restarted. \n Appendix B - Example values.yaml file for Helm Quickstart \n The example below includes configuration for deployment on a locally installed instance: \n app:\n  name: quickstart\n  dbms: none\n#externalDatabase:\n host: some.db.host\n port: 32432\n databaseName: sampledb\n username:\n password:\noperator:\n  supportOpenshift: true\n  env:\n    ENTANDO_DOCKER_IMAGE_VERSION_FALLBACK: 6.0.0\n    #ENTANDO_DOCKER_REGISTRY_OVERRIDE: docker.io # Remove comment if you want to always use a specific docker registry\n    #ENTANDO_DOCKER_IMAGE_ORG_OVERRIDE: entando # Remove the comment if you want to always use a specific docker organization\n    ENTANDO_DEFAULT_ROUTING_SUFFIX: 192.168.64.10.nip.io\n    ENTANDO_POD_READINESS_TIMEOUT_SECONDS: "1000"\n    ENTANDO_POD_COMPLETION_TIMEOUT_SECONDS: "1000"\n    ENTANDO_DISABLE_KEYCLOAK_SSL_REQUIREMENT: "true"\n    ENTANDO_K8S_OPERATOR_IMPOSE_DEFAULT_LIMITS: "false"\n    ENTANDO_K8S_OPERATOR_FORCE_DB_PASSWORD_RESET: "true"\n  tls:\n    caCrt:\n    tlsCrt:\n    tlsKey:\ndeployPDA: false\n \n '},{title:"Use Blueprint Generated Plugin and Micro Frontends Without a Bundle",frontmatter:{},regularPath:"/v6.3/tutorials/ecr/deploy-components-without-bundle.html",relativePath:"v6.3/tutorials/ecr/deploy-components-without-bundle.md",key:"v-856d3940",path:"/v6.3/tutorials/ecr/deploy-components-without-bundle.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Steps",slug:"steps"},{level:2,title:"1. Generate a docker image for your microservice",slug:"_1-generate-a-docker-image-for-your-microservice"},{level:2,title:"2. Publish the Docker image to Docker registry (DockerHub or equivalent)",slug:"_2-publish-the-docker-image-to-docker-registry-dockerhub-or-equivalent"},{level:2,title:"3. Deploy the plugin into your Entando cluster",slug:"_3-deploy-the-plugin-into-your-entando-cluster"},{level:2,title:"4. Wait for your plugin to be in Running state and link the plugin with the app using an EntandoAppPluginLink custom resource",slug:"_4-wait-for-your-plugin-to-be-in-running-state-and-link-the-plugin-with-the-app-using-an-entandoapppluginlink-custom-resource"},{level:2,title:"5. Upload the micro frontends to your Entando App",slug:"_5-upload-the-micro-frontends-to-your-entando-app"},{level:2,title:"6. Use the microfrontend and microservice",slug:"_6-use-the-microfrontend-and-microservice"}],lastUpdated:"12/8/2021, 3:22:31 PM",lastUpdatedTimestamp:1638994951e3,content:' Use Blueprint Generated Plugin and Micro Frontends Without a Bundle \n Overview \n In this tutorial you will learn how to use the plugin and microfrontend generated using the Entando Blueprint in a running cluster without the need to include the components in a bundle. \n If you haven\'t already generated a plugin and micro frontends with the Component Generator go here first  Generate a Plugin \n Prerequisites \n \n \n An Entando Plugin built with the Entando Component Generator and populated with micro frontends \n \n \n Node and NPM are installed on your machine (use LTS version) \n \n \n Docker is installed on your machine and you are able to upload images to docker-hub or an image repository of your choice \n \n \n An installed instance of the Entando platform running Kubernetes. See  Getting Started \n Steps \n 1. Generate a docker image for your microservice \n JHipster uses the JIB Maven plugin to generate a docker image for your\nmicroservice. \n The name of the output image generated with JIB will be composed by: \n \n The organization you chose during the setup wizard (by default that\'s set to  entando ) \n The name of the application \n Version  0.0.1-SNAPSHOT \n \n You can build the docker image with this command \n ./mvnw -Pprod clean package jib:dockerBuild\n \n If for example during setup wizard you chose a custom organization  myorg  and the set the application name to  jhipster  the resulting docker image is going to be  myorg/jhipster:0.0.1-SNAPSHOT \n \n Note \n The output image name can be changed in the  pom.xml  file by configuring\nthe  plugins.plugin.jib-maven-plugin.configuration.to.image  tag \n \n  <plugin>\n   <groupId>com.google.cloud.tools</groupId>\n   <artifactId>jib-maven-plugin</artifactId>\n   <configuration>\n     \x3c!-- ... --\x3e\n     <to>\n       <image>\x3c!-- use a custom value here --\x3e</image>\n     </to>\n     \x3c!-- ... --\x3e\n   </configuration>\n </plugin>\n \n \n Note \n Output image name can also be set by customizing the  ./mvnw  command using the  -Djib.to.image \nparameter. For example, if you want to build an image with organization  myneworg , name  myapp  and version  latest  you can do \n \n  ./mvnw -Pprod clean package jib:dockerBuild -Djib.to.image=myneworg/myapp:latest\n \n \n Warning \n If you change the target image of the docker build, remember to update\nthe plugin metadata in the bundle accordingly. \n 2. Publish the Docker image to Docker registry (DockerHub or equivalent) \n Let’s now publish the docker image for the microservice to make it\navailable later during bundle installation in the cluster. \n docker push <name-of-the-image:tag>\n 3. Deploy the plugin into your Entando cluster \n You can now deploy the plugin custom resource generated by the Entando Blueprint in the  bundle/plugins  folder. \n \n Warning \n As stated in step 1, if you changed the target image of your docker build, the plugin custom resource\nin the  bundle/plugins  folder needs to be updated to point to the correct image \n \n From the JHipster project directory: \n cd  bundle/plugins\n\nkubectl create -f  < plugin-file.yaml >  -n entando\n 4. Wait for your plugin to be in  Running  state and link the plugin with the app using an  EntandoAppPluginLink  custom resource \n Once the plugin server deployment is up and running, you can create an  EntandoAppPluginLink custom resource \nto make the plugin API available from the EntandoApp domain. \n Here an example of a EntandoAppPluginLink custom resource. Some assumptions with this custom resource: \n \n The EntandoPlugin generated with the blueprint is  my-demo-plugin \n The EntandoApp exposing the  my-demo-plugin  APIs is  quickstart . This is the app name in an environment built using the Getting Started instructions. \n Both are deployed on the  entando  namespace. \n The link itself is named  quickstart-to-my-demo-plugin-link \n The name of the link yaml is  my-link.yaml \n \n \n Warning \n Remember to change the fields to match your setup. \n \n apiVersion: entando.org/v1\nkind: EntandoAppPluginLink\nmetadata:\n  name: quickstart-to-my-demo-plugin-link\n  namespace: entando\nspec:\n  entandoAppName: quickstart\n  entandoAppNamespace: entando\n  entandoPluginName: my-demo-plugin\n  entandoPluginNamespace: entando\n \n Now add this link to your environment \n kubectl create -f my-link.yaml -n entando\n \n A new link deployer will start and will work behind the scenes to add your plugin  ingressPath  (this is part of the\nplugin  spec ) to the EntandoApp ingress. \n 5. Upload the micro frontends to your Entando App \n Now that the plugin and the app are linked together, you can proceed to generate the Micro Frontend from the App Builder\nand upload the static resources like  js  and  css  files. \n \n From AppBuilder go to  Configuration -> File Browser  and create a new folder inside the  public  folder and make the name of the folder the same as the name of the bundle (the value is in the  code  field available in the  /bundle/descriptor.yaml  file of the blueprint project) or using a custom name, e.g.  demo-widget \n \n \n Warning \n If you choose to use a custom folder, remember to update the references in the customUI of the widget later \n \n \n Upload all the resources available in the  /bundle/resources  folder\nof the blueprint project into the folder you created above in the App Builder file browser. \n \n \n Warning \n You can decide to recreate the folder structure to be the same as the one in  /bundle/resources  or not, but you need to update the\nreferences in the customUI / configUI of the widget later if you choose a different folder structure. \n \n \n \n Create the widget. In the App Builder go to  Components → Micro frontends & Widgets . \n \n \n Select  Add \n \n \n Set whatever title you want \n \n \n For the customUI copy the one created in one of the widgets you generated from the blueprint.\nAs an example, the customUI for the  detailWidget  of the conference entity is available in\n /bundle/ui/widgets/conference/detailsWidget/conference-details-widget.ftl \n \n \n \n Warning \n Remember to update all the references in the customUI to use the custom folder structure you defined \n \n \n Update the service url to match the location where you deployed the ingress for your microservice if you used a path different than the default. For example, \n \n Update the service-url value with the relative path of your service if you\'re deploying a bundle\n\t\tEx. <car-table service-url="/newBp/api"  />\n\tOr use the full path if you\'re deploying the BE and FE individually\n\t\tEx. <car-table service-url="http://newbp-plugin-entando.192.168.64.7.nip.io/newBp/api"/>\n \n \n Note \n Your Entando application includes a keycloak_auth fragment that will inject the token\nand connection to Keycloak that your microfrontends need to invoke protected APIs. You can see this token at  Components → UX Fragments  in the\nApp Builder and search for keycloak_auth. \n \n \n If you\'re creating a new page from scratch or your page is missing the Keycloak fragment you can add it with this freemarker snippet \n \n <@wp.fragment code="keycloak_auth" escapeXml=false />\n 6. Use the microfrontend and microservice \n You can now use your micro frontends and your microservice in your Entando App. \n'},{title:"Install Bundles from a Private Git Repository",frontmatter:{},regularPath:"/v6.3/tutorials/ecr/ecr-private-git-repo.html",relativePath:"v6.3/tutorials/ecr/ecr-private-git-repo.md",key:"v-58d00a40",path:"/v6.3/tutorials/ecr/ecr-private-git-repo.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Using SSH keys with Git",slug:"using-ssh-keys-with-git"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"1/12/2021, 11:31:10 AM",lastUpdatedTimestamp:161046907e4,content:' Install Bundles from a Private Git Repository \n Overview \n The standard deployment of the Entando Component Repository assumes that bundles are checked out from public Git repositories. Public repositories do not require user authentication in order to access content inside the Git repository. \n A customer may however choose to limit repository access to specific Git user accounts. This document will\ndescribe the steps that can be followed to allow the ECR to log onto the Git server when pulling content from a\nGit repository. \n For more background information, please consult the folowing documentation: \n \n Entando custom resource reference \n Entando Component Repository overview \n Using SSH keys with Git \n Entando supports SSH keys to connect to Git repositories. Following the SSH approach, a developer that\nconnects to Git would typically generate a public/private keypair. The developer would then register the public\nkey with the Git server, whilst storing the private key securely in the local filesystem. When the Git command line\nutility executes an operation that requires an authenticated user, it will automatically look for the private\nkey locally and match it with the public key provided by the server. If the two match up, then the operation is allowed to complete. \n Entando currently allows a Kubernetes Secret containing a Git SSH private key to be mounted in the container that hosts the Entando Component Manager service. This container is deployed with the EntandoApp and can therefore be configured\nfrom the EntandoApp custom resource. The best approach to prepare such a secret is by generating the keypair on\nyour local machine using a Docker image, and creating a Secret from the directory the keypair was generated in. \n Tutorial \n This is the recommended flow on Linux: \n \n \n Navigate to a folder in your operating system that you would like to create the Secret from \n \n \n Generate the SSH keypair from the known SSH client docker image: \n \n \n Run the Docker container in interactive mode, mounting the default user ssh directory to a local directory \n docker run -it -v $PWD/entando_ssh:/root/.ssh kroniak/ssh-client /bin/bash \n \n \n \n On the shell of the resulting container, generate your own keypair \n ssh-keygen\n \n Select all the default options, e.g. no passphrase, etc. \n \n \n Add the fingerprint to the known_hosts file by attempting to connect to your git server: \n ssh git@github.com\n \n When prompted to add it to the known hosts, type \'yes\'. The command can be expected to fail and that is OK. \n \n \n Run  exit \n \n \n \n \n Create the Secret. You are now back in your local operating system\'s shell. You will notice that a new directory has been created due\nto the previous mount that was setup in the Docker command. You may need to give yourself access to this folder before\nyou can create a Secret with the content of this folder: \n \n \n Change the permissions on the folder: \n sudo chmod ag+r entando_ssh -R\n \n \n \n Create a secret from the directory: \n kubectl create secret generic my-git-secret --from-file=entando_ssh -n <<your-namespace>>\n \n \n \n Confirm that the secret exists and has at least two keys: known_hosts, and id_rsa. Without these two keys in the\nSecret, Entando cannot log into Git. \n kubectl get secret my-git-secret -n <<your-namespace>> -o yaml\n \n \n \n \n \n Link the resulting private key to the account of a user that has access to the Git repositories in question. Ideally\nthis should be a dedicated service account user with restricted read only access to the repositories in question. For Github\naccounts, you can follow the  official Github instructions. \nWheen you are prompted for the content of the public key, please use the one generated in the previously created\nentando_ssh directory:\n entando_ssh/id_rsa.pub \n \n \n Now modify the EntandoApp resource you are deploying to mount the previously created Secret in the\n spec.ecrGitSshSecretName  property: \n \n \n       kind: "EntandoApp"\n      metadata:\n        annotations: {}\n        labels: {}\n        name: "quickstart"\n      spec:\n        dbms: none\n        replicas: 1\n        ecrGitSshSecretName: my-git-secret\n        standardServerImage: wildfly\n        ingressPath: /entando-de-app\n        ingressHostName: ampie.apps.serv.run\n        environmentVariables:\n          - name: SPRING_PROFILES_ACTIVE\n            value: "default,swagger"\n \n '},{title:"Export and Publish a Bundle",frontmatter:{sidebarDepth:2},regularPath:"/v6.3/tutorials/ecr/export-bundle-from-application.html",relativePath:"v6.3/tutorials/ecr/export-bundle-from-application.md",key:"v-69699fc0",path:"/v6.3/tutorials/ecr/export-bundle-from-application.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:3,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Export an Entando Bundle",slug:"export-an-entando-bundle"},{level:3,title:"Setup the Keycloak client",slug:"setup-the-keycloak-client"},{level:3,title:"Create env.json",slug:"create-env-json"},{level:3,title:"Run the Bundler",slug:"run-the-bundler"}],lastUpdated:"1/29/2021, 9:58:37 AM",lastUpdatedTimestamp:1611932317e3,content:' Export and Publish a Bundle \n Overview \n Use the Entando bundler command to export a bundle of Entando components from an existing Entando application. An Entando bundle can be used to do the initial install of Entando components into an Entando application, migrate Entando components from one environment to another (e.g. Dev to QA), to provide a template for building a new Entando application, or as the skeleton of an Entando solution. The output of this command is the same bundle directory structure created by an Entando project including a bundle descriptor file. \n Prerequisites \n \n Use the  Entando CLI  to verify you have the prerequisites in place for this tutorial (e.g. git, entando-bundler). \n \n ent check-env develop \n \n \n You\'ll also need a running Entando application. \n You\'ll need admin access to Keycloak or admin access to Kubernetes to set it up. \n \n The tutorial assumes you\'re using an Entando quickstart application. You may need to adjust the specific URLs, credentials, namespaces, etc. for a custom application. \n Export an Entando Bundle \n Setup the Keycloak client \n You\'ll need to setup a Keycloak client with the appropriate permissions for the bundler to access all of the necessary Entando APIs. \n \n Find the secret for the Keycloak admin account. If you already have the admin credentials, then you can skip to step 3. \n \n kubectl get secrets -n entando \n \n In a quickstart application, the secret is named  quickstart-kc-admin-secret \n \n Determine the admin password using the secret name. \n \n kubectl get secret quickstart-kc-admin-secret -n entando -o go-template = "{{println}}Username: {{.data.username | base64decode}}{{println}}Password: {{.data.password | base64decode}}{{println}}{{println}}" \n \n Example output: \n Username: entando_keycloak_admin\nPassword: 1pTZev82Ee\n \n \n Login to Keycloak using the admin credentials. The URL will be something like   http://<YOUR-DOMAIN-OR-IP>/auth . You can use this command to verify the URL. \n \n kubectl describe ingress/quickstart-kc-ingress\n \n \n Go to  Clients  →  Create \n Enter a  Client ID  of your choice, e.g.  entando-bundler , and click  Save . \n The  Settings  tab should be shown. Edit the following values: \n \n \n Access Type:  confidential \n Service Accounts Enabled:  On \n Valid Redirect URLs:  * \n Web Origins:  * \n \n \n Click  Save \n Go to the  Service Account Roles  tab \n Select  Client Roles  →  quickstart-server \n Select  Available Roles  →  superuser . \n Click  Add Selected  to add  superuser  to the  Assigned Roles . This change will be saved automatically. \n Go to the  Credentials  tab and copy the  Secret  shown there. You\'ll need this in the next section. \n Create env.json \n \n Create a directory where you\'ll run the bundler and change to that directory. \n \n mkdir  testBundle ;   cd  testBundle\n \n \n Create an  env.json  file with the environment URLs and client credentials. The  clientId  and  clientSecret  are from steps 5 and 12 above. \n \n { \n    "coreBaseApi" :   "http://<YOUR-DOMAIN-OR-IP>/entando-de-app" , \n    "k8ssvcApi" :   "http://<YOUR-DOMAIN-OR-IP>/k8s" , \n    "clientId" :   "<YOUR-CLIENT-ID>" , \n    "clientSecret" :   "<YOUR-CLIENT-SECRET>" \n } \n Run the Bundler \n \n Create a child directory to hold the bundler output. Using the name  bundle  allows you to easily use the  ent prj  command with this bundle. \n \n mkdir  bundle\n \n \n Run the bundler command with your preferred settings. \n \n ent bundler from-env --location bundle --code my-test-bundle --description “My Test Bundle”\n \n The bundler will inspect the application using the Entando APIs, collect information about the individual components, construct the appropriate descriptor files, and finally assemble the top-level descriptor file. \n $ ls bundle\nassets      contentModels  contents         fragments  labels     pageModels  resources\ncategories  contentTypes   descriptor.yaml  groups     languages  pages       widgets\n \n At this point you have a full Entando project structure. You can inspect the output to edit the exported components or you could  deploy it to another Entando application . \n'},{title:"Install Bundle Plugins from a Private Image Repository",frontmatter:{},regularPath:"/v6.3/tutorials/ecr/ecr-private-images.html",relativePath:"v6.3/tutorials/ecr/ecr-private-images.md",key:"v-3a7efb40",path:"/v6.3/tutorials/ecr/ecr-private-images.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Tutorial",slug:"tutorial"},{level:2,title:"Troubleshooting",slug:"troubleshooting"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:" Install Bundle Plugins from a Private Image Repository \n Overview \n The standard deployment of the Entando Component Repository assumes that plugin images are pulled from public repositories. Public repositores do not require user authentication in order to pull an image. The following tutorial will show you how to add secrets to your Kubernetes environment so you can successfully pull images from private repositories. \n Prerequisites \n \n A running Entando application \n A bundle containing a microservice plugin based on an image from a private repository. You can set this up by  creating a microservice bundle  and making the corresponding Docker Hub repository private. \n Tutorial \n The first step demontrates how to create a secret for Docker Hub but please see the  corresponding Kubernetes documentation  for other options. Once you have the created the secret you can either apply it to a deployed Entando application or add it to the Helm template for a new deployment. \n 1. Create the secret \nSupply the following parameters: \n \n the name of the new secret, e.g.  my-docker-secret . \n the URL to your registry server. For Docker Hub this is currently  https://index.docker.io/v1/ \n your Docker Hub username, password, and email. \n the Entando namespace, e.g.  entando  for a quickstart environment. \n \n kubectl create secret docker-registry  < your-secret-name >  --docker-server = < your-registry-server >  --docker-username = < your-name >  --docker-password = < your-pword >  --docker-email = < your-email >  -n entando\n \n 2a. Update a deployed Entando application \n If you're updating a deployed Entando application(for example a quickstart environment), you can add the new secret to the  entando-plugin  account. You'll need to supply your own namespace. \n kubectl edit serviceaccount entando-plugin -n entando\n \n Add the secret to the serviceaccount. You can either add a new section if it's the first secret or add another secret to the list. \n apiVersion :  v1\n imagePullSecrets :  \n   -   name :  your - secret - name\n kind :  ServiceAccount\n metadata :  \n   name :  entando - plugin\n \n If you describe the serviceaccount, it should list the secret. \n kubectl describe serviceaccount entando-plugin -n entando\n \n Output: \n Name :                 entando - plugin\n Namespace :            entando\n Image pull secrets :   your - secret - name\n \n If  (not found)  is listed next to the secret name, then you may have added the secret to the wrong namespace. \n 2b. Deploy a new Entando application \n If you're setting up a new Entando deployment by using an Entando Helm template (e.g. from the entando-helm-quickstart project), you can add the secret to the  values.yaml  file under the property  operator.imagePullSecrets . This is just a list containing the names of Docker secrets in the operator's namespace. \n <snip > \n operator :  \n   imagePullSecrets :  \n     -  your - secret - name\n<snip > \n \n You can now generate the deployment yaml and deploy it to Kubernetes as usual. \n 3. Install the Entando Bundle \n You can now install the Entando Bundle from the  Entando App Builder  →  Entando Component Repository . The microservice plugin should now be able to successfully pull the image. \n Troubleshooting \n This is the kind of error you'll see from  kubectl get pods  if a plugin is based on an image from a private repository and if there are any issues with the image URL or credentials, including a missing or incorrect secret. \n NAME                                                            READY   STATUS         \nMYUSERNAME-MYPLUGIN-0-0-2-server-deployment-657688c5x8tfb        1 /2     ErrImagePull \n \n "},{title:"Build and Publish a Project Bundle",frontmatter:{sidebarDepth:2},regularPath:"/v6.3/tutorials/ecr/publish-project-bundle.html",relativePath:"v6.3/tutorials/ecr/publish-project-bundle.md",key:"v-8df458c0",path:"/v6.3/tutorials/ecr/publish-project-bundle.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"CLI Steps",slug:"cli-steps"},{level:2,title:"Manual Steps",slug:"manual-steps"},{level:3,title:"Build Docker Image for Microservices",slug:"build-docker-image-for-microservices"},{level:3,title:"Build your bundle and publish to git",slug:"build-your-bundle-and-publish-to-git"},{level:2,title:"Install the bundle into an application",slug:"install-the-bundle-into-an-application"}],lastUpdated:"2/26/2021, 10:01:49 AM",lastUpdatedTimestamp:1614351709e3,content:' Build and Publish a Project Bundle \n Overview \n This tutorial shows you how to take an existing Entando project directory and deploy it to the Entando Component Repository. This involves building a Docker image from your microservice, creating your Entando bundle, checking your Bundle artifacts into git, and deploying the Entando bundle into Kubernetes. \n The Entando CLI automates many of the tasks involved in deploying an Entando bundle but you can also choose to perform the tasks manually. \n Prerequisites \n \n Use the  Entando CLI  to verify you have the prerequisites in place for this tutorial (e.g. Java, npm, git). \n \n ent check-env develop \n \n \n You will also need your git credentials, a git repository, and an Entando instance. \n You will also need an Entando project directory, either  developed by hand  or  generated by the Entando Component Generator . \n CLI Steps \n The following steps make use of the Entando  ent prj  command and its publication system (pbs) convenience methods. See the  Manual Steps  section below for a more detailed description of the underlying tasks. \n \n Build the project using the  ent prj  command. This saves you from having to build each part of the project individually. If you are using a project directory with just a bundle child directory (e.g. for a bundle exported from an environment or with hand-built components) then you should skip this step since there\'s nothing to build. \n \n ent prj build\n \n TIP \n The first run can take longer due to node downloads for any MFE widgets. For later runs you can use  ent prj fe-build  or  ent prj be-build  to independently build just the frontend or backend components. \n \n \n Initialize the bundle directory \n \n ent prj pbs-init\n \n \n Publish the build artifacts to github and Docker Hub. \n \n ent prj pbs-publish\n \n \n Create a Kubernetes custom resource and apply it to your Entando instance. You can modify the target namespace parameter ( -n ) if you changed it from the default. \n \n ent prj generate-cr  |  ent kubectl apply -n entando -f -\n \n \n Jump to the section below to finish installing your bundle:  Install the bundle into your application \n Manual Steps \n Build Docker Image for Microservices \n \n Build the project from the project directory \n \n ./mvnw -Pprod clean package jib:dockerBuild\n \n \n Note \n By default the organization used to generate the docker image is  entando , but you can provide a custom value during project initialization, as well as by changing the  pom.xml  file or by providing the  -Djib.to.image=<org>/<name>:<version>  to the  jib:dockerBuild  command. \n \n \n Note \n Output image name is generated using the organization value defined during project initialization. You can override the provided values by altering the  pom.xml  file or by customizing the  -Djib.to.image  parameter used in the  ./mvnw  command \n \n \n Warning \n If you manually override the target image of the docker build, remember to update the plugin metadata in the bundle accordingly in the bundle steps. \n \n \n View your image and tag \n \n docker  images\n \n Output: \n REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE\nmyusername/example-app   0.0.1-SNAPSHOT      4ec7f05b2b27        33 seconds ago      213MB\n \n \n Publish the Docker image to Docker repository (Docker Hub or equivalent). You may need to first login via  docker login . \n \n docker  push  < name-of-the-image:tag > \n \n For example:  docker push myusername/example-app:0.0.1-SNAPSHOT \n \n Note \n The first time your run this command it will have to push all of the layers. Subsequent runs will be much faster \n \n Output: \n  docker push myusername/example-app:0.0.1-SNAPSHOT\nThe push refers to repository [docker.io/myusername/example-app]\n545361404af4: Pushed\n...\nf1b5933fe4b5: Pushed\n0.0.1-SNAPSHOT: digest: sha256:804b3b91b83094c45020b4748b344f7199e3a0b027f4f6f54109cbb3b8a1f867 size: 2626\n Build your bundle and publish to git \n \n Populate the bundle with the generated micro frontends using  ./buildBundle.sh  or  npm run populate-bundle . \n \n ./buildBundle.sh\n \n \n Important \nThe bundle population with the micro frontends requires some time to be processed. You should be able to follow the progress of the operation on the console. \n \n \n \n The output of your bundle will be in the top level  bundle  directory in your microservice \n \n \n Commit your bundle files to git, separate from the top-level project files. \n \n \n echo  bundle  >>  .gitignore\n cd  bundle/\n git  init\n git   add   . \n git  commit -m  "Init Git repository" \n \n \n \n Create a new git repository and name it  my-bundle  (or a name of your choice). \n \n \n Add your remote repository as origin and push the bundle. \n \n \n git  remote  add  origin https://your/remote/repository.git\n git  push -u origin master\n \n \n Publish a git tag using the following commands. \n \n git tag -a "v0.0.1" -m "My first tag"\ngit push --tags\n \n \n Install the  entando-bundler \n \n npm   install  -g @entando/entando-bundler@6.3.0\n \n \n Generate a custom resource for your bundle. You should provide your own bundle name, namespace, and repository URL. \n \n entando-bundler from-git --name = < bundle-name >  --namespace = entando --repository = < your-repository-url >  --dry-run  >  example-bundle.yaml\n \n \n Make your bundle available in Kubernetes \n \n kubectl apply -f example-bundle.yaml -n entando\n Install the bundle into an application \n \n \n Log into the  App Builder \n \n \n Select  Component Repository  in the upper right \n \n \n Find your bundle and select  Install \n \n \n At this point the Entando platform will download and install the Docker image for your microservice and install the micro frontends into the Entando application. You can add those micro frontend widgets to the page(s) of your choice. \n You can use an Entando provided page or follow  this tutorial  to create your own page and/or page template. Please note that an application based on the Entando blueprint expects a user to be authenticated so you\'ll need to include the  keycloak_auth  UX fragment in your page template. \n'},{title:"Build and Publish a Simple Bundle",frontmatter:{sidebarDepth:2},regularPath:"/v6.3/tutorials/ecr/publish-simple-bundle.html",relativePath:"v6.3/tutorials/ecr/publish-simple-bundle.md",key:"v-08f2d46c",path:"/v6.3/tutorials/ecr/publish-simple-bundle.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Create the project structure",slug:"create-the-project-structure"},{level:2,title:"Add a simple widget",slug:"add-a-simple-widget"},{level:2,title:"Create the bundle descriptor",slug:"create-the-bundle-descriptor"},{level:2,title:"Publish the bundle",slug:"publish-the-bundle"},{level:3,title:"CLI steps",slug:"cli-steps"},{level:3,title:"Manual steps",slug:"manual-steps"},{level:2,title:"Install the bundle into an application",slug:"install-the-bundle-into-an-application"}],lastUpdated:"12/9/2021, 9:48:20 PM",lastUpdatedTimestamp:16391045e5,content:' Build and Publish a Simple Bundle \n Overview \n This tutorial shows you how to create a simple Entando bundle and deploy it into the Entando Component Repository. This involves manually defining a bundle with a single widget, checking your bundle artifacts into git, apply the Entando bundle custom resource to Kubernetes, and then installing the bundle into your application. \n Prerequisites \n \n Use the  Entando CLI  to verify you have the prerequisites in place for this tutorial (e.g. Java, npm, git). \n \n ent check-env develop \n \n \n You will also need your git credentials, an available git repository, and an Entando instance. \n \n Some of the following steps can be simplified by using the  ent prj  command and its publication system (pbs) convenience methods. The manual steps are also provided in those cases. \n Create the project structure \n First create a parent project directory along with a child bundle directory. In a project generated by the Entando Component Generator the microservice and micro frontend source files also live under the parent directory. \n mkdir  -p example-bundle/bundle ;   cd  example-bundle/bundle \n Add a simple widget \n Create a widget directory and descriptor file: \n mkdir  widgets\n touch  widgets/example-widget.yaml\n \n Populate the  example-widget.yaml  with a simple definition. Make sure to retain the correct YAML indentation. \n code :  example - widget\n titles : \n    en :  Example Widget\n    it :  Widget d\'esempio\n group :  free\n customUi :  <h2 > Hi from Example Widget</h2 > \n Create the bundle descriptor \n The  descriptor.yaml  is the main file processed by the Entando Component Repository and describes all of the components in the bundle. The name of the bundle descriptor must be  descriptor.yaml . \n touch  descriptor.yaml\n \n Populate the descriptor with the following YAML definition: \n code :  example - bundle\n description :  This is an example of an Entando bundle\n components : \n   widgets : \n     -  widgets/example - widget.yaml\n \n The component descriptor file name and location (e.g.  widgets/example-widget.yaml ) are arbitrary since the bundle descriptor explicitly points to the file. The typical convention is to group components by type, for example with all widgets in one directory, all page templates in another, etc. \n Publish the bundle \n You can publish a bundle using the CLI or you can perform the steps by hand. \n CLI steps \n \n Change to the project directory, if needed \n \n cd  example-bundle\n \n \n Initialize the Entando project and accept the defaults. \n \n ent prj init\n \n \n Initialize the publication system. You\'ll need the git repository URL and your credentials here. \n \n ent prj pbs-init\n \n \n Publish the bundle to git. By convention your first version will be  v0.0.1  but this is up to you. \n \n ent prj pbs-publish\n \n On subsequent iterations you can run just this command again to quickly push a new version of your bundle to git. \n \n You can now create the custom resource for your bundle and apply it to Kubernetes in one step. You should modify the target namespace parameter ( -n ) if you changed it from the default. \n \n ent prj generate-cr  |  ent kubectl apply -n entando -f -\n \n The  generate-cr  command uses the git repository URL and project name from earlier steps to create the custom resource. \n \n Jump to the section below to finish installing your bundle:  Install the bundle into an application \n Manual steps \n \n Change to the bundle directory, if needed \n \n cd  example-bundle/bundle\n \n \n Run the following commands to initialize git and commit the files. \n \n git  init\n git   add   . \n git  commit -m  "Init Git repository" \n \n \n Add your remote repository as origin and push the bundle. \n \n git  remote  add  origin https://your/remote/repository.git\n git  push -u origin master\n \n \n Publish a git tag using the following commands. \n \n git  tag -a  "v0.0.1"  -m  "My first tag" \n git  push --tags\n \n \n Now that you\'ve published your bundle to git you can create the Kubernetes custom resource for it. \n \n Install the bundler if you haven\'t previously done so. \n npm   install  -g  @entando/entando-bundler@6.3.0\n \n Next generate the custom resource for your bundle. Run the  entando-bundler from-git  command and provide your remote git repository URL via the  --repository  option and the correct namespace via  --namespace . You can also provide a thumbnail for your bundle with  --thumbnail-file  or  --thumbnail-url . \n entando-bundler from-git --name = example-bundle --namespace = entando --repository = https://your/remote/repository.git --dry-run  >  example-bundle.yaml\n \n Next you can apply this definition to Kubernetes. You may need to first transfer the file to your VM, e.g using  multipass transfer . \n kubectl -n entando apply -f example-bundle.yaml\n \n You can confirm the presence of your custom resource via  kubectl get EntandoDeBundle -n entando \n Install the bundle into an application \n Now you can go to the  App Builder  →  Component Repository  and install your bundle. You should see your bundle in the list and when you click  Install  you can select your preferred version if the bundle contains more than one. \n At this point the Entando platform will download and install the components contained in the bundle. Once complete you should see the  Install  button change to give you an option to  Uninstall  that specific version. You can also navigate to  Components  →  Micro Frontends & Widgets  and find your custom widget under the  User  section. \n'},{title:"Microfrontends",frontmatter:{sidebarDepth:2},regularPath:"/v6.3/tutorials/micro-frontends/",relativePath:"v6.3/tutorials/micro-frontends/README.md",key:"v-63795daa",path:"/v6.3/tutorials/micro-frontends/",headers:[{level:2,title:"Introduction",slug:"introduction"},{level:2,title:"Tutorials",slug:"tutorials"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:" Microfrontends \n Introduction \n \n The idea behind Micro Frontends is to think about a website or web app as  a composition of features  which are owned by  independent teams . Each team has a  distinct area of business  or  mission  it cares about and specialises in. A team is  cross functional  and develops its features  end-to-end , from database to user interface. \n —  Michael Geers,  micro-frontends.org \n \n Think of micro frontends as the implementation of a microservices architecture applied to the full web application that extends all the way to the frontend. \n Entando implements micro frontends based on  Web Components , a set of technologies that allow developers to create reusable custom elements supported by all major internet browsers. \n Web Components can work with vanilla JavaScript as well as with the most popular web frameworks (e.g., React, Angular, and Vue). \n Entando's microservice and micro frontend architecture allows developers to work with their favorite technology stack, and makes it easier for companies to integrate disparate applications. \n Tutorials \n \n \n Create a React Micro Frontend \n \n \n Create an Angular Micro Frontend \n \n \n Add an App Builder configuration screen to a\nwidget \n \n \n Display widget configuration \n \n \n The Entando Blueprint generated widgets \n \n \n Communicate Between Micro Frontends \n \n \n Widget authentication with Keycloak \n \n \n"},{title:"Create an Angular Micro Frontend",frontmatter:{sidebarDepth:2},regularPath:"/v6.3/tutorials/micro-frontends/angular.html",relativePath:"v6.3/tutorials/micro-frontends/angular.md",key:"v-23d1ddc4",path:"/v6.3/tutorials/micro-frontends/angular.html",headers:[{level:2,title:"Create Angular App",slug:"create-angular-app"},{level:3,title:"Convert to Custom Element",slug:"convert-to-custom-element"},{level:3,title:"Test Micro Frontend",slug:"test-micro-frontend"},{level:2,title:"Build It",slug:"build-it"},{level:2,title:"Host Micro Frontend",slug:"host-micro-frontend"},{level:3,title:"Create Public Folder",slug:"create-public-folder"},{level:3,title:"Add Widget",slug:"add-widget"},{level:3,title:"See It in Action",slug:"see-it-in-action"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:" Create an Angular Micro Frontend \n Prerequisites \n \n A working instance of Entando. \n \n \n Tested Versions \n node v13.8.0 → We suggest using  nvm  to handle node installations. \n Create Angular App \n Install Angular CLI. \n npm   install  -g @angular/cli\n \n Generate a new angular application. \n ng new angular-widget\n \n Choose the following options: \n ? Would you like to  add  Angular routing? No\n? Which stylesheet  format  would you like to use? CSS\n \n Serve the application. \n cd  angular-widget\n \n ng serve\n \n This is the expected output: \n angular-widget\n├── e2e\n│   └── src\n│       ├── app.e2e-spec.ts\n│       └── app.po.ts\n│\n├── node_modules\n├── src\n│   ├── app\n│   │   ├── app.component.css\n│   │   ├── app.component.html\n│   │   ├── app.component.spec.ts\n│   │   ├── app.component.ts\n│   │   └── app.module.ts\n│   │\n│   ├── assets\n│   │   └── .gitkeep\n│   │\n│   ├── environment\n│   │   ├── environment.prod.ts\n│   │   └── environment.ts\n│   │\n│   ├── favicon.ico\n│   ├── index.html\n│   ├── main.ts\n│   ├── polyfills.ts\n│   ├── styles.css\n│   └── test.ts\n│\n├── .editorconfig\n├── .gitignore\n├── angular.json\n├── browserlist\n├── karma.conf.js\n├── package.json\n├── README.md\n├── tsconfig.app.json\n├── tsconfig.json\n├── tsconfig.spec.json\n└── tslint.json\n Convert to Custom Element \n Next, let's convert our Angular app into a custom element. We'll use  Angular elements  to transform components into custom elements. \n ng  add  @angular/elements\n \n WARNING \n Install the Angular elements package using  ng add , not with  npm install  as it runs additional steps behind the scenes like adding the  document-register-element  polyfill. \n \n TIP \n Angular elements are Angular components packaged as custom elements (also called Web Components), a web standard for defining new HTML elements in a framework-agnostic way. \n \n Open  angular-widget/src/app/app.module.ts . \n \n Here's what the initial file looks like: \n \n import   {  BrowserModule  }   from   '@angular/platform-browser' ; \n import   {  NgModule  }   from   '@angular/core' ; \n\n import   {  AppComponent  }   from   './app.component' ; \n\n@ NgModule ( { \n   declarations :   [ \n    AppComponent\n   ] , \n   imports :   [ \n    BrowserModule\n   ] , \n   providers :   [ ] , \n   bootstrap :   [ AppComponent ] \n } ) \n export   class   AppModule   {   } \n \n Replace the entire file with: \n import   {  BrowserModule  }   from   '@angular/platform-browser' ; \n import   {  NgModule ,  Injector  }   from   '@angular/core' ; \n import   {  createCustomElement  }   from   '@angular/elements' ; \n import   {  AppComponent  }   from   './app.component' ; \n\n@ NgModule ( { \n   declarations :   [ \n    AppComponent\n   ] , \n   imports :   [ \n    BrowserModule\n   ] , \n   providers :   [ ] , \n   entryComponents :   [ AppComponent ] \n } ) \n export   class   AppModule   { \n   constructor ( private   injector :  Injector )   { } \n\n   ngDoBootstrap ( )   { \n     const  el  =   createCustomElement ( AppComponent ,   {   injector :   this . injector  } ) ; \n    customElements . define ( 'angular-widget' ,  el ) ; \n   } \n } \n \n \n In the initial file,  AppModule  is bootstrapped directly during application launch. \n In the updated file, we booststrap our custom element using the  ngDoBootstrap()  method . \n \n Custom Elements \n \n Must contain a hyphen  -  in the name. : \n Cannot be a single word. \n Should follow  kebab-case  for naming convention. \n Test Micro Frontend \n Now, let's check our custom element to see if it's working. \n Open  angular-widget/src/index.html . \n In the  <body> , replace  <app-root></app-root>  with your custom element  <angular-widget /> . \n <! doctype   html > \n < html   lang = \" en \" > \n < head > \n   < meta   charset = \" utf-8 \" > \n   < title > AngularWidget </ title > \n   < base   href = \" / \" > \n   < meta   name = \" viewport \"   content = \" width=device-width, initial-scale=1 \" > \n   < link   rel = \" icon \"   type = \" image/x-icon \"   href = \" favicon.ico \" > \n </ head > \n < body > \n   < angular-widget   /> \n </ body > \n </ html > \n \n Congratulations! \n You’re now running  Angular  in a micro frontend. \n Build It \n From the project root, type: \n ng build --prod --outputHashing = none\n \n This will generate an  angular-widget/dist  directory. \n If we assume browser support for  ES6 (ECMAScript 2015) , we can focus on the following JavaScript files to publish our app: \n \n main-es2015.js \n polyfills-es2015.js \n runtime-es2015.js \n \n Generated Build Files \n --outputHashing=none  generates files without hashes so we can deploy new versions of the micro frontend without having to reconfigure our widget in Entando to point to the newly built files. \n \n If you want to use file names with content hashes to avoid potential caching issues in your browser, you can update the  Custom UI  field of your widget after building new versions of your micro frontend. Widget configuration is covered in the next section. \n Host Micro Frontend \n Now we're ready to host our micro frontend in Entando. \n Create Public Folder \n \n \n Navigate to  Entando App Builder  in your browser. \n \n \n Click  Administration  at the lower left hand side of the screen. \n \n \n Click the  File Browser  tab. \n \n \n Click the  public  folder. \n \n \n Click  Create Folder . \n \n \n Enter  angular-widget \n \n \n Click  Save . \n \n \n Click  angular-widget . \n \n \n Click 'Upload Files`. \n \n \n Upload the following files from  angular-widget/dist/angular-widget : \n \n \n \n main-es2015.js \n polyfills-es2015.js \n runtime-es2015.js \n \n Additional Deployment Options \n \n Install the micro frontend from a bundle in the  Entando Component Repository . \n Add the micro frontend to  Entando App Builder . \n Load the micro frontend from an API. \n Add Widget \n \n Go to  Components > Micro frontends & Widgets  in the Entando App Builder. \n Click  Add  at the lower right. \n \n \n \n Enter the following: \n \n \n Code: angular_widget  → note: dashes are not allowed \n Title: Angular Widget  → for both English and Italian languages \n Group: Free Access \n Custom UI: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < script   async   src = \" < @wp . resourceURL  /> angular-widget/main-es2015.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> angular-widget/polyfills-es2015.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> angular-widget/runtime-es2015.js \" > </ script > \n\n < angular-widget   /> \n \n \n Click  Save . \n \n TIP \n <#assign wp=JspTaglibs[ \"/aps-core\"]>  gives you access to the  @wp  object where you can use environment variables like  resourceURL . \n See It in Action \n Let's see the Angular micro frontend in action on our page. \n Add Page \n Note \n If you've already configured your home page: \n \n   Next to the  Home  folder, under  Actions , click  Configure . \n   Skip to the  Add Widget  section. \n \n \n Let's add our widget to the  Home  page. \n \n \n Go to  Pages  →  Management \n \n \n Next to the  Home  folder, under  Actions , click  Edit . \n \n \n Next to  Page Template  select  Service Page . \n \n \n Click  Save and Configure . \n Add Widget \n \n \n In the Search field in right-hand sidebar, enter  Angular Widget . \n \n \n Drag and drop  Angular Widget  into the  Sample Frame  in the main body of the page. \n \n \n Click  Publish . \n \n \n At the upper right, click  Go to Homepage . \n \n \n \n Congratulations! \n You now have an Angular micro frontend running in Entando. \n \n"},{title:"Communicate Between Micro Frontends",frontmatter:{sidebarDepth:2},regularPath:"/v6.3/tutorials/micro-frontends/communication.html",relativePath:"v6.3/tutorials/micro-frontends/communication.md",key:"v-a598da14",path:"/v6.3/tutorials/micro-frontends/communication.html",headers:[{level:2,title:"Publisher",slug:"publisher"},{level:3,title:"Create Custom Event",slug:"create-custom-event"},{level:3,title:"Update React App to Dispatch Event",slug:"update-react-app-to-dispatch-event"},{level:3,title:"Test Event Dispatcher",slug:"test-event-dispatcher"},{level:2,title:"Subscriber",slug:"subscriber"},{level:3,title:"Add Event Listener",slug:"add-event-listener"},{level:3,title:"Display Custom Event",slug:"display-custom-event"},{level:3,title:"Test Event Listener",slug:"test-event-listener"},{level:2,title:"Add Widgets to App Builder",slug:"add-widgets-to-app-builder"},{level:3,title:"Create Environment File",slug:"create-environment-file"},{level:3,title:"Run npm build",slug:"run-npm-build"},{level:3,title:"Create Public Folder",slug:"create-public-folder"},{level:3,title:"Add Widgets",slug:"add-widgets"},{level:3,title:"View on a Page",slug:"view-on-a-page"},{level:2,title:"Angular to React",slug:"angular-to-react"},{level:3,title:"Create Angular Publisher",slug:"create-angular-publisher"},{level:3,title:"Add to App Builder",slug:"add-to-app-builder"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:" Communicate Between Micro Frontends \n Recommended Learning \n \n Tutorial:  Create a React Micro Frontend \n Tutorial:  Create an Angular Micro Frontend \n \n \n Entando supports communication between micro frontends using  Custom Events , an established web standard. In this tutorial, we'll build: \n \n A React micro frontend that publishes an event \n A React micro frontend that listens to an event \n An Angular micro frontend that publishes an event to a React micro frontend \n Publisher \n Create a simple app to publish an event. \n npx create-react-app publisher-widget --use-npm\n \n Start the app. \n cd  publisher-widget\n \n npm  start\n Create Custom Event \n Next, add event firing logic. \n Add a new file  publisher-widget/src/PublisherWidgetElement.js . \n import  React  from   'react' ; \n import  ReactDOM  from   'react-dom' ; \n import  App  from   './App' ; \n\n const   EVENTS   =   { \n   greeting :   'greeting' , \n } ; \n\n class   PublisherWidgetElement   extends   HTMLElement   { \n\n   constructor ( )   { \n     super ( ) ; \n     this . onGreet   =   name   =>   this . publishWidgetEvent ( EVENTS . greeting ,   {  name  } ) ; \n   } \n\n   connectedCallback ( )   { \n     this . mountPoint  =  document . createElement ( 'div' ) ; \n     this . appendChild ( this . mountPoint ) ; \n     this . render ( ) ; \n   } \n\n   publishWidgetEvent ( eventId ,  detail )   { \n     const  widgetEvent  =   new   CustomEvent ( eventId ,   {  detail  } ) ; \n    window . dispatchEvent ( widgetEvent ) ; \n   } \n\n   render ( )   { \n    ReactDOM . render ( < App onGreet = { this . onGreet }   / > ,   this . mountPoint ) ; \n   } \n } \n\ncustomElements . define ( 'publisher-widget' ,  PublisherWidgetElement ) ; \n\n export   default  PublisherWidgetElement ; \n \n \n In the  CustomEvent  constructor,  detail  is the specific name to use in the event payload, as per the  DOM specification . \n Import Custom Element \n Update  publisher-widget/src/index.js . \n import   './index.css' ; \n import   './PublisherWidgetElement' ; \n Test Custom Element \n Update  publisher-widget/public/index.html , and view it in the browser. \n    < body > \n     < noscript > You need to enable JavaScript to run this app. </ noscript > \n     < publisher-widget   /> \n    ...\n   </ body > \n Update React App to Dispatch Event \n Update  publisher-widget/src/App.js . \n import  React  from   'react' ; \n import   './App.css' ; \n\n class   App   extends   React . Component   { \n   constructor ( props )   { \n     super ( props ) ; \n     this . state  =   {   name :   '' } ; \n   } \n\n   handleNameChange ( value )   { \n     this . setState ( prevState   =>   ( { \n       ... prevState , \n       name :  value , \n     } ) ) ; \n   } \n\n   render ( )   { \n     const   {  name  }   =   this . state ; \n     const   {  onGreet  }   =   this . props ; \n     return   ( \n       < div > \n         < h1 > Send a greeting < / h1 > \n         < label htmlFor = \"name\" > Name < / label > \n         < input id = \"name\"  onChange = { e   =>   this . handleNameChange ( e . target . value ) }  value = { name }   / > \n         < button onClick = { ( )   =>   onGreet ( name ) } > Say hello ! < / button > \n       < / div > \n     ) ; \n   } \n } \n\n export   default  App ; \n Test Event Dispatcher \n In the JavaScript console of your browser, enter: \n window . addEventListener ( 'greeting' ,   ( evt )   =>  console . log ( 'Hello' ,  evt . detail . name ) ) \n \n Write something in the text field. Click the \"Say hello!\" button and take a look at the JS console. It will show the event message. \n Congratulations! \n You’ve now published a custom event. \n Subscriber \n Next, let’s create the subscriber. \n npx create-react-app subscriber-widget --use-npm\n \n Start the app. \n cd  subscriber-widget\n \n npm  start\n Add Event Listener \n Add a new file  subscriber-widget/src/SubscriberWidgetElement.js . \n import  React  from   'react' ; \n import  ReactDOM  from   'react-dom' ; \n import  App  from   './App' ; \n\n const   EVENTS   =   { \n   greeting :   'greeting' , \n } ; \n\n class   SubscriberWidgetElement   extends   HTMLElement   { \n\n   constructor ( )   { \n     super ( ) ; \n     this . name  =   null ; \n     this . subscribeToWidgetEvent ( EVENTS . greeting ,   ( evt )   =>   this . onGreeting ( evt . detail . name ) ) ; \n   } \n\n   connectedCallback ( )   { \n     this . mountPoint  =  document . createElement ( 'div' ) ; \n     this . appendChild ( this . mountPoint ) ; \n     this . render ( ) ; \n   } \n\n   subscribeToWidgetEvent ( eventType ,  eventHandler )   { \n    window . addEventListener ( eventType ,  eventHandler ) ; \n   } \n\n   onGreeting ( name )   { \n     this . name  =  name ; \n     this . render ( ) ; \n   } \n\n   render ( )   { \n    ReactDOM . render ( < App name = { this . name }   / > ,   this . mountPoint ) ; \n   } \n } \n\ncustomElements . define ( 'subscriber-widget' ,  SubscriberWidgetElement ) ; \n\n export   default  SubscriberWidgetElement ; \n Import Custom Element \n Update  subscriber-widget/src/index.js . \n import   './index.css' ; \n import   './SubscriberWidgetElement' ; \n Test Micro Frontend \n Update  subscriber-widget/public/index.html , and view it in the browser. \n    < body > \n     < noscript > You need to enable JavaScript to run this app. </ noscript > \n     < subscriber-widget > \n    ...\n   </ body > \n Display Custom Event \n Update  subscriber-widget/src/App.js . \n import  React  from   'react' ; \n import   './App.css' ; \n\n function   App ( {  name  } )   { \n   return  name  ?   ( < h2 > Just got a greeting from  { name } < / h2 > ) \n     :   ( < h2 > Waiting  for  a greeting ... < / h2 > ) ; \n } \n\n export   default  App ; \n Test Event Listener \n In the JavaScript console of your browser, enter: \n const  widgetEvent  =   new   CustomEvent ( 'greeting' ,   { \n   detail :   { \n     name :   'Pippo' \n   } , \n } ) ; \nwindow . dispatchEvent ( widgetEvent ) ; \n \n The custom event should now display in the  subscriber-widget . \n Congratulations! \n You’ve now created a micro frontend that listens to custom events. \n Add Widgets to App Builder \n Now let's add the publisher and subscriber micro frontends in Entando. \n \n Note: These are the same steps as the  Create a React Micro Frontend  tutorial. \n Create Environment File \n Publisher Widget \n \n \n Create an  .env  file in the project root for the  publisher-widget . \n \n \n Open the  .env  file, and enter the  PUBLIC_URL  where the micro frontend will be hosted. \n \n \n Example: \n PUBLIC_URL=http://quickstart-entando.192.168.64.34.nip.io/entando-de-app/cmsresources/publisher-widget\n \n Notes \n \n Replace  quickstart-entando.192.168.64.34.nip.io  with the ingress you use to access Entando from your local browser. \n /entando-de-app/cmsresources/  is your Resource URL. \n publisher-widget  is the public folder we'll create to host the publisher micro frontend. \n Subscriber Widget \n \n \n Create an  .env  file in the project root for the  subscriber-widget . \n \n \n Open the  .env  file, and enter the  PUBLIC_URL  where the micro frontend will be hosted. \n \n \n \n Use  subscriber-widget  for the name of the public folder we'll create to host the subscriber micro frontend. \n \n Example: \n PUBLIC_URL=http://quickstart-entando.192.168.64.34.nip.io/entando-de-app/cmsresources/subscriber-widget\n Run npm build \n Publisher Widget \n \n \n Open a command line, and navigate to the project root of the  publisher-widget . \n \n \n Run build. \n \n \n npm  run build\n \n \n Rename the following generated files in the  build  directory. \n \n \n \n \n Example of Generated Build File \n Rename to \n Function \n \n \n \n \n build/static/js/2.f14073bd.chunk.js \n static/js/vendor.js \n Third-party libraries \n \n \n build/static/js/runtime-main.8a835b7b.js \n static/js/runtime.js \n Bootstrapping logic \n \n \n build/static/js/main.4a514a6d.chunk.js \n static/js/main.js \n App \n \n \n build/static/css/main.5f361e03.chunk.css \n static/css/main.css \n Stylesheet \n Subscriber Widget \n \n Repeat steps 1-3 for the  subscriber-widget . \n Create Public Folder \n Publisher Widget \n \n \n Navigate to  Entando App Builder  in your browser. \n \n \n Go to  Configuration  →   File Browser   →  public \n \n \n Click  Create Folder . \n \n \n Enter  publisher-widget . \n \n \n Click  Save . \n \n \n Click  public  →  publisher-widget . \n \n \n Create the same folder structure as your generated build directory \n \n \n \n publisher-widget/static/css \n publisher-widget/static/js \n \n \n Upload the files we renamed in the corresponding  js  and  css  folders. \n \n \n publisher-widget/static/css/main.css \n publisher-widget/static/js/main.js \n publisher-widget/static/js/runtime.js \n publisher-widget/static/js/vendor.js \n Subscriber Widget \n \n Repeat steps 1-8 for the  subscriber-widget . \n Add Widgets \n Publisher Widget \n \n \n Go to  Entando App Builder  in your browser. \n \n \n Go to  Components  →  Micro Frontends & Widgets  at the top nav. \n \n \n Click  Add . \n \n \n Enter the following: \n \n \n \n Code: publisher_widget  → note: dashes are not allowed \n Title: Publisher Widget  → for both English and Italian languages \n Group: Free Access \n Custom UI: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < link   rel = \" stylesheet \"   type = \" text/css \"   href = \" < @wp . resourceURL  /> publisher-widget/static/css/main.css \" > \n < script   async   src = \" < @wp . resourceURL  /> publisher-widget/static/js/runtime.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> publisher-widget/static/js/vendor.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> publisher-widget/static/js/main.js \" > </ script > \n < publisher-widget   /> \n \n \n Click  Save . \n Subscriber Widget \n Repeat steps 1-5 for the subscriber widget. \n \n Code: subscriber_widget  → note: dashes are not allowed \n Title: Subscriber Widget  → for both English and Italian languages \n Group: Free Access \n Custom UI: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < link   rel = \" stylesheet \"   type = \" text/css \"   href = \" < @wp . resourceURL  /> subscriber-widget/static/css/main.css \" > \n < script   async   src = \" < @wp . resourceURL  /> subscriber-widget/static/js/runtime.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> subscriber-widget/static/js/vendor.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> subscriber-widget/static/js/main.js \" > </ script > \n < subscriber-widget   /> \n View on a Page \n You can setup the widgets on an existing page (such as the Home page) or create your own page using the tutorial  here . The following steps assume you'll use the Home page. \n \n \n Go to  Pages  →  Management \n \n \n For the  Home  page  (folder icon) , in the  Actions  column, click the  ⋮  icon \n \n \n Click  Edit . \n \n \n In the  Settings  section, select a Page Template with more than one frame, e.g.  1-column : \n \n \n \n Page Template: 1 Column \n \n \n \n Click  Save and Configure . \n \n \n In the  WIDGETS  sidebar on the right: \n \n \n \n Drag  Publisher Widget  and  Subscriber Widget  into  Frame 1  and  Frame 2 . \n \n \n \n Click  Publish . \n \n \n To view the home page, scroll to the top of the page, and click  Go to Homepage . \n \n \n Enter a greeting in the input field. Press the submit button. The subscriber widget will update with the greeting. Done! \n \n \n Congratulations! \n You can now communicate between micro frontends with  Custom Events . \n Angular to React \n We can also communicate between micro frontends using different JavaScript frameworks. \n In this next example, we’ll create an Angular micro frontend to publish an event, and we'll use the React micro frontend we created in the previous section to receive the event. \n Create Angular Publisher \n ng new angular-publisher-widget\n \n Choose the following options: \n ? Would you like to  add  Angular routing? No\n? Which stylesheet  format  would you like to use? CSS\n \n Serve the application. \n cd  angular-publisher-widget\n \n ng serve\n Convert to Custom Element \n Next, let's convert our Angular app into a custom element. We'll use  Angular elements  to transform components into custom elements. \n ng  add  @angular/elements\n \n Replace the contents of  angular-publisher-widget/src/app/app.module.ts . \n \n In this file, we bootstrap the custom element using the  ngDoBootstrap  method. \n \n import   {  BrowserModule  }   from   '@angular/platform-browser' ; \n import   {  NgModule ,  Injector  }   from   '@angular/core' ; \n import   {  createCustomElement  }   from   '@angular/elements' ; \n import   {  AppComponent  }   from   './app.component' ; \n import   {  ReactiveFormsModule  }   from   '@angular/forms' ; \n\n@ NgModule ( { \n   declarations :   [ \n    AppComponent\n   ] , \n   imports :   [ \n    BrowserModule , \n    ReactiveFormsModule\n   ] , \n   providers :   [ ] , \n   entryComponents :   [ AppComponent ] \n } ) \n export   class   AppModule   { \n   constructor ( private   injector :  Injector )   { } \n\n   ngDoBootstrap ( )   { \n     const  el  =   createCustomElement ( AppComponent ,   {   injector :   this . injector  } ) ; \n    customElements . define ( 'angular-publisher-widget' ,  el ) ; \n   } \n } \n Create Custom Event \n Replace the contents of  angular-publisher-widget/src/app/app.component.ts . \n \n Here, we're adding code to dispatch the custom event. \n \n import   {  Component  }   from   '@angular/core' ; \n import   {  FormControl ,  FormGroup  }   from   '@angular/forms' ; \n\n const   EVENTS   =   { \n   greeting :   'greeting' , \n } ; \n\n@ Component ( { \n   selector :   'app-root' , \n   templateUrl :   './app.component.html' , \n   styleUrls :   [ './app.component.css' ] \n } ) \n export   class   AppComponent   { \n  greetingForm  =   new   FormGroup ( { \n     name :   new   FormControl ( '' ) , \n   } ) ; \n\n   publishWidgetEvent ( eventId ,  detail )   { \n     const  widgetEvent  =   new   CustomEvent ( eventId ,   {  detail  } ) ; \n    window . dispatchEvent ( widgetEvent ) ; \n   } \n\n   onSubmit ( )   { \n     const  name  =   this . greetingForm . get ( 'name' ) . value ; \n     this . publishWidgetEvent ( EVENTS . greeting ,   {  name  } ) ; \n   } \n } \n Add HTML Form \n Replace the contents of  angular-publisher-widget/src/app/app.component.html . \n \n In the app component html, we're adding a simple form to call our component class  app.component.ts . \n \n < h1 > Send a greeting </ h1 > \n < form   [formGroup] = \" greetingForm \"   (ngSubmit) = \" onSubmit() \" > \n   < label > \n    Name\n     < input   type = \" text \"   formControlName = \" name \" > \n   </ label > \n   < button   type = \" submit \" > Say hello! </ button > \n </ form > \n View Micro Frontend \n Open  angular-publisher-widget/src/index.html . \n In the  <body> , replace  <app-root></app-root>  with your custom element  <angular-publisher-widget /> . \n < body > \n   < angular-publisher-widget   /> \n </ body > \n \n You can check to see if your micro frontend is working in your browser (e.g., localhost:4200) \n Add to App Builder \n Now we're ready to host our micro frontend in Entando. \n Build It \n From the project root, type: \n ng build --prod --outputHashing = none\n \n This will generate a  dist  directory. \n Create Public Folder \n \n \n Navigate to  Entando App Builder  in your browser. \n \n \n Click  Configuration  →   File Browser   →  public . \n \n \n Create a folder named  angular-publisher-widget . \n \n \n Click  Upload Files . \n \n \n From your generated  dist  folder, upload: \n \n \n \n main-es2015.js \n polyfills-es2015.js \n runtime-es2015.js \n Add Widget \n \n \n Go to  Components > Micro frontends & Widgets  in the Entando App Builder. \n \n \n Click  Add  at the lower right. \n \n \n Enter the following: \n \n \n \n Code: angular_publisher_widget  → note: dashes are not allowed \n Title: Angular Publisher Widget  → for both English and Italian languages \n Group: Free Access \n Custom UI: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < script   async   src = \" < @wp . resourceURL  /> angular-publisher-widget/main-es2015.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> angular-publisher-widget/polyfills-es2015.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> angular-publisher-widget/runtime-es2015.js \" > </ script > \n\n < angular-publisher-widget   /> \n \n \n Click  Save . \n View on Homepage \n \n \n Go to  Pages  →  Management \n \n \n Next to the  Home  page  (folder icon) , in the  Actions  column, click the  ⋮  icon \n \n \n In the Search field in right-hand sidebar, enter  Angular Publisher Widget . \n \n \n Drag and drop  Angular Publisher Widget  into the  Sample Frame  in the main body of the page. \n \n \n \n Replace  Publisher Widget . \n \n \n \n Click  Publish . \n \n \n In the top navigation, on the right, click  Go to Homepage . \n \n \n Enter a greeting in the input field. Press the submit button. The subscriber widget will update with the greeting. Done! \n \n \n \n Note: If you don't see an input field, refresh the page. \n \n Congratulations! \n You've now created an Angular micro frontend that can communicate with a React micro frontend. \n \n"},{title:"Authentication",frontmatter:{},regularPath:"/v6.3/tutorials/micro-frontends/authentication.html",relativePath:"v6.3/tutorials/micro-frontends/authentication.md",key:"v-cafac8c0",path:"/v6.3/tutorials/micro-frontends/authentication.html",lastUpdated:"3/25/2021, 5:39:39 PM",lastUpdatedTimestamp:1616708379e3,content:" Authentication \n Keycloak is used for authentication. \n To set up keycloak server, please refer to Keycloak\n documentation . \n As all MFE widgets use the same Keycloak instance, it should be\ninitialized on a container of all widgets. \n Using Details widget generated using Entando JHipster blueprint as an\nexample, let’s get familiar with authentication implementation. \n As mentioned before, widget auth implementation assumes that Keycloak is\ninitialized outside of the widget. In Details example, it is done in\nindex.html where Keycloak server’s keycloak.js is used. \n <head>\n    <script src=\"keycloak.js\"><\/script>\n    <script>\n        var keycloak = new Keycloak();\n        keycloak\n          .init({ onLoad: 'check-sso' })\n          .success(onInit);\n    <\/script>\n</head>\n \n \n Note \n keycloak.js is provided by your Keycloak server at\n <SERVER_URL:PORT>/auth/js/keycloak.js \n \n Keycloak is initialized by passing Keycloak server path, realm and\nclient ID and calling  init({/* options */})  function. \n const keycloak = Keycloak({\n  url: 'http://localhost:9080/auth',\n  realm: 'jhipster',\n  clientId: 'jhipster-entando-react-client',\n});\n\nkeycloak\n  .init({ onLoad: 'check-sso' })\n  .success(onInit);\n \n Depending on Keycloak version you are using,  init()  function can\nreturn a Promise (newer versions support  promiseType: 'native' \noption). \n keycloak\n  .init({ onLoad: 'check-sso', promiseType: 'native' })\n  .then(authenticated => {\n    alert(authenticated ? 'Authenticated' : 'Not authenticated');\n  })\n  .catch(() => {\n    alert('Failed to initialize');\n  });\n \n All the Keycloak events are made custom events - this way widgets could\nreact to them if a need arises. \n function createKcDispatcher(payload) {\n  return () => window.dispatchEvent(new CustomEvent('keycloak', { detail: payload }));\n}\n\nkeycloak.onReady = createKcDispatcher({ eventType: 'onReady' });\nkeycloak.onAuthSuccess = createKcDispatcher({ eventType: 'onAuthSuccess' });\nkeycloak.onAuthError = createKcDispatcher({ eventType: 'onAuthError' });\nkeycloak.onAuthRefreshSuccess = createKcDispatcher({ eventType: 'onAuthRefreshSuccess' });\nkeycloak.onAuthRefreshError = createKcDispatcher({ eventType: 'onAuthRefreshError' });\nkeycloak.onAuthLogout = createKcDispatcher({ eventType: 'onAuthLogout' });\nkeycloak.onTokenExpired = createKcDispatcher({ eventType: 'onTokenExpired' });\nconst onInit = createKcDispatcher({ eventType: 'onInit' });\n \n Keycloak object is then stored into  window.entando  object for widgets\nto have access to. \n window.entando = {\n  ...(window.entando || {}),\n  keycloak,\n};\n \n On the widget side inside the custom element creation logic Keycloak\nobject is accessed and passed into the component via Keycloak context \n const getKeycloakInstance = () =>\n  (window &&\n    window.entando &&\n    window.entando.keycloak &&\n    { ...window.entando.keycloak, initialized: true }\n  ) || { initialized: false };\n\n\n// ...\n\nconstructor(...args) {\n  // ...\n  this.keycloak = getKeycloakInstance();\n}\n\nconnectedCallback() {\n  // ...\n  ReactDOM.render(\n    <KeycloakContext.Provider value={this.keycloak}>\n      <ConferenceDetailsContainer />\n    </KeycloakContext.Provider>,\n    this.mountPoint\n  );\n}\n \n And on the component side you can show different content depending on\nthe authentication status \n At  auth/KeycloakViews.js \n export const AuthenticatedView = ({ children, keycloak }) => {\n  const authenticated = keycloak.initialized && keycloak.authenticated;\n  return authenticated ? children : null;\n};\n\nexport const UnauthenticatedView = ({ children, keycloak }) => {\n  const authenticated = keycloak.initialized && keycloak.authenticated;\n  return !authenticated ? children : null;\n};\n \n At  components/ConferenceDetailsContainer.js \n render() {\n  const { conference, loading } = this.state;\n  const { t, keycloak } = this.props;\n\n  return (\n    <ThemeProvider theme={this.theme}>\n      <UnauthenticatedView keycloak={keycloak}>\n        {t('common.notAuthenticated')}\n      </UnauthenticatedView>\n      <AuthenticatedView keycloak={keycloak}>\n        {loading && t('common.loading')}\n        {!loading && <ConferenceDetails conference={conference} />}\n      </AuthenticatedView>\n    </ThemeProvider>\n  );\n}\n \n \n Note \n Keycloak object is accessible via props because of  withKeycloak  HOC:\n export default withKeycloak(ConferenceDetailsContainer); \n \n Next Steps \n To apply more fine-grained access controls, see  this tutorial . \n"},{title:"Tutorial: Blueprint generated widgets' overview",frontmatter:{},regularPath:"/v6.3/tutorials/micro-frontends/generate-micro-frontends-from-a-database-entity/",relativePath:"v6.3/tutorials/micro-frontends/generate-micro-frontends-from-a-database-entity/README.md",key:"v-f69511c4",path:"/v6.3/tutorials/micro-frontends/generate-micro-frontends-from-a-database-entity/",headers:[{level:2,title:"Common parts",slug:"common-parts"},{level:3,title:"Authentication",slug:"authentication"},{level:3,title:"Custom events",slug:"custom-events"},{level:3,title:"Tests and mocks",slug:"tests-and-mocks"},{level:3,title:"PropTypes",slug:"proptypes"},{level:3,title:"Fetching data",slug:"fetching-data"},{level:2,title:"Form widget",slug:"form-widget"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:' Tutorial: Blueprint generated widgets\' overview \n When you  create an entity using Entando blueprint , it generates a few\npremade widgets. In this section we will review them. \n We will be using  Conference  as an entity name for the examples below. \n Common parts \n Each widget contains a README file that should help you with the setup. \n All generated widgets are web components created using Custom Elements\nAPI. \n Each widget is displayed using the custom element tag - e.g., inside the\nDetails widget folder  conference/detailsWidget/public/index.html  you\ncan find\n conference-details id="1" override-edit-handler hide-edit-button /> .\nThis element  <conference-details />  is defined in the component entry\npoint at\n conference/detailsWidget/src/custom-elements/ConferenceDetailsElement.js . \n \n Note \n custom element names ( conference-details ) require a dash in them to\nbe used, e.g., (kebab-case) - they can not be single words. \n \n For more information about web components, custom elements and micro\nfrontends, please refer to "Create a react micro frontend widget"\nsection. \n Authentication \n If widget requires authentication, component is wrapped in\n KeycloakContext.Provider  and Keycloak object is fetched from\n window.entando.keycloak  variable. Entando is using Keycloak as our\nauthentication provider, but you can add any providers you like. \n ReactDOM.render(\n  <KeycloakContext.Provider value={this.keycloak}>\n    <StylesProvider jss={this.jss}>\n      <ThemeProvider theme={this.muiTheme}>{FormContainer}</ThemeProvider>\n    </StylesProvider>\n  </KeycloakContext.Provider>,\n  this.mountPoint\n);\n \n For more information about authentication implementation, please refer\nto the "Authentication" section. \n Custom events \n All widgets rely on custom events for communication which is why custom\nevent creation and removal is in each widget, as well as event listener\ncreation. Note that when an event listener is created, it should be when\nthe element is no longer needed. It should be created in the custom\nelement’s  disconnectedCallback()  function. \n To add more events to listen to the widgets, add the event types to\n INPUT_EVENT_TYPES  object at\n detailsWidget/src/custom-elements/widgetEventTypes.js  which will add\nit to the listener list (or remove the event by removing the element). \n For more information about custom events and widget communication,\nplease refer to the section on "Widget communication". \n Tests and mocks \n Each widget has tests written for it. Entando uses\n react-testing-library , but developers are free to upgrade and use any\ntool. Tests are kept at  detailsWidget/src/components/  and mocks for\nthem are at  detailsWidget/src/components/ . \n PropTypes \n PropTypes for data used across several components are shared - you can\nsee and modify them at  detailsWidget/src/components/ . This way you can\navoid repeating same propTypes in each component and just import shared\nones \n import React from \'react\';\nimport conferenceType from \'components/__types__/conference\';\n\nconst ConferenceDetails = props => {\n  // ...\n};\n\nConferenceDetails.propTypes = {\n  conference: conferenceType,\n  t: PropTypes.func.isRequired,\n};\n\nexport default ConferenceDetails;\n Fetching data \n For data fetching from widgets use Fetch API. You can find functions for\nfetching data at  detailsWidget/src/api  in different files for\ndifferent contexts. \n Form widget \n For displaying forms within a widget use\n Formik  which helps with form state\nmanagement. For data validation use\n Yup . \n'},{title:"Create a React Micro Frontend",frontmatter:{sidebarDepth:2},regularPath:"/v6.3/tutorials/micro-frontends/react.html",relativePath:"v6.3/tutorials/micro-frontends/react.md",key:"v-3be4ca38",path:"/v6.3/tutorials/micro-frontends/react.html",headers:[{level:2,title:"Create React App",slug:"create-react-app"},{level:3,title:"Wrap with Custom Element",slug:"wrap-with-custom-element"},{level:3,title:"Import Custom Element",slug:"import-custom-element"},{level:3,title:"Test Micro Frontend",slug:"test-micro-frontend"},{level:2,title:"Get Resource URL",slug:"get-resource-url"},{level:2,title:"Build It",slug:"build-it"},{level:3,title:"npm build",slug:"npm-build"},{level:2,title:"Host Micro Frontend",slug:"host-micro-frontend"},{level:3,title:"Create Public Folder",slug:"create-public-folder"},{level:3,title:"Update Custom UI Field",slug:"update-custom-ui-field"},{level:3,title:"View in Homepage",slug:"view-in-homepage"}],lastUpdated:"1/13/2021, 4:46:36 PM",lastUpdatedTimestamp:1610574396e3,content:" Create a React Micro Frontend \n Prerequisites \n \n A working instance of Entando. \n Use the Entando CLI to verify you have the command line prerequisites in place for this tutorial (e.g. npm). \n Create React App \n We'll use  Create React App  to create a simple app in seconds. \n npx create-react-app my-widget --use-npm\n \n This is the expected output: \n my-widget\n├── README.md\n├── node_modules\n├── package.json\n├── .gitignore\n├── public\n│   ├── favicon.ico\n│   ├── index.html\n│   ├── logo192.png\n│   ├── logo512.png\n│   ├── manifest.json\n│   └── robots.txt\n└── src\n    ├── App.css\n    ├── App.js\n    ├── App.test.js\n    ├── index.css\n    ├── index.js\n    ├── logo.svg\n    ├── serviceWorker.js\n    └── setupTests.js\n \n Start the app. \n cd  my-widget\n npm  start\n Wrap with Custom Element \n Add a new file  src/WidgetElement.js  with the custom element that will wrap the entire React app. \n import  React  from   'react' ; \n import  ReactDOM  from   'react-dom' ; \n import  App  from   './App' ; \n\n class   WidgetElement   extends   HTMLElement   { \n     connectedCallback ( )   { \n         this . mountPoint  =  document . createElement ( 'div' ) ; \n         this . appendChild ( this . mountPoint ) ; \n        ReactDOM . render ( < App  / > ,   this . mountPoint ) ; \n     } \n } \n\ncustomElements . define ( 'my-widget' ,  WidgetElement ) ; \n\n export   default  WidgetElement ; \n \n TIP \n connectedCallback  is a lifecycle hook that  runs each time the element is added to the DOM. \n \n The React  root  node is programatically generated in the  connectedCallback  method when our custom element is added to the DOM. \n Custom Elements \n \n Must contain a hyphen  -  in the name. : \n Cannot be a single word. \n Should follow  kebab-case  for naming convention. \n Import Custom Element \n Open  src/index.js . Here's what the initial file looks like: \n import  React  from   'react' ; \n import  ReactDOM  from   'react-dom' ; \n import   './index.css' ; \n import  App  from   './App' ; \n import   *   as  serviceWorker  from   './serviceWorker' ; \n\nReactDOM . render ( < App  / > ,  document . getElementById ( 'root' ) ) ; \n\n // If you want your app to work offline and load faster, you can change \n // unregister() to register() below. Note this comes with some pitfalls. \n // Learn more about service workers: https://bit.ly/CRA-PWA \nserviceWorker . unregister ( ) ; \n \n Replace the entire file with these two lines. \n import   './index.css' ; \n import   './WidgetElement' ; \n Test Micro Frontend \n \n \n Open  public/index.html . \n \n \n Replace  <div id=\"root\"></div>  with the custom element  <my-widget /> . \n \n \n    < body > \n     < noscript > You need to enable JavaScript to run this app. </ noscript > \n     < my-widget   /> \n    ...\n   </ body > \n \n Congratulations! \n You’re now running  React  in a containerized micro frontend. \n Get Resource URL \n Let's add our micro frontend to Entando by adding our JavaScript and CSS files to the  public  folder. \n TIP \n Entando makes files publicly available through the  public  folder. \n Add Widget \n Initially, we'll add a widget to get the resource URL for the  public  folder. Later on, we'll use the same widget to add our micro frontend to Entando. \n \n \n Go to  Components > Micro frontends & Widgets  in the Entando App Builder. \n \n \n Click  Add  at the lower right. \n \n \n \n \n Enter the following: \n \n \n Code: my_widget  → note: dashes are not allowed \n Title: My Widget  → for both English and Italian languages \n Group: Free Access \n Custom UI: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < @wp . resourceURL  /> \n \n TIP \n <#assign wp=JspTaglibs[ \"/aps-core\"]>  gives you access to the  @wp  object where you can use environment variables like  resourceURL . \n \n \n Click  Save . \n Add Page \n Next, let's add our widget to a page so we can view the  Resource URL . \n If you're getting started with a new install of Entando, let's add our widget to the  Home  page: \n \n \n For Experienced Entando users: \n Add a new page → Add your widget to the page \n \n \n \n \n Go to  Pages  →  Management \n \n \n Next to the  Home  folder, under  Actions , click  Edit . \n \n \n Next to  Page Template  select  Service Page . \n \n \n Click  Save and Configure . \n \n \n In the Search field in right-hand sidebar, enter  My Widget . \n \n \n Drag and drop  My Widget  into the  Sample Frame  in the main body of the page. \n \n \n Click  Publish . \n \n \n At the upper right, click  Go to Homepage . \n \n \n \n This will take you to a blank home page with your widget. \n \n \n Copy the  Resource URL . For example, this is the URL in a quickstart environment set up via the Getting Started guide: \n \n /entando-de-app/cmsresources/\n Build It \n Now that we have the Resource URL where we'll host our  Create React App , we're ready to build. \n \n \n Create an  .env.production  file in the project root of your  Create React App . \n \n \n Add the  PUBLIC_URL  where we'll be hosting our files. \n \n \n PUBLIC_URL=/entando-de-app/cmsresources/my-widget\n \n Notes \n \n /entando-de-app/cmsresources/  is the Resource URL for your Entando application \n /my-widget  is the public folder we'll create to host our files \n npm build \n \n \n Open a command line, and navigate to the project root of your  Create React App . \n \n \n Run the command: \n \n \n npm  run build\n \n \n Rename the following generated files in the  build  directory. \n \n \n \n \n Example of Generated Build File \n Rename to \n Function \n \n \n \n \n build/static/js/2.f14073bd.chunk.js \n static/js/vendor.js \n Third-party libraries \n \n \n build/static/js/runtime-main.8a835b7b.js \n static/js/runtime.js \n Bootstrapping logic \n \n \n build/static/js/main.4a514a6d.chunk.js \n static/js/main.js \n App \n \n \n build/static/css/main.5f361e03.chunk.css \n static/css/main.css \n Stylesheet \n \n \n \n Generated Build Files \n We rename the JavaScript and CSS files so we can deploy new versions of the micro frontend without having to update the  Custom UI  field of our widget to reference the new files. \n \n If you want to use the original  file names with the content hashes to avoid potential caching issues in your browser , update the  Custom UI  field of your widget when deploying new versions of your micro frontend. The  Custom UI  settings will be covered in the next section. \n Additional Deployment Options \n \n Install the micro frontend from a bundle in the  Entando Component Repository . \n Add the micro frontend to  Entando App Builder . \n Load the micro frontend from an API. \n Host Micro Frontend \n Now we're ready to host our micro frontend in Entando. \n Create Public Folder \n \n \n Navigate to  Entando App Builder  in your browser. \n \n \n Click  Administration  at the lower left hand side of the screen. \n \n \n Click the  File Browser  tab. \n \n \n Click the  public  folder. \n \n \n Click  Create Folder . \n \n \n Enter  my-widget . \n \n \n Click  Save . \n \n \n Click  public  →  my-widget . \n \n \n Create the same folder structure as your generated build directory \n \n \n \n my-widget/static/css \n my-widget/static/js \n \n \n Upload the files we renamed in the corresponding  js  and  css  folders. \n \n \n my-widget/static/css/main.css \n my-widget/static/js/main.js \n my-widget/static/js/runtime.js \n my-widget/static/js/vendor.js \n \n Note: You can drag and drop the files in your browser. \n \n Upload the  React  logo. \n \n \n my-widget/static/media/logo.5d5d9eef.svg  → You don't need to rename this file. \n Update Custom UI Field \n \n \n Go to  Components  →  Micro frontends & Widgets . \n \n \n Under the  My Widgets  category → next to  My Widget  → under  Action  → select  Edit . \n \n \n Update  Custom UI  field: \n \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < link   rel = \" stylesheet \"   type = \" text/css \"   href = \" < @wp . resourceURL  /> my-widget/static/css/main.css \" > \n < script   async   src = \" < @wp . resourceURL  /> my-widget/static/js/runtime.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> my-widget/static/js/vendor.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> my-widget/static/js/main.js \" > </ script > \n < my-widget   /> \n \n \n Click  Save . \n View in Homepage \n Let's see the React micro frontend in action on our page. \n \n \n In the  Entando App Builder  dashboard, click  Go to Homepage  at the upper right. \n \n \n Go to the page that you created, and click refresh. \n \n \n \n Congratulations! \n You now have a React micro frontend running in Entando. \n \n"},{title:"Entando Platform",frontmatter:{sidebarDepth:0},regularPath:"/v7.0/docs/",relativePath:"v7.0/docs/README.md",key:"v-1c11d3d2",path:"/v7.0/docs/",headers:[{level:2,title:"Entando Architecture",slug:"entando-architecture"},{level:2,title:"Why Kubernetes?",slug:"why-kubernetes"}],lastUpdated:"4/19/2022, 10:05:46 PM",lastUpdatedTimestamp:1650420346e3,content:" Entando Platform \n Entando is the leading open source  Application Composition Platform  for Kubernetes. It enables parallel teams to accelerate development and innovation of business capabilities on a modern, cloud-native, and Kubernetes-native stack. \n With native support for Javascript app development, a micro frontend and microservices architecture, deployment of apps in containers that can be individually scaled up and down, and automated management of containers with Kubernetes, we simplify the move for enterprises looking to modernize across on-prem and cloud infrastructures. \n Entando Architecture \n \n The Entando platform includes the following major elements: \n \n Entando App Engine : assemble micro frontends & microservices and compose them on a page. \n Entando App Builder : the user interface to build and design applications. \n Entando Component Generator : provide advanced data modeling capabilities and automatically generate the corresponding microservices and micro frontends. \n Entando Component Repository : a shared, internal repository to encourage code reuse across the enterprise. \n Entando Identity Management : token-based authentication across multiple domains and connect service providers with identity providers. \n Entando WCMS : a web content management system that supports headless CMS. \n (optional)  Entando Business Automation Bundle : workflow and task automation including out of the box integration with Red Hat Process Automation Manager (PAM). \n Why Kubernetes? \n Instead of you doing the work to ensure your apps and services stay up and running, Kubernetes does the work for you. For each app or service, you can set resource limits, the number of pods you want backing each service, upgrade strategy, and auto-scaling. Kubernetes actively manages your cluster to match your defined resource utilization and ensures your site doesn't go down. \n How Google Runs Containers in Production \n Each week, Google deploys over 2 billion containers in production to run all of its services like Gmail, YouTube, and Search. Kubernetes is Google's open source solution to automate the management of containers at scale. \n \n Over 50% of Fortune 500 companies use Kubernetes with product offerings from Amazon Elastic Kubernetes Service (EKS), Google Cloud Platform (GKE), IBM (Red Hat) OpenShift, Microsoft Azure (AKS), and VMWare Pivotal (PKS). \n"},{title:"Add a Configuration Screen in App Builder",frontmatter:{},regularPath:"/v6.3/tutorials/micro-frontends/widget-configuration.html",relativePath:"v6.3/tutorials/micro-frontends/widget-configuration.md",key:"v-59f43a00",path:"/v6.3/tutorials/micro-frontends/widget-configuration.html",headers:[{level:2,title:"Create React App",slug:"create-react-app"},{level:2,title:"Add Input Field",slug:"add-input-field"},{level:2,title:"Custom Element",slug:"custom-element"},{level:2,title:"Configuration Screen",slug:"configuration-screen"},{level:2,title:"Add Attribute",slug:"add-attribute"},{level:2,title:"Display Input",slug:"display-input"},{level:2,title:"Build It",slug:"build-it"},{level:2,title:"Update Widget in App Builder",slug:"update-widget-in-app-builder"}],lastUpdated:"1/29/2021, 10:47:17 AM",lastUpdatedTimestamp:1611935237e3,content:' Add a Configuration Screen in App Builder \n Entando 6 widgets can be customized through an App Builder configuration screen that is itself a micro frontend. It can be developed and tested in isolation without a running Entando instance. \n Create React App \n Let’s start with the boilerplate provided by  Create React\nApp , probably the most popular one. \n npx create-react-app my-widget-config --use-npm \n my-widget-config\n├── README.md\n├── node_modules\n├── package.json\n├── .gitignore\n├── public\n│   ├── favicon.ico\n│   ├── index.html\n│   ├── logo192.png\n│   ├── logo512.png\n│   ├── manifest.json\n│   └── robots.txt\n└── src\n    ├── App.css\n    ├── App.js\n    ├── App.test.js\n    ├── index.css\n    ├── index.js\n    ├── logo.svg\n    ├── serviceWorker.js\n    └── setupTests.js\n \n Then, type  cd my-widget-config  and  npm start  to start the app. \n Add Input Field \n Let’s start with a simple form: only an input with a label. So, let’s\nedit  App.js \n import React from \'react\';\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { name: \'\'};\n  }\n\n  handleNameChange(value) {\n    this.setState(prevState => ({\n      ...prevState,\n      name: value,\n    }));\n  }\n\n  render() {\n    const { name } = this.state;\n    return (\n      <div>\n        <h1>Sample Entando 6 Widget Configuration</h1>\n        <label htmlFor="name">Name</label>\n        <input id="name" onChange={e => this.handleNameChange(e.target.value)} value={name} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n \n You are free to use your favorite form handling library e.g.,\n Formik ,\n redux-form  (that requirese redux) or others. \n In regards to styling, since this is going to be an App Builder screen,\nwe strongly suggest using  PatternFly\nv3  ( patternfly  and  patternfly-react \npackages) to keep UX coherence. \n Custom Element \n Now, let’s add the web component that will wrap the entire React app.\nLet’s name it  WidgetElement \n import React from \'react\';\nimport ReactDOM from \'react-dom\';\nimport App from \'./App\';\n\nclass WidgetElement extends HTMLElement {\n  constructor() {\n    super();\n    this.reactRootRef = React.createRef();\n    this.mountPoint = null;\n  }\n\n  get config() {\n    return this.reactRootRef.current ? this.reactRootRef.current.state : {};\n  }\n\n  set config(value) {\n    return this.reactRootRef.current.setState(value);\n  }\n\n  connectedCallback() {\n    this.mountPoint = document.createElement(\'div\');\n    this.appendChild(this.mountPoint);\n    ReactDOM.render(<App ref={this.reactRootRef} />, this.mountPoint);\n  }\n}\n\ncustomElements.define(\'my-widget-config\', WidgetElement);\n\nexport default WidgetElement;\n \n Its responsibility is rendering the react app and syncing the react app\nstate in a  config  property, that  must  be named that way. The key to\nApp Builder communication is that it works in three steps: \n \n \n App Builder reads  config  property when the widget config screen is\nrendered \n \n \n config  property is mutated when a user configures the widget \n \n \n When a user saves the config, App Builder retrieves it (again, from\nthe  config  property) and persists it through Entando APIs \n \n \n This means the widget developer can focus on the configuration screens\nwithout having to call Entando APIs to read or write configuration. \n One more JS file to update:  index.js . Starting from this \n import React from \'react\';\nimport ReactDOM from \'react-dom\';\nimport \'./index.css\';\nimport App from \'./App\';\nimport * as serviceWorker from \'./serviceWorker\';\n\nReactDOM.render(<App />, document.getElementById(\'root\'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n \n You only have to import  WidgetElement  plus the css, if needed.\nSomething like \n import \'./index.css\';\nimport \'./WidgetElement\';\n \n We assume we don’t need a service worker for the widget, so we can\ndelete serviceWorker.js. \n To ensure our web component is working we have to edit\n public/index.html . Remove  <div id="root"></div>  from the  body  (we\nprogrammatically generated the react root in the  connectedCallback \nmethod of  WidgetElement ) and add our new web component tag\n <my-widget /> . \n <!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" />\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\n    <title>React App</title>\n  </head>\n  <body>\n    <my-widget-config />\n  </body>\n</html>\n \n \n Note \n the web component tag name ( my-widget-config  in this tutorial)\n must  match the first parameter of the  customElements.define \nmethod. \n \n The page should auto reload and... congrats, you’re running an Entando 6\nwidget in isolation. \n Configuration Screen \n Next, we’ll build our widget before embedding it into the Entando 6\ninstance. From the react project root, type \n npm run build \n and a  build/static  directory will be generated. For convenience in this tutorial, rename the generated files: \n \n \n a file like  js/runtime~main.c7dcdf0b.js  to  js/runtime.js \n(bootstrapping logic) \n \n \n a file like  js/2.230b21ef.chunk.js  to  js/vendor.js  (third-party\nlibraries) \n \n \n a file like  js/main.1fd3965a.chunk.js  to  js/main.js  (app) \n \n \n Next load these files into Entando under  public/my-widget-config/static  using  Administration  →  File Browser . \n Now go to  Components  →  Micro frontends & Widgets  and find the original widget we\'re creating the configuration screen for. Edit the widget and update the\n configUI  field. \n {\n  "customElement": "my-widget-config",\n  "resources": [\n    "my-widget-config/static/js/runtime.js",\n    "my-widget-config/static/js/vendor.js",\n    "my-widget-config/static/js/main.js"\n  ]\n}\n \n \n Note \n \n \n It is possible to keep the original names in order to avoid\npotential caching issues, but then you will have to update the\n Config UI  field in the App Builder widget screen each time a new\nversion of the widget is deployed. \n \n \n configUI  is a JSON object, so pay attention to save a\nwell-formed one (the integrated JSON editor will help you) \n \n \n value for  customElement  must match the name of custom tag in\n index.html  and the one passed as parameter to\n customElements.define  in  WidgetElement \n \n \n \n You can now add a page in App Builder, drag the widget into the page template slot and you’ll see the configuration screen we just built. \n Display Widget Configuration \n So, we already created a React micro frontend widget and configuration\nscreen to customize a  name  field. \n In this tutorial we will display that field in our micro frontend\nwidget. \n Add Attribute \n Edit  WidgetElement  to add attribute handling to the custom element,\nand re-render our app when an attribute changes. Now, the  name \nattribute is being read from the custom element and passed as a prop to\nthe react root component ( App ). \n import React from \'react\';\nimport ReactDOM from \'react-dom\';\nimport App from \'./App\';\n\nconst ATTRIBUTES = {\n  name: \'name\',\n};\n\nclass WidgetElement extends HTMLElement {\n\n  static get observedAttributes() {\n    return Object.values(ATTRIBUTES);\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (!Object.values(ATTRIBUTES).includes(name)) {\n      throw new Error(`Untracked changed attribute: ${name}`);\n    }\n    if (this.mountPoint && newValue !== oldValue) {\n      this.render();\n    }\n  }\n\n  connectedCallback() {\n    this.mountPoint = document.createElement(\'div\');\n    this.appendChild(this.mountPoint);\n    this.render();\n  }\n\n  render() {\n    const name = this.getAttribute(ATTRIBUTES.name);\n    ReactDOM.render(<App name={name} />, this.mountPoint);\n  }\n}\n\ncustomElements.define(\'my-widget\', WidgetElement);\n\nexport default WidgetElement;\n \n \n Note \n attributeChangedCallback  is also a custom elements lifecycle hook\nmethod. \n Display Input \n Edit the  App  component now, to make it display the  name  prop. \n import React from \'react\';\nimport \'./App.css\';\n\nfunction App({name}) {\n  return (\n    <div className="App">\n      <header className="App-header">\n        <p>\n          Hello, {name}!\n        </p>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n \n Now, to ensure our custom element is working we can edit\n public/index.html  and set a value for the  name  attribute of the\ncustom element. \n <!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" />\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\n    <title>React App</title>\n  </head>\n  <body>\n    <my-widget name="Marco"/>\n  </body>\n</html>\n \n After page reload, you should be able to display a simple "Hello,\nMarco!" message. \n Build It \n From the react project root, type: \n npm run build \n and the  build/static  directory will be regenerated. Again, for convenience, rename the files and then update them in Entando under  public/my-widget/static  using  Administration  →  File Browser : \n \n \n a file like  js/runtime~main.c7dcdf0b.js  to  js/runtime.js \n(bootstrapping logic) \n \n \n a file like  js/2.230b21ef.chunk.js  to  js/vendor.js  (third-party\nlibraries) \n \n \n a file like  js/main.1fd3965a.chunk.js  to  js/main.js  (app) \n \n \n a file like  css/main.d1b05096.chunk.js  to  css/main.css \n(stylesheet) \n \n \n \n Note \n you could keep the original names in order to avoid potential caching\nissues, but then you will have to update the  Custom UI  field in the\nApp Builder widget screen every time a new version of the widget is\ndeployed. \n \n If the application server you’re running does not have hot deploy\nenabled, restart it. \n Update Widget in App Builder \n Open the  Entando App Builder , go to  Components  →  Micro frontends & Widgets , find the widget  My Widget  and click to edit it. \n Update the  Custom UI  field from: \n <#assign wp=JspTaglibs[ "/aps-core"]>\n<link rel="stylesheet" type="text/css" href="<@wp.resourceURL />my-widget/static/css/main.css">\n<script async src="<@wp.resourceURL />my-widget/static/js/runtime.js"><\/script>\n<script async src="<@wp.resourceURL />my-widget/static/js/vendor.js"><\/script>\n<script async src="<@wp.resourceURL />my-widget/static/js/main.js"><\/script>\n<my-widget />\n \n to \n <#assign wp=JspTaglibs[ "/aps-core"]>\n<link rel="stylesheet" type="text/css" href="<@wp.resourceURL />my-widget/static/css/main.css">\n<script async src="<@wp.resourceURL />my-widget/static/js/runtime.js"><\/script>\n<script async src="<@wp.resourceURL />my-widget/static/js/vendor.js"><\/script>\n<script async src="<@wp.resourceURL />my-widget/static/js/main.js"><\/script>\n<@wp.currentWidget param="config" configParam="name" var="configName" />\n<my-widget name="${configName}" />\n \n We basically added a JSTL tag to extract a field (under  configParam )\nfrom the config field of the current widget and put it in a  configName \nvariable, that we pass to the custom element. \n Save the widget and reload the page that contains the widget. You should see\n Hello, Marco!  as expected. \n'},{title:"Contributing to Entando",frontmatter:{},regularPath:"/v7.0/docs/community/contributing.html",relativePath:"v7.0/docs/community/contributing.md",key:"v-73f90d08",path:"/v7.0/docs/community/contributing.html",headers:[{level:2,title:"Contributing to the Source",slug:"contributing-to-the-source"},{level:2,title:"Code Style and Formatting",slug:"code-style-and-formatting"},{level:3,title:"Java",slug:"java"},{level:3,title:"Javascript",slug:"javascript"},{level:3,title:"Find the Code",slug:"find-the-code"},{level:2,title:"Get Help",slug:"get-help"},{level:2,title:"Licenses",slug:"licenses"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Contributing to Entando \n There are many ways to contribute to Entando including participating in the  Entando Forum , opening issues on GitHub,  updating documentation , building bundles using the  Entando Component Repository , and contributing directly to the source. \n Contributing to the Source \n Entando welcomes contributions to our source code repositories. This is a brief overview of how to create a pull request for an Entando repository. \n If you're new to forks in the git world checkout this guide  Working with Forks \n \n Find the repository you want to edit on the Entando GitHub\n \n https://github.com/entando \n https://github.com/entando-k8s \n \n \n Create a fork of the repository you want to update \n Make your changes or updates on your fork. We recommend making your changes on a branch so that you can update your commits as needed before creating your PR \n Submit a PR against the main (or master) branch of the repository you're working against. If you're fixing a specific issue reference that issue number in the notes and linked issues \n Watch the automated builds to make sure everything passes \n The Entando team will merge your changes! \n Code Style and Formatting \n Most Entando repositories enforce code style rules. References and setup for the main\nsource types are provided below. \n Java \n Java rules are based on checkstyle and PMD can be found at in the  entando-code-style  project. There are configuration files for Intellij, Eclipse, and Netbeans for automated formatting. \n Javascript \n Code style and formatting rules for all Entando javascript projects are enforced by linters in every project. For a reference example see: .sass-lint.yml and .eslintrc.js in the  App builder \n In the future these rules will be replaced by Prettier. \n Find the Code \n Entando source can be found on GitHub in the following organizations. \n \n https://github.com/entando \n https://github.com/entando-k8s \n \n For an overview of the key projects in both GitHub organizations and their role in the architecture see  Entando Deployment Structure \n Get Help \n If you have questions, need help, or want to find out more about contributing join us at \n \n Entando Forum \n Community Slack \n Licenses \n The Entando Platform is 100% open source and most Entando repositories are licensed under the LGPL V3.0. The entando-docs repository is one exception with a  CC BY 4.0 license . See the LICENSE file in the root directory of a given repository for its specific license information. \n Entando libraries licensed with LGPL V3.0 that are used to build applications may be linked to proprietary applications. If linked statically, the application code must also be released as LGPL. If the application is linked dynamically to Entando, the proprietary code does not need to be released. \n A commercial open source license is provided for the Entando Platform for customers with Gold and Platinum subscriptions. This license permits freely extending or modifying Entando without requiring contribution of confidential IP back to the open source community. \n"},{title:"Entando Standard Demo Application",frontmatter:{sidebarDepth:2},regularPath:"/v6.3/tutorials/samples/install-standard-demo.html",relativePath:"v6.3/tutorials/samples/install-standard-demo.md",key:"v-bd433584",path:"/v6.3/tutorials/samples/install-standard-demo.html",headers:[{level:2,title:"Application Details",slug:"application-details"},{level:3,title:"Micro Frontends (MFE)",slug:"micro-frontends-mfe"},{level:3,title:"Configuration Micro Frontends",slug:"configuration-micro-frontends"},{level:3,title:"Microservices",slug:"microservices"},{level:3,title:"Static Widgets",slug:"static-widgets"},{level:3,title:"Static CMS Content",slug:"static-cms-content"},{level:2,title:"Installation",slug:"installation"},{level:3,title:"Installation in OpenShift",slug:"installation-in-openshift"},{level:3,title:"Installation in Public Cloud (AKS, EKS, GKE)",slug:"installation-in-public-cloud-aks-eks-gke"},{level:3,title:"Installation in Local Environment",slug:"installation-in-local-environment"},{level:2,title:"Source Code",slug:"source-code"}],lastUpdated:"12/15/2020, 12:52:01 PM",lastUpdatedTimestamp:1608054721e3,content:' Entando Standard Demo Application \n Application Details Micro Frontends (MFE) Configuration Micro Frontends Microservices Static Widgets Static CMS Content Installation Installation in OpenShift Installation in Public Cloud (AKS, EKS, GKE) Installation in Local Environment Source Code \n Application Details \n The Entando Standard Demo application demonstrates a number of the major features in the Entando platform including: \n \n Keycloak integration for role based access controls \n Micro frontends implemented using React and Angular and co-existing on the same dashboard page \n Micro front communication techniques \n Microservices run via Spring Boot \n Entando Content Management \n Micro Frontends (MFE) \n The application includes six custom micro frontends which are described below. \n 1. Seeds Card \n \n \n The Seeds Card MFE is a React micro frontend that is visible on the My Dashboard page. The MFE makes an API call to the banking microservice to fetch a numeric result depending on the configured card type. The value displayed will change as the configuration is changed. \n The MFE is authorization-aware and will pass the bearer token to the microservice for authorization and authentication. If you render the dashboard page and you aren\'t authenticated the widget shows an error message. \n This widget emits events that are consumed by the Seedscard Transaction Table widget \n 2. Seeds Card NG \n \n \n The Seeds Card NG MFE is an Angular widget that is identical to the Seeds Card widget above except for the choice of front end technology. \n This MFE communicates with Seedscard Transaction Table widget which is implemented in React. \n 3. Manage Users \n Authorized View\n \n Not Authorized View\n \n \n The Manage Users MFE makes an API call to Entando Identity Management to fetch user information. The MFE is visible under the dropdown under the username when the user is logged into the app. \n By default the users provisioned in the application do not include the authorization required to manage users in Entando Identity Management. This is used to demonstrate role based access control for an MFE using Keycloak. To enable the Manage Users widget login to Keycloak and assign the  view-users  and  manage-users  roles from the realm-management client to the desired user. \n 4. Seedscard Transaction Table \n \n \n This MFE is a React micro frontend that consumes events from the Card MFEs detailed above. \n The Transaction Table widget makes an API call to the banking microservice to fetch transaction data for the logged in user. \n 5. Signup \n \n \n The Sign Up MFE is a form widget that makes an API call to the customer microservice to create a new user. The Signup MFE is visible on the sign up page and can be accessed from any page when a user is not authenticated. \n 6. Alert Icons \n \n \n The Alert Icon MFE displays an icon on the dashboard page and includes a configuration MFE to allow the user to select the appropriate icon and datatype to display. \n The Alert Icon MFE makes an API call to the banking microservice to fetch data in the default deployment. \n Configuration Micro Frontends \n Many of the MFEs detailed above include configuration screens visible in the App Builder when the MFE is placed on a page. In the App Builder navigate to  Components -> Micro frontends & Widgets  to see the configured MFEs. To see the rendered config screen place the MFEs above on a new page. \n Microservices \n The application includes two microservices (service paths:  /banking  and  /customer ) to support the data visible in the MFEs detailed above. Both microservices demonstrate the automated deployment and linking of a microservice to an Entando application via the Entando operator. \n The data for the microservices is created using Liquibase and demonstrates using the operator and Liquibase + Spring Boot to automatically provision data into an environment. The demo data is available in the source code for the microservices on GitHub. \n Static Widgets \n The application uses static HTML, FreeMarker, and JavaScript widgets to display content including headers, footers, images and other content in the application. To view the static widgets log into the App builder and select  Components -> Micro frontends & Widgets \n Static CMS Content \n The application makes extensive use of the Entando CMS. This includes the creation of content templates, content types, and content. If you want to learn more about the Entando CMS in the application log into the App Builder and select  Content ->  Templates ,  Content -> Management , or  Content -> Types  as good starting points to view the content and static assets. \n Installation \n Installation in OpenShift \n \n Prepare OpenShift \n \n Create a namespace \n oc new-project entando\n \n Deploy the Entando custom resources \n curl  -L -C - https://raw.githubusercontent.com/entando/entando-releases/v6.3.0/dist/qs/custom-resources.tar.gz  |   tar  -xz\n \n oc create -f dist/crd/\n \n \n Deploy the sample application \n \n curl  -L -C - -O https://raw.githubusercontent.com/entando-samples/standard-demo/v6.3.0/deployment/sd-demo-openshift.yaml\n \n Get the base URL of your OpenShift instance (if running in CRC or minishift this will be the IP of your local cluster). If you are using an IP based public URL add  .nip.io  to the end. In the command below replace  <YOUR_CLUSTER_URL>  with the value of the ingress for your cluster. \n sed  -i  "s/apps.rd.entando.org/<YOUR_CLUSTER_URL>/"  sd-demo-openshift.yaml\n \n oc create -f sd-demo-openshift.yaml\n \n \n Watch the application start \n \n watch  oc get pods -n entando\n \n Watch the installation until the cluster is ready for use, indicated by a pod named quickstart-server-* with 3/3 in the READY column and RUNNING in the STATUS column. Use CTRL-C to stop watching the deployment \n \n Get the ingress path to your application \n \n oc get ingress -n entando\n \n Copy the value that starts with  quickstart-entando  under hosts. Then in your browser open the app-builder by appending  /app-builder/  (trailing slash is important) and the end user application at  /entando-de-app . \n For example: \n quickstart-entando. < YOUR_IP_HERE > .nip.io/entando-de-app/\nquickstart-entando. < YOUR_IP_HERE > .nip.io/app-builder/\n Installation in Public Cloud (AKS, EKS, GKE) \n Follow the cluster setup instructions for your public cloud instance for  Azure AKS ,  Amazon EKS  or  Google GKE . Then follow the deployment instructions below instead of deploying the default Entando application. \n \n Prepare Kubernetes \n \n Create a namespace \n kubectl create namespace entando\n \n Deploy the Entando custom resources \n curl  -L -C - https://raw.githubusercontent.com/entando/entando-releases/v6.3.0/dist/qs/custom-resources.tar.gz  |   tar  -xz\n \n kubectl create -f dist/crd/\n \n \n Deploy the sample application \n \n curl  -L -C - -O https://raw.githubusercontent.com/entando-samples/standard-demo/v6.3.0/deployment/sd-demo-cloud.yaml\n \n In the command below replace  <YOUR_NGINX_INGRESS_IP>  with the value of the IP you retrieved for nginx in setting up your public cloud cluster. \n sed  -i  "s/apps.rd.entando.org/<YOUR_NGINX_INGRESS_IP>.nip.io/"  sd-demo-cloud.yaml\n \n kubectl create -f sd-demo-cloud.yaml\n \n \n Watch the application start \n \n watch  kubectl get pods -n entando\n \n Watch the installation until the cluster is ready for use, indicated by a pod named quickstart-server-* with 3/3 in the READY column and RUNNING in the STATUS column. Use CTRL-C to stop watching the deployment \n \n Get the ingress path to your application \n \n kubectl get ingress -n entando\n \n Copy the value that starts with  quickstart-entando  under hosts. Then in your browser open the app-builder by appending  /app-builder/  (trailing slash is important) and the end user application at  /entando-de-app . \n For example: \n quickstart-entando. < YOUR_IP_HERE > .nip.io/entando-de-app/\nquickstart-entando. < YOUR_IP_HERE > .nip.io/app-builder/\n Installation in Local Environment \n The instructions below include setting up a local Kubernetes instance using multipass and K3s. \n \n Install Kubernetes\nInstall  Multipass \n \n Launch VM \n multipass launch --name ubuntu-lts --cpus  4  --mem 8G --disk 20G\n \n Open Ubuntu shell \n multipass shell ubuntu-lts\n \n Install k3s \n curl  -sfL https://get.k3s.io  |   sh  -\n \n \n Prepare Kubernetes \n \n Create a namespace \n sudo  kubectl create namespace entando\n \n Deploy the Entando custom resources \n curl  -L -C - https://raw.githubusercontent.com/entando/entando-releases/v6.3.0/dist/qs/custom-resources.tar.gz  |   tar  -xz\n \n sudo  kubectl create -f dist/crd/\n \n \n Deploy the sample application \n \n curl  -L -C - -O https://raw.githubusercontent.com/entando-samples/standard-demo/v6.3.0/deployment/sd-demo-kubernetes.yaml\n \n ROUTING_SUFFIX = $( hostname  -I  |   awk   \'{print $1}\' ) .nip.io\n sed  -i  "s/apps.rd.entando.org/ $ROUTING_SUFFIX /"  sd-demo-kubernetes.yaml\n \n sudo  kubectl create -f sd-demo-kubernetes.yaml\n \n \n Watch the application start \n \n sudo   watch  kubectl get pods -n entando\n \n Watch the installation until the cluster is ready for use, indicated by a pod named quickstart-server-* with 3/3 in the READY column and RUNNING in the STATUS column. Use CTRL-C to stop watching the deployment \n \n Get the ingress path to your application \n \n sudo  kubectl get ingress -n entando\n \n Copy the value that starts with  quickstart-entando  under hosts. Then in your browser open the app-builder by appending  /app-builder/  (trailing slash is important) and the end user application at  /entando-de-app . \n For example: \n quickstart-entando. < YOUR_IP_HERE > .nip.io/entando-de-app/\nquickstart-entando. < YOUR_IP_HERE > .nip.io/app-builder/\n Source Code \n The source the Entando sample application is open source and can be found with our other open source examples and tutorials on GitHub at: \n https://github.com/entando-samples/standard-demo \n'},{title:"Entando Contributor Covenant Code of Conduct",frontmatter:{},regularPath:"/v7.0/docs/community/code-of-conduct.html",relativePath:"v7.0/docs/community/code-of-conduct.md",key:"v-15da424c",path:"/v7.0/docs/community/code-of-conduct.html",headers:[{level:2,title:"Our Pledge",slug:"our-pledge"},{level:2,title:"Our Standards",slug:"our-standards"},{level:2,title:"Enforcement Responsibilities",slug:"enforcement-responsibilities"},{level:2,title:"Scope",slug:"scope"},{level:2,title:"Enforcement",slug:"enforcement"},{level:2,title:"Enforcement Guidelines",slug:"enforcement-guidelines"},{level:3,title:"1. Correction",slug:"_1-correction"},{level:3,title:"2. Warning",slug:"_2-warning"},{level:3,title:"3. Temporary Ban",slug:"_3-temporary-ban"},{level:3,title:"4. Permanent Ban",slug:"_4-permanent-ban"},{level:2,title:"Attribution",slug:"attribution"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Entando Contributor Covenant Code of Conduct \n Our Pledge \n We as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, religion, or sexual identity\nand orientation. \n We pledge to act and interact in ways that contribute to an open, welcoming,\ndiverse, inclusive, and healthy community. \n Our Standards \n Examples of behavior that contributes to a positive environment for our\ncommunity include: \n \n Demonstrating empathy and kindness toward other people \n Being respectful of differing opinions, viewpoints, and experiences \n Giving and gracefully accepting constructive feedback \n Accepting responsibility and apologizing to those affected by our mistakes,\nand learning from the experience \n Focusing on what is best not just for us as individuals, but for the\noverall community \n \n Examples of unacceptable behavior include: \n \n The use of sexualized language or imagery, and sexual attention or\nadvances of any kind \n Trolling, insulting or derogatory comments, and personal or political attacks \n Public or private harassment \n Publishing others' private information, such as a physical or email\naddress, without their explicit permission \n Other conduct which could reasonably be considered inappropriate in a\nprofessional setting \n Enforcement Responsibilities \n Community leaders are responsible for clarifying and enforcing our standards of\nacceptable behavior and will take appropriate and fair corrective action in\nresponse to any behavior that they deem inappropriate, threatening, offensive,\nor harmful. \n Community leaders have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions that are\nnot aligned to this Code of Conduct, and will communicate reasons for moderation\ndecisions when appropriate. \n Scope \n This Code of Conduct applies within all community spaces, and also applies when\nan individual is officially representing the community in public spaces.\nExamples of representing our community include using an official e-mail address,\nposting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event. \n Enforcement \n Instances of abusive, harassing, or otherwise unacceptable behavior may be\nreported to the community leaders responsible for enforcement at\ncommunity@entando.com. \n All complaints will be reviewed and investigated promptly and fairly. \n All community leaders are obligated to respect the privacy and security of the\nreporter of any incident. \n Enforcement Guidelines \n Community leaders will follow these Community Impact Guidelines in determining\nthe consequences for any action they deem in violation of this Code of Conduct: \n 1. Correction \n Community Impact : Use of inappropriate language or other behavior deemed\nunprofessional or unwelcome in the community. \n Consequence : A private, written warning from community leaders, providing\nclarity around the nature of the violation and an explanation of why the\nbehavior was inappropriate. A public apology may be requested. \n 2. Warning \n Community Impact : A violation through a single incident or series\nof actions. \n Consequence : A warning with consequences for continued behavior. No\ninteraction with the people involved, including unsolicited interaction with\nthose enforcing the Code of Conduct, for a specified period of time. This\nincludes avoiding interactions in community spaces as well as external channels\nlike social media. Violating these terms may lead to a temporary or\npermanent ban. \n 3. Temporary Ban \n Community Impact : A serious violation of community standards, including\nsustained inappropriate behavior. \n Consequence : A temporary ban from any sort of interaction or public\ncommunication with the community for a specified period of time. No public or\nprivate interaction with the people involved, including unsolicited interaction\nwith those enforcing the Code of Conduct, is allowed during this period.\nViolating these terms may lead to a permanent ban. \n 4. Permanent Ban \n Community Impact : Demonstrating a pattern of violation of community\nstandards, including sustained inappropriate behavior,  harassment of an\nindividual, or aggression toward or disparagement of classes of individuals. \n Consequence : A permanent ban from any sort of public interaction within\nthe community. \n Attribution \n This Code of Conduct is adapted from the  Contributor Covenant ,\nversion 2.0, available at\nhttps://www.contributor-covenant.org/version/2/0/code_of_conduct.html. \n Community Impact Guidelines were inspired by  Mozilla's code of conduct\nenforcement ladder . \n For answers to common questions about this code of conduct, see the FAQ at\nhttps://www.contributor-covenant.org/faq. Translations are available at\nhttps://www.contributor-covenant.org/translations. \n"},{title:"Entando App Builder",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/docs/compose/app-builder.html",relativePath:"v7.0/docs/compose/app-builder.md",key:"v-055df94c",path:"/v7.0/docs/compose/app-builder.html",headers:[{level:3,title:"Key Features:",slug:"key-features"},{level:3,title:"Next Steps:",slug:"next-steps"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Entando App Builder \n The Entando App Builder plays a key role in the composition of Entando Applications. It is a feature-rich, low-code user interface to customize and manage components. It also offers a Dashboard and a modular CMS to streamline the design and build process. \n \n The App Builder allows you to create pages and content, configure widgets and plugins, and interact with the  Entando Component Repository  (ECR). It also interfaces with the  Entando Hub , where you can share components and collaborate. \n Pages are designed and embedded with functionality via drag-and-drop: \n \n In the default deployment, the App Builder is a React JS application served by Node. In a quickstart environment, the App Builder is deployed as a container. It is the frontend of the core application and uses REST APIs to communicate with the core instance and  Entando Component Manager (ECM) . The App Builder can query the ECM to fetch information on Entando Bundles available to the ECR. \n Key Features: \n \n \n Install component bundles from the Entando Component Repository \n \n \n Deploy standalone packaged business capabilities \n \n \n Preview page design and functionality \n \n \n Append or update applications \n \n \n Deliver standardized UX design with page and content templates \n \n \n Use micro frontends to build pages from modular, editable content \n Next Steps: \n \n \n To begin,  install Entando \n \n \n Welcome Wizard \n \n \n Create a new page \n \n \n Try out components or packaged business capabilities from the  Entando Hub \n \n \n"},{title:"Entando Component Repository",frontmatter:{},regularPath:"/v7.0/docs/compose/ecr-overview.html",relativePath:"v7.0/docs/compose/ecr-overview.md",key:"v-08a2e18a",path:"/v7.0/docs/compose/ecr-overview.html",headers:[{level:2,title:"Introduction",slug:"introduction"},{level:2,title:"Glossary",slug:"glossary"},{level:3,title:"Component",slug:"component"},{level:3,title:"ECR Bundle",slug:"ecr-bundle"},{level:3,title:"EntandoDeBundle custom resource",slug:"entandodebundle-custom-resource"},{level:3,title:"Entando-component-manager",slug:"entando-component-manager"},{level:3,title:"Entando-K8S-service",slug:"entando-k8s-service"},{level:2,title:"Architecture",slug:"architecture"},{level:2,title:"Example flow",slug:"example-flow"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Entando Component Repository \n Introduction \n The Entando Component Repository (ECR) is meant to be a repository to\nshare reusable components among different Entando instances. \n The following glossary relates to the ECR and related concepts: \n Glossary \n Component \n An Entando component - simply referred to as component - is a piece of\nreusable code/resource to be used in an Entando widget, page or\napplication. Examples of components are widgets, microfrontends,\ncontent-types, labels, plugins, and static resources \n ECR Bundle \n An ECR bundle - is a package containing one or more components and a\n'descriptor.yaml' file providing information about the bundle. The\nbundle is published on an Git registry and is shared with an Entando\napplication using the EntandoDeBundle custom resource. \n EntandoDeBundle custom resource \n The EntandoDeBundle custom resource is a Kubernetes custom resource\nreadable by the Entando6 operator. It’s used to provide information\nabout an ECR bundle and make the bundle available in kubernetes for the\nentando-component-manager. \n Entando-component-manager \n The entando-component-manager - a.k.a component-manager is part of the\nEntando6 app and dialogs both with the Kubernetes cluster via the\nentando-k8s-service and with the entando-core. The\nentando-component-manager reads the bundles from the cluster and exposes\nthem via an API accessible from AppBuilder. The component-manager is\nalso responsible of the installation/removal of components from\nentando-core \n Entando-K8S-service \n The Entando-K8S-Service is part of the Entando infrastructure and is\nresponsible for the low-level communication with the K8S cluster API. \n Architecture \n \n From an architectural point of view, the ECR is composed of \n \n The EntandoDeBundles which contain the metadata associated with a bundle \n The Entando-k8s-service which reads the bundles from the\ncluster/namspace(s) and serves them via a consumable API \n The Component-manager which creates the connection between the EntandoApp\nand the K8S-service. \n Example flow \n \n \n The user lands on the ECR page in app-builder and wants to see the\nlist of bundles shared with that EntandoApp \n \n \n AppBuilder asks the component-manager for the list of available\nbundles \n \n \n Component-manager queries the k8s-service to get the available\nbundles \n \n \n The k8s-service queries the cluster/namespace(s) it is able to read\nfrom for available bundles and returns the list to the\ncomponent-manager \n \n \n Component-manager returns a list to App-Builder \n \n \n The user is able to see the available bundles and is able to install\none or more of them \n \n \n"},{title:"Entando Component Manager",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/docs/compose/ecm-overview.html",relativePath:"v7.0/docs/compose/ecm-overview.md",key:"v-49a9cc40",path:"/v7.0/docs/compose/ecm-overview.html",headers:[{level:3,title:"Key Features:",slug:"key-features"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Entando Component Manager \n ​​An Entando Application is composed of the  Entando App Builder ,  Entando App Engine , and Entando Component Manager. The Entando Component Manager (ECM) provides functionality to build and organize micro frontends and widgets from within the App Builder. It also manages the connections between an application and the installed plugins. \n The Component Manager is a service that links the  Entando Component Repository  (ECR) of the App Builder to the core application instance. It appears as  quickstart-cm-deployment  in the Kubernetes pod list: \n \n The ECM communicates with the Kubernetes service to populate the ECR with the bundles available as  Custom Resources  in the Entando namespace. These bundles can be installed in the application and managed from within the ECR. \n \n In the flow pictured above: \n \n A user visits the ECR page in the App Builder \n The ECR makes a REST call to the  digital-exchange  endpoint \n The Component Manager receives the  digital-exchange  request \n The Component Manager calls the  k8s-service  to return the list of available  EntandoDeBundles  in the namespace \n \n A similar process occurs when bundles are installed or uninstalled. The  Entando Operator  performs actions based on lifecycle events for affected Entando Custom Resources. \n Key Features: \n \n \n Manages the installation and removal of project bundles \n \n \n Makes components available in the App Builder through the Component Repository \n \n \n Handles versioning of component bundles for sharing and collaborating \n \n \n"},{title:"Welcome Wizard",frontmatter:{},regularPath:"/v7.0/docs/compose/welcome-wizard.html",relativePath:"v7.0/docs/compose/welcome-wizard.md",key:"v-1727dd82",path:"/v7.0/docs/compose/welcome-wizard.html",lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Welcome Wizard \n The Welcome Wizard is displayed when you first log in to the Application Builder. You can also start it later by going to the top navigation bar in the Application Builder, click on the information icon, and click  Begin Welcome Wizard . You can disable it from the wizard popup by selecting  Don't show next time  and then  Close , or by going to  My Profile → Preferences  and setting the  Welcome Wizard  preference to  Off . \n \n The Wizard will guide you through the key steps in designing and publishing a page in your application: \n \n Create a Page by setting its title, code, location, group, and template. \n Design the Page by placing a set of pre-configured widgets on the page. \n Preview the Page \n Publish the Page \n \n For more information see the following tutorials: \n \n Page Management \n Widgets and Fragments \n Content Creation \n Digital Assets \n \n"},{title:"Web Accessibility in Entando",frontmatter:{},regularPath:"/v7.0/docs/consume/accessibility.html",relativePath:"v7.0/docs/consume/accessibility.md",key:"v-2bcbdf28",path:"/v7.0/docs/consume/accessibility.html",headers:[{level:2,title:"Requirements and Standards",slug:"requirements-and-standards"},{level:2,title:"Tools",slug:"tools"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Web Accessibility in Entando \n \n The power of the Web is in its universality.\nAccess by everyone regardless of disability is an essential aspect. \n \n - Tim Berners-Lee, W3C Director and inventor of the World Wide Web \n Web accessibility means that websites, tools, and technologies are designed and developed so that people with\ndisabilities can use them. Accessibility is essential for developers and organizations that want to create high-quality\nwebsites and web tools, and not exclude people from using their products and services.\nSee  w3.org  for an introduction to this topic. \n Requirements and Standards \n Many projects and programs will have specific requirements in the area of accessibility, particularly for applications\nor sites with a broad reach or specific governance considerations. Entando's approach to accessibility is to provide the\ntools and techniques that allow a development team to meet their own specific accessibility requirements. \n Development teams will need someone to become familiar with the relevant accessibility standards and help make design\ndecisions on how they will be applied to a specific project. Those standards vary by region so please check the\nlegislation in your area or consult an accessibility specialist. Useful resources include: \n \n W3C Web Accessibility Initiative (WAI) \n Web Content Accessibility Guidelines (WCAG) \n USA:  Section 508 of the Rehabilitation Act \n \n At the end of the day it's up to a development team to make sure their implementation is compliant with a specific\nguideline or standard. Typically a team will make use of Entando Page Templates, Content Templates, and custom micro\nfrontends in order to accomplish this goal. \n Tools \n Accessibility requirements are ideally known at the start of a project so the design language and tools can be adopted\nearly in the project. Using them consistently will ease implementation of the accessibility elements needed to meet the\ndesired compliance level. Retrofitting a project for accessibility can be done but is typically more involved. Example\ndesign systems used by Entando clients include: \n \n Material-UI  - a React framework used to build a custom design system and/or one based on\nMaterial Design. \n Carbon Design System  - IBM's open source design system \n Bootstrap Italia  - a Bootstrap 4-based frontend theme that implements\nthe Italian Design Guidelines for public websites. \n \n Assessing web accessibility is important throughout the life of a project. There are many tools available in this area. A\nuseful list can be found  on the W3C site  with filters by guideline, region,\nlanguage, etc. Entando clients have made good use of the following: \n \n a11y.css \n Access Assistant \n Continuum Explorer Pro \n Wave (web accessibility evaluation tool) \n \n"},{title:"Entando Identity Management -- Keycloak",frontmatter:{},regularPath:"/v7.0/docs/consume/identity-management.html",relativePath:"v7.0/docs/consume/identity-management.md",key:"v-013efea8",path:"/v7.0/docs/consume/identity-management.html",headers:[{level:2,title:"Logging into your Keycloak Instance",slug:"logging-into-your-keycloak-instance"},{level:2,title:"Authentication",slug:"authentication"},{level:2,title:"Authorization",slug:"authorization"},{level:3,title:"Role Assignment for Plugins/Microservices",slug:"role-assignment-for-plugins-microservices"},{level:3,title:"Core",slug:"core"},{level:2,title:"Social Login",slug:"social-login"},{level:2,title:"One Time Passwords",slug:"one-time-passwords"},{level:2,title:"Themes, Look and Feel",slug:"themes-look-and-feel"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Entando Identity Management -- Keycloak \n Entando Identity Management is based on open source Keycloak. Entando Applications rely on a Keycloak instance that is either  externally installed  or specific to an application. The architecture and requirements to customize your Keycloak instance are described below. \n Logging into your Keycloak Instance \n Keycloak is protected by a Secret deployed to your Entando Kubernetes instance. You can query Kubernetes for the Secret\'s default admin credentials, substituting your environment\'s namespace and Secret name: \n ent kubectl get secret default-sso-in-namespace-admin-secret -n entando -o go-template="{{println}}Username: {{.data.username | base64decode}}{{println}}Password: {{.data.password | base64decode}}{{println}}{{println}}"\n \n To find the Secret name, run \n kubectl get secrets -n YOUR-NAMESPACE\n \n and search for the Secret that ends in  namespace-admin-secret . \n Authentication \n All authentication is powered by Keycloak on Entando. This ensures that a micro frontend can call a microservice with a token available to the client. \n \n Entando implements Keycloak as a central point of authentication to provide a single, unified view of identity. This architecture increases portability. Keycloak acts as an abstraction layer to the underlying Identity Provider (IDP), allowing Entando to integrate into other IDPs without modifying the source. \n Authorization \n Role Assignment for Plugins/Microservices \n Keycloak authorizes microservices using clients and roles. Authorizations are stored in a JSON Web Token and available to services when invoked. \n Below are the steps to grant a user one or more roles for a specific client. This controls permissions when configuring the microservice. Note: when a microservice is installed in Entando, a corresponding client (and set of roles) is created per its plugin definition. \n \n Login to your Keycloak instance \n Select  Users  from the menu on the left \n Use the search box to find the appropriate user, e.g. "admin" \n Click on the user ID \n \n \n \n Click on the  Role Mappings  tab \n Use the  Client Roles  drop-down menu to specify the microservice client \n Select from the client\'s  Available Roles \n \n \n \n Use the  Add Selected  button to move the desired roles to  Assigned Roles . These will subsequently appear under  Effective Roles . \n Core \n When a user is authenticated to the  entando-core  via Keycloak, a copy of that user is added to the  entando-core  user management database to enable WCMS functionality. Within the App Builder, WCMS roles and groups can be assigned to a user for access to App Builder functions or  portal-ui  content in the runtime application. \n The code that copies the user into the  entando-core  can be customized per implementation to automatically create groups and roles. See the  entando-keycloak-plugin  for details of the code that copies users and data to the WCMS database. The README in that project includes properties that are available to your Entando Application. \n See  KeycloakAuthorizationManager.java  for an example of adding attributes programatically. In particular, refer to the  processNewUser  method. \n Social Login \n Keycloak allows Entando to provide social login as an out-of-the-box capability.  Keycloak Social Identity Providers  documents how to enable and configure social logins in your Entando Applications. \n One Time Passwords \n Keycloak enables One Time Passwords (OTP) login to Entando Applications. See  Keycloak OTP Policies  to configure and enable OTP in your application. \n Themes, Look and Feel \n Developers can customize the look and feel of the login page, as well as the identity management system that ships with Entando. The  Keycloak Theme Documentation  provides instructions for creating your own theme. Alternatively, you can modify the  Entando Theme . \n'},{title:"Entando Custom Resources for Kubernetes",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/docs/consume/custom-resources.html",relativePath:"v7.0/docs/consume/custom-resources.md",key:"v-092f5bf0",path:"/v7.0/docs/consume/custom-resources.html",headers:[{level:2,title:"Objective",slug:"objective"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"The Core Entando Custom Resources",slug:"the-core-entando-custom-resources"},{level:2,title:"The ResourceRequirements specification",slug:"the-resourcerequirements-specification"},{level:2,title:"EntandoKeycloakServer",slug:"entandokeycloakserver"},{level:3,title:"Overview",slug:"overview-2"},{level:3,title:"Example",slug:"example"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties"},{level:2,title:"EntandoApp",slug:"entandoapp"},{level:3,title:"Overview",slug:"overview-3"},{level:3,title:"Example",slug:"example-2"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-2"},{level:2,title:"EntandoPlugin",slug:"entandoplugin"},{level:3,title:"Overview",slug:"overview-4"},{level:3,title:"Example",slug:"example-3"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-3"},{level:2,title:"EntandoAppPluginLink",slug:"entandoapppluginlink"},{level:3,title:"Overview",slug:"overview-5"},{level:3,title:"Example",slug:"example-4"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-4"},{level:2,title:"EntandoDatabaseService",slug:"entandodatabaseservice"},{level:3,title:"Example",slug:"example-5"},{level:3,title:"Explanation of properties",slug:"explanation-of-properties-5"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Entando Custom Resources for Kubernetes \n Objective \n This is an overview of Entando Kubernetes Custom Resources and their usage on the Entando Platform. \n Prerequisites \n \n Basic knowledge of Kubernetes and how to deploy Docker images \n Overview \n Amongst its many features, Kubernetes comes with a REST API for dozens of different resource types.\nGenerally these APIs offer full Create/Retrieve/Update/Delete (CRUD) access to each of the resource types. We\ntypically format these resources in YAML or JSON and use commandline tools such as\n kubectl  or  oc  to manage them. Each of these resources has a clearly defined structure \n that is well documented in the  Kubernetes API . \n Kubernetes  also allows clients to subscribe to events generated as these resources get updated. These subscriptions\nare called \'watches\' and allow clients to be notified whenever the state of a resource changes. It also\nenforces a strong role based access control (RBAC) on all resources, with granular permissions at the level of operation (Create/Retrieve/Update/Delete/Watch) per resource. \n The basic architecture for Kubernetes worked so well for its developers that it was made available to third  party developers. Kubernetes now offers a mechanism for third parties to provide their own custom\nresource types that still leverqage CRUD support, event subscriptions and RBAC out of the box.\nThis mechanism is referred to as Custom Resources. \n Custom Resources are most commonly used with Kubernetes Operators. Operators are Docker images that have been\ndeployed to Kubernetes Deployments. Generally, they observe a set of custom resources and perform some operations against\nthe Kubernetes API to reflect the state changes in the Custom Resource. We can say that Custom Resources are associated\nwith specific semantics in how they are translated in the cluster. \n A new Custom Resource can be introduced into Kubernetes by registering a Custom Resource Definition (CRD). This is\njust another yaml or json resource that defines the structure of the custom resource to be installed using the OpenAPI\nJSON Schema format. When talking about Custom Resources, it is very important to distinguish between Custom Resource\nDefinitions and Custom Resources. CRD\'s are static type definitions provided by an Operator\nprovider such as Entando. For those familiar with programming languages, CRD\'s are like class definitions, whereas\nCustom Resources are actual instances of that class. \n Entando introduces two groups of Custom Resources. \n \n Core Custom Resources required\nfor a basic installation of Entando in a Kubernetes cluster. These directly result in other\nKubernetes resources being deployed in the cluster. \n Custom Resources specific\nto the Entando Component Repository that serve primarily as metadata for other Entando components. \n The Core Entando Custom Resources \n The Entando Operator observes all the Core Entando Custom Resources in one or more namespaces. If a Core\nEntando Custom Resource is created, updated or deleted, the Entando Operator will trigger a new run-to-completion Pod\nthat will translate that state change into a state change in the actual Kubernetes Cluster. Often, this will\nresult in the Deployment of one or more Docker images, along with one or more Services, and sometimes an Ingress. We refer to the Docker Images that implement these run-to-completion Pods as Entando Kubernetes Controllers. \n The Entando Operator itself is also implemented as a Docker image. See the\n entando-k8s-controller-coordinator repo  for details. \n More detailed instructions on how to install Entando are available in our\n Getting Started tutorial . Learn more about  Configuring the Operator here . \n The ResourceRequirements specification \n All of the Entando Custom Resources that result in physical Kubernetes Deployments can be configured with specific\nresource requirements. These settings can be provided under the  spec  object of the custom resource. It currently\nsupports the following attributes: \n \n spec.resourceRequirements.storageRequest  - the initial storage requested from the persistence provider. Please keep\nin mind that resizable storage is not supported by all storage providers, and this may be the final size of the storage\nallocated. \n spec.resourceRequirements.storageLimit  - the maximum amount of storage required by the deployment. \n spec.resourceRequirements.memoryRequest  - the initial memory requested from the node the deployment\'s primary container is running on. \n spec.resourceRequirements.memoryLimit  - the maximum amount of memory the deployment\'s primary container will use. If\nit exceeds this amount, the container may be terminated by Kubernetes. \n spec.resourceRequirements.cpuRequest  - the initial CPU allocation from the node the deployment\'s primary container is running on. \n spec.resourceRequirements.cpuLimit  - the maximum CPU allocation for the deployment\'s primary container. \n spec.resourceRequirements.fileUploadLimit   - the maximum upload file size supported by the deployment. \n \n All of these attributes require a number and a unit of measurement, e.g. "64Mi". Please consult the\n official Kubernetes documentation \nfor more information on how to configure these attributes. \n EntandoKeycloakServer \n The EntandoKeycloakServer Custom Resource is used to deploy and configure a Red Hat Keycloak Server instance on the\ncluster. After deploying this Keycloak instance, the Entando Operator will create a Kubernetes Secret that provides\nthe necessary information for subsequent deployment operations to access the Keycloak instance as the Admin user. This\nallows the rest of the Entando Kubernetes Controllers to create a Keycloak OpenID Connect (OIDC) client for every HTTP service that\ngets deployed. If you already have a Keycloak instance that you want to use, you can skip this custom resource entirely and create the  keycloak-admin-secret  in the operator\'s namespace as specified in the\n external Keycloak tutorial . \n Overview \n \n Entando Cluster Citizen:  Keycloak \n Custom Resource Definition:  EntandoKeycloakServer \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-keycloak-controller \n Github Repo:  entando-k8s/entando-k8s-keycloak-controller \n \n \n Deployment Details:\n \n Docker image:  entando/entando-keycloak \n Github Repo:  entando/entando-keycloak \n \n \n Possible Database Images:\n \n MySQL:  docker.io/centos/mysql-57-centos7 \n PostgreSQL:  docker.io/centos/postgresql-96-centos7 \n Example \n ---\nkind: "EntandoKeycloakServer"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-keycloak"\n  namespace: "keycloak-namespace"\nspec:\n  dbms: "postgresql"\n  imageName: "entando/entando-keycloak"\n  ingressHostName: "test-keycloak.ampie.dynu.net"\n  isDefault: true\n  environmentVariables: \n    - name: KEYCLOAK_WELCOME_THEME\n      value: your-custom-theme\n  tlsSecretName: your-tls-secret\n  replicas: 1\n Explanation of properties \n \n \n spec.dbms  is used to select the database management of choice. The Entando Operator will use this value to deploy a dedicated Database instance in this namespace\nfor Keycloak to use. If this value matches the  spec.dbms  property\nof a previously  configured  EntandoDatabaseService ,\nthe Keycloak image will be configured to use this service.\nIf left empty or given a value of \'none\', Keycloak will deploy using its own internal\nH2 database. \n \n \n spec.imageName  is used to provide a customized image. By default, the operator will use the  entando/entando-keycloak \ndiscussed above. When using the default image, please refer to the\n Docker image section \nin the README of the Entando Operator to determine how the Docker registry and version for the image is calculated.\nWhen you need to customize the theme or add extensions to Keycloak, you can create your own custom image and provide\nthe value in this property. Make sure you use the default image ( entando/entando-keycloak )\nas a base image. You can then add your customizations and build your own. Please use a fully qualified\nDocker image name here. \n \n \n spec.ingressHostName  is the hostname of the Kubernetes Ingress to be created for Keycloak. Please ensure that this is\naccessible using the default routing suffix of your Entando Operator Deployment or a DNS name previously\nregistered with your DNS provider. \n \n \n spec.isDefault  is \'true\' by default and this should suffice for most conditions. This will result in the standard\n keycloak-admin-secret  being replaced by a Secret connecting you to this newly created Keycloak instance.\nTheoretically one could use multiple Keycloak instances in a cluster, in which case this property should be false. \n \n \n spec.environmentVariables  is a Map of environment variables to pass to the Keycloak Docker image. For example, this could\nbe used to select a specific theme for Keycloak with the variable KEYCLOAK_WELCOME_THEME. These parameters\nare applied to the container\'s environment variables after all variables have been calculated. It can therefore\nalso be used as a mechanism to override any of the default environment variables that need customization. \n \n \n spec.tlsSecretName  is the name of a standard Kubernetes\n TLS Secret  that will be used for the\nresulting Ingress. This is only required if the\n globally configured TLS Secret \nfor the Operator is absent or has not been created with a wildcard hostname that supports this Keycloak instance\'s hostname. \n \n \n spec.replicas  - the number of replicas to be made available on the Deployment of this Keycloak Server. \n \n \n spec.resourceRequirements  - the minimum and maximum  resource allocations  for the Keycloak server container. \n EntandoApp \n An EntandoApp is a Deployment of a Docker image that hosts an Entando and Java based web application. Entando offers two\nstandard images that can be used, but generally we expect our customers to provide their images here. An EntandoApp\ndeployment packages three images into a single Pod: the EntandoApp image discussed here, AppBuilder, and Component Manager. \n Overview \n \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-app-controller \n Github Repo:  entando/entando-k8s-app-controller \n \n \n Deployment Details - Entando App:\n \n Docker image:  entando/entando-de-app-wildfly   or    entando/entando-de-app-eap \n Github Repo:  entando-k8s/entando-de-app \n Entando Cluster Citizen:  Entando App \n \n \n Deployment Details - AppBuilder:\n \n Docker image:  entando/app-builder \n Github Repo:  entando/app-builder \n \n \n Deployment Details - ComponentManager:\n \n Docker image:  entando/entando-component-manager \n Github Repo:  entando-k8s/entando-component-manager \n Entando Cluster Citizen:  Component Manager \n \n \n Possible Database Images:\n \n MySQL:  docker.io/centos/mysql-57-centos7 \n PostgreSQL:  docker.io/centos/postgresql-96-centos7 \n Example \n ---\nkind: "EntandoApp"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-app"\n  namespace: "your-namespace"\nspec:\n  standardServerImage: wildfly\n  customServerImage: your-org/your-image:4.3.2\n  dbms: "postgresql"\n  ingressPath: your-app\n  ingressHostName: "test-app.your-routing-suffix.com"\n  environmentVariables: \n    - name: ENTANDO_VAR1\n      value: your-var1\n  tlsSecretName: your-tls-secret\n  replicas: 1\n  ecrGitSshSecretName: your-secret\n  storageClass: standard\n Explanation of properties \n \n \n spec.standardServerImage  can be either wildfly  or  eap . This instructs the Entando Operator to use one of the\ntwo standard Entando App images. \n \n wildfly  will deploy the  entando/entando-de-app-wildfly  image \n eap  will deploy the  entando/entando-de-app-eap  image \n \n This property and the  spec.customServerImage  are  assumed to be mutually exclusive. Only provide a value to\none of the two. Please refer to the\n Docker image section \nin the README of the Entando Operator to determine how the Docker registry and version of these images are calculated. \n \n \n spec.customServerImage  can be used to deploy the Docker image containing your own custom Entando App. Please\nfollow the instructions on how to  build your own image . \nThis property and the  spec.standardServerImage  are  assumed to be mutually exclusive. Only provide a\nvalue to one of the two. \n \n \n spec.dbms  is used to select the database management of choice. If left empty, a default value of  postgresql \nis assumed. The value  none  is not supported. The Entando Operator will use this value to deploy a dedicated Database instance in this namespace\nfor the EntandoApp to use. If this value matches the  spec.dbms  property\nof a previously configured  EntandoDatabaseService ,\nthe Entando App will be configured to use this service. \n \n \n spec.ingressPath  specifies the web context of the Entando App to be deployed. This is required to create a single\npath entry in the Ingress that is used to expose the Entando App. The default behaviour of Wildfly and\nJBoss EAP is to use the name of the WAR file that is deployed, but it is possible to override this in the EntandoApp\nproject using a  jboss-web.xml  file .\nIn the absence of this file, the web context would be the\nMaven artifactId of the Entando App project. It is also possible to modify this by changing the  <finalName>  element\nin the Maven  pom.xml . \n \n \n spec.ingressHostName  is the hostname of the Kubernetes Ingress to be created for the Entando App. Please\nensure that this is accessible using the default routing suffix of your Entando Operator Deployment or a DNS\nname previously registered with your DNS provider. Keep in mind that EntandoPlugins linked to this app will\nalso be made available on this host. \n \n \n spec.environmentVariables  is a Map of environment variables to pass to the EntandoApp Docker image. For example, this could\nbe used to provide connection details for custom datasources or message queues as discussed in the\n custom datasources tutorial . Also note that all of the\n Spring variables in an Entando project \ncan also be overridden here by specifying the equivalent SNAKE_CASE names of the dot-delimited Spring properties.\nThese parameters are applied to the container\'s environment variables after all variables have been calculated.\nIt can therefore also be used as a mechanism to override any of the default environment variables that need customization.\nKeep in mind that these parameters will be passed to each of the three containers in this Pod as environment\nvariables, and that care needs to be taken to avoid conflicting variable names. \n \n \n spec.tlsSecretName  is the name of a standard Kubernetes\n TLS Secret  that will be used for the\nresulting Ingress. This is only required if the\n globally configured TLS Secret \nfor the Operator is absent or has not been created with a wildcard hostname that supports this Keycloak instance\'s hostname. \n \n \n spec.replicas  - the number of replicas to be made available on the Deployment of this Entando App. \n \n \n spec.resourceRequirements  - the minimum and maximum  resource allocation  for the Entando App Engine container. \n \n \n spec.ecrGitSshSecretName  - a secret containing a private key file named  rsa_id  that matches a public key configured in the Git server. \n \n \n spec.storageClass  - the name of the StorageClass to use for PersistentVolumeClaims created for this EntandoApp. For more information, go to  Kubernetes explanation on Storage Classes . \n EntandoPlugin \n An Entando Plugin is a microservice that can be made available to one or more EntandoApps in the cluster. Please follow\nour instructions on using our blueprint to  build your own EntandoPlugin . The\nDeployment resulting from an EntandoPlugin is a single-container Pod deployment and will include the\nplugin Docker image specified. \n Overview \n \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-plugin-controller \n Github Repo:  entando/entando-k8s-plugin-controller \n \n \n Deployment Details - plugin:\n \n Docker image: as provided by user \n Entando Cluster Citizen:  Plugin \n \n \n Possible Database Images:\n \n MySQL:  docker.io/centos/mysql-57-centos7 \n PostgreSQL:  docker.io/centos/postgresql-96-centos7 \n Example \n ---\nkind: "EntandoPlugin"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-plugin"\n  namespace: "your-namespace"\nspec:\n  image: your-org/your-image:4.3.2\n  securityLevel: lenient\n  ingressPath: /your-plugin\n  healthCheckPath: /actuator/health\n  dbms: "postgresql"\n  ingressHostName: "test-app.your-routing-suffix.com"\n  roles:\n    - code: admin\n      name: Administrators\n    - code: user\n      name: Users\n  permissions: \n    - clientId: some-keycloak-client \n      role: some-admin\n    - clientId: another-keycloak-client \n      role: another-admin\n  environmentVariables: \n    - name: ENTANDO_VAR1\n      value: your-var1\n  tlsSecretName: your-tls-secret\n  replicas: 1\n Explanation of properties \n \n spec.image  is the Docker image you can provide for the plugin you want to deploy. Please follow\nour instructions on using our blueprint to  build your own EntandoPlugin .\nIf you start with the Entando Blueprint, the resulting Spring Boot application will make use of the environment variables set by the Entando Operator. \n spec.dbms  is used to select the database management of choice. The Entando Operator will use this value to deploy a dedicated Database instance in this namespace\nfor the Entando Plugin to use. If left empty or if the value is  none , it\nis assumed that the plugin in question does not require a database. If this value matches\nthe  spec.dbms  property  of a previously  configured\n EntandoDatabaseService ,\nthe Entando Plugin will be configured to use this service. \n spec.ingressPath  specifies the web context where the Entando Plugin will be made available when linked to EntandoApps.\nPlease ensure this is in sync with the  server.servlet.context-path  property set in your Spring Boot application. \n spec.ingressHostName  is the hostname of the Kubernetes Ingress to be created for the Entando Plugin. Please\nensure that this is accessible using the default routing suffix of your Entando Operator Deployment or a DNS\nname previously registered with your DNS provider. This hostname will not be used from your Widgets that you\nimplemented for this plugin, as these widgets will use the hostname of the EntandoApp they are used from.\nThis hostname is useful for embedded web user interfaces in this plugin, such as admin user interfaces\nor diagnostic user interface. \n spec.roles  specifies the set of roles that this plugin expects. At deployment time, the Entando Operator ensures\nthat each of these roles are created on Keycloak for the Keycloak client representing this EntandoPlugin. It is\nup to the Plugin provider to ensure that Spring Security has been set up to enforce the access rules implied\nby the individual roles. Each role has a unique  code  and a more human readable   name  as a property. \n spec.permissions  specifies the set of permissions this plugin requires on other services with known Keycloak Clients.\nAt deployment time, the Entando Operator will use the service account user of this EntandoPlugin\'s Keycloak Client\nand create the necessary role bindings on the specified client id of the service to be used.\nEach permission specifies the  clientId  in Keycloak of the target service, and the  role  that this EntandoPlugin\nshould be bound to in that Keycloak client. \n spec.environmentVariables  is a Map of environment variables to pass to the EntandoPlugin Docker image.\nIt is entirely up to the plugin provider to determine the semantics of each variable. We strongly suggest for the\nplugin provider to use the standard Spring Property Resolver syntax for Spring variables, as this would allow\nany of these variables to be overridden here by specifying the equivalent SNAKE_CASE names of the dot-delimited\nSpring properties.\nThese parameters are applied to the container\'s environment variables after all variables have been calculated.\nIt can therefore also be used as a mechanism to override any of the default environment variables that need customization.\nKeep in mind that these parameters will be passed to both containers in this Pod as environment\nvariables, and that care needs to be taken to avoid conflicting variable names. \n spec.tlsSecretName  is the name of a standard Kubernetes\n TLS Secret  that will be used for the\nresulting Ingress. This is only required if the\n globally configured TLS Secret \nfor the Operator is absent or has not been created with a wildcard hostname that supports this Keycloak instance\'s hostname. \n spec.replicas  - the number of replicas to be made available on the Deployment of this Entando Plugin. \n spec.resourceRequirements  - the minimum and maximum  resource allocation  for the Entando Plugin container. \n EntandoAppPluginLink \n The EntandoAppPluginLink custom resource is created when an AppBuilder user links an EntandoPlugin to the current\nEntandoApp or deploys an EntandoPlugin for use in the current EntandoApp. The Entando Operator processes the resulting\nEntandoAppPluginLink and creates a path for the Plugin on the Ingress that exposes the EntandoApp in question. This path\nis determined by the  spec.ingressPath  property on the EntandoPlugin custom resource itself. If the EntandoPlugin\nresides in a namespace other than the namespace of the EntandoApp, the EntandoOperator creates a Kubernetes\nService in the namespace of the EntandoApp that simply delegates to the Service in the namespace of the EntandoPlugin. \n Overview \n \n Kubernetes Controller Details:\n \n Docker image:  entando/entando-k8s-app-plugin-link-controller \n Github Repo:  entando/entando-k8s-app-plugin-link-controller \n Example \n ---\nkind: "EntandoAppPluginLink"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-link"\n  namespace: "your-namespace"\nspec:\n  entandoAppName: your-app\n  entandoAppNamespace: your-namespace\n  entandoPluginName: your-app\n  entandoPluginNamespace: your-namespace\n Explanation of properties \n \n spec.entandoAppName  specifies the name of the EntandoApp that requires the plugin, found in  EntandoApp.metadata.name \n spec.entandoAppNamespace  specifies the namespace of the EntandoApp that requires the plugin, found in  EntandoApp.metadata.namespace \n spec.entandoPluginName  specifies the name of the EntandoApp that requires the plugin, found in  EntandoPlugin.metadata.name \n spec.entandoPluginNamespace  specifies the namespace of the EntandoApp that requires the plugin, found in  EntandoPlugin.metadata.namespace \n EntandoDatabaseService \n By default, the Entando Operator deploys one of either the MySQL or PostgreSQL database Docker images for every custom\nresource that requires a database. Many customers may, however, have existing infrastructure for their databases which\nthey may want to leverage. The EntandoDatabaseService custom resource allows customers to deploy a Service that points\nto an external database. When deploying one of the Entando Custom Resources that require a database, the Entando\nOperator will look for EntandoDatabases in the same namespace. If it finds one with the same  spec.dbms  setting\nas the database required by the custom resource, it will create a dedicated schema/username/password combination\nfor the custom resource and point the deployment emanating from Custom Resources to this external database. \n Example \n ---\nkind: "EntandoDatabaseService"\napiVersion: "entando.org/v1"\nmetadata:\n  name: "test-database-service"\n  namespace: "your-namespace"\nspec:\n  dbms: "oracle"\n  host: 10.0.12.41\n  port: 1521\n  databaseName: yourdb \n  tablespace: \n  secretName: some-secret\n  jdbcParameters:\n    maxStatements: 300 \n    loginTimeout: 180\n Explanation of properties \n \n spec.dbms  is used to select the database management of choice if this value matches the  spec.dbms  property\nof the Entando custom resource that will use it. Valid values are  oracle ,  postgresql  and  mysql . \n spec.host  can either be a valid IPv4 address or a hostname. Where an IP address is provided, the Entando Operator\nwill create a Kubernetes Service with an associated EndPoints resource to allow for routing to this address. Where\na hostname is provided, the Entando Operator will simply create a Kubernetes Service of type  cname . \n spec.port  is the port that the external database service is running on. This value is optional in which case we will\nuse the default port for the DBMS vendor in question. \n spec.databaseName  is the name of the database that the Entando Operator should be creating schemas in. This property\nis only for use with PostgreSQL and Oracle, as MySQL doesn\'t distinguish between schemas and databases. \n spec.tablespace  is only required for Oracle so that Schemas can be created in different tablespaces. \n spec.secretName  should be the name ( Secret.metadata.name ) of a Kubernetes Secret in the same namespace that has\na  username  key and a  password  key to provide the Entando Operator with the necessary access and permissions\nto create Schemas and users on the database in question. \n spec.jdbcParameters  is a map of name/value pairs that will be appended to the JDBC connection string to allow for\nfurther customization of the actual connection to the database. \n \n'},{title:"Accessing Entando APIs",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/docs/consume/entando-apis.html",relativePath:"v7.0/docs/consume/entando-apis.md",key:"v-384a5208",path:"/v7.0/docs/consume/entando-apis.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:3,title:"Enable or disable the Swagger UI in a running container",slug:"enable-or-disable-the-swagger-ui-in-a-running-container"},{level:2,title:"How to find your client secret",slug:"how-to-find-your-client-secret"},{level:2,title:"Setup in local environment",slug:"setup-in-local-environment"},{level:3,title:"Configure Keycloak",slug:"configure-keycloak"},{level:3,title:"Start the Entando Application",slug:"start-the-entando-application"},{level:2,title:"APIs Overview",slug:"apis-overview"},{level:3,title:"API structure",slug:"api-structure"},{level:3,title:"Models",slug:"models"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Accessing Entando APIs \n Overview \n Entando includes the Swagger UI in a quickstart environment and is reachable at  /entando-de-app/api/swagger-ui.html : \n http://[your-host-name]/entando-de-app/api/swagger-ui.html\n Enable or disable the Swagger UI in a running container \n The Swagger UI can be enabled or disabled in a running container by modifying the SPRING_PROFILES_ACTIVE environment variable for the entando-de-app container. \n \n Edit the deployment. The name may be different outside of a quickstart environment. \n \n sudo kubectl -n entando edit deployment/quickstart-server-deployment\n \n \n \n (Optional) Scale the deployment  spec.replicas  to 0 before updating the deployment. This is necessary if you're using an in-memory database, e.g. the default quickstart configuration, and will prevent database errors that can happen on an immediate restart after the profile is changed. Save the deployment to apply the change. \n \n \n Find the entando-de-app env variables section under  spec.template.spec.containers.env[image: entando-de-app] \n \n \n 4a. To enable the swagger UI, add the SPRING_PROFILES_ACTIVE environment variable, if it's missing, or add  swagger  to its comma-delimited list. \n         - name: SPRING_PROFILES_ACTIVE\n          value: default,swagger\n \n 4b. To disable the swagger UI, remove  swagger  from the value. \n \n \n (Optional) Reset the deployment  spec.replicas  back to 1. \n \n \n Save the deployment to apply the change. \n How to find your client secret \n You'll need your client credentials to execute the Entando APIs. \n \n \n Login into your Keycloak instance \n \n \n Go to  Administration → Clients \n \n \n Select the desired client (e.g. in a quickstart environment this is  quickstart-server ) \n \n \n Click on the  Credentials  tab to get the secret \n Setup in local environment \n You may prefer to run a local standalone Entando application for some tasks. You'll need Java 11, maven, and Keycloak for authentication. See  these instructions  to setup a standalone Keycloak. \n Configure Keycloak \n Configure your Keycloak client in order to support Swagger UI. A quickstart environment has this pre-configured. \n \n \n Login to your Keycloak instance \n \n \n Access the Administration console \n \n \n Click on  Clients  on the left bar and select your client (e.g.  quickstart-server ) \n \n \n Update the following values under  Settings : \n \n Set  Valid Redirect URIs  to  http://localhost:[your port]/entando-de-app/*  or  *  to allow all redirect URIs. \n Set  Web Origins  to  http://localhost:[your port]  or  *  to accept all origins. \n Start the Entando Application \n \n \n Clone the Entando reference application: \n git clone https://github.com/entando/entando-de-app\n \n \n \n Start the application with the following options: \n \n Enable the Swagger profile via  -Dspring.profiles.active=swagger \n Enable the Keycloak profile via  -Pkeycloak \n Configure the application connection to Keycloak itself. For simplicity this uses the same client credentials you'll use to try out the APIs.\n \n Set  -Dkeycloak.auth.url  to your Keycloak endpoint (including  /auth ), e.g.  -Dkeycloak.auth.url=http://my-keycloak-server/auth \n Set  -Dkeycloak.client.id  to your client id, e.g.  -Dkeycloak.client.id=quickstart-server \n Set  -Dkeycloak.client.secret  to your client secret, e.g.  -Dkeycloak.client.secret=my-secret . See  How to find your client secret  above. \n \n \n (Optional) Set -Djetty.port=8085  if the default port 8080 is already in use. \n (Optional) To skip the docker steps (or if you don't have docker installed/running), add  -DskipDocker=true \n \n Here's a full example: \n mvn clean package jetty:run-war -Pjetty-local -Pderby -Pkeycloak -Dspring.profiles.active=swagger -Djetty.port=8085 -Dorg.slf4j.simpleLogger.log.org.eclipse.jetty.annotations.AnnotationParser=error -Dkeycloak.auth.url=http://my-keycloak-host/auth -Dkeycloak.client.id=quickstart-server -Dkeycloak.client.secret=my-client-secret -DskipDocker=true\n \n \n \n Wait for the application to start. \n [INFO] Started ServerConnector@1355c8be{HTTP/1.1, (http/1.1)}{0.0.0.0:8085}\n[INFO] Started @66257ms\n[INFO] Started Jetty Server\n \n \n \n Navigate to the Swagger UI in a browser at  /entando-de-app/api/swagger-ui.html \n  http://localhost:[your port]/entando-de-app/api/swagger-ui.html\n APIs Overview \n The Entando core exposes REST APIs for every action that can be taken in\nthe App Builder environment. For example, you can use\nthese APIs to create pages, create page templates or to add widgets to\npages. The APIs can be used to support automation, testing, or\nintegrations with external systems. \n API structure \n All of the APIs share a common top level structure. Each response will\ncontain a top level entry for  errors ,  metadata , and  payload . \n The  errors  will always contain code and a message string indicating an\nerror condition in the request. The  metadata  section is used for\npaging, sorting, filtering and data that is distinct from the body. The\nbody of each response is included in the  payload  section of the\nresponse and varies according to each API. \n Models \n All of the model classes returned by the Entando core are annotated so that the model definition is included in the Swagger documentation. At the bottom of the Swagger page all of the model classes returned by the API endpoints can be found. \n Tutorial \n \n \n Access your application Swagger UI as discussed above \n \n \n Click on the  Authorize  button in the upper right corner \n \n \n Enter the client id and client secret in the open window and click  Authorize \n \n \n If you are redirected to the Entando login page, log in with your credentials (default are  admin / adminadmin ) \n \n \n You will be redirected to the Swagger UI page, now authenticated \n \n \n Use the  Try it out  button on the APIs \n \n \n Scroll to  widget-controller \n \n \n Select the blue GET row \n \n \n Select  Try it out \n \n \n Look at the results in the window. You should see a Server response with Code 200 and full response body. \n \n \n \n \n"},{title:"Entando Blueprint Features",frontmatter:{},regularPath:"/v7.0/docs/create/blueprint-features.html",relativePath:"v7.0/docs/create/blueprint-features.md",key:"v-4e900774",path:"/v7.0/docs/create/blueprint-features.html",headers:[{level:2,title:"The Features:",slug:"the-features"},{level:2,title:"Premade Widgets",slug:"premade-widgets"},{level:3,title:"Authentication",slug:"authentication"},{level:3,title:"Custom events",slug:"custom-events"},{level:3,title:"Tests and mocks",slug:"tests-and-mocks"},{level:3,title:"PropTypes",slug:"proptypes"},{level:3,title:"Fetching data",slug:"fetching-data"},{level:2,title:"Form widget",slug:"form-widget"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Entando Blueprint Features \n The Entando Blueprint makes it easier and faster to customize your application by generating controllers, repositories, services, and micro frontends for your entity. It means generating those project files in minutes, simply by answering questions that define the parameters of your application. \n The Entando Blueprint uses JHipster technology based on Embedded JavaScript (EJS), a templating language that provides powerful constructs for large scale file generation. \n The Features: \n \n Backend with Spring Boot\n \n Data modeling \n JHipster Design Language (JDL) support \n Keycloak integration \n Liquibase integration for schema upgrade \n Preconfigured Cross-Origin Resource Sharing (CORS) settings \n Profiles (dev, prod) \n Swagger/OpenAPI frontend \n \n \n Frontend with React\n \n .env profiles \n Localization \n Keycloak integration \n \n \n \n For more information: \n \n Install  JHipster Entando Blueprint \n Try implementing an Entando Blueprint--  Create microservices and micro frontents \n Premade Widgets \n When you create an entity using the Entando Blueprint, it generates a few\npremade widgets. Each will be reviewed below. \n \n Authentication \n Custom events \n Tests and mocks \n PropTypes \n Fetching data \n Form widget \n \n We will be using  Conference  as an entity name for the example below. \n What the widgets have in  common : \n \n \n Each widget contains a README file that helps with the setup. \n \n \n All generated widgets are web components created using Custom Elements\nAPI. \n \n \n Each widget is displayed using the custom element tag. For example, inside the\ndetails widget folder  conference/detailsWidget/public/index.html , you\ncan find\n conference-details id=\"1\" override-edit-handler hide-edit-button /> .\nThe element  <conference-details />  is defined in the component entry\npoint at\n conference/detailsWidget/src/custom-elements/ConferenceDetailsElement.js . \n \n \n \n Note \n Custom element names require a hyphen like  conference-details  (kebab-case)--they cannot be single words. \n \n For more information about web components, custom elements and micro\nfrontends, refer to  Create a React micro frontend widget . \n Authentication \n If a widget requires authentication, the component is wrapped in\n KeycloakContext.Provider  and the Keycloak object is fetched from the\n window.entando.keycloak  variable. Entando uses Keycloak as the\nauthentication provider, but you can add any provider as needed. \n ReactDOM.render(\n  <KeycloakContext.Provider value={this.keycloak}>\n    <StylesProvider jss={this.jss}>\n      <ThemeProvider theme={this.muiTheme}>{FormContainer}</ThemeProvider>\n    </StylesProvider>\n  </KeycloakContext.Provider>,\n  this.mountPoint\n);\n \n For more information about the authentication process, please refer\nto the  Authentication section . \n Custom events \n All widgets rely on custom events for communication.  That is why each widget contains custom event creation and removal, along with the event listener creation.  Note that when an event listener is created, it should be when\nthe element is no longer needed. It should be created in the custom\nelement’s  disconnectedCallback()  function. \n To add more event listeners, add the event types to\n INPUT_EVENT_TYPES  object at\n detailsWidget/src/custom-elements/widgetEventTypes.js , which adds\nit to the listener list. To remove the event, simply remove the element from the list. \n For more information about custom events and widget communication,\nplease refer to the section on  Widget communication . \n Tests and mocks \n Each widget has tests written for it. Entando uses\n react-testing-library , but developers are free to upgrade and use any\ntool desired. Tests and mocks are at  detailsWidget/src/components/ . \n PropTypes \n PropTypes for data used across several components are shared. You can\nsee and modify them at  detailsWidget/src/components/ . This way you can\navoid repeating the same propTypes in each component by importing them. \n import React from 'react';\nimport conferenceType from 'components/__types__/conference';\n\nconst ConferenceDetails = props => {\n  // ...\n};\n\nConferenceDetails.propTypes = {\n  conference: conferenceType,\n  t: PropTypes.func.isRequired,\n};\n\nexport default ConferenceDetails;\n Fetching data \n For data fetching from widgets, use Fetch API. You can find the functions for\nfetching data at  detailsWidget/src/api , in different files for\ndifferent contexts. \n Form widget \n For displaying forms within a widget, use\n Formik  which helps with form state\nmanagement. For data validation, use\n Yup . \n"},{title:"The Entando Operator",frontmatter:{},regularPath:"/v7.0/docs/consume/operator-intro.html",relativePath:"v7.0/docs/consume/operator-intro.md",key:"v-3761aa7c",path:"/v7.0/docs/consume/operator-intro.html",headers:[{level:2,title:"TLS Secret Creation",slug:"tls-secret-creation"},{level:2,title:"Database Deployment",slug:"database-deployment"},{level:2,title:"Ingress Path Generation",slug:"ingress-path-generation"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" The Entando Operator \n The Entando Operator processes the custom resources in Kubernetes that represent the different  components of an Entando application .\nThe goal of the operator is to provide automation and a set of default configuration options to simplify and accelerate the deployment of an Entando application. \n The sections below provide details and assumptions that the operator makes when deploying Entando Custom Resources. If you're using OpenShift, these sections will provide details on how to configure your deployment via the Operator Hub. \n For details on the individual custom resources and their configuration, check out the  custom resources documentation .  See the instructions here on deploying via the Entando Operator . \n TLS Secret Creation \n When configuring and deploying Entando via the operator, you will be asked to provide a secret for some of the components in the architecture. A few things to be aware of when creating and configuring a Secret: \n \n The Secret is assumed to be in the same namespace as the component being created. \n This Secret is expected to have a private key, and a certificate for the hostname (or a wildcard certificate) that the service will be exposed on. \n Refer to the 'ingressHostname' property in the custom resource for more information on how the hostname is determined. \n If a Secret isn't provided, the Entando Operator will evaluate the value of the  ENTANDO_PATH_TO_TLS_KEYPAIR , which is expected to contain two files: tls.key and tls.crt.\n \n If a key pair is found in the folder specified, the operator will use that key pair. \n If a key pair is not found, the Entando Operator will evaluate the value of the  ENTANDO_USE_AUTO_CERT_GENERATION . If that property is set to  true , the Entando Operator will assume that the cluster has been configured with a valid Certificate Authority (CA) and leave it to the Ingress controller to generate its own certificates. \n \n \n \n Click here for instructions on setting up TLS in your Entando Apps . \n Database Deployment \n Some Entando components include the option to select a database management system (DBMS): \n \n \n The value of the DBMS field in Entando Custom Resources can be mysql, oracle, postgresql or embedded. \n \n IMPORTANT!  -- If embedded is selected for a component, only one replica for the component can be created. \n IMPORTANT!  -- Oracle instances are not supported for automatic deployment in a container. You must create your own Oracle instance or reuse an existing instance and then configure the  external database  for your EntandoApp. \n \n \n \n If an EntandoDatabaseService has been deployed in the component's namespace and the DBMS specified for this EntandoDatabaseService is the same as the DBMS specified for this EntandoApp, then the Entando Operator will create dedicated\nschemas (in the case of PostgreSQL or Oracle), or databases in the case of MySQL. \n \n If a matching EntandoDatabaseService does not exist in this namespace, the Entando Operator\nwill automatically deploy the appropriate container to host the DBMS specified. This last option is not yet supported for Oracle. \n \n \n \n For an EntandoApp, three schemas/databases will be created: the Entando Port DB, tne Entando Serv DB and a database for the Entando Component Manager. \n \n If the Port and Serv schemas/databases are empty, the Entando Operator  will use the underlying Entando App to populate these databases with the data backup available in the standard backup path in the WAR deployment. \n In scenarios where the EntandoApp needs to connect to an existing database that is fully managed\nby the customer, it is best to setup the standard database connection variables using the\n spec.environmentVariables  property and set this property to 'none'. This will skip any database\npreparations steps in the deployment. \n \n \n \n When deploying a component the operator will evaluate the spec and if it supports the standard  spec.dbms \nproperty, the value of this property will be given to the component's  spec.dbms . Please consult\nthe documentation for each component's CRD to determine how each Entando resource uses the dbms (if any). \n Ingress Path Generation \n When deploying an Entando Custom Resource that uses an Ingress path: \n \n The  ingressHostName  property defines the host path that will be used to access this\nservice from outside the cluster. The Entando Operator will create an ingress with this hostname and expose the resource at its default path. \n \n"},{title:"Customizing the Entando Component Generator",frontmatter:{},regularPath:"/v7.0/docs/create/component-gen-customize.html",relativePath:"v7.0/docs/create/component-gen-customize.md",key:"v-32a2b2dc",path:"/v7.0/docs/create/component-gen-customize.html",lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Customizing the Entando Component Generator \n The Entando Component Generator is an instance of a JHipster blueprint that can be extended to match your team's needs and requirements. If you're interested in extending the blueprint or creating your own blueprint, contact us on the  Entando Forum  or  Community Slack  and we'll help you get started. \n This is the source for the  Entando Blueprint . \n To learn more about creating blueprints and to see other blueprints available from JHipster checkout the  blueprint documentation  or visit  JHipster  for an overview. \n"},{title:"Component Generation Technologies",frontmatter:{},regularPath:"/v7.0/docs/create/component-gen-tech.html",relativePath:"v7.0/docs/create/component-gen-tech.md",key:"v-0f8a9c74",path:"/v7.0/docs/create/component-gen-tech.html",lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Component Generation Technologies \n When generating a microservice using the Entando Component Generator there are a number of technical choices that need to be made \n \n Microservice code\n \n The Component Generator currently only supports the generation of Spring Boot microservices but will support the generation of Quarkus based services soon. \n If you're interested in using Quarkus in your Entando app, contact us on the  Forum  or  Community Slack  and we'll help you get started. \n If you're considering non-Java based microservices,  here is a definition of an Entando plugin , including information on the runtime contract required to use them. \n \n \n Database type\n \n Entando recommends standardizing your choice of database to simplify operational maintenance but you do have the ability to use different databases for different microservices if you choose. \n Supported choices are none, MySQL, and Postgres. Enterprise customers can choose Oracle but should contact Entando Support for details. \n \n \n Development databases\n \n You can choose to utilize a full RDBMS or developers can utilize lightweight in memory or on disk databases with h2. \n \n \n Caching implementation\n \n When generating a microservice you will be presented with the type of cache to inject into the services. It is recommended that this is a standard choice for all of the microservices in your application but can be customized on a per service basis if desired. \n \n \n Build system\n \n Determines the java build tool to use when building your services \n Supports maven or gradle \n \n \n Other technologies\n \n Users of the component generator can also decide to use other technologies from JHipster or from the JHipster marketplace. \n There are many powerful technologies in the marketplace but it is up to the developer to integrate any choices from the marketplace into their Entando application. Entando doesn't provide any direct support for marketplace tech choices. \n \n \n Micro frontends\n \n Users can optionally choose to generate micro frontends for entities generated via the blueprint. \n The Entando Component Generator only provides micro frontends in React from the generation flow but developers can create and bundle micro frontends using other technologies as well. \n \n \n \n If you want to try out these choices follow the tutorial on  creating Entando microservices and micro frontends using the component generator . \n"},{title:"Bundle and Component Descriptors",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/docs/curate/ecr-bundle-details.html",relativePath:"v7.0/docs/curate/ecr-bundle-details.md",key:"v-1acd0da6",path:"/v7.0/docs/curate/ecr-bundle-details.html",headers:[{level:3,title:"Bundle Conventions",slug:"bundle-conventions"},{level:3,title:"Bundle Descriptor",slug:"bundle-descriptor"},{level:2,title:"Plugin",slug:"plugin"},{level:3,title:"Permissions",slug:"permissions"},{level:2,title:"Widget",slug:"widget"},{level:2,title:"Fragment",slug:"fragment"},{level:2,title:"Page Template",slug:"page-template"},{level:2,title:"Page",slug:"page"},{level:2,title:"CMS Asset",slug:"cms-asset"},{level:2,title:"Content Template",slug:"content-template"},{level:2,title:"Content Type",slug:"content-type"},{level:2,title:"Content",slug:"content"},{level:2,title:"Categories",slug:"categories"},{level:2,title:"Groups",slug:"groups"},{level:2,title:"Labels",slug:"labels"},{level:2,title:"Languages",slug:"languages"},{level:2,title:"Static Resources",slug:"static-resources"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Bundle and Component Descriptors \n The Entando Component Manager reads the  descriptor.yaml  file from the root of the bundle package and uses it to install any components and resources included in the bundle. \n The different component types are shown below: \n \n Here is the basic bundle structure: \n .\n├ descriptor.yaml\n├ resources/\n│ └ ...\n└ ... (folders reported in descriptor.yaml file)\n Bundle Conventions \n \n \n The bundle descriptor file must be named  descriptor.yaml  or the bundle will not be recognized. \n \n \n Static resources should be placed in a  resources  folder. They are not explicitly referenced in the  descriptor.yaml  file itself. \n Bundle Descriptor \n The bundle descriptor YAML file aggregates all included components and has the structure shown below. Note that the Page Template feature is  pageModels  and the Content Template feature is  contentModels . \n \n Warning \n The bundle descriptor file must be named  descriptor.yaml \n \n descriptor.yaml \n code: survey_bundle # The bundle ID\ndescription: This is the survey bundle # The description of the bundle\n\ncomponents: # All components are listed here.\nOptional. Use if the component requires deployment\n  plugins:\n    - folder/you/want/your_plugin_descriptor.yaml\n    - folder/you/want/another_plugin_descriptor.yaml\nTo create Widgets, add references to the descriptor files \n  widgets:\n    - widgets/your_widget_descriptor.yaml\n    - widgets/another_widget_descriptor.yaml\nTo create Fragments, add references to the descriptor files \n  fragments:\n    - fragments/your_fragment.yaml\nTo create Page Templates, add references to the descriptor files \n  pageModels:\n    - pageModels/your_page_model_descriptor.yaml\n    - pageModels/another_page_model_descriptor.yaml\nTo create and publish Pages, add references to the descriptor files \n  pages:\n    - page/your_page_descriptor.yaml\n    - page/another_page_descriptor.yaml\nTo create a CMS Asset, add a reference to the descriptor file in the same location \nas the image or file you want to upload\n  assets:\n    - assets/your-asset/your_asset_descriptor.yaml\n    - assets/your-asset/your_image.jpg\nTo create Content Types, add references to the descriptor files\n  contentTypes:\n    - contentTypes/your_content_type_descriptor.yaml\nTo create Content Templates, add references to the descriptor files\n  contentModels:\n    - contentModels/your_content_model_descriptor.yaml\n    - contentModels/another_content_model_descriptor.yaml\nTo create and publish Contents, add references to the descriptor files\n  contents:\n    - contents/your_content_descriptor.yaml\n    - contents/another_content_descriptor.yaml\nTo create Categories, add references to the descriptor files\n  categories:\n    - categories/your_categories.yaml\nTo create Groups, add references to the descriptor files\n  groups:\n    - groups/your_groups.yaml\nTo create Labels, add references to the descriptor files\n  labels:\n    - labels/your_labels.yaml\nTo enable Languages, add references to the descriptor files\n  languages:\n    - languages/languages.yaml\n Plugin \n Here is an example of a plugin descriptor: \n Plugin descriptor.yaml \nDescriptor version field added in v3 and later. \nTo take advantage of the environment variables below, v4 will need to be specified.\ndescriptorVersion: "v4" \nThe Docker image used to create the plugin\nimage: "entando/your-image:1.0.0" \nThe base name to assign to pods that have to be created in Kubernetes\ndeploymentBaseName: "yourplugin" \nThe DBMS the plugin will use\ndbms: "postgresql" \nThe roles the plugin will expose in Keycloak\nroles: \n  - "task-list"\n  - "task-get"\n  - "connection-list"\n  - "connection-get"\n  - "connection-create"\n  - "connection-delete"\n  - "connection-edit"\nThe health check path that Kubernetes will use to check the status \nof the plugin deployment  \nhealthCheckPath: "/actuator/health" \nThe ingress path to assign to the plugin deployment \ningressPath: "/your-plugin-path"\nA list of Keycloak clientIds/roles to bind to one another\npermissions: \n  - clientId: realm-management\n    role: manage-users\n  - clientId: realm-management\n    role: view-users\nA set of environment variables that can be set inline or \nreferenced as Secrets in the namespace. Supported as of descriptorVersion v4.\nenvironmentVariables:\n  - name: SIMPLE_VAR  # directly injects the value\n    value: yourSimpleValue\n  - name: SECRET_VAR  # leverages a secret value\n    valueFrom:\n      secretKeyRef:\n        name: YOUR-BUNDLE-ID-your-secret\n        key: yourSecretKey\n \n TIP \n Entando uses the  healthCheckPath  to monitor the health of the plugin. A plugin in an Entando Bundle can use any technology, as long as it provides a health check service configured via the  healthCheckPath . This path must be specified in the descriptor file and return an HTTP 200 or success status. This can be implemented by a Java service included with the Entando Blueprint in the Spring Boot application. You can also  use a Node.js service as shown here . \n \n TIP \n See the  Plugin Environment Variables  tutorial to setup environment variables, either inline or based on Kubernetes Secrets. \n Permissions \n The  permissions  property specifies a list of coupled  clientIds  and roles that will be bound in Keycloak. To find them, open the Keycloak console and navigate to  clients  →  awesomeplugin-server  →  Service Account Roles . \n Widget \n Here is an example of a Widget descriptor: \n Widget descriptor.yaml \n code: another_todomvc_widget # The Widget identification\n\ntitles: # Widget\'s Titles\n  en: TODO MVC Widget # Title in English\n  it: TODO MVC Widget # Title in Italian\n\ngroup: free # The owner group of the Widget\nOptional. The UI Path, where the widget.ftl file will have the customUi content\ncustomUiPath: widget.ftl\nOptional. The Custom UI\ncustomUi: >-\n    <h1>Your Custom Widget UI</h1>\nOptional. The ConfigUI\nconfigUi:\n  customElement: todomvc-config # The name of the custom element used to render the configUI\n  resources:\n    - <bundleid>/static/js/main.js # The resources necessary for the custom element to render the configUI, like the code\n Fragment \n Here is an example of a Fragment descriptor: \n Fragment descriptor.yaml \n code: your_fragment # The unique ID\nOptional. The Fragment content\nguiCode: >-\n  "<div>Here is the content</div>"\nOptional. A path to a FreeMarker file containing the Fragment content\nguiCodePath: fragment.ftl\n Page Template \n Here is an example of a Page Template descriptor: \n Page Template descriptor.yaml \n code: todomvc_page_template # The Page Template identification\ndescription: TODO MVC basic page template # The Page Template description\n\ntitles: # Page Template\'s Titles\n  en: TODO MVC PageTemplate # Title in English\n  it: TODO MVC PageTemplate # Title in Italian\nThe Page Template configuration\nconfiguration:\n  frames: # All frames\n    - pos: 0 # Frame position\n      description: Header # Frame description\n      sketch: # Frame sketch configuration\n        x1: 0\n        y1: 0\n        x2: 11\n        y2: 1\n      defaultWidget:\n        code: your-widget # the Widget code to apply when using the button "apply default widgets" in the page configuration UI\nA simplified way to define a Frame\n    - pos: 1\n      description: Breadcrumb\n      sketch: { x1: 0, y1: 0, x2: 11, y2: 1 }\nOptional. Define the Page Template in a separate file or inside the descriptor file with `template`\ntemplatePath: page.ftl\nOptional. Define the Page Template as below or in a separate file with `templatePath`\ntemplate: >-\n  <#assign wp=JspTaglibs[\\"/aps-core\\"]>\n  <!DOCTYPE HTML PUBLIC \\"-//W3C//DTD HTML 4.0 Transitional//EN\\">\n  <html>\n      <head>\n          <title><@wp.currentPage param=\\"title\\" /></title>\n      </head>\n      <body>\n          <h1><@wp.currentPage param=\\"title\\" /></h1>\n          <a href=\\"<@wp.url page=\\"homepage\\"/>\\">Home</a><br>\n          <div>\n              <h1>Bundle 1 Page Template</h1>\n              <@wp.show frame=0 />\n          </div>\n      </body>\n  </html>\n Page \n This descriptor enables a page to be created and published via a bundle. Page status can be  published  or  draft . The Widget section can be used to fully configure a page layout. \n Groups in a page descriptor are configured by  ownerGroup  and  joinGroups . The  ownerGroup  property specifies the group of users who can manage the entity in the AppBuilder. The  joinGroups  property specifies who can view or access the page. For example, setting  ownerGroup  to "free" means anyone with access to the AppBuilder can manage the page, whereas setting  joinGroup  to "free" means any end user can view the page in the application. \n Page descriptor.yaml \n code: dashboard\nparentCode: homepage\ntitles:\n  en: your dashboard\n  it: La mia Dashboard\npageModel: dashboard\nownerGroup: free\njoinGroups: []\ndisplayedInMenu: true\nseo: false\ncharset: utf-8\nECR will publish the page according to this property\nstatus: published|draft\nPage Configuration\nwidgets:\n  - code: Brand-Logo\n    config: null\n    pos: 0\n  - code: Login_buttons\n    config: null\n    pos: 2\n  - code: seeds_card\n    config:\n      cardname: creditcard\n    pos: 6\n  - code: list_item\n    config:\n      icon: managealerts\n      count: \'0\'\n      title: Alerts\n    pos: 7\n  - code: list_item\n    config:\n      icon: viewstatements\n      count: \'0\'\n      title: View Statements\n    pos: 11\n  - code: seedscard-transaction-table\n    config: null\n    pos: 13\n CMS Asset \n This descriptor contains the metadata required for uploading and updating a CMS Asset. \n Asset descriptor.yaml \n correlationCode: \'your-reference-code\'\ntype: image\nThis file should be placed in the same folder as the descriptor.yaml\nname: 113f4437cac3b3f3d4db7229f12287a4_d3.png\ndescription: 113f4437cac3b3f3d4db7229f12287a4_d3.png\ngroup: free\ncategories: []\n Content Template \n Here is an example of a Content Template descriptor: \n Content-template descriptor.yaml \n id: 8880003\ncontentType: CNG\ndescription: Demo Content Template\nOptional. Define the Content Template Shape in a separate file or inside the descriptor file with `contentShape`\ncontentShapePath:\nOptional. Define the Content Template Shape as below or in a separate file with `contentShapePath`\ncontentShape: >-\n  <article>\n    <h1>$content.Title.text</h1>\n    <h2>Demo content template</h2>\n    #if ( $content.MainBody.text != "" )\n    $content.MainBody.text\n    #end\n  </article>\n\n\nwidgets:\n  - code: Brand-Logo\n    config: null\n    pos: 0\n  - code: Login_buttons\n    config: null\n    pos: 2\n  - code: seeds_card\n    config:\n      cardname: creditcard\n    pos: 6\n  - code: list_item\n    config:\n      icon: managealerts\n      count: \'0\'\n      title: Alerts\n    pos: 7\n  - code: list_item\n    config:\n      icon: viewstatements\n      count: \'0\'\n      title: View Statements\n    pos: 11\n  - code: seedscard-transaction-table\n    config: null\n    pos: 13\n Content Type \n For more details on Content Type properties, refer to the  Content Type documentation . \n Content-type descriptor.yaml \n code: CNG\nname: Demo\nstatus: 0\n\nattributes:\n  - code: title\n    type: Text\n    name: Title\n    roles:\n      - code: jacms:title\n        descr: The main title of a Content\n    disablingCodes: []\n    mandatory: true\n    listFilter: false\n    indexable: false\n\n    enumeratorStaticItems: string\n    enumeratorStaticItemsSeparator: string\n    enumeratorExtractorBean: string\n\n    validationRules:\n      minLength: 0\n      maxLength: 100\n      regex: string\n      rangeStartString: string\n      rangeEndString: string\n      rangeStartStringAttribute: string\n      rangeEndStringAttribute: string\n      equalString: string\n      equalStringAttribute: string\n      rangeStartDate: string\n      rangeEndDate: string\n      rangeStartDateAttribute: string\n      rangeEndDateAttribute: string\n      equalDate: string\n      equalDateAttribute: string\n      rangeStartNumber: 0\n      rangeStartNumberAttribute: string\n      rangeEndNumber: 0\n      rangeEndNumberAttribute: string\n      equalNumber: 0\n      equalNumberAttribute:\n      ognlValidation:\n        applyOnlyToFilledAttr: false\n        errorMessage: Something\n        keyForErrorMessage: some\n        keyForHelpMessage: thing\n        ognlExpression: string\n Content \n This descriptor enables content to be created and optionally published via a bundle, according to the  status  property. The content ID is optional and enables linking from other components, like Content Widget. It can be autogenerated or explicitly declared. \n Groups in a content descriptor are configured by the owner group  mainGroup  and the join group  groups . The owner group consists of users who can manage the content within AppBuilder, while the join group consists of users who can view the content. \n Content descriptor.yaml \n id: NWS650\ntypeCode: NWS\ndescription: Dealing with a financial emergency\nmainGroup: free\ngroups:\n  - free\nstatus: PUBLIC\nattributes:\n  - code: date\n    value: \'2020-04-23 00:00:00\' # the date should be in ISO-8601 format\n  - code: title\n    values:\n      en: Dealing with a financial emergency\n  - code: subtitle\n    values:\n      en: |\n        <p>How to tackle financial stress</p>\n  - code: body\n    values:\n      en: |\n        <p>For many Americans, financial concerns are their number-one stress point. Here are 6 ways to help reduce your money stress and get motivated to take control of your finances.</p>\n  - code: img\n    values:\n      en:\n        correlationCode: \'651\'\n        name: bank_750xx684385064_d0.jpg\n  - code: links\n    elements:\n      - code: links\n        value:\n          symbolicDestination: \'#!U;http://www.yoursite.com/!#\'\n          destType: 1\n          urlDest: \'http://www.yoursite.com/\'\n          pageDest: null\n          contentDest: null\n          resourceDest: null\n        values:\n          en: vostro sito\n      - code: links\n        value:\n          symbolicDestination: \'#!U;http://www.yoursite.com/!#\'\n          destType: 1\n          urlDest: \'http://www.yoursite.com/\'\n        values:\n          en: vostro sito 2\n  - code: attaches\n    elements:\n      - code: attaches\n        values:\n          en:\n            correlationCode: \'205\'\n            name: Entando_Admin_Console_Overview_4.3.3_EN.pdf\n Categories \n This descriptor contains a list of Categories: \n Category descriptor.yaml \n - code: new-category # Identifies the Category\n  parentCode: home # The parent Category; home is the base category\n  titles:\n    it: "Una nuova categoria" # Category name in Italian\n    en: "New category" # Category name in English\n Groups \n This descriptor contains a list of Groups: \n Group descriptor.yaml \n - code: your_group # Identifies the Group\n  name: "Your group" # The name of the Group\n Labels \n This descriptor contains a list of Labels: \n Label descriptor.yaml \n - key: YOUR-FIRST-LABEL # Identifies the Label\n  titles: # The titles on the Label\n    it: Vostro Titolo # The title in Italian\n    en: Your Title # The title in English\n Languages \n This descriptor contains a list of Languages to enable during the installation process: \n Language descriptor.yaml \n - code: en\n  description: English\n- code: it\n  description: Italian\n Static Resources \n In order to upload static files, you will need to create a folder called  resources . All files inside this folder will be uploaded into Entando with the same folder structure. \n resources/\n├ css/\n│ └ styles.css\n├ js/\n│ └ script.js\n├ images/\n│ ├ favicon.ico\n│ └ logo.png\n└ page.html\n \n Using the structure above, the resultant files in the Entando architecture will be: \n your-bundle-id/\n├ css/\n│ └ styles.css\n├ js/\n│ └ script.js\n├ images/\n│ ├ favicon.ico\n│ └ logo.png\n└ page.html\n \n \n Important \n The  code  property  your-bundle-id  is inside  descriptor.yaml . \n \n To use static files in a Widget or Page Template, use the FTL tag  <@wp.resourceURL /> : \n <img src="<@wp.resourceURL />your-bundle-id/images/logo.png">\n<link rel="stylesheet" href="<@wp.resourceURL />your-bundle-id/css/styles.css">\n<link rel="shortcut icon" href="<@wp.resourceURL />your-bundle-id/images/favicon.ico" type="image/x-icon"/>\n<script type="application/javascript" src="<@wp.resourceURL />your-bundle-id/js/script.js"><\/script>\n \n '},{title:"Entando Component Generator",frontmatter:{},regularPath:"/v7.0/docs/create/component-gen-overview.html",relativePath:"v7.0/docs/create/component-gen-overview.md",key:"v-e897f2b4",path:"/v7.0/docs/create/component-gen-overview.html",headers:[{level:2,title:"Objectives",slug:"objectives"},{level:2,title:"Generated Component Flow",slug:"generated-component-flow"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Entando Component Generator \n The Entando Component Generator, powered by JHipster, is a tool that gives developers the ability to quickly generate Entando components to extend an Entando Application. \n The component generator takes advantage of the concept of  JHipster blueprints  to provide powerful templating and standard generation patterns. \n Objectives \n The component generator has two main objectives \n \n \n Accelerate development \n \n Automate the creation of microservices and micro frontends with code that runs without changes. Start from running software. \n Code is meant to be developed on and changed by developers. Ready for customization. \n Using standard tools, technologies, and patterns that can be consumed by developers who are not familiar with the underlying blueprint \n \n \n \n Standardize microservice creation and technology choices \n \n Encode business standards for networking, monitoring, build tools, and distribution into a blueprint to ensure that developers are starting from a technical point that matches your teams requirements \n Ensure code follows standards and practices of your teams including code formatting, testing tools, static analysis tools, package structures, and other rules specific to your organization \n Enable teams to quickly recognize and adopt code from system integrators and other third parties because the patterns and standards are encoded in the starting point of your applications \n Generated Component Flow \n This section provides an overview of the component generation process. If you want to jump into the code and a tutorial start here:  Entando Component Generator Tutorial \n \n \n \n Create components \n \n The Component Generator will create a Spring Boot microservice and optionally will create React micro frontends for entities that you add to your project \n The microservice and generated micro frontends are runnable out of the box and preconfigured to connect to  Entando Identity Management \n The code is meant to be edited and enhanced by developers. JHipster provides interactive updates and merges if you need to re-run the generator or add new functionality via JHipster \n The microservice includes liquibase and integrated data mocking if you want to generate data in your API calls \n \n \n \n Define bundle and deploy assets \n \n The Entando blueprint includes scripts and tools to automatically generate a bundle ready for deployment to the ECR. The bundle will include your microservice, generated microfrontends, and any microfrontends that you have created manually under the  ui  folder \n The generated Spring Boot microservice can be built and deployed to a Docker registry using the provided maven Jib plugin \n Generated bundles can be pushed to a git repository of the users choice \n \n \n \n Deploy bundles to  Entando Component Repository (ECR) \n \n Once your Docker images are pushed to your registry and your bundle is available in Git you can generate an Entando bundle descriptor and push the bundles to the ECR \n The bundles can be versioned and updated using tags in the git repository \n \n \n \n Install in Entando Apps \n \n Once the bundles are in the ECR they are available for deployment in any Entando application that has access to the ECR in the cluster \n \n \n \n"},{title:"Filtering bundles",frontmatter:{},regularPath:"/v7.0/docs/curate/ecr-bundle-filters.html",relativePath:"v7.0/docs/curate/ecr-bundle-filters.md",key:"v-ce697074",path:"/v7.0/docs/curate/ecr-bundle-filters.html",headers:[{level:2,title:"Filtering bundles by component",slug:"filtering-bundles-by-component"},{level:3,title:"Supported labels keys are:",slug:"supported-labels-keys-are"},{level:3,title:"Example",slug:"example"},{level:2,title:"Filtering bundles by status",slug:"filtering-bundles-by-status"},{level:2,title:"Filtering bundles by textual search",slug:"filtering-bundles-by-textual-search"},{level:2,title:"Mixing search criteria",slug:"mixing-search-criteria"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Filtering bundles \n ECR bundles are filterable by component, by status or by textual research. \n Filtering bundles by component \n ECR bundles are filterable by component from App Builder user interface. \n \n Behind the scenes, filtering is done using the label-based filtering provided out of the box from Kubernetes. \n To enable filtering of a bundle, the custom-resource representing the bundle on the Entando Cluster needs to contain the correct labels. An important note on the values to add the  labels  field, even if to correctly define a label in a k8s resource both the key and the value are required, from an Entando point of view only the key part of the label is used for filtering. The value could be set to anything, but our reccomendation is to use  "true"  for clarity and simplicity. \n Supported labels keys are: \n \n \n \n \n \n \n \n Label entry \n Description \n \n \n \n \n widget: "true" \n The bundle contains one or more microfrontends (widgets)  \n \n \n plugin: "true" \n The bundle contains one or more microservices (plugins) \n \n \n fragment: "true" \n The bundle contains one or more fragments \n \n \n pageTemplate: "true" \n The bundle contains one or more page templates \n \n \n contentType: "true" \n The bundle contains one or more content types \n \n \n contentTemplate: "true" \n The bundle contains one or more content templates \n Example \n Here is an example of the metadata for a ecr bundle containg micro-frontends, some microservices and page templates \n apiVersion: entando.org/v1\nkind: EntandoDeBundle\nmetadata:\n  name: demo-bundle\n  labels:\n    widget: "true"\n    plugin: "true"\n    pageTemplate: "true"\nspec:\n  details:\n  ...\n Filtering bundles by status \n ECR bundles are filterable by status from App Builder user interface. \n \n You can choose to see the full list of the bundles available in Kubernetes cluster by selecting the  Explore  tab, or the list of the currently installed bundles by clicking on the  Installed  tab. \n Filtering bundles by textual search \n You can search for bundles containing some keywords by executing a textual search. \n \n You can open the menu on the left to select which field to target. \n If you are creating a new bundle, keep in mind the textual search is performed against data extracted from the bundle CRD file. \n Mixing search criteria \n You can mix all previous search criteria to refine the scope of your search as you want.\nFor example, you could search for all available bundles ( Explore  tab) that contain  Page Templates  components\n(using the checkboxes) and the word  Login  in their name (using the textual search). \n'},{title:"Bundle versions and updates - FAQ",frontmatter:{},regularPath:"/v7.0/docs/curate/ecr-bundle-versions-faq.html",relativePath:"v7.0/docs/curate/ecr-bundle-versions-faq.md",key:"v-3b569df0",path:"/v7.0/docs/curate/ecr-bundle-versions-faq.html",headers:[{level:2,title:"Does the ECR support versioning?",slug:"does-the-ecr-support-versioning"},{level:2,title:"How is a bundle version defined?",slug:"how-is-a-bundle-version-defined"},{level:2,title:"What format should I use to version my bundle?",slug:"what-format-should-i-use-to-version-my-bundle"},{level:2,title:"As a bundle developer, how should I create a new version of a bundle?",slug:"as-a-bundle-developer-how-should-i-create-a-new-version-of-a-bundle"},{level:2,title:"How to prevent a particular bundle version from being visible in the ECR?",slug:"how-to-prevent-a-particular-bundle-version-from-being-visible-in-the-ecr"},{level:2,title:"My bundle contains a microservice generated with the Entando Component Generator, does the version of the microservice have to be the same as the bundle version?",slug:"my-bundle-contains-a-microservice-generated-with-the-entando-component-generator-does-the-version-of-the-microservice-have-to-be-the-same-as-the-bundle-version"},{level:2,title:"How bundle versions are installed from the ECR",slug:"how-bundle-versions-are-installed-from-the-ecr"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Bundle versions and updates - FAQ \n Does the ECR support versioning? \n A bundle, as discussed in the  overview , is a package containing one or more components.\nAs in many other packaging systems, the ECR supports bundle versioning, allowing developers to create and release improvements of their package over time. \n How is a bundle version defined? \n In the ECR, the bundle custom resource comes with a set of  tags , each one representing a version of the bundle.\nHere an example for a CMS quickstart bundle \n apiVersion: entando.org/v1\nkind: EntandoDeBundle\nmetadata:\n    name: cms-quickstart-bundle\nspec:\n  details:\n    name: Entando Example CMS Bundle\n    description: Example Bundle containing CMS components for the Quickstart experience\n  tags:\n    - integrity: ''\n      shasum: ''\n      tarball: 'https://github.com/entando/entando-cms-quickstart-bundle.git'\n      version: v0.0.1\n    - integrity: ''\n      shasum: ''\n      tarball: 'https://github.com/entando/entando-cms-quickstart-bundle.git'\n      version: v0.0.2\n \n As you can see from the code above, the bundle  cms-quickstart-bundle  has 2 versions available.\nEach version in the  tags  object must correspond a tag in the git repository provided in the  tarball  field. \n What format should I use to version my bundle? \n The ECR requires versions to follow the  semantic versioning 2.0.0 , with the possibility to prepend a  v  to the version itself. Some valid bundle versions are: \n \n 1.0 \n v0.1.0-alpha \n 1.0.1-SNAPSHOT \n 22.109.10234-RC.1 \n As a bundle developer, how should I create a new version of a bundle? \n If you're a bundle developer and you want to release a new version of your bundle, you can simply update the content of your bundle and commit the changes to the bundle git repository.\nOnce all the required changes are committed, you can create a new tag in the git repository using the  git tag  command and publish it to the remote repository using the  git push --tags  command \n For example, let's assume my bundle already has a version  1.0.0  and I want to publish the version  2.0.0  of my bundle, here the commands I need to use to create and publish the new tag: \n     git tag -a \"2.0.0\" -m \"My new version\"\n    git push --tags\n How to prevent a particular bundle version from being visible in the ECR? \n If, for some reason, you don't want a particular version to be available for the installation, you can proceed as follows: \n \n You can edit the bundle directly using the command  kubectl edit entandodebundles.entando.org -n <namespace-of-the-bundle> <name-of-the-bundle> \n \n or if you still have the original file you can also: \n \n remove the undesired version from the tag list in your bundle Kubernetes file ( integrity ,  shasum ,  tarball  and  version ) \n delete your bundle from your cluster using a command like this  kubectl delete -f your-bundle-file.yml [-n your-cluster-namespace] \n upload your bundle again to Kubernetes using a command like this  kubectl create -f your-bundle-file.yml [-n your-cluster-namespace] \n My bundle contains a microservice generated with the Entando Component Generator, does the version of the microservice have to be the same as the bundle version? \n The version of the microservice - or to be more precise the docker image associated with the microservice - isn't bound to the version of the bundle containing the microservice itself. \n This gives the bundle developer complete control over the bundle release process, especially in those situations where the bundle contains more components and even more microservices. \n How bundle versions are installed from the ECR \n When the user decides to install a version of the bundle, the ECR checks the provided tag in the git repository and clones locally just the content of the repository for that tag. \n For this reason it's important that for each provided tag in the custom-resource a corresponding tag is available in the git repository, otherwise the ECR will not be able to donwload the bundle and will throw an error. Note that the ECR can only see published tags, so make sure that all the time you create a new tag in your git repository you publish it to the remote repository too. \n"},{title:"How to customize bundle info shown in Entando App Builder",frontmatter:{},regularPath:"/v7.0/docs/curate/ecr-bundle-presentation-config.html",relativePath:"v7.0/docs/curate/ecr-bundle-presentation-config.md",key:"v-862815f4",path:"/v7.0/docs/curate/ecr-bundle-presentation-config.html",lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" How to customize bundle info shown in Entando App Builder \n \n In the image above you can see an example of a bundle as is displayed in the ECR user interface inside the Entando App Builder. \n The corresponding custom-resource file on Kubernetes is similar to this: \n apiVersion: entando.org/v1\nkind: EntandoDeBundle\nmetadata:\n  name: simple-entando-bundle\nspec:\n  details:\n    name: \"Entando Bundle\"\n    description: An example of an Entando bundle\n    dist-tags:\n      latest: v0.0.1\n    time:\n      created: '2020-05-20T15:59:21.946Z'\n      modified: '2020-05-20T15:59:21.946Z'\n      v0.0.1: '2020-05-20T15:59:21.946Z'\n    versions:\n      - v0.0.1\n    keywords:\n      - entando6\n    author: Entando\n    thumbnail: >-\n      data:image/jpeg;base64,....\n  tags:\n....\n \n In order to change the UI elements, you need to update the custom-resource in accordance with this table \n \n \n \n Field \n UI Element \n \n \n \n \n spec.details.name \n Set the bundle title \n \n \n spec.details.description \n Set the bundle description (only visible in the list presentation format) \n \n \n spec.details.thumbnail \n Set the bundle thumbnail, expressed as a base64 encoded string \n \n \n spec.details.dist-tags.latest \n Set what's the latest version of the bundle \n \n \n \n"},{title:"How Microservices get Connected to Entando Apps",frontmatter:{},regularPath:"/v7.0/docs/curate/ecr-how-microservices-connect-to-apps.html",relativePath:"v7.0/docs/curate/ecr-how-microservices-connect-to-apps.md",key:"v-4aeaf8dc",path:"/v7.0/docs/curate/ecr-how-microservices-connect-to-apps.html",headers:[{level:2,title:"How a Microservice from a Bundle gets Deployed with the ECR?",slug:"how-a-microservice-from-a-bundle-gets-deployed-with-the-ecr"},{level:2,title:"Other Options",slug:"other-options"},{level:2,title:"Kubernetes naming conventions",slug:"kubernetes-naming-conventions"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" How Microservices get Connected to Entando Apps \n In this document we will describe some of the assumptions and details related to the process of connecting a microservice part of a bundle to an Entando App. \n In order to fully understand the concepts explained in this piece of the documentation, please make sure you have familiarity with these concepts: \n \n Entando custom resources \n Entando ingresses \n How a Microservice from a Bundle gets Deployed with the ECR? \n When a bundle containing a microservice is installed using the ECR, behind the scenes some actions take place. \n \n To begin, an  EntandoPlugin custom resource  is generated starting from the PluginDescriptor. Some fields will be automatically generated from the provided image. \n \n \n From the  image  field in the PluginDescriptor, we will extract the  organization ,  name  and  version  of the image. \n organization ,  name  and  version  are then converted to valid characters and composed to form the plugin name ( metadata.name ), the labels ( metadata.labels ) and the ingressPath ( spec.ingressPath ) of the custom resource. \n \n NOTE : Two PluginDescriptors having images with the same organization, name and version will generate a custom resource with the same  metadata.name  and  spec.ingressPath . \n \n Next, a check for a microservice with the same name is performed to verify if a new deployment is required for the microservice. \n If a microservice with the same name is not available in the namespace where the Entando App has been deployed, a new EntandoPlugin custom resource is created and deployed in the namespace using the details defined in the bundle. \n At the same time, an EntandoAppPluginLink custom resource is deployed in the namespace in order to expose the microservice ingress path on the EntandoApp ingress. \n If both the EntandoPlugin custom resource and the EntandoAppPluginLink are deployed correctly, the APIs of the microservice will be available from the same domain of the EntandoApp, making it possible reach those APIs from the EntandoApp using relative urls. \n \n This is the standard flow when no other micorservice with a given name is already available in the EntandoApp namespace. \n If there is an existing microservice with the same name as the one generated from the PluginDescriptor, the ECR will connect the EntandoApp to\nthe existing microservice by generating and deploying the required EntandoAppPluginLink per step 3 above.\nThis way, plugins can be reused by many applications at the same time. \n Other Options \n The naming convention recommendations above are accurate for creating bundles and for self contained applications where the Entando operator is managing the lifecycle of your microservices. If you have a substantial API infrastructure or you intend to deploy a large number of versioned microservices you can also utilize Entando with API management infrastructure like API gateways. If you are using an API gateway or other API abstraction layer you will need to manually manage the ingress for your micro frontends in your application to point to the API gateway deployment. \n In cases where conflicts occur bundles can easily be renamed by updating metdata. \n Kubernetes naming conventions \n Here some rules about naming conventions extracted from the  Kubernetes documentation on object names and ids \n \n Most resource types require a name that can be used as a DNS subdomain name as defined in RFC 1123. This means the name must: \n \n contain no more than 253 characters \n contain only lowercase alphanumeric characters, '-' or '.' \n start with an alphanumeric character \n end with an alphanumeric character \n \n \n"},{title:"Troubleshooting ECR",frontmatter:{},regularPath:"/v7.0/docs/curate/ecr-troubleshooting-guide.html",relativePath:"v7.0/docs/curate/ecr-troubleshooting-guide.md",key:"v-619bf73c",path:"/v7.0/docs/curate/ecr-troubleshooting-guide.html",headers:[{level:2,title:"A bundle installation/removal has failed, how to access the logs?",slug:"a-bundle-installation-removal-has-failed-how-to-access-the-logs"},{level:3,title:"Overview",slug:"overview"},{level:3,title:"Solution",slug:"solution"},{level:2,title:"My bundle has an issue, how should I publish a new version of the bundle?",slug:"my-bundle-has-an-issue-how-should-i-publish-a-new-version-of-the-bundle"},{level:3,title:"Overview",slug:"overview-2"},{level:3,title:"Solution",slug:"solution-2"},{level:2,title:"Bundle installation fails because a file has not been found in the bundle",slug:"bundle-installation-fails-because-a-file-has-not-been-found-in-the-bundle"},{level:3,title:"Overview",slug:"overview-3"},{level:3,title:"Solution",slug:"solution-3"},{level:2,title:"Bundle installation failed due to plugin(s) images not reachable",slug:"bundle-installation-failed-due-to-plugin-s-images-not-reachable"},{level:3,title:"Overview",slug:"overview-4"},{level:3,title:"Solution",slug:"solution-4"},{level:2,title:"I can't uninstall a bundle because some components are in use",slug:"i-can-t-uninstall-a-bundle-because-some-components-are-in-use"},{level:3,title:"Overview",slug:"overview-5"},{level:3,title:"Solution",slug:"solution-5"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Troubleshooting ECR \n A bundle installation/removal has failed, how to access the logs? \n Overview \n Currently the Entando component manager logs are available in kubernetes via dashboard (openshift) or cli tools (k9s or kubectl).\nIf in you Entando cluster you have more than one Entando App custom resource, you will need to know what's the correct component-manager to check using the corresponding Entando App name and namespace where the app has been deployed. \n Solution \n Using  kubectl  and assuming for simplicity that you have only one Entando App named  quickstart  and your Entando cluster is only composed of one namespace, also named  quickstart ,\nyou can get the component-manager logs using the command \n kubectl logs -f deployment/quickstart-server-deployment --namespace quickstart -c de-container\n \n Note : the  -f  flag is optional and could be used to follow the logs for debugging purposes \n My bundle has an issue, how should I publish a new version of the bundle? \n Overview \n Sometimes a bundle could have some issues: typos in the  descriptor.yaml  file, wrong references of components or to not available docker images are just a few of the possible errors. \n Solution \n \n If the bundle is shared using a git repository, you can make the required changes to your project and publish the new version to git and generate a new tag for it. \n Once the new tag is published, update the bundle costum-resource avaialble in you Entando Cluster by adding the new tag to the  tags  objects  and replacing the latest  dist-tags  to point to this new version. \n Proceed with the new installation \n \n If you're actively working on your bundle and you simply want to verify things are working correctly, instead of generating a new tag for each release of the bundle you can try to keep overriding a specific tag using the git command  git tag -f . We suggest you to follow this practice only during development and not in production. \n Bundle installation fails because a file has not been found in the bundle \n Overview \n When a component that is referenced in the  descriptor.yaml  is missing in the bundle or not correctly referenced, the bundle installation fails and in the logs is reported which file has not been found. \n ERROR - File with name {filename} not found in the bundle\n Solution \n When such a problem happens, verify that the component referenced in the descriptor file are actually present in the bundle and that the reference is properly typed. \n Publish a new version of your bundle as described in the\n \"My bundle has an issue\"  section \n Bundle installation failed due to plugin(s) images not reachable \n Overview \n Plugin included in a bundle are referenced using their docker image. Sometime the image is not available - maybe has not yet be published or is in a private docker registry - and plugin installation can't happen and the entire bundle installation process can't finish successfully \n Solution \n Verify that the docker image you are referencing is correct and publicly available. \n \"My bundle has an issue\"  section \n I can't uninstall a bundle because some components are in use \n Overview \n When removing an installed bundle, the Entando component manager verfies that the bundle components\nare not in use by any other component. Removing such components would cause an error during removal\nas in certain case the deleting a component in use is not permitted. \n Solution \n In order to prevent such errors, the user is alerted and required to manually decouple the bundle\ncomponents before beign able to completely remove the bundle from the system. \n"},{title:"Bundle uninstall",frontmatter:{},regularPath:"/v7.0/docs/curate/ecr-uninstall-flow.html",relativePath:"v7.0/docs/curate/ecr-uninstall-flow.md",key:"v-170b2834",path:"/v7.0/docs/curate/ecr-uninstall-flow.html",headers:[{level:2,title:"Uninstall process",slug:"uninstall-process"},{level:2,title:"Troubleshooting",slug:"troubleshooting"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Bundle uninstall \n Uninstall process \n To uninstall a bundle that was previously installed on an Entando App Engine, from Entando App builder UI go to\nthe  Component Repository  tab. For the bundle you want to uninstall, click on the  Installed  button next to it. This will open a pop-up window with the option to uninstall. \n \n An initial check is made to verify none of the bundle components are in use.\nIf any of the components are in use, a popup will alert you.\nNote that you can't force the removal of a bundle if its components are in use. \n Once the removal process starts: \n \n Bundle resources are deleted from the Entando App Engine \n Components included in the bundle are removed from the Entando App Engine \n Plugins are unlinked \n Troubleshooting \n If any error happens during the uninstall process and you don't know what to do,\ncheck out the  Troubleshooting guide  or the  Entando Forum \n"},{title:"Development Process on Entando",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/docs/getting-started/development-concepts.html",relativePath:"v7.0/docs/getting-started/development-concepts.md",key:"v-10f101c0",path:"/v7.0/docs/getting-started/development-concepts.html",headers:[{level:2,title:"Create Components",slug:"create-components"},{level:2,title:"Curate and Share Components",slug:"curate-and-share-components"},{level:2,title:"Compose an Application",slug:"compose-an-application"},{level:2,title:"Consume Applications",slug:"consume-applications"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Development Process on Entando \n With the Entando Platform, the development of an application is organized into four distinct stages: Create, Curate, Compose, and Consume. In the simplest terms, you  create  functional building blocks,  curate  them into a catalog,  compose  the blocks onto a page or a website, which is then  consumed  in an application. \n Entando provides a distributed and composable environment in which components can be independently built, scaled and iterated. This process enables parallel teams to accelerate development and innovation on a cloud- and Kubernetes-native stack. \n Create Components \n The first step in building a modern application on Entando is to design and create each independent component or functional block. Developers can use the  Entando Component Generator  and  Blueprint  to automate the building and packaging of project files, with the flexibility to customize. The modular design of apps built on Entando means new business capabilities can be integrated into your application without reworking existing systems. \n \n \n \n Documentation \n Tutorials \n \n \n \n \n Entando Component Generator \n Micro Frontends \n \n \n Entando Blueprint Feature \n Microservices \n \n \n Component Generation Technologies \n Build and Publish Project Bundles \n Curate and Share Components \n On the Entando Platform, Curate and Share means development teams can bundle and share components within a central catalog. Multiple teams or groups can collaborate on single components or a whole packaged business capability (PBC) across organizations and applications. They can test and assess components for readiness, manage and publish versions and share metadata for continuous upgrades. \n \n \n \n Documentation \n Tutorials \n \n \n \n \n Bundle and Component Descriptors \n Install Bundles from a Private Git Repository \n \n \n Filtering Bundles \n Install Bundle Plugins from a Private Image Repo \n \n \n Customize Bundle Info in App Builder \n \n \n \n Bundle Version and Updates FAQ \n \n \n \n Bundle Uninstall \n Compose an Application \n The Compose stage on Entando is centered around the  Entando App Builder , a low-code composition user interface. In the App Builder, application owners can assemble new components or upgrade existing ones with templates, widgets and fully functional PBCs. The  Entando Component Manager  and  Entando Component Repository  are integrated into the App Builder, making the composing process flexible and agile by managing all your components there. \n \n \n \n Documentation \n Tutorials \n \n \n \n \n Welcome Wizard \n Page Management \n \n \n Entando Component Repository \n Widgets and Fragments \n \n \n Entando App Builder \n Content Creation \n \n \n Entando Component Manager \n Content Templates \n \n \n \n Digital Assets \n Consume Applications \n In the development lifecycle of an application, Consume is the execution stage where end users interact with the app to complete certain tasks. On Entando, the modular design of the components and services means each can be scaled individually or as a whole, according to those interactions. Likewise, content can be added or changed, engine rules adapted and upgrades made seamlessly. As a result, the development cycle is a continuous process with minimal disruptions and faster time to market. \n \n \n \n Documentation \n Tutorials \n \n \n \n \n Accessibility \n External Identity Management System \n \n \n Entando Operator \n Add REST API \n \n \n Entando APIs \n Invoke Entando core APIs \n \n \n Custom Resources \n Change Default Datasource \n \n \n Entando Identity Management System \n \n \n \n \n"},{title:"Getting Started with Entando",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/docs/getting-started/",relativePath:"v7.0/docs/getting-started/README.md",key:"v-498b9a6d",path:"/v7.0/docs/getting-started/",headers:[{level:2,title:"Try Entando",slug:"try-entando"},{level:2,title:"Learn about Entando",slug:"learn-about-entando"},{level:2,title:"Automatic Install",slug:"automatic-install"},{level:2,title:"Manual Install",slug:"manual-install"},{level:3,title:"Install Kubernetes",slug:"install-kubernetes"},{level:3,title:"Prepare Kubernetes",slug:"prepare-kubernetes"},{level:3,title:"Deploy Entando",slug:"deploy-entando"},{level:2,title:"Login to Entando",slug:"login-to-entando"},{level:2,title:"Next Steps",slug:"next-steps"}],lastUpdated:"4/20/2022, 3:03:28 PM",lastUpdatedTimestamp:1650481408e3,content:" Getting Started with Entando \n WARNING \n Mac:  Entando 7 is not currently compatible with the Apple M1 ARM64 architecture found in some newer Macs. \n Try Entando \n You can set up Entando in two simple steps or install it manually to meet your specific needs. \n \n Automatic Install : The fastest way to locally install and start up Entando in Kubernetes. \n Manual Install : Useful if you want a shared cluster or a custom local instance. \n \n Once you're set up, you can  build a simple bundle and create an app  to try out the platform or walk through the  Welcome Wizard  in our  App Builder . For a more in-depth experience, check out our  Standard Banking Demo . \n Learn about Entando \n Learn about what Entando can do or explore the elements that make developing applications on Kubernetes faster and easier: \n \n Introduction to Entando \n Learning Paths \n Concepts Overview \n Automatic Install \n Automatically install Entando via the Entando command-line interface (CLI) and prepare a local developer environment with default settings.\nThe following steps launch an Ubuntu VM via Multipass, install Kubernetes, then deploy Entando to it. \n \n Install  Multipass \n \n https : //multipass.run/#install \n \n \n Install Entando into Kubernetes on Ubuntu using the  Entando CLI \n \n curl  -sfL https://get.entando.org  |   bash \n \n \n The progress of the install will be displayed on the console. Installation can take 10+ minutes depending on how long the Docker images take to download. The sequence of steps performed by the CLI is identical to the manual steps below. To understand what the CLI does, review the manual steps. \n The URL to access the Entando App Builder will print to the console once the install completes. \n Login with username: admin  and password:  adminadmin . Refer to  Login to Entando  for more information and next steps. \n Manual Install \n Manual installation allows you to configure a shared cluster or customize a local developer environment. The following learn-as-you-go approach gives you a working knowledge of Kubernetes as you get Entando up and running in a local environment. This is a three stage process: \n \n Install Kubernetes \n Prepare the Kubernetes Environment \n Deploy Entando \n \n We've tested a variety of Kubernetes implementations, including Minikube, Minishift, CodeReady Containers, K3s, and Microk8s, to find the optimal combination of low CPU/memory usage, fast startup times, and minimal configuration. After downloading the necessary files, we'll have our own instance of Kubernetes up and running in <60 seconds. \n What's Needed to Run Kubernetes? \n Kubernetes is a container orchestrator designed to manage a server cluster. It requires at least one master node running a Linux OS. A lightweight Ubuntu virtual machine (VM) can be created in seconds with Multipass. Choosing a Type 1 hypervisor eliminates a guest OS, maximizing speed and performance. \n Install Kubernetes \n Enable Hypervisor \n Why a Hypervisor? \n Hypervisors allow you to create and run VMs. Virtualization software that run on top of your operating system as \"guests\" are Type 2 hypervisors, e.g. VirtualBox or VMWare Workstation. Type 1 hypervisors run directly on your host machine. \n \n Install a Type 1 hypervisor for optimal performance. \n Mac:  Install  hyperkit \n brew  install  hyperkit\n \n Windows:   Install Hyper-V \n \n What if my machine doesn't support hyperkit or Hyper-V? \n Install a Type 2 hypervisor that runs on top of your operating system. \n \n Install Virtual Box:\n Mac \n Windows \n Launch an Ubuntu VM \n Why Multipass? \n Multipass is a cross-platform tool developed by the publishers of Ubuntu to create lightweight Ubuntu VMs in seconds. \n \n \n \n Install  Multipass \n \n \n Launch a VM \n \n \n multipass launch --name quickstart --cpus  4  --mem 8G --disk 20G\n \n \n Open a VM shell \n \n multipass shell quickstart\n Run Kubernetes \n Why K3s? \n K3s is a certified Kubernetes distribution designed for production workloads in resource-constrained environments. \n It's packaged as a single <50MB binary that minimizes the dependencies and procedure required to install, run and auto-update a production Kubernetes cluster. \n \n \n Install the version of  K3s  supported by Entando 7.0. Note that this is not the latest version of K3s. \n \n curl  -sfL https://get.k3s.io  |   INSTALL_K3S_CHANNEL = \"v1.21.10+k3s1\"   sh  -\n \n \n Check that the cluster  STATUS  is  Ready . \n \n sudo  kubectl get  node \n \n \n What's running out of the box? \n sudo  kubectl get pods -A\n \n \n \n Congratulations! \n You now have a local instance of Kubernetes up and running. \n \n Now that Kubernetes is running, you can use kubectl to send commands directly to K3s from the host machine, rather than from within the VM. To set this up with the  ent CLI , run  ent attach-vm quickstart  and then use  ent kubectl  for any calls to K8s. Alternatively, see the K3s documentation to  access your cluster with kubectl . \n Prepare Kubernetes \n To install Entando, we'll add  Custom Resources , create a  Namespace  and configure external access to our cluster. \n Create a Namespace \n What are Namespaces? \n Kubernetes supports multiple virtual clusters backed by the same physical cluster. These virtual clusters are called  namespaces . You can use namespaces to allocate resources and set CPU/memory limits for individual projects or teams. \n \n sudo  kubectl create namespace entando\n Add Custom Resources \n Why Custom Resources? \n Standard resources in Kubernetes include  Pods , which are groups of one or more containers,  Services  to call or access Pods, and  Ingresses  to enable external access to Services. \n Custom resources  let you store and retrieve structured data. Combining a custom resource with a custom controller allows you to define a desired state to automate how your applications or services run in a Kubernetes cluster. \n \n Examples of custom resources in Entando are the  Entando App Engine  and the  Entando Identity Management System . \n From your Ubuntu shell \n \n Install the cluster-scoped custom resource definitions (CRDs) \n \n sudo  kubectl apply -f https://raw.githubusercontent.com/entando/entando-releases/v7.0.0/dist/ge-1-1-6/namespace-scoped-deployment/cluster-resources.yaml\n \n \n Install the namespace-scoped custom resources \n \n sudo  kubectl apply -n entando -f https://raw.githubusercontent.com/entando/entando-releases/v7.0.0/dist/ge-1-1-6/namespace-scoped-deployment/namespace-resources.yaml\n Configure Access to Your Cluster \n What about Networking? \n Entando sets up  Ingresses  in Kubernetes to expose HTTP routes from outside the cluster to services within the cluster. This is used to access Entando from a local browser. \n If you run into network issues during startup, or if you are using Windows for your local development instance, you'll need to  troubleshoot your network . Indications of network issues can include Entando failing to completely start or a working Entando instance failing to restart later. \n \n To set up external access to your cluster, you need to specify the fully qualified domain of your Ubuntu VM, which we refer to via the placeholder YOUR-HOST-NAME. \n \n \n On Windows with Hyper-V, YOUR-HOST-NAME is the name of your VM followed by  .mshome.net , e.g.  quickstart.mshome.net . \n \n \n On Mac, Linux, or Windows without Hyper-V, you'll use a host name based on your VM's IP address. You can determine the IP address from within the VM with this command: \n \n \n hostname  -I  |   awk   '{print $1}' \n \n \n Your IP-based YOUR-HOST-NAME should follow this pattern:  quickstart.YOUR-IP.nip.io , e.g.  quickstart.192.168.64.33.nip.io . The suffix  .nip.io  makes use of the free  nip.io  DNS service so that any requests to this host name will resolve to your VM. The prefix  quickstart  is arbitrary so you can choose your own. \n \n Now that you've determined YOUR-HOST-NAME, use it to configure the Entando Application. \n \n Download the template  entando-app.yaml . \n \n curl -sLO \"https://raw.githubusercontent.com/entando/entando-releases/v7.0.0/dist/ge-1-1-6/samples/entando-app.yaml\"\n \n \n Modify  entando-app.yaml  to set the  ingressHostName  to YOUR-HOST-NAME. Examples: \n \n \n ingressHostName : quickstart.mshome.net \n ingressHostName : quickstart.192.168.63.33.nip.io \n \n Embedded Databases \n To speed up the  Getting Started  environment, embedded databases are used by default.\nSee this  Tutorial on Default Databases  for information on how to change your database connection, or you can modify the  dbms  setting in the  entando-app.yaml . \n \n Entando Operator \n An optional ConfigMap can be used to modify the behavior of the Entando Operator. For example, on a slower network, you may want to increase the download timeouts. Refer to the  Entando Operator  page for more information. \n Deploy Entando \n Deploy Entando by applying  entando-app.yaml  to your namespace. \n sudo  kubectl apply -f entando-app.yaml -n entando\n \n \n Use the  get pods --watch  command to observe Entando starting up. \n sudo  kubectl get pods -n entando --watch\n \n What does a successful startup look like? \n \n The  entando-operator  and  entando-k8s-service  start when you apply the namespace resources above, so they should already be in the  Running  status by the time you reach this point \n When you apply the  entando-app.yaml , the  quickstart-deployer  starts and kicks off a series of deployments, beginning with the Keycloak deployment via the  default-sso-in-namespace-deployer \n \n Jobs / Deployments \n \n Some Pods, like  quickstart-deployer , run to completion and then shutdown; they should eventually show  READY :  0/1  and  STATUS :  Completed \n Other deployments, like  quickstart-ab-deployment  or  quickstart-deployment , should eventually show  READY :  1/1  and  STATUS :  Running \n The deployment is finished when the  quickstart-deployer  Pod shows a status of  Completed \n \n Lifecycle Events \n \n Each line represents an event:  Pending ,  ContainerCreating ,  Running  or  Completed \n Restarts should ideally be  0 ; otherwise, there may be a resource problem (slow network, not enough CPU or memory, etc.) with your cluster, and Kubernetes is trying to self-heal \n \n NAME                                                  READY   STATUS              RESTARTS  AGE    \nentando-operator-5b5465788b-s6wjh                    1/1     Running             0          99m\nentando-k8s-service-86f8954d56-lp5nl                 1/1     Running             0          99m\nquickstart-deployer-7217                             0/1     ContainerCreating   0          7s\nquickstart-deployer-7217                             1/1     Running             0          14s\ndefault-sso-in-namespace-deployer-2045               0/1     Pending             0          0s\ndefault-sso-in-namespace-deployer-2045               0/1     Pending             0          0s\ndefault-sso-in-namespace-deployer-2045               0/1     ContainerCreating   0          0s\ndefault-sso-in-namespace-deployer-2045               1/1     Running             0          4s\ndefault-sso-in-namespace-deployment-7ddc5d44f-bsq7w  0/1     Pending             0          0s\ndefault-sso-in-namespace-deployment-7ddc5d44f-bsq7w  0/1     Pending             0          5s\ndefault-sso-in-namespace-deployment-7ddc5d44f-bsq7w  0/1     ContainerCreating   0          5s\ndefault-sso-in-namespace-deployment-7ddc5d44f-bsq7w  0/1     Running             0          88s\ndefault-sso-in-namespace-deployment-7ddc5d44f-bsq7w  0/1     Running             0          114s\ndefault-sso-in-namespace-deployment-7ddc5d44f-bsq7w  1/1     Running             0          115s\ndefault-sso-in-namespace-deployer-2045               0/1     Completed           0          2m6s\ndefault-sso-in-namespace-deployer-2045               0/1     Terminating         0          2m6s\ndefault-sso-in-namespace-deployer-2045               0/1     Terminating         0          2m6s\nquickstart-ab-deployment-5b5c7c4f5c-w774v            0/1     Pending             0          0s\nquickstart-ab-deployment-5b5c7c4f5c-w774v            0/1     Pending             0          0s\nquickstart-ab-deployment-5b5c7c4f5c-w774v            0/1     ContainerCreating   0          0s\nquickstart-deployment-667859b44d-nnk79               0/1     Pending             0          0s\nquickstart-cm-deployment-69bb5f9fd8-ll8dk            0/1     Pending             0          0s\nquickstart-deployment-667859b44d-nnk79               0/1     Pending             0          2s\nquickstart-deployment-667859b44d-nnk79               0/1     ContainerCreating   0          2s\nquickstart-cm-deployment-69bb5f9fd8-ll8dk            0/1     Pending             0          2s\nquickstart-cm-deployment-69bb5f9fd8-ll8dk            0/1     ContainerCreating   0          3s\nquickstart-cm-deployment-69bb5f9fd8-ll8dk            0/1     Running             0          88s\nquickstart-ab-deployment-5b5c7c4f5c-w774v            0/1     Running             0          102s\nquickstart-ab-deployment-5b5c7c4f5c-w774v            0/1     Running             0          2m\nquickstart-cm-deployment-69bb5f9fd8-ll8dk            0/1     Running             0          2m3s\nquickstart-ab-deployment-5b5c7c4f5c-w774v            1/1     Running             0          2m10s\nquickstart-cm-deployment-69bb5f9fd8-ll8dk            1/1     Running             0          2m12s\nquickstart-deployment-667859b44d-nnk79               0/1     Running             0          3m29s\nquickstart-deployment-667859b44d-nnk79               0/1     Running             0          4m50s\nquickstart-deployment-667859b44d-nnk79               1/1     Running             0          4m52s\nquickstart-deployer-7217                             0/1     Completed           0          7m17s\nquickstart-deployer-7217                             0/1     Terminating         0          7m17s\nquickstart-deployer-7217                             0/1     Terminating         0          7m17s\n \n \n \n Press  Ctrl-C  to exit the  watch  command once everything is up and running. \n \n What Pods come out of the box? \n sudo  kubectl get pods -n entando\n \n NAME                                                  READY   STATUS    RESTARTS   AGE\nentando-operator-5b5465788b-s6wjh                     1/1     Running   0          106m\nentando-k8s-service-86f8954d56-lp5nl                  1/1     Running   0          106m\ndefault-sso-in-namespace-deployment-7ddc5d44f-bsq7w   1/1     Running   0          7m4s\nquickstart-ab-deployment-5b5c7c4f5c-w774v             1/1     Running   0          5m1s\nquickstart-cm-deployment-69bb5f9fd8-ll8dk             1/1     Running   0          5m\nquickstart-deployment-667859b44d-nnk79                1/1     Running   0          5m\n\n \n \n \n The URL of your running Entando instance is http://YOUR-HOST-NAME/app-builder/. \n \n Example URL \n \n quickstart.192.168.64.33.nip.io/app-builder/\n Login to Entando \n Now that you've installed Entando, login to the Entando App Builder. \n \n \n Username:  admin \n Password:  adminadmin \n \n After login, change your password to activate your account. \n \n Note: If the login process hangs for more than 5 seconds, refresh the browser. \n \n \n In the App Builder, applications are composed from various components, including micro frontends and CMS content. \n Congratulations! \n You now have Entando up and running on Kubernetes in your local environment. \n Next Steps \n Check out these resources to continue your journey with Entando! \n \n \n Build Your First Application:  Use the  Welcome Wizard  to build your first application via guided prompts. \n \n \n Try a Tutorial:  Take advantage of the  Learning Paths , which organize a few of the most popular tutorials by user type. \n \n \n Dig Deeper into Entando Concepts:  Review the  Docs  sections to more deeply understand the Entando building blocks. \n \n \n Learn about the Quickstart Environment:  See the  Quickstart Tips  for more information on how to manage your Getting Started or quickstart environment. \n \n \n \n"},{title:"Entando Solution Templates",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/docs/getting-started/landing-page.html",relativePath:"v7.0/docs/getting-started/landing-page.md",key:"v-59320970",path:"/v7.0/docs/getting-started/landing-page.html",headers:[{level:2,title:"Entando Customer Portal",slug:"entando-customer-portal"},{level:2,title:"Entando Hub",slug:"entando-hub"},{level:2,title:"Entando Process Driven Applications Plugin",slug:"entando-process-driven-applications-plugin"},{level:2,title:"Entando Standard Banking Demo",slug:"entando-standard-banking-demo"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Entando Solution Templates \n The Entando Application Composition Platform offers several Solution Templates to demonstrate various business capabilities and integrations: \n \n Entando Customer Portal \n Entando Hub \n Entando Process Driven Applications Plugin \n Entando Standard Banking Demo \n \n Each open source Solution Template was built with Entando and can be used as-is, reviewed for common development practices, or leveraged as a useful starting point for a related application. \n The following Solution Templates and other sets of components are available in the  public Entando Hub  for installation in a user environment, where turnkey functionality can be customized and extended. \n Entando Customer Portal \n The  Entando Customer Portal  streamlines development of a customer-facing, self-service subscription management application. The platform integrates Keycloak role based access control and Jira Service Management as a ticket tracking system. \n Entando Hub \n The  Entando Hub  empowers a team to share and collaborate on proprietary or Entando open source components. Capabilities, versions and metadata can be transparently analyzed, managed and published. \n Entando Process Driven Applications Plugin \n The  Entando Process Driven Applications Plugin  provides a comprehensive and versatile automation scheme for Business Process Management. It comprises a custom UX layer, a Spring Boot Backend for Frontend microservice interface, and integration with the  Red Hat Process Automation Manager . \n Entando Standard Banking Demo \n The  Entando Standard Banking Demo  showcases the benefits and possibilities of a composable application built from modular components. The example banking environment integrates a transaction table, sign up form, alert icon, and summary cards to demonstrate MFE communication and capabilities. Prominent features include Keycloak role based access control, coexistence of React and Angular MFEs, and pluggable Spring Boot microservices. \n \n"},{title:"Entando Architecture Concepts",frontmatter:{},regularPath:"/v7.0/docs/getting-started/concepts-overview.html",relativePath:"v7.0/docs/getting-started/concepts-overview.md",key:"v-85a297e8",path:"/v7.0/docs/getting-started/concepts-overview.html",headers:[{level:2,title:"Entando App Engine",slug:"entando-app-engine"},{level:2,title:"Entando App Builder",slug:"entando-app-builder"},{level:2,title:"Entando Component Generator",slug:"entando-component-generator"},{level:2,title:"Entando Component Repository",slug:"entando-component-repository"},{level:2,title:"Entando Identity Management",slug:"entando-identity-management"},{level:2,title:"Entando WCMS",slug:"entando-wcms"},{level:2,title:"Entando Cluster Citizens",slug:"entando-cluster-citizens"},{level:3,title:"Architecture Diagram",slug:"architecture-diagram"},{level:3,title:"Members of the Cluster",slug:"members-of-the-cluster"},{level:2,title:"Entando Ingresses",slug:"entando-ingresses"},{level:3,title:"What is an Ingress?",slug:"what-is-an-ingress"},{level:3,title:"How Ingresses are used in an Entando Cluster",slug:"how-ingresses-are-used-in-an-entando-cluster"},{level:3,title:"Default Ingress HTTP Routes",slug:"default-ingress-http-routes"},{level:3,title:"Exposing Plugins in the EntandoApp Domain",slug:"exposing-plugins-in-the-entandoapp-domain"},{level:3,title:"How to Check Ingresses in my Cluster",slug:"how-to-check-ingresses-in-my-cluster"},{level:3,title:"Learn More",slug:"learn-more"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Entando Architecture Concepts \n A portal, website, web app, or mobile app built with Entando is called an Entando application.\nAn Entando application is an assembly of out of the box and/or custom built components running on the\nEntando Platform. Components can be widgets, micro frontends, microservices, page templates, WCMS content or WCMS content types. \n Entando App Engine \n The Entando App Engine is the heart of the Entando Platform by providing the primary out-of-the-box services for\ndeveloping applications. Key features: \n \n Expose the APIs the Entando App Builder uses to provide the page and content management interface for your application. \n Handle the work of assembling micro frontends and microservices and combining them on specific pages as defined by the Entando App Builder. \n Provide the data access layer to persist the page and application design. \n Manage the cluster infrastructure. \n \n See also:  APIs tutorial \n Entando App Builder \n The  Entando App Builder  is the feature-rich management interface used to design and build pages for Entando applications. \n See also:  Widget Tutorial \n Entando Component Generator \n The Entando Component Generator is Entando\'s implementation of  JHipster  that allows users to\nquickly and efficiently generate the skeleton of an Entando Component. The Entando Component Generator provides advanced\ndata modeling capabilities including object relational mapping and automatic generation of micro frontends and microservices.\nThe generated skeleton serves as a starting point to help a development team swiftly meet the needs of the business. \n See also:  Entando JHipster Blueprint \n Entando Component Repository \n The  Entando Component Repository  (ECR) is used to store and retrieve shareable components so they can be used in multiple\nEntando applications across the enterprise. \n Entando Identity Management \n Entando Identity Management  is the  Keycloak -based token-based authentication mechanism used by the\nEntando platform. It provides the ability to add Single Sign On capabilities across multiple domains and to connect service\nproviders with identity providers. \n See also:  Entando Authentication \n Entando WCMS \n The Entando Web Content Management System (WCMS) is a lightweight content and digital asset management system with support\nfor headless operation. It allows management of widgets and html fragments so they can be placed within an Entando application. \n See also:  Content Types  or  Content Templates \n Entando Cluster Citizens \n The purpose of this guide is to give an overview of the members of an Entando cluster and their role. \n Architecture Diagram \n Let’s start with a picture of an Entando cluster and how the various\nmembers interact with each other. \n Members of the Cluster \n An Entando cluster is composed of various citizens which interact with\neach other. Most of these citizens have a Custom Resource Definition\nfile associated with them and are deployable on Kubernetes using the\nEntando operator and controllers. \n EntandoApp \n An Entando application is composed of three parts: \n \n \n Entando App Builder : the user interface to customize and build an Entando application, as well as interact with the Entando Component Repository. \n \n \n Entando App Engine : the backend APIs providing access to Entando\nservices. \n \n \n Entando Component Manager : the service providing the Entando\nComponent Repository functionality, e.g. listing the available\nbundles, install/uninstall a bundle, etc. \n \n \n The interaction between these three components (and the rest of the\nEntando cluster) use the authorization/authentication features provided\nby Keycloak. \n Entando Component Manager \n As briefly introduced before, the  Entando Component Manager  is able to\nlist the EntandoDeBundles accessible from the EntandoApp and provide the\ninstall/uninstall services to install a bundle on an Entando App. All of\nthese services are made possible by the communication with the Entando\nKubernetes service, the only service of the Entando ecosystem (other\nthan the operator itself) able to interact with the cluster and some of\nthe Entando Custom Resources. \n Entando Kubernetes Service \n The Entando Kubernetes Service is part of the Entando cluster\ninfrastructure custom resource, and provides an access point to some of\nthe custom resources defined by Entando, in particular: \n \n \n Entando applications \n \n \n Entando plugins \n \n \n Entando links \n \n \n Entando Component Repository bundles \n \n \n Some of the main services provided by the Entando Kubernetes Service\nare: \n \n \n Provide a list of the available EntandoDeBundles to the\ncomponent-manager \n \n \n Deploy a plugin during the installation of a bundle or discovery of\nan already available plugin and expose that to an app \n \n \n Create a link between an EntandoApp and an EntandoPlugin to expose\nthe plugin’s APIs to the EntandoApp and the micro frontends (MFEs) \n Entando Component Repository Bundles \n An EntandoDeBundle - or Component Repository bundle - is a package with\na set of Entando components and resources. The Entando Component Manager\nis able to read these kinds of packages and install the components to\nextend the functionalities of an EntandoApp. For more details on the\nEntandoDeBundle and the Entando Component Repository, check the\n Component Repository Overview \ndocumentation. \n Entando Plugin \n An Entando plugin is a microservice that exposes APIs reusable by one or\nmore Entando apps. Usually the plugin services are exposed to the\nEntando developer and the end users via micro frontends. Check the\n micro frontends  tutorials for more details. You can\nquickly generate an Entando plugin using the  Entando JHipster Blueprint . The generated project will be ready to work in an Entando environment providing the\nintegration with Keycloak, generating a set of default micro frontends\nand exposing the plugin’s logic via an EntandoDeBundle (check the\nreferences for details). \n Keycloak \n Keycloak is responsible for authorization and\nauthentication on Entando. All members of an Entando cluster interact with\nKeycloak to verify user/service authorization to perform any specific\ntask. Check out the references below for more details on Keycloak. \n Entando Ingresses \n What is an Ingress? \n An Ingress is a Kubernetes resource which purpose is to expose HTTP and HTTPS routes from outside the cluster to services within the cluster. Traffic routing is controlled by rules defined on the Ingress resource. \n How Ingresses are used in an Entando Cluster \n When deploying an Entando Cluster, ingresses are generated for the resources that requires to be exposed to the outside world. The process of creating an ingress, setup the correct routes and the certificates is done by the via the Entando Operator and the entando custom resource controllers. \n Keycloak Ingress \n A dedicated ingress is created for Keycloak to expose the authentication and authorization functionalities. A dedicated ingress is required to guarantee that both token issuing and token validation work correctly, even when the services using the Keycloak instance are on different namespaces. \n EntandoApp Ingress \n Another ingress is automatically created to expose App Builder, App Engine and the Entando Component Manager, a service part of the ECR.\nThe three containers are served under the same domain. This is beneficial since they are able to interact without cross-origin issues. \n The Entando App ingress is also used when linking an Entando Plugin with and Entando App, operation that usually happens when a bundle containing an Entando Plugin is installed via the ECR in an Entando App. Check out the dedicated section for details. \n Entando Plugin Ingress \n Entando Plugins are automatically exposed via an ingress when deployed in an Entando Cluster. \n Default Ingress HTTP Routes \n In this table you can see what are the default routes that are exposed for each ingress\n \n \n \n \n \n \n \n Ingress \n Ingress Http route \n Application \n \n \n \n \n Keycloak ingress \n /auth \n Keycloak \n \n \n Entando App ingress \n /entando-de-app \n App engine \n \n \n /app-builder/ \n App builder \n \n \n /digital-exchange \n Entando component manager \n \n \n /plugin-ingressPath \n Entando plugin linked to the app \n \n \n Entando plugin ingress \n /plugin-ingressPath \n Entando plugin \n \n \n \n Note : The Entando plugin variable  ingressPath  is defined in the Entando Plugin custom resource under the  spec  element. The plugin ingress path is also used to expose the plugin within the EntandoApp domain. \n Exposing Plugins in the EntandoApp Domain \n The process of exposing an Entando Plugin under the same domain (ingress) of the Entando App is made possible from the creation of an  EntandoAppPluginLink  custom resource and the corresponding controller. \n Once the link between the Entando App and the Entando Plugin is created, the controller reads the specification of the link and automatically creates the HTTP routes in the Entando App so that the plugin is exposed on the same domain as the App builder, App engine and Component Manager. \n This allows the micro frontend developers, who need access to the plugin, to disregard CORS policy and the full path where the plugin is exposed. The plugin can be referenced using relative URLs. \n How to Check Ingresses in my Cluster \n Using the Openshift Dashboard \n On the Openshift dashboard, ingresses are not exposed directly as pods and deployments. The dashboard provides direct access to the Ingress Routes (or simply routes) under the  Applications  →  Routes  menu. \n \n To see the ingress resources, you need to access them from the  Resources   →  Other resources  menu. From the dropdown, select the  Ingress  resource and you should be able to see the ingress available on that specific project/namespace. \n Using kubectl from the Command Line \n Once you know the namespace(s) where your Entando Cluster is deployed, use the following command from the command line. \n kubectl get ingresses.extensions -n YOUR-NAMESPACE\n \n Here an example of the result in a test namespace \n > kubectl get ingresses.extensions -n local\n\nNAME                               CLASS    HOSTS                             ADDRESS         PORTS   AGE\ndefault-sso-in-namespace-ingress   <none>   quickstart.192.168.64.15.nip.io   192.168.64.15   80      19d\nquickstart-ingress                 <none>   quickstart.192.168.64.15.nip.io   192.168.64.15   80      19d\n \n To get more details about a specific ingress, you can use the  get  command specifying the ingress name you want to check and the  yaml  output format. \n > kubectl get ingresses.extensions -n local qst-ingress -o yaml\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  creationTimestamp: "2020-05-13T15:27:08Z"\n  generation: 1\n  labels:\n    EntandoApp: qst\n  managedFields:\n  - apiVersion: extensions/v1beta1\n    fieldsType: FieldsV1\n    fieldsV1:\n      f:status:\n        f:loadBalancer:\n          f:ingress: {}\n    manager: nginx-ingress-controller\n    operation: Update\n    time: "2020-05-13T15:27:08Z"\n  name: qst-ingress\n  namespace: local\n  ownerReferences:\n  - apiVersion: entando.org/v1\n    blockOwnerDeletion: true\n    controller: true\n    kind: EntandoApp\n    name: qst\n    uid: aa7053e1-fd8b-419f-bdee-df3018c013fa\n  resourceVersion: "16802097"\n  selfLink: /apis/extensions/v1beta1/namespaces/local/ingresses/qst-ingress\n  uid: e9b6f027-369a-4b84-b4b1-736a6e49f180\nspec:\n  rules:\n  - host: local.192.168.1.9.nip.io\n    http:\n      paths:\n      - backend:\n          serviceName: qst-server-service\n          servicePort: 8080\n        path: /entando-de-app\n        pathType: ImplementationSpecific\n      - backend:\n          serviceName: qst-server-service\n          servicePort: 8083\n        path: /digital-exchange\n        pathType: ImplementationSpecific\n      - backend:\n          serviceName: qst-server-service\n          servicePort: 8081\n        path: /app-builder/\n        pathType: ImplementationSpecific\nstatus:\n  loadBalancer:\n    ingress:\n    - ip: 127.0.0.1\n Learn More \n For more details about ingress concepts in Kubernetes, please refer to the official documentation: \n \n Kubernetes Ingress documentation \n \n'},{title:"Caching and Clustering in an Entando Application",frontmatter:{},regularPath:"/v7.0/docs/reference/caching-and-clustering.html",relativePath:"v7.0/docs/reference/caching-and-clustering.md",key:"v-a7172670",path:"/v7.0/docs/reference/caching-and-clustering.html",headers:[{level:2,title:"App Engine Clustering and High Availability",slug:"app-engine-clustering-and-high-availability"},{level:2,title:"Storage Requirements for Clustered Entando Applications",slug:"storage-requirements-for-clustered-entando-applications"},{level:2,title:"Caching",slug:"caching"},{level:3,title:"Data Management",slug:"data-management"},{level:2,title:"Redis Implementation",slug:"redis-implementation"},{level:2,title:"Performance",slug:"performance"},{level:3,title:"Cache Management",slug:"cache-management"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Caching and Clustering in an Entando Application \n App Engine Clustering and High Availability \n The Entando App Engine can be deployed as a clustered set of instances using the clustering and replication ability of Kubernetes. It is backed by a shared cache with two default choices for implementation. \n This guide demonstrates how to configure and test a clustered instance of the Entando App Engine. \n Microservices clustering that adds functionality to an Entando Application is different from clustering used by the Entando App Engine. Microservices rely on a custom clustering configuration and setup based on implementation and selections made during their creation. Refer to documentation addressing  clustered microservices and caching implementation  for configuration and deployment details. \n Storage Requirements for Clustered Entando Applications \n To scale an Entando Application across multiple nodes, a storage class that supports a  ReadWriteMany  access policy must be created. There are a number of ways to accomplish this, inclusive of dedicated storage providers such as GlusterFS. Cloud Kubernetes providers also offer clustered storage options specific to their implementation, such as Google Cloud File in GKE or Azure Files in AKS. \n Two different storage classes can be used for clustered vs. non-clustered storage if the default class doesn\'t support  ReadWriteMany . Add the following properties to the operator ConfigMap: \n entando.k8s.operator.default.clustered.storage.class: "[clustered RWX storage class]"\nentando.k8s.operator.default.non.clustered.storage.class: "[RWO storage class]"\n \n Set both values to the storage class appropriate to the configuration. \n TIP \n To scale an Entando Application without the use of clustered storage assumes all instances are scheduled to a single node and requires a  ReadWriteOnce (RWO)  policy in conjunction with taints on other nodes. Understanding the pros and cons of same-node scheduling is critical for node resource optimization and application recovery should the instance become unreachable. Note that if the node quits or is shut down, the application will be unavailable until Kubernetes reschedules the pods to an alternate node. \n Caching \n Data Management \n At startup, the Entando App Engine will load all database data into the shared cache. Applicable content will be served from the cache when a page is rendered or content is fetched. In the event of a write to the cache, both the cache and database will be updated. \n The following objects are cached in the base implementation of the Entando App Engine: \n \n Pages \n Page templates \n Categories \n Widgets \n Configuration (Application level configuration) \n Roles \n Groups \n Languages \n Labels (i18n) \n User profiles \n API Catalog (legacy API metadata separate from swagger) \n Data models and data types (deprecated) \n Redis Implementation \n An Entando Application can be configured to utilize an external  Redis  cache. In a Redis implementation of an Entando Application, the cache is deployed independently of the Entando App Engine and the Entando App Engine is configured to connect to the deployed instance. \n \n The Redis cache is not deployed by the Entando Operator and must be managed by a DevOps team member or Kubernetes cluster administrator. \n Check out the Caching and Clustering tutorial  for more information and step-by-step instructions to use a Redis cache in an Entando Application. \n Performance \n Consider the following when designing an Entando App Engine cluster: \n \n In a read only implementation, or an implementation with infrequent writes to the cached objects listed above, the network latency between pods on different nodes will not be a major driver of runtime performance. Each pod will have a fully replicated copy of the cache. \n In write heavy implementations, network latency between nodes can factor into performance. \n The overall performance impact of network latency will vary depending upon implementation. Performance is impacted by the types of objects written, the size of those objects, and whether the writes invalidate single or entire lists of objects in the cache. \n \n It is generally recommended that performance testing on clustered instances correlates to the expected runtime traffic pattern of a live application. Every application will have a unique performance profile. \n Cache Management \n When a new replica of an Entando Application joins a cluster of applications, the cache is replicated to that node. If the cache is relatively large or the network is slow, this may add to the total startup time of the new instance. Existing instances will continue to function. \n'},{title:"Entando Deployment Structure",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/docs/reference/deployment-structure.html",relativePath:"v7.0/docs/reference/deployment-structure.md",key:"v-6cd1d58a",path:"/v7.0/docs/reference/deployment-structure.html",headers:[{level:2,title:"entando-operator",slug:"entando-operator"},{level:2,title:"database init containers",slug:"database-init-containers"},{level:2,title:"entando-de-app",slug:"entando-de-app"},{level:2,title:"app-builder",slug:"app-builder"},{level:2,title:"component-manager(cm)",slug:"component-manager-cm"},{level:2,title:"entando-k8s-service",slug:"entando-k8s-service"},{level:2,title:"keycloak",slug:"keycloak"},{level:2,title:"Other Key Repositories",slug:"other-key-repositories"},{level:3,title:"entando-core",slug:"entando-core"},{level:3,title:"entando-cms",slug:"entando-cms"},{level:3,title:"entando-components",slug:"entando-components"},{level:3,title:"Entando Kubernetes Controllers",slug:"entando-kubernetes-controllers"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Entando Deployment Structure \n This page provides a high level overview of the key Entando GitHub repositories along with a brief description\nof how those repositories are realized in a running Entando deployment. The descriptions provided here are meant\nas a guide for identifying opportunities to dig deeper into the architecture and how things are structured\nrather than a panacea for understanding the architecture. \n entando-operator \n The Entando operator coordinates the installation and configuration of all of the components of an Entando\nCluster. The operator can be installed once per Entando Cluster and used to coordinate the plugin lifecycle for\nmultiple Entando applications across many namespaces. \n \n GitHub:  https://github.com/entando-k8s/entando-k8s-controller-coordinator/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-k8s-controller-coordinator \n Customization \n It is unlikely that the operator will be customized as part of an Entando implementation. It is not built to\nbe extended inside the codebase. The most common pattern will be to use the existing custom resources that the\noperator knows how to deploy to extend the Entando platform. \n database init containers \n During installation, an Entando application needs to create several databases and initialize those\ndatabases with information when deploying from a backup in your images. At initialization, the  entando-k8s-dbjob \nwill be run 5 times in total. Once for keycloak, twice for the entando application (port and serv dbs), once to\npopulate the Entando application database, and once to create the Component Repository database. \n \n GitHub:  https://github.com/entando-k8s/entando-k8s-dbjob \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-k8s-dbjob \n \n The screenshot below highlights the init containers for the Entando application schema creation, db\ninitialization, and component repository database. \n \n Many managed kubernetes instances like OpenShift won’t show init containers in their dashboards. So if you’re\ntroubleshooting you may need to look deeper. When fetching logs for an init container using kubectl, you must\npass the container name as an argument to the call. For example, \n     kubectl logs <pod> -c <container> -n <namespace>        \n    kubectl logs default-sso-in-namespace-deployment-db-preparation-job-ddbdbddb-a  -c default-sso-in-namespace-deployment-db-schema-creation-job -n sprint1-rc\n Customization \n It is unlikely that the init containers will be customized as part of an Entando project. The init containers\nwill automatically restore a backup included in your application so that you can create custom images that\ninclude your application setup.\nSee  Backing Up and Restoring Your Environment . \n entando-de-app \n The  entando-de-app  is a J2EE application and is an instance of the  entando-core  (see a description of the\n entando-core  repo below). Reviewing the dependencies of this application in the pom.xml will reveal the\ndependencies on the  entando-core ,  entando-engine , and  admin-console  which encompass the core\nfunctionality in versions of Entando prior to Entando 6. In a quickstart deployment the  entando-de-app  is deployed as part of the  entando-composite-app  multi\ncontainer pod. \n \n GitHub:  https://github.com/entando/entando-de-app/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-de-app-eap , https://hub.docker.com/repository/docker/entando/entando-de-app-wildfly \n Customization \n The  entando-de-app  is very likely to be customized as part of an Entando implementation. This image can be\ncustomized with new APIs, legacy Entando plugins, new database tables, or other extensions to the  entando-core .\nIt is highly recommended that most extensions to the platform on Entando occur in microservices. However, legacy\nintegrations, extensions to the CMS, and migrations from earlier Entando versions may require changes to the  entando-de-app . \n app-builder \n The  app-builder  is the front end of the  entando-de-app . It communicates with the  entando-de-app  via  REST\nAPIs . The  app-builder  is a React JS application and is served via node in the default\ndeployment. In a quickstart deployment, the  app-builder  container is deployed in the  entando-app \nmultiple container pod. The  app-builder  also communicates with the Component Manager via REST API to fetch\ninformation about Entando bundles deployed to the Entando Component Repository (ECR). \n \n GitHub:  https://github.com/entando/app-builder/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/app-builder/ \n Customization \n The  app-builder  is customized as part of many Entando implementations.\nIt can be customized at runtime via micro frontends\n widget configuration . \n component-manager(cm) \n The  component-manager  provides the link between the entando-de-app (or your custom core instance) and the ECR. The  component-manager  queries the entando-k8s service to fetch available\nbundles that have been deployed as custom resources inside of an Entando cluster.\nThe  component-manager  also manages the relationships between an Entando application and the\ninstalled plugins. This can be seen in the plugin link custom resources in Kubernetes. \n \n GitHub:  https://github.com/entando-k8s/entando-component-manager/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-component-manager/ \n Customization \n It is unlikely that the  component-manager  will be customized as part of an Entando implementation. \n entando-k8s-service \n The  entando-k8s-service  acts as an abstraction layer to fetch data from kubernetes APIs. The primary\nfunctionality is in discovering and making available for installation Entando plugins. The\n entando-k8s-service  is invoked by the  component-manager . \n \n GitHub:  https://github.com/entando-k8s/entando-k8s-service/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-k8s-service/ \n Customization \n It is very unlikely that the  entando-k8s-service  will be customized as part of an Entando implementation. \n keycloak \n The  entando-keycloak  project is an extension of the base Keycloak images. The extension provides the default\nthemes for Entando, a customized realm and clients, and adds the Oracle ojdbc jars for connection to Oracle\ndatabases. \n \n GitHub:  https://github.com/entando/entando-keycloak/ \n DockerHub:  https://hub.docker.com/repository/docker/entando/entando-keycloak/ \n Customization \n The keycloak image will often be customized as part of an Entando implementation. Common extensions will\ninclude changing the theme, adding default connections, adding default social logins, adding default clients,\nor other changes. \n Other Key Repositories \n entando-core \n The entando-core project is a J2EE application that exposes APIs for the Entando CMS, includes the legacy\nadmin console, and includes the portal-ui project that performs the server side composition for pages\nrendered via an Entando application. Note that only the composition is performed server side.\nJavascript code is rendered on the client. The entando-core is realized via an instance that includes the\nWAR files generated from a core build as dependencies. In a default deployment this is the  entando-de-app . \n \n GitHub:  https://github.com/entando/entando-core/ \n DockerHub: None (deployed to maven central) \n Customization \n For users familiar with versions prior to Entando 6, there will be cases where the  entando-core  is customized.\nIn most cases, these customizations will be delivered via a WAR overlay in the instance project.\nUsing a WAR overlay is a functional approach for users already familiar with the process, but it is highly\nrecommended to extend the platform using microservices for new projects. \n entando-cms \n The  entando-cms  project is the  app-builder  (React JS) side of the Entando WCMS. It is bundled into the\n app-builder  at build time and will be included in the default deployment of the  app-builder  in almost all cases. \n \n GitHub:  https://github.com/entando/entando-cms/ \n DockerHub: None (deployed to npm) \n Customization \n In some cases the  entando-cms  may be customized if new custom features are added to CMS specific\nfunctionality. However, most cases will use the more general  app-builder  extension points noted above.\nThe  entando-cms  does not expose any dedicated extension interfaces outside of those already provided by the\n app-builder . \n entando-components \n The entando-components project is a collection of legacy plugins for Entando 5 and earlier. These plugins are deployed as WAR dependencies in an entando-core instance. \n \n GitHub:  https://github.com/entando/entando-components/ \n DockerHub: None (deployed to maven central) \n Entando Kubernetes Controllers \n There are a number of controllers that are available to the Entando operator to manage installations and\ncomponents in an Entando Cluster. Those controllers are small and lightweight images that are executed as\nrun to completion pods to manage the installation flow for different parts of the infrastructure. The\ncontrollers are implemented using Quarkus. For more information on the controllers, the Entando custom\nresources, and configuring your Entando deployment see also:\n Custom Resources . \n GitHub: \n \n https://github.com/entando-k8s/entando-k8s-composite-app-controller/ \n https://github.com/entando-k8s/entando-k8s-plugin-controller/ \n https://github.com/entando-k8s/entando-k8s-cluster-infrastructure-controller/ \n https://github.com/entando-k8s/entando-k8s-app-controller/ \n https://github.com/entando-k8s/entando-k8s-app-plugin-link-controller/ \n \n DockerHub: \n \n https://hub.docker.com/repository/docker/entando/entando-k8s-composite-app-controller/ \n https://hub.docker.com/repository/docker/entando/entando-k8s-plugin-controller/ \n https://hub.docker.com/repository/docker/entando/entando-k8s-cluster-infrastructure-controller/ \n https://hub.docker.com/repository/docker/entando/entando-k8s-app-controller/ \n https://hub.docker.com/repository/docker/entando/entando-k8s-app-plugin-link-controller/ \n Customization \n It is unlikely that the controllers will be customized as part of an Entando implementation. \n"},{title:"Cluster Resource Limits",frontmatter:{},regularPath:"/v7.0/docs/reference/cluster-resource-limits.html",relativePath:"v7.0/docs/reference/cluster-resource-limits.md",key:"v-42c4794c",path:"/v7.0/docs/reference/cluster-resource-limits.html",headers:[{level:3,title:"Cluster Resource Limits",slug:"cluster-resource-limits"},{level:3,title:"Bundle size limitations",slug:"bundle-size-limitations"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Cluster Resource Limits \n Entando needs a well-defined amount of resources in order to start and Kubernetes takes care of using only the needed amount of them.\nHowever, you can choose to impose boundaries on the minimum and maximum used/allocated resources by updating the downloaded  entando.yaml  file and setting the  ENTANDO_K8S_OPERATOR_IMPOSE_DEFAULT_LIMITS  property to true.\nIn this way, Entando will allocate a predefined amount of resources and Kubernetes will act more strictly checking for resource availability. See  Kubernetes resources  for more information. \n By not imposing limits you can minimize initial needed resources and startup time, leaving Kubernetes free to manage its resources as he wants.\nBy imposing limits you can obtain a better-balanced system. \n It's important to note that, accordingly to the Kubernetes documentation, in order to deploy on a namespace with a\n ResourceQuotas  on memory and cpu, \n \n every Container must have a memory request, memory limit, cpu request, and cpu limit \n \n so, in that case, you will need to set  ENTANDO_K8S_OPERATOR_IMPOSE_DEFAULT_LIMITS  to true, otherwise your deploy will fail. \n Here you can see the detailed resource requests/limits per container: \n \n \n \n Component \n Mem requests \n CPU requests \n Mem limits \n CPU limits \n \n \n \n \n AppBuilderDeployableContainer \n 128Mi \n 125m \n 512Mi \n 500m \n \n \n EntandoAppDeployableContainer \n 448Mi \n 375m \n 1792Mi \n 1500m \n \n \n ComponentManagerDeployableContainer \n 192Mi \n 188m \n 768Mi \n 750m \n \n \n EntandoPluginDeployableContainer \n 256Mi \n 250m \n 1024Mi \n 1000m \n \n \n EntandoK8SServiceDeployableContainer \n 192Mi \n 250m \n 768Mi \n 1000m \n \n \n KeycloakDeployableContainer \n 192Mi \n 250m \n 768Mi \n 1000m \n Bundle size limitations \n Entando supports bundles without size limitations, you can install as many bundles as you want and bundles as big as you desire. \n The only thing you have to check is the  <YOUR-APP-NAME>-de-pvc  volume size. Each bundle is installed in that volume, so when it reaches its maximum capacity you will not be able to install bundles anymore. \n You can find  quickstart-de-pvc  volume inside de-container container, that is part of the pod named  <YOUR-APP-NAME>-server-deployment-*** , where asterisks should assume values based on your instance.\nFeel free to set its size accordingly to your needs. \n"},{title:"Manage Entando Databases",frontmatter:{},regularPath:"/v7.0/docs/reference/databases.html",relativePath:"v7.0/docs/reference/databases.md",key:"v-9378b468",path:"/v7.0/docs/reference/databases.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Lightweight, low-config Databases with PostgreSQL and MySQL",slug:"lightweight-low-config-databases-with-postgresql-and-mysql"},{level:2,title:"Existing External Databases",slug:"existing-external-databases"},{level:3,title:"Structure",slug:"structure"},{level:3,title:"How it works",slug:"how-it-works"},{level:3,title:"Keeping track of credentials",slug:"keeping-track-of-credentials"},{level:2,title:"Vendor specific notes",slug:"vendor-specific-notes"},{level:3,title:"Oracle",slug:"oracle"},{level:3,title:"Notes",slug:"notes"},{level:3,title:"MySQL",slug:"mysql"},{level:3,title:"Resulting Connection String",slug:"resulting-connection-string-2"},{level:3,title:"Notes",slug:"notes-2"},{level:3,title:"PostgreSQL",slug:"postgresql"},{level:2,title:"Skipping database preparation",slug:"skipping-database-preparation"},{level:3,title:"How it works",slug:"how-it-works-2"},{level:2,title:"Liquibase Migration",slug:"liquibase-migration"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Manage Entando Databases \n Overview \n Entando’s Docker images currently support three different relational\ndatabase management systems: PostgreSQL, MySQL and Oracle. With\nPostgreSQL and MySQL. By default, Entando’s will automatically create a\nKubernetes Deployment hosting the database management systems. However,\nfor Oracle, and also for other scenarios that may require it, Entando\nsupports connectivity to existing external databases. This document\nprovides the user with the necessary information to decide how to manage\nEntando’s databases. \n Lightweight, low-config Databases with PostgreSQL and MySQL \n When deploying Entando Custom Resources that require databases to a new\nNamespace, the default behavior for Entando is to create a Kubernetes\nDeployment. It uses the standard OpenShift compliant images. \n This is a fairly low-configuration approach, as Entando will create and\ninitialize the databases transparently. Persistent data is stored on any\nPersistent Volume that meets our Persistent Volume Claim requirements.\nWhen an Entando Custom Resource is redeployed, the Persistent Volumes\nremain in tact. Since the subsequent data initialization is idempotent,\nthe supporting Deployments will scale up and behave as expected. \n Generally our services encapsulate the database they use entirely, and\nprovide facilities to import and export the data without needing any\nknowledge of the internal workings of the underlying data store. For\nmost simple Entando Apps the database doesn’t grow too large and is\nfairly easy to manage. This state of affairs allowed us to keep our\ndatabases isolated from each other, thus allowing for isolated\ndeployments without needing complex coordination of database migration\nfor the different deployment pipelines. \n It is worth noting that these database Deployments are not clustered.\nThe customer is therefore strongly advised to provide redundancy and\nclustering in the form of clustered storage. These database deployments\ndo specify a restartPolicy of \'Always\', so in the event of a\nnon-corrupting failure, the database pod should therefore restart in\nabout 30 seconds. This by no means offers the features of a full\ndatabase cluster, but may suffice for many scenarios. \n However, in more advanced use cases, such as the use of our CMS\nfunctionality, this simplistic approach may not scale. And where there\nis a a centralized database admin team, or where there is a requirement\nto comply to strict organizational governance w.r.t. databases, this\napproach does result in a multitude of databases that may be difficult\nfor the database admin team to manage. \n Existing External Databases \n For this reason, Entando can also be configured to use an existing\ndatabase service provided by the customer. In these scenarios, the\ncustomer is expected to take responbility for the lower level database\noperations such as tablespace creation, permissions and clustering.\nEntando will however still be responsible for creating and populating\nthe tables, indices and foreing keys. Entando will also create all of\nthese in the appropriate table \'container\' for the DBMS in question such\nas a schema (Oracle/PostgreSQL) or a database (MySQL). In order to\nachieve this, Entando installs a dedicated CustomResourceDefinition in\nKubernetes, called an \'EntandoDatabaseService\' \n The idea is for EntandoDatabaseService custom resources to be created in\nthe namespace the EntandoApps and EntandoPlugin that should use them\nwill be created. The EntandoDatabaseService is usually created along\nwith a secret that carries admin credentials to the database in\nquestion. \n Structure \n The EntandoDatabaseService custom resource looks like this: \n  EntandoDatabaseService\nmetadata:\n  name: string, any K8S compliant name\n  namespace: string, the namespace this will be created in\nspec:\n  dbms: string, one of oracle, postgresql or mysql\n  host: string, either an ip address or hostname where the database service is hosted\n  port: integer, the port on which the database service is hosted\n  databaseName: string, the name of the database, only required for PostgreSQL and Oracle\n  secretName: the name of the Secret in the same namespace carrying admin credentials to the database service\n  tablespace: (Oracle only)  the tablespace to use to create the required schemas in\n  jdbcParameters: a map containing name-value pairs for any additional parameters required for the JDBC driver to connect to the database.\n \n The Secret that will provide the admin credentials, identified by the\nabove  secretName  should look like this: \n Secret:\n  name: string, any K8S compliant name\n  namespace: string, the namespace this will be created in\n  stringData:\n    username: string, name of an admin user that can create schemas and other users\n    password: string, password of the above user\n How it works \n In order for the EntandoApp and EntandoPlugin deployer to pick up the\ncorrect database service, the EntandoDatabaseService needs to be created\nBEFORE the EntandoApps and EntandoPlugins are created. There can be\nmultiple EntandoDatabaseServices in the namespace, but they need to\npoint to database services of different vendors, i.e. PostgreSQL, Oracle\nand MySQL. Entando currently cannot enforce any validation but if there\nare two EntandoDatabaseServices that have the same DBMS vendor, it will\nsimply pick the first one and continue. Please ensure that only one\nEntandoDatabaseService exists for each DBMS vendor you need to use. \n Once the appropriate EntandoDatabaseServices have been created, any\nEntandoApp or EntandoPlugin that is created will have to specify the\nappropriate DBMS vendor in their  spec.dbms  property. If the\nEntandoOperator detects an EntandoDatabaseService with a matching DBMS\nvendor, it will continue to create the necessary schemas on the specific\ndatabase. If the EntandoOperator does not detect an\nEntandoDatabaseService with a matching DBMS vendor, it will fall back\nonto its default behaviour which is to create a matching Deployment and\nspin up a database service from the same namespace. If the  spec.dbms \nproperty is not specified on an EntandoApp, the EntandoOperator will\ndefault to PostgreSQL. If the  spec.dbms  property is not specified on\nan EntandoPlugin, the EntandoOperator will assume that the EntandoPlugin\nin question does not require a database and hence bypass any database\nand schema creation. \n When the EntandoOperator processes your Entandoapp or EntandoPlugin with\nan appropriate  spec.dbms  specified, it will create a Schema/User pair\nfor each datasource required. A typical EntandoApp deployment requires 3\ndatasources (portdb,servdb and dedb). Plugins generally only require one\ndatasource (plugindb). \n The database schema and user created will have the same name. The name\nis derived from the name of the EntandoPlugin or EntandoApp by replacing\nall characters that are not ANSI-SQL compliant with an underscore. The\ndatasource name is then suffixed to the schema name. When defining the\nname of your app or plugin, please keep in mind that some DBMS vendors\ndo not support long schema names. Future versions of Entando will allow\nyou to override the schema prefix for an app or plugin, but for now this\nis a limitation one has to keep in mind. \n Keeping track of credentials \n The EntandoOperator generates a Kubernetes Secret for each schema/user\ncombination it creates. The name of this secret is the concatenation of\nthe name of the EntandoApp or EntandoPlugin, the datasource qualifier\nand then the suffix "-secret". For instance, for an EntandoApp called\n"my-app" the "portdb" datasource will have a corresponding Kubernetes\nSecret called "my-app-portdb-secret". The EntandoOperator will never\noverwrite or update an existing database secret. We generate a random\nstring for the password which is generally considered the safest\napproach. If you do however wish to change the password in for the\nresulting user, please remember to update the password on the Kubernetes\nSecret too. Such an operation is however error prone and could result in\nsubsequent deployments failing. \n The EntandoOperator’s schema creation logic is idempotent. If it\ntherefore finds that the generated schema/user combination found in the\nassociated Kuberentes Secret already exists, it won’t do anything.\nHowever, it will attempt to log in, and if it fails to log in, it will\nattempt to create the user. If the user already exists, but with a\ndifferent password than the one in the Kubernetes Secret, all subsequent\ndeployment operations will fail. \n Vendor specific notes \n Oracle \n Example \n   EntandoDatabaseService\n    metadata:\n      name:oracle-service\n    spec:\n      dbms: oracle\n      host: 10.0.0.13\n      port: 1521\n      databaseName: ORCLPDB1.localdomain\n      secretName: oracle-secret\n      tablespace: entando_ts\n      jdbcParameters: {}\n  Secret:\n    metadata:\n      name: oracle-secret\n    stringData:\n      username: admin\n      password: admin123\n Resulting connection string: \n jdbc:oracle:thin:@//10.0.0.13:1521/ORCLPDB1.localdomain \n Notes \n Oracle has some rather complicated rules in building the correct\nconnection string. Please note that for the sake of portability and\nlightweight image we are limited to the thin driver. The  databaseName \ncould also be an Oracle service as opposed to an Oracle  SID . Please\ncoordinate with your Oracle DB Admin to determine exactly what value to\nuse here. We strongly recommend testing your settings with some code or\na tool that constructs JDBC connection. \n When the EntandoOperator prepares the schemas for your EntandoApp or\nEntandoPlugin, it will create a user for every datasource required, and\nas is standard behaviour for Oracle, that user will have its own schema\nwith the same name. Permissions are set up to ensure that one user\ncannot access tables from another user’s schema. Please note that Oracle\nlimits schema names to 30 characters. If you intend to use Oracle,\nplease keep the name of your apps and plugins short enough. The suffixes\nthat we append to the app or plugin name to ensure the resulting schema\nname is unique are usually shorter than 8 characters, so names of about\n20 characters should be safe. \n You can specify which tablespace Entando should use to create the\nschemas in using the  spec.tablespace  property \n ORA-01704: string literal too long \n Entando requires extended datatypes to be activated in Oracle 12c and\nhigher\n( https://oracle-base.com/articles/12c/extended-data-types-12cR1 ) \n MySQL \n Example \n EntandoDatabaseService\n  metadata:\n    name:mysql-service\n  spec:\n    dbms: mysql\n    host: 10.0.0.13\n    port: 3306\n    databaseName:\n    secretName: mysql-secret\n    jdbcParameters:\n       useSSL: "true"\nSecret:\n  metadata:\n    name: mysql-secret\n  stringData:\n    username: admin\n    password: admin123\n Resulting Connection String \n jdbc:mysql://10.0.0.13:3306 \n Notes \n MySQL doesn’t distinguish between schemas and databases. For this reason, no\ndatabaseName is required. The EntandoOperator will therefore create an\nentirely new database for each datasource your EntandoApp or\nEntandoPlugin requires. It will also create a user with the same name as\nthe database with permission set up to ensure one user cannot access the\ndatabase of another user. Please note that MySQL limits database names\nto 63 characters. Keep this in mind when defining the names of your\nEntandoApps and EntandoPlugins \n PostgreSQL \n Example \n   EntandoDatabaseService\n    metadata:\n      name:postgresql-service\n    spec:\n      dbms: postgresql\n      host: 10.0.0.13\n      port: 5432\n      databaseName: my_db\n      secretName: postgresql-secret\n      jdbcParameters: {}\n\n  Secret:\n    metadata:\n      name: postgresql-secret\n    stringData:\n      username: admin\n      password: admin123\n Resulting Connection String \n jdbc:postgresql://10.0.0.13:5432/my_db \n Notes \n PostgreSQL behaves very similar to Oracle when it comes to how it\nassociates a user with its own schema. The current username is used as a\ndefault schema/prefix to resolve tables. As with Oracle, Entando ensures\nthat two users don’t have access to each other’s schemas. \n Skipping database preparation \n When an Entando App is being deployed, there is an operator responsible for the entire deployment process. It also takes care of DB creation and preparation.\nIf you already have a prepared DB (schemas, tables, etc.), you could skip schemas creation and DB preparation of the EntandoApp in order to speed up the deployment process. \n You can achieve this by specifying some properties for the EntandoApp component present in the  entandoapp.yaml  file. \n For  spec.dbms  property you should choose  none , then you should add all needed DB connection parameters.\nAfter updating parameters with the one you need, you should end with a yaml like this: \n      -   kind :   "EntandoApp" \n       metadata : \n         annotations :   { } \n         labels :   { } \n         name :   "example-qs" \n       spec : \n         dbms :   "none" \n         replicas :   1 \n         standardServerImage :  wildfly\n         ingressPath :  /entando - de - app\n         environmentVariables : \n           -   name :  SPRING_DATASOURCE_USERNAME\n             value :  admin\n           -   name :  SPRING_DATASOURCE_PASSWORD\n             value :  adminadmin\n           -   name :  SPRING_DATASOURCE_URL\n             value :   "jdbc:postgresql://192.168.1.82:5432/testdb?currentSchema=admin_qs_dedb" \n           -   name :  SPRING_JPA_DATABASE_PLATFORM\n             value :  org.hibernate.dialect.PostgreSQLDialect\n           -   name :  PORTDB_URL\n             value :   "jdbc:postgresql://192.168.1.82:5432/testdb?currentSchema=admin_qs_portdb" \n           -   name :  PORTDB_USERNAME\n             value :  admin\n           -   name :  PORTDB_PASSWORD\n             value :  adminadmin\n           -   name :  PORTDB_CONNECTION_CHECKER\n             value :  org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLValidConnectionChecker\n           -   name :  PORTDB_EXCEPTION_SORTER\n             value :  org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLExceptionSorter\n           -   name :  SERVDB_URL\n             value :   "jdbc:postgresql://192.168.1.82:5432/testdb?currentSchema=admin_qs_servdb" \n           -   name :  SERVDB_USERNAME\n             value :  admin\n           -   name :  SERVDB_PASSWORD\n             value :  adminadmin\n           -   name :  SERVDB_CONNECTION_CHECKER\n             value :  org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLValidConnectionChecker\n           -   name :  SERVDB_EXCEPTION_SORTER\n             value :  org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLExceptionSorter\n How it works \n Using  spec.dbms: "none"  will cause the operator to skip that initial schema/user creation step entirely.\nThen adding those variables under the  spec.environmentVariables  section will supply connection parameters that will be used by EntandoApp.\nKeep in mind that all these parameters will be applied to each of the containers in the EntandoApp pod and that they will also override existing values. \n Liquibase Migration \n Beginning with Entando 7.0, the Entando App Engine modules will implement automatic Liquibase migrations to manage structural changes to databases running on MySQL or PostgreSQL. \n The parameter provided to the environment variable  DB_MIGRATION_STRATEGY  determines how required updates are applied to components of an existing database. Three database migration modes are supported and govern upgrade behavior: \n \n auto  (default setting): The application starts and databases are updated. Changes are applied to each component introduced in Entando versions 7.0 and later. \n disabled : The application does not start. Database changes are detected but not implemented. The application indicates which components require updates. \n generate_sql : The application does not start but generates the SQL scripts to upgrade databases manually. \n \n'},{title:"Entando CLI",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/docs/reference/entando-cli.html",relativePath:"v7.0/docs/reference/entando-cli.md",key:"v-04b3508c",path:"/v7.0/docs/reference/entando-cli.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Installation",slug:"installation"},{level:3,title:"Prerequisites",slug:"prerequisites"},{level:3,title:"Install the CLI",slug:"install-the-cli"},{level:3,title:"Check the Environment",slug:"check-the-environment"},{level:3,title:"Update the CLI",slug:"update-the-cli"},{level:2,title:"Available Commands",slug:"available-commands"},{level:2,title:"Project Management",slug:"project-management"},{level:3,title:"Project Setup",slug:"project-setup"},{level:3,title:"Prepare and Publish a Bundle",slug:"prepare-and-publish-a-bundle"},{level:3,title:"Install the Bundle into an Application",slug:"install-the-bundle-into-an-application"},{level:3,title:"Run a Project Locally",slug:"run-a-project-locally"},{level:3,title:"Bundle and Custom Resource Management",slug:"bundle-and-custom-resource-management"},{level:3,title:"Get the Bundle ID and Plugin ID",slug:"get-the-bundle-id-and-plugin-id"},{level:2,title:"Bundle Commands",slug:"bundle-commands"},{level:3,title:"Prepare a Bundle for Publication",slug:"prepare-a-bundle-for-publication"},{level:3,title:"Extract a Bundle from an Application",slug:"extract-a-bundle-from-an-application"},{level:2,title:"Profile Management",slug:"profile-management"},{level:2,title:"Configuration Management",slug:"configuration-management"},{level:3,title:"Commands",slug:"commands"},{level:3,title:"Keys",slug:"keys"},{level:2,title:"Diagnostic Commands",slug:"diagnostic-commands"},{level:2,title:"Reference",slug:"reference"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Entando CLI \n Overview \n The Entando Command Line Interface (CLI) provides a set of commands that accelerate common tasks such as installing a new instance of Entando, generating an Entando project via JHipster, deploying an Entando Bundle, creating an Entando Application, etc. \n Installation \n Prerequisites \n The basic requirements for the CLI vary depending on the category of developer tasks. The CLI is able to install secondary dependencies using the  ent check-env  command as described  here . \n \n \n \n Category \n Prerequisite \n \n \n \n \n Basic Development \n Git or  Git for Windows \n \n \n \n nvm or  NVM for Windows \n \n \n Install Entando in a local VM \n Multipass \n \n \n Build and publish Entando Bundles \n Docker and Docker Compose \n \n \n \n a Git repository for the bundle artifacts \n \n \n \n a Docker Hub account (or organization) for microservice Docker images \n \n \n Deploy an Entando Bundle \n a Kubernetes cluster with admin access, which can be a local cluster (created via the Entando CLI or manually) or a shared remote cluster \n \n \n \n TIP \n The automated option in  Getting Started  will install the CLI along with an Ubuntu VM containing K3s Kubernetes and a quickstart Entando Application. \n Install the CLI \n Install the current offical release of the CLI via the following command \n curl  -L https://get.entando.org/cli  |   bash \n Check the Environment \n Use the  check-env  command to prepare your environment for development. This will verify the presence of required dependencies as well as the appropriate versions for your specific Entando instance. Certain configurations allow  check-env  to automatically install dependencies and prompt the developer for guidance or approval as needed. \n ent check-env develop\n Update the CLI \n The CLI can be updated to the latest version (corresponding to the current Entando version) using \n bash   < ( curl  -L  "https://get.entando.org/cli" )  --update\n \n Run  ent check-env develop  after updating the CLI to determine if dependency versions have changed. \n Alternatively, deleting the  ~/.entando  directory with  rm -rf ~/.entando  and then reinstalling the CLI, per the instructions above, will perform a clean install. This will also remove the private copies of JHipster, Entando Blueprint, etc. \n Available Commands \n Use  ent help  to review the list of available commands \n ~~~~~~~~~~~~~~~~~~~\n Entando CLI\n~~~~~~~~~~~~~~~~~~~\n\n> Essentials:\n  - Activate using:  ~/.entando/ent/v7.0.0/cli/v7.0.0/activate\n  - Deactivate using: ~/.entando/ent/v7.0.0/cli/v7.0.0/deactivate\n\n> Available commands:\n  - app                  => Helper for managing an Entando App\n  - app-info             => Displays information about an Entando App\n  - bundler              => Wrapper for the ent private installation of the Entando bundle tool\n  - check-env            => Checks the environment for required dependencies and settings\n  - diag                 => Runs diagnostics and aggregates the related info in a .tgz file\n  - ecr                  => Helper for managing the ECR\n  - ent                  => Helper for managing the local ents\n  - help                 => Help information\n  - host                 => Helper for managing the system that hosts the quickstart VM\n  - jhipster             => Wrapper for the ent private installation of jhipster\n  - kubectl              => Helper for using kubectl in ent managed scenarios\n  - npm                  => Wrapper for the ent private installation of npm (mostly for internal use)\n  - pod                  => Displays information related to a set of pods\n  - prj                  => Helper for managing Entando bundle projects\n  - profile              => Helper for managing an Entando App\n  - quickstart           => Helper for installing Entando instances locally\n  - run-tests            => Runs the internal tests\n\n> Further info about entando:\n  - ~/.entando/ent/v7.0.0/cli/v7.0.0/README.md\n  - https://www.entando.com/\n  - https://developer.entando.com/\n\n> ⚠ RECOMMENDED FIRST STEP ⚠ :\n  - Check the dependencies (ent check-env --help)\n \n Check a command\'s help text ( --help ) to view specific options and subcommands, e.g.  ent check-env --help . For general configuration options related to ent itself, see  ent --help . \n Project Management \n Sequences commonly used with Entando projects are detailed below. \n Project Setup \n \n Create a project directory \n \n mkdir  testProject  &&   cd  testProject\n \n \n Generate the project skeleton using the JHipster-based Entando Blueprint \n \n ent jhipster --blueprints entando\n \n \n Generate an entity and MFEs \n \n ent jhipster entity Conference\n \n \n Build the new project \n \n ent prj build\n \n \n Note: Using the  ent prj  wrapper avoids having to build each part of the project individually. The first run using  ent prj  can be slower due to MFE node downloads. See  the BLueprint tutorial  for more details. \n Prepare and Publish a Bundle \n Use the publication system (pbs) to assemble your Entando project into a bundle that can be loaded into Kubernetes. You\'ll need your GitHub credentials, an empty GitHub repository to hold your bundle artifacts, and a Docker Hub account or organization. \n \n Initialize the bundle directory. This method accepts SSH and HTTPS URLs. \n \n ent prj pbs-init\n \n \n Publish the build artifacts to GitHub and Docker Hub \n \n ent prj pbs-publish\n \n \n Deploy the bundle into the Entando Component Repository \n \n ent prj deploy\n \n See  Build and Publish a Project Bundle  for more details. \n Install the Bundle into an Application \n The CLI allows you to install a bundle without accessing the Entando App Builder. \n \n Note: A bundle must be deployed before it can be installed. \n \n \n Run the following command from the project folder \n \n ent prj  install \n \n \n If a bundle has already been installed, use  --conflict-strategy  to adopt a strategy for existing components (CREATE, SKIP, OVERRIDE) \n \n ent prj  install  --conflict-strategy = OVERRIDE\n Run a Project Locally \n \n Initialize Keycloak, which leverages Docker Compose \n \n ent prj ext-keycloak start\n \n \n Initialize backend microservices \n \n ent prj be-test-run\n \n To fetch logs from bundle plugins, use the command \n ent prj be-log\n \n \n Initialize one or more frontend widgets, each from its own shell \n \n ent prj fe-test-run\n \n Check out  Run Blueprint-generated Microservices and Micro Frontends in Dev Mode  for more details. \n Bundle and Custom Resource Management \n Entando supports a series of  ent ecr  commands to manage bundles and custom resources. The following commands are particularly useful. \n Display the list of bundles associated with the current profile \n ent ecr list\n \n Generate a custom resource and deploy it to the current profile \n ent ecr deploy\n \n The helpers  get-bundle-id  and  get-plugin-id  have been added to  ent ecr  to calculate and display unique identifiers related to custom resources. This provides additional security controls around bundle-specific and microservice plugin resources. \n Determine the bundle identifier \n ent ecr get-bundle-id YOUR-BUNDLE-REPOSITORY-URL\n \n Determine the plugin identifier \n ent ecr get-plugin-id --auto YOUR-BUNDLE-REPOSITORY-URL\n Get the Bundle ID and Plugin ID \n Entando uses a unique identifier for your bundle as a way to provide additional security controls around bundle-specific resources. You can determine this identifier with the command \n ent prj get-bundle-id --auto\n \n A unique identifier will also be calculated for each microservice plugin in your project. You can determine this identifier with the command \n ent prj get-plugin-id --auto --repo = < BUNDLE-REPO-URL > \n Bundle Commands \n Use the  ent bundler  command to prepare a bundle for publication or extract a bundle from an application. \n Prepare a Bundle for Publication \n The project command  ent prj generate-cr  provides a wrapped version of  ent bundler  and prepares a bundle custom resource from a Git repository. Reference the help text for options (e.g. bundle name, description, repository). The output of  ent prj generate-cr  is a YAML file which can be piped to  ent kubectl  for direct application to Kubernetes. \n   ent bundler from-git\n \n See the  Build and Publish a Simple Bundle tutorial  for an example of how to use  ent prj generate-cr . \n Extract a Bundle from an Application \n Point the bundler to an existing Entando Application to extract its components (pages, content, etc.) and static assets into a custom bundle. This bundle can be used to migrate Entando components from one environment to another (e.g. Dev to QA), as a template for building a new Entando Application, or as the skeleton of an Entando solution. \n The bundler provides an interactive mode to identify the components to export from the application. The bundle folder structure created by an Entando project, including a top-level descriptor file, is generated with the following command. \n   ent bundler from-env  \n \n An  env.json  file to configure the application URLs and client credentials must live in the directory from which the bundler is run. \n { \n    "coreBaseApi" :   "http://<YOUR-DOMAIN-OR-IP>/entando-de-app" , \n    "k8ssvcApi" :   "http://<YOUR-DOMAIN-OR-IP>/k8s" , \n    "clientId" :   "<YOUR-CLIENT-ID>" , \n    "clientSecret" :   "<YOUR-CLIENT-SECRET>" \n } \n \n Instructions to export a bundle, including how to configure  env.json , can be found in the  Export and Publish a Bundle tutorial . \n Profile Management \n To manage and switch between different ent configurations, use  ent profile . \n To switch between different Entando Applications, even if they are in different clusters,  ent profile  uses Kubernetes contexts, kubeconfig files, and/or custom commands (refer to  ent profile first-use-readme ). \n It is common practice for the vendor tool that connects to a cloud Kubernetes to create a Kubernetes context that must be linked to the profile. \n An overview of the current connection and profile information is provided via  ent status . \n \n Create and switch to a new profile \n \n ent pro new [profileName] [EntandoAppName] [namespace]\n\nThis sets the minimal profile data and explains next steps.\n \n \n Link the current profile to a Kubernetes context (alias of  ent attach-kubectx ) \n \n ent pro link [contextName]\n \n This instructs ent how to connect to the Kubernetes containing the Entando Application. \n \n Activate the profile that ent should use across shells \n \n ent pro use [profileName]\n \n This attempts to fully restore a profile type by considering the login and related Entando Applications. \n \n Activate the profile that ent should use within the current shell \n \n source ent pro use [profileName]\n \n This allows ent instances in different shells to simultaneously use different Kube contexts, kubeconfigs or custom commands. The quickstart script creates a profile named "qs--{vmname}" that is associated with the Entando Application it generates. \n \n Print a list of the available profiles \n \n ent pro list\n \n \n Delete a profile \n \n ent pro delete [profileName]\n Configuration Management \n The output of  ent config  is a key-value archive of configurations related to the current profile.\nIt can serve several purposes, but a few "good to know" keys and commands are below. \n Commands \n \n Print the current config archive \n \n ent config --print\n \n \n Interactively edit a config archive \n \n ent config --edit\n \n \n Return the value of a config key \n \n ent config --get {key}\n \n \n Set the value of a config key \n \n ent config --set {key} {value}\n \n \n Delete a config key \n \n ent config --set {key}\n Keys \n \n \n \n Key \n Definition \n \n \n \n \n ENTANDO_NAMESPACE \n stores the fallback namespace used by explicit or implicit runs of  ent kubectl \n \n \n ENTANDO_APPNAME \n stores the Entando Application name related to the current profile \n \n \n DESIGNATED_JAVA_HOME \n stores the path of the Java version used internally by ent \n Diagnostic Commands \n Performing the  Automatic Install  found in the Getting Started guide installs the CLI in a Multipass VM. The following commands can be run from this VM for insight into an Entando Application. \n \n Display basic information about Kubernetes and Entando resources (e.g. namespace, pods, ingresses) \n \n ent app-info\n \n \n Display  kubectl describe  and  kubectl logs  for each of the major Entando pods in a namespace \n \n ent pod-info\n \n \n List the current pods in an Entando namespace and prepare a diagnostic tar.gz \n \n ent diag\n \n This outputs  kubectl describe  and  kubectl logs  for each of the fundamental Entando pods. It also exports custom resources, ingresses, deployments, "previous" pod logs, namespace events, etc. Diagnostic information can be highly useful when analyzing and troubleshooting behavior. The command  ent diag  outputs the directory paths of the diagnostic logs, similar to the following \n > Collected diagdata available under "~/.entando/reports/entando-diagdata-2020-11-19T02:58:47+0000" for consultation\n> Collected diagdata available in archive "~/.entando/reports/entando-diagdata-2020-11-19T02:58:47+0000.tgz"\n Reference \n \n Source repository:  https://github.com/entando/entando-cli/tree/develop \n \n'},{title:"jACMS Aps Core Tag Library",frontmatter:{},regularPath:"/v7.0/docs/reference/freemarker-tags/freemarker-JACMS-tags.html",relativePath:"v7.0/docs/reference/freemarker-tags/freemarker-JACMS-tags.md",key:"v-6d775b02",path:"/v7.0/docs/reference/freemarker-tags/freemarker-JACMS-tags.html",headers:[{level:2,title:"Tag content",slug:"tag-content"},{level:3,title:"Tag Class com.agiletec.plugins.jacms.aps.tags.ContentTag",slug:"tag-class-com-agiletec-plugins-jacms-aps-tags-contenttag"},{level:3,title:"Description",slug:"description"},{level:3,title:"Attributes",slug:"attributes"},{level:2,title:"Tag contentInfo",slug:"tag-contentinfo"},{level:3,title:"Tag Class com.agiletec.plugins.jacms.aps.tags.ContentInfoTag",slug:"tag-class-com-agiletec-plugins-jacms-aps-tags-contentinfotag"},{level:3,title:"Description",slug:"description-2"},{level:3,title:"Attributes",slug:"attributes-2"},{level:2,title:"Tag contentList",slug:"tag-contentlist"},{level:3,title:"Tag Class com.agiletec.plugins.jacms.aps.tags.ContentListTag",slug:"tag-class-com-agiletec-plugins-jacms-aps-tags-contentlisttag"},{level:3,title:"Description",slug:"description-3"},{level:3,title:"Attributes",slug:"attributes-3"},{level:2,title:"Tag contentListFilter",slug:"tag-contentlistfilter"},{level:3,title:"Tag Class Tag class: com.agiletec.plugins.jacms.aps.tags.ContentListFilterTag",slug:"tag-class-tag-class-com-agiletec-plugins-jacms-aps-tags-contentlistfiltertag"},{level:3,title:"Description",slug:"description-4"},{level:3,title:"Attributes",slug:"attributes-4"},{level:2,title:"Tag contentListUserFilterOption",slug:"tag-contentlistuserfilteroption"},{level:3,title:"Tag Class Tag class: com.agiletec.plugins.jacms.aps.tags.ContentListUserFilterOptionTag=",slug:"tag-class-tag-class-com-agiletec-plugins-jacms-aps-tags-contentlistuserfilteroptiontag"},{level:3,title:"Description",slug:"description-5"},{level:3,title:"Attributes",slug:"attributes-5"},{level:2,title:"Tag searcher",slug:"tag-searcher"},{level:3,title:"Tag Class com.agiletec.plugins.jacms.aps.tags.SearcherTag",slug:"tag-class-com-agiletec-plugins-jacms-aps-tags-searchertag"},{level:3,title:"Description",slug:"description-6"},{level:3,title:"Attributes",slug:"attributes-6"},{level:2,title:"Tag rowContentList",slug:"tag-rowcontentlist"},{level:2,title:"Tag Class Tag class: com.agiletec.plugins.jacms.aps.tags.RowContentListTag",slug:"tag-class-tag-class-com-agiletec-plugins-jacms-aps-tags-rowcontentlisttag"},{level:3,title:"Description",slug:"description-7"},{level:3,title:"Attributes",slug:"attributes-7"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' jACMS Aps Core Tag Library \n \n \n Version: 2.3 \n \n \n Short Name: jacmsaps \n \n \n URI: /jacms-aps-core \n Tag  content \n Tag Class  com.agiletec.plugins.jacms.aps.tags.ContentTag \n Description \n Displays the content given its ID. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n contentId \n false \n ID of the content to display. It can accept "expression language". \n \n \n modelId \n false \n Id of the model to use to display the content. The model ID can be either specified explicitly (the model must match the content to serve) or the type name ("list" or "default"); in the latter case the model specified in the configuration will be used. The model must adhere to the content being returned. "Expression language" is accepted. \n \n publishExtraTitle \n false \n Toggles the insertion of the values of the titles in the Request Context. The title values are extracted from the attribute marked with the role "jacms:title". Admitted values are (true, false), default \'false\'. \n \n \n var \n false \n Inserts the rendered content in a variable of the page context with the name provided. \n \n \n attributeValuesByRoleVar \n false \n Inserts the map of the attribute values indexed by the attribute role, in a variable of the page context with the name provided. \n Tag  contentInfo \n Tag Class  com.agiletec.plugins.jacms.aps.tags.ContentInfoTag \n Description \n Return information of a specified content. The content can will be extracted by id from widget parameters or from request parameter. The tag extract any specific parameter (by "param" attribute) or entire ContentAuthorizationInfo object (setting "var" attribute and anything on "param" attribute). \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n contentId \n false \n ID of the content \n \n \n param \n false \n Admitted values for "param" attribute are: \'contentId\' (returns the code of content id), \'mainGroup\' (returns the code of owner group), \'authToEdit\' (returns true if the current user can edit the content, else false). \n \n \n var \n false \n Inserts the required parameter (or the entire authorization info object) in a variable of the page context with the name provided. \n Tag  contentList \n Tag Class  com.agiletec.plugins.jacms.aps.tags.ContentListTag \n Description \n Loads a list of contents IDs by applying the filters (if any). Only the IDs of the contents accessible in the portal can be loaded. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n listName \n true \n Name of the variable in the page context that holds the search result. \n \n \n contentType \n false \n Sets the code of the content types to search. The name must match the configured one, respecting capital letters and spaces. \n \n \n category \n false \n Identifier string of the category of the content to search. \n \n \n cacheable \n false \n Toggles the system caching usage when retrieving the list. Admitted values (true, false), default "true". \n \n \n titleVar \n false \n Inserts the title on a variable of the page context with the name provided. \n \n \n pageLinkVar \n false \n Inserts the code of the page to link on a variable of the page context with the name provided. \n \n \n pageLinkDescriptionVar \n false \n Inserts the description of the page to link on a variable of the page context with the name provided. \n \n \n userFilterOptionsVar \n false \n Name of the variable in the page context that holds the user filter options \n Tag  contentListFilter \n Tag Class  Tag class: com.agiletec.plugins.jacms.aps.tags.ContentListFilterTag \n Description \n "ContentListTag" sub-tag, it creates a filter to restrict the result of the content search. Please note that the filters will be applied in the same order they are declared and the result of the search will reflect this fact. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n key \n true \n String used to filter and sort the contents. This string can be: - the name of a content attribute compatible with the type declared in the "contentListTag" (it requires the "attributeFilter" attribute to be "true") - the ID of one of the content metadata (the "attributeFilter" must be false) The allowed filter key that can be applied to content metadata are: - "created" allows sorting by date of creation of content - "modified" allows sorting by date of modification of content. \n \n \n attributeFilter \n true \n Decides whether the filter must be applied to an attribute or to a content metadata, admitted values are (true, false). The "key" attribute will be checked for validity if the filter is going to be applied to a metadata \n \n \n value \n false \n The filtering value. \n \n \n start \n false \n Filters the contents by attribute type or by the field specified with the key (respect the following matches): Text field -→ start Text Text attribute type -→ start Text Numeric attribute type -→ start Numeric date attribute type -→ start data If the data filter is used: - today, oggi or odierna will select all the contents with a date greater or equal to the system date - using date with the pattern "dd/MM/yyyy" will select all the contents with a date greater or equal to the one inserted. \n \n \n end \n false \n Similar the the "start" attribute but with the opposite behavior. \n \n \n order \n false \n Specifies the sorting behavior of the IDs found: "ASC"ending or "DESC"ending. By default no ordering is performed. \n \n \n likeOption \n false \n Toggles the \'like\' functionality. Admitted values: (true, false). Default: false. The option is available for metadata and on Text Content attributes. \n Tag  contentListUserFilterOption \n Tag Class  Tag class: com.agiletec.plugins.jacms.aps.tags.ContentListUserFilterOptionTag = \n Description \n "ContentListTag" sub-tag, it creates a custom user filter to restrict the result of the content search by front-end user. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n key \n true \n The key of the filter. This string can be: - the name of a content attribute compatible with the type declared in the "contentListTag" (it requires the "attributeFilter" attribute to be "true") - the ID of one of the content metadata (the "attributeFilter" must be false) The allowed filter key that can be applied to content metadata are: - "fulltext" allows filter by full-text search<br /> - "category" allows filter by a system category. \n \n \n attributeFilter \n true \n Decides whether the filter must be applied to an attribute or to a content metadata, admitted values are (true, false). The "key" attribute will be checked for validity if the filter is going to be applied to a metadata. \n Tag  searcher \n Tag Class  com.agiletec.plugins.jacms.aps.tags.SearcherTag \n Description \n Generates a list of content IDs, restricting them to the key word contained in the "search" parameter of the http request. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n listName \n yes \n Name of the variable, stored in the page context, containing the list of content IDs. \n Tag  rowContentList \n Tag Class  Tag class: com.agiletec.plugins.jacms.aps.tags.RowContentListTag \n Description \n Publish a list of contents. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n listName \n true \n Name of the variable in the page context that holds the contents (list of properties of key "contentId" and "modelId"). \n \n \n titleVar \n false \n Inserts the title on a variable of the page context with the name provided. \n \n \n pageLinkVar \n false \n Inserts the code of the page to link on a variable of the page context with the name provided. \n \n \n pageLinkDescriptionVar \n false \n Inserts the description of the page to link on a variable of the page context with the name provided. \n \n \n \n'},{title:"Learning Paths",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/",relativePath:"v7.0/tutorials/README.md",key:"v-61834b18",path:"/v7.0/tutorials/",headers:[{level:2,title:"Frontend Development",slug:"frontend-development"},{level:2,title:"Backend Development",slug:"backend-development"},{level:2,title:"Operations",slug:"operations"}],lastUpdated:"4/19/2022, 10:05:46 PM",lastUpdatedTimestamp:1650420346e3,content:" Learning Paths \n Entando simplifies the development of modern apps: \n \n Built using modern JavaScript frameworks \n Backed by microservices deployed in containers, and \n Orchestrated by Kubernetes for fully automated DevOps lifecycles \n \n \n Entando supports full stack micro frontend and microservice architectures for codebases that are easier to understand, maintain, and debug across large, distributed teams, and comes with a private component repository that makes it easy for teams to share and reuse components. \n Use the navigation on the left to find step-by-step tutorials for common tasks or check out our learning paths below for a more structured approach. \n Frontend Development \n \n \n \n Basic \n Intermediate \n Advanced \n \n \n \n \n Build a Basic Widget \n Add Configuration to a Widget \n Generate Micro Frontends and Microservices Based on a Database Entity \n \n \n Create a React Micro Frontend \n Enable Communication between MFEs \n \n \n \n Create an Angular Micro Frontend \n Add Access Controls to your MFEs \n \n \n \n Create and Manage Content \n Backend Development \n \n \n \n Basic \n Intermediate \n Advanced \n \n \n \n \n Build and Publish a Simple Bundle \n Build and Publish a Project Bundle \n Export a Bundle from an Existing Application \n \n \n Generate Micro Frontends and Microservices Based on a Database Entity \n Use JDL Studio to Create a Complex Database Entity \n Manage Plugin Environment Variables \n \n \n Run Micro Frontends and Microservices in Your Local Environment \n Add Access Controls to Your Microservices \n \n \n \n \n Use Postman with OAuth2 APIs \n Operations \n \n \n \n Basic \n Intermediate \n Advanced \n \n \n \n \n Set Up Entando on a Local Kubernetes Cluster \n Backing Up and Restoring Your Entando Environment \n Install Bundle Microservices from a Private Registry \n \n \n Set Up Entando on Amazon Elastic Kubernetes Service (EKS) \n Customize the base Entando Application via a Docker Image \n Add a GitHub Actions CI Workflow \n \n \n Set Up Entando on Azure Kubernetes Service (AKS) \n Connect Your Entando Application to an External Database \n Manage NGINX \n \n \n Set Up Entando on Google Kubernetes Engine (GKE) \n Install the Standard Demo Application \n Setup Plugin Profiles \n \n \n Set Up Entando on Red Hat OpenShift \n Configure the Entando Operator \n \n \n \n \n"},{title:"Aps Core Tag Library",frontmatter:{},regularPath:"/v7.0/docs/reference/freemarker-tags/freemarker-core-tags.html",relativePath:"v7.0/docs/reference/freemarker-tags/freemarker-core-tags.md",key:"v-2b5ccb75",path:"/v7.0/docs/reference/freemarker-tags/freemarker-core-tags.html",headers:[{level:2,title:"Tag action",slug:"tag-action"},{level:3,title:"Description",slug:"description"},{level:3,title:"Example",slug:"example"},{level:3,title:"Attributes",slug:"attributes"},{level:3,title:"Tag class",slug:"tag-class"},{level:2,title:"Tag categories",slug:"tag-categories"},{level:3,title:"Description",slug:"description-2"},{level:3,title:"Example",slug:"example-2"},{level:3,title:"Attributes",slug:"attributes-2"},{level:3,title:"Tag class",slug:"tag-class-2"},{level:2,title:"Tag checkHeadInfoOuputter",slug:"tag-checkheadinfoouputter"},{level:3,title:"Description",slug:"description-3"},{level:3,title:"Attributes",slug:"attributes-3"},{level:3,title:"Tag class",slug:"tag-class-3"},{level:2,title:"Tag cssURL",slug:"tag-cssurl"},{level:3,title:"Description",slug:"description-4"},{level:3,title:"Example",slug:"example-3"},{level:3,title:"Attributes",slug:"attributes-4"},{level:3,title:"Tag class",slug:"tag-class-4"},{level:2,title:"Tag currentPage",slug:"tag-currentpage"},{level:3,title:"Description",slug:"description-5"},{level:3,title:"Example",slug:"example-4"},{level:3,title:"Attributes",slug:"attributes-5"},{level:3,title:"Tag class",slug:"tag-class-5"},{level:2,title:"Tag currentWidget",slug:"tag-currentwidget"},{level:3,title:"Description",slug:"description-6"},{level:3,title:"Example",slug:"example-5"},{level:3,title:"Attributes",slug:"attributes-6"},{level:3,title:"Tag class",slug:"tag-class-6"},{level:2,title:"Tag fragment",slug:"tag-fragment"},{level:3,title:"Description",slug:"description-7"},{level:3,title:"Attributes",slug:"attributes-7"},{level:3,title:"Tag class",slug:"tag-class-7"},{level:2,title:"Tag freemarkerTemplateParameter",slug:"tag-freemarkertemplateparameter"},{level:3,title:"Description",slug:"description-8"},{level:3,title:"Attributes",slug:"attributes-8"},{level:3,title:"Tag class",slug:"tag-class-8"},{level:2,title:"Tag headInfo",slug:"tag-headinfo"},{level:3,title:"Description",slug:"description-9"},{level:3,title:"Example",slug:"example-6"},{level:3,title:"Attributes",slug:"attributes-9"},{level:3,title:"Tag class",slug:"tag-class-9"},{level:2,title:"Tag i18n",slug:"tag-i18n"},{level:3,title:"Description",slug:"description-10"},{level:3,title:"Example",slug:"example-7"},{level:3,title:"Attributes",slug:"attributes-10"},{level:3,title:"Tag class",slug:"tag-class-10"},{level:2,title:"Tag ifauthorized",slug:"tag-ifauthorized"},{level:3,title:"Description",slug:"description-11"},{level:3,title:"Example",slug:"example-8"},{level:3,title:"Attributes",slug:"attributes-11"},{level:3,title:"Tag class",slug:"tag-class-11"},{level:2,title:"Tag imgURL",slug:"tag-imgurl"},{level:3,title:"Description",slug:"description-12"},{level:3,title:"Example",slug:"example-9"},{level:3,title:"Attributes",slug:"attributes-12"},{level:3,title:"Tag class",slug:"tag-class-12"},{level:2,title:"Tag info",slug:"tag-info"},{level:3,title:"Description",slug:"description-13"},{level:3,title:"Example",slug:"example-10"},{level:3,title:"Attributes",slug:"attributes-13"},{level:3,title:"Tag class",slug:"tag-class-13"},{level:2,title:"Tag internalServlet",slug:"tag-internalservlet"},{level:3,title:"Description",slug:"description-14"},{level:3,title:"Example",slug:"example-11"},{level:3,title:"Attributes",slug:"attributes-14"},{level:3,title:"Tag class",slug:"tag-class-14"},{level:2,title:"Tag nav",slug:"tag-nav"},{level:3,title:"Description",slug:"description-15"},{level:3,title:"Example",slug:"example-12"},{level:3,title:"Attributes",slug:"attributes-15"},{level:3,title:"Tag class",slug:"tag-class-15"},{level:2,title:"Tag outputHeadInfo",slug:"tag-outputheadinfo"},{level:3,title:"Description",slug:"description-16"},{level:3,title:"Attributes",slug:"attributes-16"},{level:3,title:"Tag class",slug:"tag-class-16"},{level:2,title:"Tag pageInfo",slug:"tag-pageinfo"},{level:3,title:"Description",slug:"description-17"},{level:3,title:"Attributes",slug:"attributes-17"},{level:3,title:"Tag class",slug:"tag-class-17"},{level:2,title:"Tag pager",slug:"tag-pager"},{level:3,title:"Description",slug:"description-18"},{level:3,title:"Example",slug:"example-13"},{level:3,title:"Attributes",slug:"attributes-18"},{level:3,title:"Tag class",slug:"tag-class-18"},{level:2,title:"Tag parameter",slug:"tag-parameter"},{level:2,title:"Tag pager",slug:"tag-pager-2"},{level:3,title:"Description",slug:"description-19"},{level:3,title:"Example",slug:"example-14"},{level:3,title:"Attributes",slug:"attributes-19"},{level:3,title:"Tag class",slug:"tag-class-19"},{level:2,title:"Tag printHeadInfo",slug:"tag-printheadinfo"},{level:3,title:"Description",slug:"description-20"},{level:3,title:"Attributes",slug:"attributes-20"},{level:3,title:"Tag class",slug:"tag-class-20"},{level:2,title:"Tag resourceURL",slug:"tag-resourceurl"},{level:3,title:"Description",slug:"description-21"},{level:3,title:"Example",slug:"example-15"},{level:3,title:"Attributes",slug:"attributes-21"},{level:3,title:"Tag class",slug:"tag-class-21"},{level:2,title:"Tag show",slug:"tag-show"},{level:3,title:"Description",slug:"description-22"},{level:3,title:"Example",slug:"example-16"},{level:3,title:"Attributes",slug:"attributes-22"},{level:3,title:"Tag class",slug:"tag-class-22"},{level:2,title:"Tag url",slug:"tag-url"},{level:3,title:"Description",slug:"description-23"},{level:3,title:"Example",slug:"example-17"},{level:3,title:"Attributes",slug:"attributes-23"},{level:3,title:"Tag class",slug:"tag-class-23"},{level:2,title:"Tag pageWithWidget",slug:"tag-pagewithwidget"},{level:3,title:"Description",slug:"description-24"},{level:3,title:"Example",slug:"example-18"},{level:3,title:"Attributes",slug:"attributes-24"},{level:3,title:"Tag class",slug:"tag-class-24"},{level:2,title:"Tag currentUserProfileAttribute",slug:"tag-currentuserprofileattribute"},{level:3,title:"Description",slug:"description-25"},{level:3,title:"Attributes",slug:"attributes-25"},{level:3,title:"Tag class",slug:"tag-class-25"},{level:2,title:"Tag userProfileAttribute",slug:"tag-userprofileattribute"},{level:3,title:"Description",slug:"description-26"},{level:3,title:"Attributes",slug:"attributes-26"},{level:3,title:"Tag class",slug:"tag-class-26"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Aps Core Tag Library \n \n \n Version: 2.3 \n \n \n Short Name: wp \n \n \n URI: /aps-core \n Tag  action \n Description \n Build the URL to call a jsp or a functionality of a servlet defined\nwithin the system. This tag can use the ParameterTag sub-tag to add url\nparameters. \n Example \n (<@wp.action path="/do/my.action" var="myaction" />)  or\n (<@wp.action path="/JSP/my.jsp" var="my.jsp"/>) \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n path \n no \n The relative path of jsp or servlet to invoke, relative to the context of web-application \n \n \n var \n no \n Name of the page-scoped variable where to place the URL. \n Tag class \n com.agiletec.aps.tags.ActionURLTag \n Tag  categories \n Description \n Return the list of the system categories on SelectItem objects. \n Example \n <@wp.categories var="systemCategories" titleStyle="prettyFull" root="$\\{userFilterOptionVar.userFilterCategoryCode}" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n titleStyle \n no \n The style of the single select item. Currently it can be \'default\' (single title node), \'full\' (title with all parents) or \'prettyFull\' (title with all parents in form of \'..\'). The default when none is given is \'default\'. \n \n \n fullTitleSeparator \n no \n The separator beetwen the titles when \'titleStyle\' is \'full\' or \'prettyFull\'. \n \n \n var \n no \n Name of the page-scoped variable where to place the list of categories. \n \n \n root \n no \n The root of the categories to show. The default is the system root categories \n Tag class \n com.agiletec.aps.tags.CategoriesTag \n Tag  checkHeadInfoOuputter \n Description \n This sub-tag verifies the availability of the information to display.\nThis sub-tag can be used only in a page template, in conjunction with\n\'outputHeadInfo\'. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n type \n yes \n Specifies the type of information to analyse. \n Tag class \n com.agiletec.aps.tags.CheckHeadInfoOutputterTag \n Tag  cssURL \n Description \n Extension of the ResourceURL tag. It returns the URL of the css files. \n Example \n <@wp.cssURL />href="<@wp.cssURL />myportal.css" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n Tag class \n com.agiletec.aps.tags.CssURLTag \n Tag  currentPage \n Description \n Returns the requested information held by the current page bean. \n Example \n <@wp.currentPage param="code" var="currentViewCode" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n param \n false \n The wanted parameter: actually can be either "title", "owner" (group), "code", "hasChild" or "childOf" (with attribute "targetPage"). The default when none is given is "title". \n \n \n langCode \n no \n Code of the language to use for the page information being returned. \n \n \n var \n no \n Name of the page context variable where the information are placed. Please note that the in this case the special characters will not be escaped. \n \n \n targetPage \n no \n Target page when "param" is "childOf". \n \n \n escapeXml \n no \n Decides whether to escape the special characters in the information retrieved or not. Value admitted (true, false), the default is true. \n Tag class \n com.agiletec.aps.tags.CurrentPageTag \n Tag  currentWidget \n Description \n Returns information about the widget where the tag resides. To obtain\ninformation about a widget placed in a frame other than the current, use\nthe "frame" attribute. \n Example \n <@wp.currentWidget param="config" configParam="name" var="configName" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n param \n yes \n The requested parameter. It can assume one of the following values: - "code" returns the code of the associated widget type (empty if none associated) - "title" returns the name of the associated widget type (empty if none associated) - "config" returns the value of the configuration parameter declared in the "configParam" attribute. The default is "title". \n \n \n configParam \n no \n Name of the configuration parameter request. This attribute is mandatory when the attribute "param" is set to "config". \n \n \n var \n no \n Name of the page context variable where the requested information is pushed. In this case the special characters will not be escaped. \n \n \n frame \n false \n Id of the frame hosting the widget with the desired information. \n \n \n escapeXml \n no \n Toggles the escape of the special characters. Admitted value are (true, false), the default is "true". \n Tag class \n com.agiletec.aps.tags.CurrentWidgetTag \n Tag  fragment \n Description \n Print a gui fragment by the given code. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n code \n true \n The code of the fragment to return. \n \n \n var \n false \n Name of the page context variable where the requested information is pushed. In this case the special characters will not be escaped. \n \n \n escapeXml \n false \n Toggles the escape of the special characters. Admitted value are (true, false), the default is "true". \n Tag class \n org.entando.entando.aps.tags.GuiFragmentTag \n Tag  freemarkerTemplateParameter \n Description \n Add a parameter into the Freemarker’s TemplateModel Map. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n var \n true \n Name of the variable where the requested information is pushed. \n \n \n valueName \n true \n Name of the variable of the page context where extract the information. \n \n \n removeOnEndTag \n false \n Whether to remove the parameter on end of Tag. Possible entries (true, false). Default value: false. \n Tag class \n org.entando.entando.aps.tags.FreemarkerTemplateParameterTag \n Tag  headInfo \n Description \n Declares the information to insert in the header of the HTML page. The\ninformation can be passed as an attribute or, in an indirect manner,\nthrough a variable of the page context. It is mandatory to specify the\ntype of the information. \n Example \n <@wp.headInfo type="JS" info="entando-misc-bootstrap/bootstrap.min.js" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n type \n yes \n Declaration of the information type. Currently only "CSS" is currently supported. \n \n \n info \n no \n Information to declare. This is an alternative of the "var" attribute. \n \n \n var \n no \n Name of the variable holding the information to declare. This attribute is the alternative of the "info" one. This variable can be used for those types of information that cannot be held by an attribute. \n Tag class \n com.agiletec.aps.tags.HeadInfoTag \n Tag  i18n \n Description \n Return the string associated to the given key in the specified language.\nThis string is either returned (and rendered) or can be optionally\nplaced in a page context variable. This tag can use the ParameterTag\nsub-tag to add label parameters. \n Example \n <@wp.i18n key="COPYRIGHT" escapeXml="false" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n key \n yes \n Key of the label to return. \n \n \n lang \n no \n Code of the language requested for the lable. \n \n \n var \n no \n Name of the variable (page scope) where to store the wanted information. In this case the special characters will not be escaped. \n \n \n escapeXml \n no \n Toggles the escape of the special characters of the returned label. Admitted values (true, false), the default is true. \n Tag class \n com.agiletec.aps.tags.I18nTag \n Tag  ifauthorized \n Description \n Toggles the visibility of the elements contained in its body, depending\non user permissions. \n Example \n <@wp.ifauthorized permission="enterBackend"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n permission \n no \n The code of the permission required. \n \n \n groupName \n no \n The name of the group membership required. \n \n \n var \n no \n The name of the (boolean) page context parameter where the result of the authorization check is placed. \n Tag class \n com.agiletec.aps.tags.CheckPermissionTag \n Tag  imgURL \n Description \n Extension of the ResourceURL tag. It returns the URL of the images to\ndisplay as static content outside the cms. \n Example \n <@wp.imgURL />entando-logo.png" alt="Entando - Access. Build. Connect." /> \n Attributes \n Tag class \n com.agiletec.aps.tags.ImgURLTag \n Tag  info \n Description \n Returns the information of the desired system parameter. \n Example \n <@wp.info key="systemParam" paramName="applicationBaseURL" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n key \n yes \n Key of the desired system parameter, admitted values are: "startLang" returns the code of start language of web browsing "defaultLang" returns the code of default language "currentLang" returns the code of current language "langs" returns the list of the languages defined in the system "systemParam" returns the value of the system param specified in the "paramName" attribute. \n \n \n var \n no \n Name of the variable where to store the retrieved information (page scope). In this case the special characters will not be escaped. \n \n \n paramName \n no \n Name of the wanted system parameter; it is mandatory if the "key" attribute is "systemParam", otherwise it is ignored. \n \n \n escapeXml \n no \n Toggles the escape of the special characters in the information returned. Admitted values are (true,false), the former being the default value. \n Tag class \n com.agiletec.aps.tags.InfoTag \n Tag  internalServlet \n Description \n Tag for the "Internal Servlet" functionality. Publishes a function\nserved by an internal Servlet; the servlet is invoked from a path\nspecified in the attribute "actionPath" or by the widget parameter\nsharing the same name. This tag can be used only in a widgets. \n Example \n <@wp.internalServlet actionPath="/ExtStr2/do/jpuserreg/UserReg/initRegistration" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n actionPath \n false \n The init action path. \n \n \n staticAction \n false \n Whether to execute only the given action path. Possible entries (true, false). Default value: false. \n Tag class \n com.agiletec.aps.tags.InternalServletTag \n Tag  nav \n Description \n Generates through successive iterations the so called "navigation" list.\nFor every target/page being iterated (inserted in the page context) are\nmade available the page code, the title (in the current language) and\nthe link. Is it also possible to check whether the target page is empty\n-that is, with no configured positions- or not. \n Example \n <@wp.nav var="page"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n spec \n no \n Declares the set of the pages to generate. \n \n \n var \n yes \n Name of the page context variable where the data of target being iterated are made available. \n Tag class \n com.agiletec.aps.tags.NavigatorTag \n Tag  outputHeadInfo \n Description \n Iterates over various information in HTML header displaying them; this\ntag works in conjunction with other specific sub-tags. Please note that\nthe body can contain only a sub-tag, or information, at once. This tag\nmust be used only in a page template. E.g (<@wp.outputHeadInfo\ntype="CSS">) \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n type \n yes \n Specifies the type of information to return, in accordance with the sub-tag to use. \n Tag class \n com.agiletec.aps.tags.HeadInfoOutputterTag \n Tag  pageInfo \n Description \n Returns the information of the specified page. This tag can use the\nsub-tag "ParameterTag" to add url parameters if the info attribute is\nset to \'url\'. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n pageCode \n true \n The code of the page. \n \n \n info \n false \n Code of required page parameter. Possible entries: "code" (default value) , "title", "owner" (group), "url", "hasChild" or "childOf" (with attribute "targetPage"). \n \n \n langCode \n false \n Code of the language to use for the returned information. \n \n \n var \n false \n Name used to reference the value pushed into the pageContext. In this case, the system will not escape the special characters in the value entered in pageContext. \n \n \n targetPage \n no \n Target page when "param" is "childOf". \n \n \n escapeXml \n false \n Whether to escape HTML. Possible entries (true, false). Default value: true. \n Tag class \n com.agiletec.aps.tags.PageInfoTag \n Tag  pager \n Description \n List pager. \n Example \n <@wp.pager listName="result" objectName="groupContent" max="10" pagerIdFromFrame="true" advanced="true" offset="5"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n max \n no \n The maximum value for each object group. \n \n \n listName \n yes \n Name of the list as found in the request. \n \n \n objectName \n yes \n Name of the object currently iterated. The following methods are exposed:  getMax, getPrevItem, getNextItem, getCurrItem, getSize, getBegin, getEnd, getMaxItem, getPagerId. \n \n \n pagerId \n no \n Sets the ID of the pager itself, it has to be used when two or more pagers exist in the same page. This attributes overrides "pagerIdFromFrame". \n \n \n pagerIdFromFrame \n no \n Sets the ID of the pager (mandatory when two or more pagers share the same page) based upon the frame where the tag is placed. Admitted values are (true, false), the latter being the default. Please note that the "pagerId" attribute takes precedence over this one. \n \n \n advanced \n no \n Toggles the pager in advanced mode. Admitted values are (true, false). the advanced mode of the tag is used when the list to iterate over is huge. \n \n \n offset \n no \n This attribute is considered only when the pager is in advanced mode. This is the numeric value of the single step increment (or decrement) when iterating over the list \n Tag class \n com.agiletec.aps.tags.PagerTag \n Tag  parameter \n Tag  pager \n Description \n This tag can be used to parameterise other tags. The parameter value can\nbe added through the \'value\' attribute or the body tag. When you declare\nthe param tag, the value can be defined in either a value attribute or\nas text between the start and the ending of the tag. \n Example \n <@wp.parameter name="resourceName"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n name \n true \n The name of the parameter. \n \n \n value \n false \n The value of the parameter. \n Tag class \n com.agiletec.aps.tags.ParameterTag \n Tag  printHeadInfo \n Description \n Returns the information to display. This sub-tag must be used only in a\npage template, in conjunction with \'outputHeadInfo\'. \n Attributes \n Tag class \n com.agiletec.aps.tags.HeadInfoPrinterTag \n Tag  resourceURL \n Description \n Returns URL of the resources. \n Example \n <@wp.resourceURL />static/js/entando-misc-html5-essentials/html5shiv.js"> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n root \n no \n Declares the resource root. If not otherwise specified, the value of SystemConstants.PAR_RESOURCES_ROOT_URL is used. \n \n \n folder \n no \n Declares a specific directory for the desired resources. Unless specified, the value "" (empty string) is used in the generation of the URL. \n Tag class \n com.agiletec.aps.tags.ResourceURLTag \n Tag  show \n Description \n Defines the position of inclusion of a widget. This tag can be used only\nin a page template. \n Example \n <@wp.show frame="0" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n frame \n yes \n The positional number of the frame, starting from 0. \n Tag class \n com.agiletec.aps.tags.WidgetTag \n Tag  url \n Description \n Generates the complete URL of a portal page. The URL returned is either\nreturned (and rendered) or placed in the given variable. To insert\nparameters in the query string the sub-tag "ParameterTag" is provided. \n Example \n <@wp.url paramRepeat="true" > \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n page \n no \n Code of the destination page. The default is the current page. \n \n \n lang \n no \n Code of the language to use in the destination page. \n \n \n var \n no \n Name of the page-scoped variable where to place the URL. \n \n \n paramRepeat \n no \n Repeats in the URL all the parameters of the actual request. \n \n \n excludeParameters \n no \n Sets the list of parameter names (comma separated) to exclude from repeating. By default, this attribute excludes only the password parameter of the login form. Used only when paramRepeat="true". \n Tag class \n com.agiletec.aps.tags.URLTag \n Tag  pageWithWidget \n Description \n Search and return the page (or the list of pages) with the given widget\ntype. When "filterParamName" and "filterParamValue" attributes are\npresent, the returned list will be filtered by a specific widget\nconfiguration. \n Example \n <@wp.pageWithWidget widgetTypeCode="userprofile_editCurrentUser" var="userprofileEditingPageVar" listResult="false" /> \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n var \n true \n Attribute_description: \n \n \n widgetTypeCode \n true \n The code of the widget to search \n \n \n filterParamName \n false \n Optional widget config param name \n \n \n filterParamValue \n false \n Optional widget config param value \n \n \n listResult \n false \n Optional, dafault false. When true the result is a list of pages, when false the returned page is the first occurence \n Tag class \n com.agiletec.aps.tags.PageWithWidgetTag \n Tag  currentUserProfileAttribute \n Description \n Current User Profile tag. Return a attribute value of the current user\nprofile. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n attributeName \n false \n the name of the attribute from which extract the value. \n \n \n attributeRoleName \n false \n the name of the attribute role from which extract the value. \n \n \n var \n false \n Name used to reference the value pushed into the pageContext. \n \n \n escapeXml \n false \n Decides whether to escape the special characters in the information retrieved or not. Value admitted (true, false), the default is true. \n Tag class \n org.entando.entando.aps.tags.CurrentUserProfileAttributeTag \n Tag  userProfileAttribute \n Description \n User Profile tag. Return a attribute value from the profile givea an\nusername. \n Attributes \n \n \n \n \n \n \n \n \n Attribute \n Required \n Description \n \n \n \n \n username \n true \n the username \n \n \n attributeName \n false \n the name of the attribute from which extract the value. \n \n \n attributeRoleName \n false \n the name of the attribute role from which extract the value. \n \n \n var \n false \n Name used to reference the value pushed into the pageContext. \n \n \n escapeXml \n false \n Decides whether to escape the special characters in the information retrieved or not. Value admitted (true, false), the default is true. \n Tag class \n org.entando.entando.aps.tags.UserProfileAttributeTag \n'},{title:"Development Tips and Tricks",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/docs/reference/local-tips-and-tricks.html",relativePath:"v7.0/docs/reference/local-tips-and-tricks.md",key:"v-662a322c",path:"/v7.0/docs/reference/local-tips-and-tricks.html",headers:[{level:2,title:"Quickstart Management",slug:"quickstart-management"},{level:3,title:"General",slug:"general"},{level:3,title:"Multipass",slug:"multipass"},{level:3,title:"Entando in Kubernetes",slug:"entando-in-kubernetes"},{level:2,title:"Shared Servers",slug:"shared-servers"},{level:2,title:"Network Issues",slug:"network-issues"},{level:3,title:".nip.io isn't allowed",slug:"nip-io-isn-t-allowed"},{level:3,title:"The IP address changed after the initial install",slug:"the-ip-address-changed-after-the-initial-install"},{level:2,title:"Windows Development",slug:"windows-development"},{level:3,title:"Multipass loses control of VMs",slug:"multipass-loses-control-of-vms"},{level:3,title:"Hyper-V IP changes",slug:"hyper-v-ip-changes"},{level:3,title:"JHipster",slug:"jhipster"},{level:3,title:"Multipass with VirtualBox",slug:"multipass-with-virtualbox"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Development Tips and Tricks \n We've collected a list of tips and tricks to optimize your local quickstart or  Getting Started  development environment. We invite you to ask questions, collaborate with the community, and share your own favorite\npractices over on the  Entando forum . \n Quickstart Management \n Here are a few common questions about the quickstart environment. The quickstart environment uses Multipass to launch an Ubuntu VM, where K3s Kubernetes is then installed and from which Entando is deployed. \n General \n Q: How can I remove a quickstart environment? \n A:  If you want to completely remove the VM created by Multipass, you can use  multipass delete YOUR-VM-NAME  (where the default YOUR-VM-NAME for a quickstart is  entando ) and then  multipass purge  to recover the resources. If you just want to shutdown Entando but keep the VM, you can use  multipass shell YOUR-VM-NAME  to shell into the VM and then remove the namespace via  sudo kubectl delete namespace entando . \n Q: What if the installation fails due to timeout? \n A:  A Docker Hub policy limiting download bandwidth may cause the quickstart installation to fail with timeout errors. The workaround is a two step process: \n \n Delete the  entando  namespace \n \n ent k delete namespace entando\n \n \n Run the following \n \n ent quickstart \"entando\" \"quickstart\" --simple --debug=1 --yes --with-vm --release=v7.0.0\n \n The namespace will be recreated, preserving the images already pulled, so it's unlikely the installation time will exceed the timeout threshold again. \n Multipass \n Q: How can I shell into a Multipass VM? \n A:   multipass shell YOUR-VM-NAME . If you don't provide YOUR-VM-NAME, Multipass will use the default name  primary , and even launch it for you if it doesn't exist. \n Q: What do I need to do after restarting my laptop? \n A:  By default, Multipass is installed as a service and will restart automatically. If Multipass isn't running, you'll need to first initialize this service; then you can start your VM via  multipass start YOUR-VM-NAME . Kubernetes will launch automatically along with any installed pods, including Entando. It can take a few minutes for all of the pods to fully initialize, but you can use  sudo kubectl -n entando get pods --watch  to observe the progress. \n Q: How can I pause or idle my Entando instance? \n A:  You can pause with  multipass stop YOUR-VM-NAME , or idle with  multipass suspend YOUR-VM-NAME  to preserve the VM state. You can then use  multipass start YOUR-VM-NAME  to start the VM. \n Q: What else can Multipass do? \n A:  You can run  multipass help  or refer to the  Multipass docs  for more information on Multipass. \n Entando in Kubernetes \n Q: How can I install a new copy of Entando into an existing VM? \n A:  By default, the quickstart installation deploys Kubernetes resources into a dedicated namespace called  entando . If you want to remove all of the resources in  entando , you can simply delete the namespace with  sudo kubectl delete namespace entando . You can then re-create the namespace and re-install the resources. Alternatively, you can achieve this with  ent quickstart --vm-reuse=true , but you'll need to set other  ent quickstart  options, so check the  ent  help. \n Q: How can I shell into a running pod or view its logs? \n A:  You can use the standard Kubernetes commands, e.g.  sudo kubectl exec -it YOUR-POD-NAME -c YOUR-CONTAINER-NAME -- bash  or  sudo kubectl logs YOUR-POD-NAME YOUR-CONTAINER-NAME . \n Q: What do I do if Entando doesn't fully initialize? \n A:  The most common cause of this is a networking problem. See the  Network issues  section below for details. If all else fails, reach out to the Entando team on Slack or in the Forums. \n Shared Servers \n We recommend using Multipass to quickly spin up an Ubuntu VM to host a local Kubernetes cluster for test purposes. A local environment is often useful, but most teams utilize a shared Kubernetes cluster. This shared cluster is managed by an operations team, and installed either on-premise or with a cloud provider for full integration testing, CI/CD, DevOps, etc. \n Network Issues \n A local Entando 7 quickstart installation (e.g. what you get if you follow the  Getting Started  guide) may use a set of local domain names to enable access to Entando services. Your IP address will vary, but may look something like this: \n quickstart.192.168.99.1.nip.io\nYOUR-APP.192.168.99.1.nip.io\n \n The base domain configured via the ingressHostName (e.g. in your entandoapp.yaml) is based on the IP address that is created during the initial VM installation. This domain is used to generate ingress routes to map incoming URLs to individual services. In production environments, there's generally a dedicated network layer to manage IPs/routing (both on premise and in the cloud), but this is not readily available in most local setups. Below are a couple of common issues that can prevent Entando from initializing in a local environment: \n  .nip.io isn't allowed \n \n This could be due to firewall settings or corporate security policies. The simplest workaround is to manually edit your /etc/hosts file and map the domain to the IP of your local virtual machine. \n \n  192.168.99.1 quickstart.192.168.99.1.nip.io\n 192.168.99.1 YOUR-APP.192.168.99.1.nip.io\n \n \n If you add microservices to your installation, you may need to add additional mappings for the new ingresses. \n To update files on Windows, see the  Windows process  below. \n  The IP address changed after the initial install \n \n Restarting a Windows computer can cause this (see  Windows Hyper-V IP Changes  below), and the workaround noted in the  .nip.io isn't allowed  section above also applies (i.e. update your /etc/hosts file). Simply update the IP address in the first column to use the current IP of your virtual machine. \n Windows Development \n Multipass loses control of VMs \n Q: What do I do if Multipass cannot access my VMs? \n A:  The most common symptoms include an  IP=UNKNOWN  entry when issuing a  multipass list , and when attempts to stop or shell into the VM consistently fail. \n Internet Connection Sharing (ICS) is a Windows service that provides Internet connectivity to virtual machines, and its  hosts.ics  file can occasionally get corrupted. Restarting the host laptop or desktop should remedy this, but a quicker and simpler fix is to shutdown any VMs using the hypervisor (Hyper-V or VirtualBox), remove the  hosts.ics  file from  Windows/System32/drivers/etc  using elevated privileges, and then restart the VM(s). You can examine the  hosts.ics  file first to check if it is well-formed, with clean IP to VM-NAME mappings insteaad of spurious numbers or letters. \n Hyper-V IP changes \n Q: My Entando installation stops working when I restart Windows. How can I fix this? \n A:  The basic issue is that Windows Hyper-V makes it difficult to set a static IP for a VM (see this  forum post  for details). As discussed  above , Entando's ingress routes rely on a fixed IP address and will break if the IP address changes after initial installation. Here are a few options to solve this issue, short of modifying your router or network switch settings: \n Option 1: Single host routing \n The simplest way to deal with the peculiarities of Hyper-V IP assignment is to avoid it, instead using Windows-specific mshome.net addresses. This allows you to access a VM with an address like  YOUR-VM-NAME.mshome.net . If you set up your enviroment using the  Automatic Install  instructions, then the ent CLI will select the single host option and the address will be  entando.mshome.net . You can accomplish the same thing yourself using the  ent quickstart  script, but see  --help  for the current set of options. \n Option 2: Manually update your hosts file \n The next simplest option to re-enable external access to your cluster is to update your hosts file after each Windows restart. \n You need two pieces of information for this workaround, and you'll also need administrator access. \n \n Determine the original IP used for your VM. This is included in the  ENTANDO_DEFAULT_ROUTING_SUFFIX , or you can find it included in the ingress names. Run   kubectl -n entando get ingress  to see something like this: \n \n NAME                                     CLASS    HOSTS                                           \ndefault-sso-in-namespace-ingress         <none>   quickstart.192.168.235.100.nip.io  \nquickstart-ingress                       <none>   quickstart.192.168.235.100.nip.io  \n \n \n Determine the current IP using  hostname -I  in the VM, or by running  multipass list  from Windows: \n \n $ multipass list\nName                    State             IPv4             Image\nprimary                 Running           172.31.118.12   Ubuntu 18.04 LTS\n \n \n As a Windows administrator, edit your hosts file  (C:\\Windows\\System32\\drivers\\etc\\hosts)  to map any required URLs from the old IP to the new IP. This will bypass .nip.io lookups. \n \n 172.31.118.12 quickstart.192.168.235.100.nip.io\n172.31.118.12 YOUR-APP.192.168.235.100.nip.io\n \n \n You should now be able to access your Entando URLs via the new IP. If your Entando installation stalled during startup, it should continue initializing as soon as the external address is functional again. \n Option 3: Add a Windows route \n This option is initially a little more involved, but future repairs to your network settings can then be made very easily. You'll need to choose a static IP, configure a Windows route to map it to the Hyper-V interface, and claim the IP in the Ubuntu VM via a netplan entry. \n When implementing this option for the first time, all steps must be executed before installing Entando. Subsequent Windows restarts require steps #1 and #2, only. \n \n \n Determine an IP that is unused on your local network (e.g. via ping). The following steps assume that IP 192.168.99.1 is selected. \n \n \n Determine the interface address to Hyper-V (e.g. 32 below). Use cmd  route print  and find the Interface entry for Hyper-V: \n \n \n Interface List\n 32...00 15 5d 86 45 20 ......Hyper-V Virtual Ethernet Adapter\n \n \n Using elevated privileges, add a persistent route to map your IP to the Hyper-V interface: \n \n route -p add [YOUR-IP] mask 255.255.255.255 0.0.0.0 IF [HYPER-V-INTERFACE]\nroute -p add 192.168.99.1 mask 255.255.255.255 0.0.0.0 IF 32\n \n \n \n Verify the route was added via  route print 192.168.99.1 . This command is useful after restart to check if the route needs to be created again. \n \n \n Configure your VM to claim the same address. Shell into the VM using  winpty multipass shell YOUR-VM-NAME . \n \n \n Change to the root user to make the following steps simpler:  sudo -i \n \n \n Determine your network adapter name via  ip link , e.g. eth0. It's often second in the list after the loopback adapter. \n \n \n ubuntu@primary:~$  ip   link \n 1 : lo:  < LOOPBACK,UP,LOWER_UP >  mtu  65536  qdisc noqueue state UNKNOWN mode DEFAULT group default qlen  1000 \n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n 2 : eth0:  < BROADCAST,MULTICAST,UP,LOWER_UP >  mtu  1500  qdisc mq state UP mode DEFAULT group default qlen  1000 \n    link/ether 00:15:5d:00:1a:0c brd ff:ff:ff:ff:ff:ff\n \n \n \n Navigate to your netplan directory:  cd /etc/netplan \n \n \n Create a netplan entry starting with 0 (so it's indexed and loaded first):  vi 0-entando.yaml \n \n \n network : \n   version :   2 \n   renderer :  networkd\n   ethernets : \n     YOUR-NETWORK-ADAPTER : \n       dhcp4 :  no\n       addresses :  \n         -  YOUR - IP/24\n \n Example: \n network : \n   version :   2 \n   renderer :  networkd\n   ethernets : \n     eth0 : \n       dhcp4 :  no\n       addresses :  \n         -  192.168.99.1/24\n \n \n \n Apply the changes with  netplan apply \n \n \n From the VM, verify connectivity via  ping 192.168.99.1 . You should receive a response and not a timeout. \n \n \n (Optional) Run a Python server to verify you can access the VM from the host at  http://192.168.99.1:8000.  It may take a minute or so before the server is ready. \n \n \n python3 -m http.server 8000\n \n \n You should now be able to install Entando using the static IP. If your Entando installation stalled during startup, and was previously configured with a static IP, it should continue initializing as soon as the external address is functional again. \n Option 4: Reinstall Entando \n We're including this option because it works and requires no additional configuration. If you work with Entando regularly, we recommend developing in a centralized and shared Kubernetes instance rather than running a full stack locally. If you require a local cluster, we recommend using option 1 or 2. \n JHipster \n Q: How can I run JHipster on Windows? \n A:  JHipster requires a TTY interface for its menus to function correctly. Here are a few options to satisfy that requirement on Windows: \n \n Run  jhipster  under cmd or Powershell \n Using Git Bash, run  winpty jhipster.cmd \n Use Ubuntu bash via WSL (1 or 2), or within the Multipass VM \n Multipass with VirtualBox \n Q: How do I run Multipass with VirtualBox? \n A:  Multipass supports the use of VirtualBox on Windows as an alternative to Hyper-V. Refer to the Multipass documentation for VirtualBox configuration instructions. \n For Entando to work correctly with VirtualBox, you will need to add a port forwarding rule to access Entando from your host system. \n \n Create your VM within Multipass \n Go to the Oracle VM VirtualBox Manager to edit the  Network  settings for the VM \n Go to the  Advanced  options and click  Port Forwarding Rules \n Add a new rule\n \n Name : your choice \n Protocol : TCP \n Host IP : leave this blank \n Host Port : 80 \n Guest IP : leave this blank \n Guest Port : 80 \n Click OK \n \n \n Any requests to port 80 on your localhost should be forwarded to the VM. \n Use the IP of your host to configure the  ENTANDO_DEFAULT_ROUTING_SUFFIX  in your YAML file, e.g.  192.168.64.25.nip.io . You must use the host ID and not the non-routable address identified from within the guest VM, e.g. 10.0.2.15. \n \n"},{title:"Entando 7.0 Release Notes",frontmatter:{},regularPath:"/v7.0/docs/releases/",relativePath:"v7.0/docs/releases/README.md",key:"v-cac5d3b6",path:"/v7.0/docs/releases/",headers:[{level:2,title:"General",slug:"general"},{level:2,title:"Supported Kubernetes Versions",slug:"supported-kubernetes-versions"},{level:2,title:"Security Updates",slug:"security-updates"},{level:2,title:"New Features and Major Fixes",slug:"new-features-and-major-fixes"},{level:3,title:"Entando Hub",slug:"entando-hub"},{level:3,title:"Application Engine",slug:"application-engine"},{level:3,title:"App Builder",slug:"app-builder"},{level:3,title:"Entando Component Generator (ECG)",slug:"entando-component-generator-ecg"},{level:3,title:"Entando Component Repository (ECR)",slug:"entando-component-repository-ecr"},{level:3,title:"ent (entando-cli)",slug:"ent-entando-cli"},{level:3,title:"Identity Provider (IdP)",slug:"identity-provider-idp"},{level:3,title:"Infrastructure",slug:"infrastructure"},{level:3,title:"Entando Bundler",slug:"entando-bundler"},{level:3,title:"EOL Kubernetes Versions",slug:"eol-kubernetes-versions"},{level:2,title:"Breaking Changes",slug:"breaking-changes"},{level:2,title:"Known Issues",slug:"known-issues"},{level:3,title:"Apple M1",slug:"apple-m1"},{level:3,title:"ECR",slug:"ecr"},{level:2,title:"Upgrades",slug:"upgrades"},{level:2,title:"Previous Releases",slug:"previous-releases"}],lastUpdated:"4/20/2022, 2:18:04 PM",lastUpdatedTimestamp:1650478684e3,content:' Entando 7.0 Release Notes \n General \n Entando version 7.0 is a major release. It includes significant changes to the K8s infrastructure provisioning mechanism that provide better security, improved reliability, a simplified deployment process and an extensibility mechanism based on the new capabilities workflow. Entando 7 also introduces the  Entando Hub , an updated compatibility matrix (e.g. Keycloak 15, PostgreSQL 14), development stack upgrades (e.g. JHipster 7.2) and several consolidation changes. \n Supported Kubernetes Versions \n \n Kubernetes (1.19-1.21) \n Red Hat Openshift 4.x (K8s 1.20-1.21) \n Rancher k3s (K8s 1.19-1.21) \n Security Updates \n \n \n Fixed a missing escape in the CMS that could have led to XSS. \n \n \n The visibility of bundle microservices has been restricted; bundle microservices can now only view their own Secrets. \n \n \n Changed the vulnerable dependencies found in several modules to non-vulnerable versions: Commons IO, Velocity, Spring, Guava, Hibernate, Struts 2, TagLib, Tika, Apache CXF, Jackson, Netty. \n \n Related list of CVEs: CVE-2021-22696, CVE-2021-27807, CVE-2021-27906, CVE-2021-28657, CVE-2017-6888, CVE-2021-20291, CVE-2020-17530, CVE-2020-10693, CVE-2015-5211, CVE-2020-25649, CVE-2018-1000873. \n \n \n \n Addressed vulnerabilities: CVE-2021-44228, CVE-2022-21724, CVE-2021-22569, CVE-2022-23437, CVE-2022-23596, CVE-2021-25738, CWE-20, CWE-400, CWE-451, CVE-2022-21363. \n \n \n Updated the ECG to address vulnerable dependencies. One exception is Swagger UI, which is activated only in development mode and not recommended for production use. \n \n \n Most of the existing ECG (Blueprint) vulnerabilities have been fixed; regardless, the user is strongly advised to rerun vulnerability scans every time a new bundle is generated. The remaining vulnerabilities will be fixed in the next minor version of Entando; these are not exploitable in production and only exposed during the internal development process. In particular, they concern: \n \n The dev webserver, used when developing the app \n The Jest test files, used when running tests with Jest \n General webpack configuration \n Dev utilities, used in the dev environment \n The PostCSS utility, used to import the CSS when building the final artifact \n New Features and Major Fixes \n Entando Hub \n The  Entando Hub  is a new  Entando Component Repository  feature that allows different EntandoApps to share bundles. The  Entando App Builder  now allows curators to  browse, deploy, install and upgrade bundles from one or more Entando Hub instances . \n Application Engine \n \n Entando has implemented the SQL versioning tool Liquibase to track, manage and deploy updates to databases. Refer to  Liquibase Migration  to learn how the App Engine automates database schema management and modifications. \n The latest MySql 8.x and PostgreSQL 14 versions are now supported. \n Oracle 18c as an external DBMS is now supported. \n Infinispan is now used only for EAP session sharing. \n Object cache  has been implemented in Redis. \n Logging infrastructure has been moved to Logback. \n The performance of CMS Content APIs has been optimized \n App Builder \n \n Added dash (-) support for fragment code validation. \n Improved UI performance affected by instances containing significant content and assets. \n Implemented performance improvements in page management. \n Resolved several extended bugs hindering performance and user experience. \n Reduced the size of the application state and started phasing out obsolete technologies. \n Entando Component Generator (ECG) \n \n The ECG has been upgraded to use JHipster 7.2. \n The ECG now allows the use of a BOM curated by Entando. This BOM contains more recent dependencies than standard for a specific version of JHipster. \n Removed the .map files generated from Blueprint-generated code. \n Implemented bug fixes and improved error handling. \n Switched to bundle plugin descriptor version 4. Support has been added for environment variables and the default ingressPath no longer includes the image version. \n Entando Component Repository (ECR) \n \n Added support for bundle upgrade, downgrade and update. \n Implemented bundle improvements; in particular, bundle plugin security and reliability via name signing. \n It is now possible to specify standard and secret  environment variables  for a bundle plugin (microservice). \n Basic support now provided for  bundle plugin configuration profiles . \n Better support now provided for bundles and bundle plugins with very long names. \n ENTANDO_PLUGIN_NAME has been renamed to ENTANDO_RESOURCE_NAME. \n Implemented better management of certain error conditions during installation and updates. \n Introduced system-level bundles, which allow the installation of global static resources. \n The ECR client now explicitly marks bundles that are installed with an amended installation plan and allows the plan to be recalled. \n Added support for Oracle 18c. \n Fixed a bug that caused the ECR to indefinitely stay in busy-state due to particular failure conditions. \n Fixed a bug that (under certain conditions) prevented the bundle plugin pod from properly restarting when scaled down, then back up again. \n The ECR now correctly deletes the plugin pod when the bundle is uninstalled; the deployment and volumes are retained. \n The EntandoPlugin controller will rollback in the event of a timeout. A failing pod triggers the deployment to scale to 0 and error logging. \n ent (entando-cli) \n \n Reworked the  ent diag  command to also export CRs, ingresses, deployments, "previous" pod logs, namespace events, etc. \n ent is now able to sync the kubectl version of the current profile with the server version via  ent auto-align-kubectl . \n Added the helper  be-log  to  ent prj  to fetch logs from bundle plugins. \n In order to run node-based Entando tools, ent now installs and uses a private copy of node at user-level. \n A jq internal dependency is now installed at user-level, privately to ENT. \n Added the command  ent pkg  to manage packages installed at user-level, with initial support for jq and K9s. \n Added the helpers  get-bundle-id  and  get-plugin-id  to  ent ecr  and  ent prj  to determine the plugin and bundle names of custom resources. \n Added the helper  gen-secret  to  ent ecr  and  ent prj  to generate Secrets for the plugins. \n Added the subcommands  ent ecr cr  and  ent ecr deploy . \n ent now installs the entando-releases dependencies at release level, allowing multiple profiles to share them. \n Fixed a bug that caused ent to git-ignore the "bundle" subdirs in the MFE branches. \n ent prj pbs-init  now accepts SSH/HTTPS URLs. \n ent check-env  now considers Docker and Java mandatory dependencies (still skippable with "--lenient"). \n The default K3s version used by the ent quickstart has been updated to v1.21. \n Identity Provider (IdP) \n \n Keycloak integration has been updated to version 15.\n \n Note: Older versions of some OAuth libraries (e.g. spring-boot-starter-oauth2-client, oauth-oidc-sdk) which worked with Keycloak 11 may need to be updated. \n Infrastructure \n \n Implemented a massive rework of the internal dependency management system with respect to the concept of ProvidedCapability. \n Added support for OpenShift 4.8 and Kubernetes 1.21. \n Added ComponentManager and Keycloak hardening. \n Tuned Entando Platform timeouts and memory limits. \n Moved from a HELM-based deployment process to a pure CustomResource-based deployment and installation process. \n Installation parameters used by the operator have all been moved to the entando-operator-config ConfigMap. \n Implemented better support for cloud DBMS. \n Updated libraries (Jetty, Keycloak, Spring) and the entire compatibility matrix. \n Dropped support for suffix-mode installation. Only single-hostname is supported now. \n Dropped support for cluster-level operator installation. \n Removed EntandoClusterInfrastructure and EntandoCompositeApp CR. \n k8s-service is now part of the base Entando infrastructure and therefore installed alongside the operator. \n ComponentManager now communicates with k8s-service using service-to-service authentication, and strictly within the cluster network. \n Entando Operator deployment is now simply called entando-operator. \n k8s-service deployment dropped the application qualifier and is now simply called entando-k8s-service. \n Fixed an intermittent issue with the operator that prevented installing new bundles until the operator was restarted. \n Updated all the Entando base images for reliability and security. \n Replaced the CentOS images with Rocky images and rebased the derived images. \n Updated the auto provisioned PostgreSQL image to version 14. \n MySQL and PostgreSQL are now served by customized and updated entando-mysql and entando-postgres images. \n Entando Bundler \n \n It’s now possible to extract protected assets. \n Fixed several bugs in the extraction of pages and widgets. \n Added support for categories. \n Error handling has been improved. \n It\'s now possible to generate system-level bundles (see  ECR ). \n Extract/download have been optimized to only touch the relevant resources. \n Libraries have been updated for reliability and security. \n EOL Kubernetes Versions \n \n Dropped official support for OpenShift 3.11 \n Breaking Changes \n \n The internal PostgreSQL version has been updated to version 14. The default version for a plugin database relying on auto provisioning is also now PostgreSQL 14. \n Known Issues \n Apple M1 \n \n Entando does not currently support ARM64 architecture; it cannot be installed on newer Macs built with the Apple M1 processor. \n ECR \n \n See the  Upgrade Steps  below to upgrade a 6.3.2 ECR to 7.0. As of Entando 7.0, Liquibase support is now in place to enable automatic database upgrades. \n Upgrades \n \n \n SQL scripts to upgrade Entando 6.3.x databases to version 7.0 have been provided for all supported vendors (MySQL, PostgreSQL, Oracle). Upgrade scripts are available at the following locations: \n \n entando-de-app: https://github.com/entando/entando-de-app/tree/develop/upgrade/6.3.2-to-7.0.0 \n component-manager: https://github.com/entando-k8s/entando-component-manager/tree/develop/upgrade/6.3.2-to-7.0.0 \n \n \n \n Entando 7.0 custom resource definitions are backwards compatible with version 6.3.2, allowing an Entando 7.0 application to live in the same cluster as an Entando 6.3.2 application. \n Previous Releases \n Refer to the  Versions  list in the left navigation menu to access documentation and release notes for previous versions of Entando. \n'},{title:"Content Creation",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/compose/content-tutorial.html",relativePath:"v7.0/tutorials/compose/content-tutorial.md",key:"v-407b1dc0",path:"/v7.0/tutorials/compose/content-tutorial.html",headers:[{level:2,title:"Create Content",slug:"create-content"},{level:2,title:"Save and Approve Content",slug:"save-and-approve-content"},{level:2,title:"Find Content",slug:"find-content"},{level:2,title:"Content Actions",slug:"content-actions"},{level:2,title:"Publish, Unpublish, or Delete Content",slug:"publish-unpublish-or-delete-content"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Content Creation \n This tutorial describes how to create, edit and publish content in an application with the Entando Web Content Management System from within the  App Builder . \n Create Content \n \n \n Log into your App Builder. \n \n \n From the left sidebar, go to  Content  →  Management . All existing\ncontent is displayed in a table. \n \n \n \n \n \n To create new  Content , click the  Add  button on the right side of page. Select the  Type  desired from the drop-down list. New types can be added to the list in the  Content Type  section.\n \n \n \n You are asked to provide the following information. \n \n \n Info \n \n \n Content Type : This is predefined. \n \n \n Description : Enter the name or description. This field is required. \n \n \n \n \n Groups \n \n \n Owner Group : Choose an available user group to manage the content from the drop-down list. Click the  +  symbol to select. This field is required and can be amended in the App Builder's  User  section under  Groups . \n \n \n View Only Groups : Add groups to provide viewing access to content. \n \n \n \n \n Categories : Click  +  under  Join  to include the  Content  in the appropriate category for searching and sorting.  This field is not mandatory. \n \n \n Content Attributes : Enter the required  Date  and  Title  fields under the  Attributes  section. You can enter the remaining optional fields as needed. \n \n \n Content Info - History : This displays the iterations for the saved item. You can view the details or revert to a previous version. \n Save and Approve Content \n \n For new or edited content, determine which  Status  it belongs to: \n \n \n \n Draft : The  Content  is in the development stage and not ready for approval or publication. The  Save  or  Save and Continue  buttons establish  Draft  status for the content. \n \n \n Ready : The  Content  is ready for review, but has not been approved or published.  Items with this status can be saved and approved later or published immediately. \n \n \n \n Saving options: \n \n \n \n Save : The content is saved in a  Draft  version. \n \n \n Save and Continue : The content is saved in a  Draft  version and the editable form is displayed. \n \n \n Save and Approve : The content is saved, approved, and ready for use in an application. \n Find Content \n Using the  Advanced Filters  feature, you can search for Content by name, type, category, group, or status.\n \n In the resulting table, content is listed with these parameters:  Name ,  Author \n Code ,  Created by ,  Last Edited ,  Type ,  Status ,  Visibility ,  Group ,  Creation  Date,  Last Modified , and executable  Actions . Any field can be deleted from view by unchecking them in the  Additions to the Table of Results  drop-down menu. \n Content Actions \n For all items in the  Content  table, the  Actions  drop-down menu provides these executable options: \n \n \n Copy/Paste : Replicate the content \n \n \n Draft Version : Edit the unpublished draft version \n \n \n Published Version : Edit or revert to a previous published version of the content \n \n \n Edit : Update the data fields in the Content definition \n Publish, Unpublish, or Delete Content \n To  Publish ,  Unpublish , or  Delete  content, use the buttons above the table for checked items. This takes you to a confirmation page where a summary displays the usage of the item in your application. \n \n"},{title:"Content Templates",frontmatter:{},regularPath:"/v7.0/tutorials/compose/content-templates-tutorial.html",relativePath:"v7.0/tutorials/compose/content-templates-tutorial.md",key:"v-26c50960",path:"/v7.0/tutorials/compose/content-templates-tutorial.html",headers:[{level:2,title:"Create a Content Template",slug:"create-a-content-template"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Content Templates \n Content Templates define how information is displayed when a Content is published. They provide the styling and layout for Content Types and offer different representations of the same content. \n Create a Content Template \n Content Templates are managed via the Web CMS, through a user interface provided by the  Entando App Builder . Follow the steps below to create and configure a Content Template. \n 1. From the left menu of the App Builder, go to  Content  →  Templates . \n 2. Click the  Add  button in the upper right corner. \n \n 3. Define the characteristics of the Content Template: \n \n \n \n Type : Choose a Content Type from the drop-down list. Click the  Set  button to input your selection and enable Attribute suggestions in subsequent fields. \n \n \n Code : Enter a sequence of up to 10 numbers to uniquely identify the Content Template. This field is mandatory. \n \n \n Name : Enter a name or description for the Content Template. This field supports a string value of 50 characters or less and should consist of one or more of the following: uppercase letters, lowercase letters, numbers and/or special characters. \n \n \n Model : Enter HTML to model the Content Template based on Velocity language. \n \n \n Style Sheet : (Optional) Enter the CSS to be applied to the HTML  Model . \n \n \n 4. Click the  Save  button. \n This adds the Content Template to the Content Type. \n"},{title:"Content Attributes",frontmatter:{},regularPath:"/v7.0/tutorials/compose/content-attributes.html",relativePath:"v7.0/tutorials/compose/content-attributes.md",key:"v-1aac2a40",path:"/v7.0/tutorials/compose/content-attributes.html",headers:[{level:2,title:"Simple Attribute Types",slug:"simple-attribute-types"},{level:2,title:"Composed Attribute Types",slug:"composed-attribute-types"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Content Attributes \n Attributes can be seen as the smallest elements that compose a Content\nType. In other words, a Content Type is just a collection of different\nattributes. Attributes are responsible for carrying the actual\ninformation inside a Content in Entando and could be of different types.\nIn this chapter, we will review and describe the different attribute\ntypes. \n Firstly, we can distinguish simple attribute types from composite\nattribute types. In the first case, the attribute type carries a single\npiece of information (for example, an image), while the latter is an\naggregation of simple attribute types (for example, a set of images). \n Simple Attribute Types \n Attach \n This represents the information carried by a file, which is attached to\nthe content. \n It consists of an URL corresponding to the desired file present in the\nsystem’s resources, and a text which can either indicate the description\nor the name of the file. \n This attribute type is rendered as a button named “Add”. By pushing that\nbutton, the user is prompted to select a desired file present in the\nsystem’s Digital Assets Attachments list. \n Boolean \n This attribute type represents a boolean value which can either be true\nor false. This attribute type is rendered as two radio buttons labeled\n“Yes” and “No”. \n Checkbox \n This attribute type behaves in the same way as a Boolean does – it is\nactually an alternative to the Boolean attribute type - but it is\nrendered with a checkbox labeled “Yes” or “No”. \n Date \n This attribute type represents a date, tracking time within a content;\nit is often used to filter contents appearing in lists by publication\ndate, etc. \n It is rendered as a datepicker. \n Timestamp \n This attribute type is specialized for the Date attribute, allowing you\nto also specify the hour, minute and second. \n It is rendered as a datepicker for the date, and a select for hours,\nminutes and seconds. \n Enumerator \n The enumerator attribute type represents textual information with a\npredefined set of choices; it is defined by: \n \n \n Elements which are mandatory and declares the set of available\nchoices; \n \n \n Separator, which is optional and declares the character to use to\nseparate the arguments of the enumerator. By default the comma “,”\nis used. \n \n \n ExtractorBean: this parameter represents the name of the Spring bean\nto use to process the values of the enumerator. The name must\nexactly match the id of the bean as defined in the Spring\nconfiguration file. \n \n \n It is rendered as a select list. \n Enumerator Map \n The enumerator map attribute type represent textual information with a\npredefined set of choices; it is defined by: \n \n \n Elements in the form of a separated list of key=value pairs, (i.e.\nkey1=value1,key2=value2) \n \n \n Separator, which is optional and declares the character to use to\nseparate the key, values pairs. By default the comma is used. \n \n \n It is rendered as a select list which shows the available values. \n Hypertext \n This attribute type holds HTML tagged text; it retains a single value\nfor all languages. \n Even if this attribute type could support all HTML tags, we strongly\nrecommend using only tags which provide meaning and avoid those which\ndecorate or add graphics. \n Hypertext attributes are rendered as a text area in the content edit\npage; if the CKEditor is active, the user has access to a set of\nadditional functionalities from a dedicated editor’s toolbar. Such as\ntable insertion and table manipulation, special characters insertion,\nstring formatting, links creation. \n Image \n This attribute type binds an image resource to the content. \n The image is always taken from the Digital Assets images list. The user\nwill need to specify the description accompanying the image. \n Usually attributes of type Image are not indexed and are not used to\nfilter contents. \n It is rendered as a button named “Add” that, when pushed, allows the\nuser to select an image from the Digital Assets images list. Once\nselected the user is presented with a preview, as a thumbnail, of the\nimage and has the possibility to define some parameters: \n \n \n Text which is mandatory and by default takes the name of the\nselected image \n \n \n legend (optional) \n \n \n alt (optional) \n \n \n description (optional) \n \n \n title (optional) \n \n \n Link \n This attribute type represents an hypertext link; it is normally used to\ninclude a link in your content: it is possible to define up to three\ndifferent types of links: \n \n \n external links: a link pointing to a location external to the Entando\nportal \n \n \n link to page: a link which points to a page of the portal \n \n \n link to a content: a link to another content \n \n \n It is rendered as a button named “Add” that when pushed opens up a modal\nwindow from which the user can select the link type. \n Longtext \n This attribute type represents a simple unformatted text; it supports\nseveral languages and is normally used for small descriptions, when a\nshort string won’t suffice. \n It supports minimum length , maximal length and regular expressions as\noptional parameters. \n It is rendered as a textarea. \n Monotext \n Monotext represents the information in textual form, but supports only a\nlanguage; it is used for all \n those fields which do not require localization. \n It supports minimum length, maximal length, and regular expressions as\noptional parameters. \n It is rendered as a textfield. \n Number \n This attribute type holds an integer number; it retains a single value\nfor all languages. \n Supports the optional parameters: From, To, and Equal to. \n It is rendered as a textfield. \n Text \n This attribute type holds a string; it retains a single value for all\nlanguages. \n It supports minimum length, maximal length, and regular expressions as\noptional parameters. \n It is rendered as a textfield. \n ThreeState \n Conceptually similar to the Boolean attribute, this attribute type\nallows a third status “Both” to be present. \n It is rendered as a radio button with “Yes”, “No”, “Both” options. \n Composed Attribute Types \n All the attributes types of the previous chapter can only retain a\nsingle type of information, but sometimes it is desirable to aggregate\ndifferent types of attributes into one attribute: this is where composed\nattributes are used. \n From a functional point of view, it would be perfectly legal to build a\ncontent type specifying all the attributes back to back: the content\nwould be formally complete, but from a logical point of view the\nattributes would appear mutually unrelated and, worse, the relationship\nbetween them would not be explicit. \n Entando offers three types of composed attributes: List, Monolist,\nComposite. \n List \n This Attribute Type represents a set of independent and homogeneous\nelementary Attribute types, each associated with one of the languages\ndefined in the system. \n An immediate consequence is that this kind of list can handle only\nmono-language basic attributes. \n It is rendered with a button named “Add” that if pushed presents the\nuser a prompt to select or define the single elements which compose the\nlist. \n Monolist \n This attribute type is a list that is common to all the system\nlanguages; this kind of list handles multi-language and mono-language\nattributes. \n It is rendered with a button named “Add” that, if pushed, presents the\nuser with a prompt to select or define the single elements that compose\nthe monolist. \n Composite \n This attribute type is an aggregate of different, non-homogeneous,\nsimple attributes types. The aggregation of different types is treated\nas a single unit. \n It is rendered as a combination of the elementary attribute types, where\neach attribute type presents the proper rendering. \n"},{title:"Content Types",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/compose/content-types-tutorial.html",relativePath:"v7.0/tutorials/compose/content-types-tutorial.md",key:"v-7d1effe0",path:"/v7.0/tutorials/compose/content-types-tutorial.html",headers:[{level:2,title:"Create a Content Type",slug:"create-a-content-type"},{level:2,title:"Attribute Configuration",slug:"attribute-configuration"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Content Types \n A Content Type represents or models a Content. Alternatively, a Content is an instance or specialization of a Content Type. \n Content Types are characterized by  Attribute Types . Each Attribute Type consists of one or more properties, known as Attributes, which are defined by their Attribute Type. \n Create a Content Type \n Content Types are managed via the Web CMS, through a user interface provided by the  Entando App Builder . Follow the steps below to create and configure a Content Type. \n 1. From the left menu of the App Builder, go to  Content  →  Types . \n 2. Click the  Add  button in the upper right corner. \n \n 3. Configure the Content Type. \n When adding a Content Type it is mandatory to enter  Code  and  Name  values consistent with the following: \n \n \n Code : A unique identifier of the Content Type that must be 3 uppercase letters. \n \n \n Name : A string value of 50 characters or less consisting of one or more of the following: uppercase letters, lowercase letters, numbers and/or special characters. \n \n \n Other field entries are not mandatory, but to specify a meaningful Content Type you must choose the appropriate  Type  from the drop-down in the Attributes section. The available options define Attributes to characterize the Content. \n \n 4. Click the  Add  button. \n This launches the configuration of the selected Attribute Type. Each Attribute Type requires its own configuration. \n Attribute Configuration \n Clicking  Add  loads a form to configure the Attribute. The  Type  field is pre-filled with your Attribute Type selection. \n 1. Define the characteristics of the Attribute: \n \n \n \n Code : It is mandatory to enter a unique name for the Attribute key of an Attribute Type. This field supports a string value of 10 characters or less and should consist of one or more of the following: uppercase letters, lowercase letters, numbers and/or special characters. \n \n \n Name : Enter a description of the Attribute. This field supports a string value of 50 characters or less and should consist of one or more of the following: uppercase letters, lowercase letters, numbers and/or special characters. \n \n \n Certain Attribute Types support the option to declare that the Attribute is  Mandatory ,  Searchable  and/or  Can be used as a filter in lists  via toggle buttons. \n \n \n Certain Attribute Types support the option to choose an Attribute  Role . Be sure to click the  Add  button after making your selection. \n \n \n The remaining fields are not mandatory and may be left empty. \n \n \n TIP \n Certain Attribute Types allow you to assign the  Role  of  jacms:title - The main title of a Content . This informs plugins or services that the Attribute is a title, regardless of its key, or  Code . Entering "title" for the  Code  avoids confusion when this  Role  is selected. \n \n 2. Click the  Continue  button. \n This adds the configured Attribute to the Attribute Type. \n \n \n \n Complete the additional configuration steps required by your Attribute Type, if applicable. \n \n \n (Optional) Add other Attribute Types to your Content Type, subject to the configuration process above. \n \n \n 3. Click the  Save  button. \n The Content Type you created is now displayed in the table. \n \n'},{title:"Page and Content Protection",frontmatter:{},regularPath:"/v7.0/tutorials/compose/creating-protected-resources.html",relativePath:"v7.0/tutorials/compose/creating-protected-resources.md",key:"v-5875d3a0",path:"/v7.0/tutorials/compose/creating-protected-resources.html",headers:[{level:2,title:"Create a Group",slug:"create-a-group"},{level:2,title:"Protect a Page",slug:"protect-a-page"},{level:2,title:"Protect Content",slug:"protect-content"},{level:2,title:"Protect Images and Attachments",slug:"protect-images-and-attachments"},{level:2,title:"Freemarker Tags and Consuming Protected Resources",slug:"freemarker-tags-and-consuming-protected-resources"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Page and Content Protection \n In the Entando Web Content Management System (WCMS) you have the ability to protect pages, content, and digital assets (images and files) by assigning groups that have the authorization to view those assets. If users without the correct authorization attempt to view those assets the platform will return an error. You can handle those errors as required for your application with dedicated error pages or by adding logic to your widgets or freemarker templates. \n Create a Group \n Protected pages, content, and digital assets in the WCMS are protected by assigning groups to the resource that is being created. You can add new groups in the Entando App Builder as follows: \n \n Go to  Users → Groups  from the left navigation \n Select  Add \n Enter a  Name  and a  Code  for your group` \n \n The groups you create here can be utilized to protect pages, content, images, and attachments in the CMS. Groups can be assigned to individual users in the  Users  section of the app builder or as part of a customization of your entando-core-app using APIs or custom code. \n Pages and Content have settings for an  Owner Group  as well as a set of optional  Join Groups . The  Owner Group  indicates the team within the  App Builder  who owns and can modify the page. Additional groups can be given access to the item via the  Join Group  setting. Note: the default App Builder configuration prevents the  Owner Group  from being changed after the item is created. \n Protect a Page \n \n Select  Pages → Management  from the left navigation \n Create a new page. Assign values as you see fit \n To protect a page, assign the  Owner Group  to any group other than  Free Access \n (Optional) Add groups via  Join Group \n Finish configuring the page and select  Save \n \n At this point only users assigned to either the  Owner Group  or  Join Group  will have the ability to view that page. They can also manage the Page if they have the appropriate App Builder role. \n If you would like to test this, navigate to the page URL in a private or incognito browser window and you will be redirected to the  Sign in to Proceed Further  page of your application.\nThe  Sign in to Proceed Further  page can be changed by going to  Pages → Settings  and picking the page you would like to render to users who need to sign in. \n Protect Content \n \n Select  Content → Management  from the left navigation \n Select the  Add Content  button and pick the content type to be created \n To protect a content item, assign the  Owner Group  to any group other than  Free Access \n (Optional) Add groups via  Join Group \n Finish configuring the page and select  Save \n \n The content you are creating will only be available to users assigned to the  Owner Group  of  Join Group . The default WCMS widgets will only return content authorized for a given user. See the  freemarker tags  section below for information on creating custom widgets that utilize protected content. \n Images and Attachments and Groups \n When creating content the  Owner Group  of the content and the  Group  assigned to the digital asset must match. For example, when creating content with an  Owner Group  of  Administrators  the content creator will be unable to select images and attachments that are assigned a different group. The exception to this is assets with a group of  Free Access . Assets with  Free Access  can be added to protected content. \n Protect Images and Attachments \n Images and attachments uploaded to the CMS can be protected by assigning groups. \n \n Select  Content → Assets  from the left navigation \n Upload your file(s) \n In the provided modal window select the  Group  that you would like to own the asset \n Only users with the assigned  Group  will have the ability to view the asset you've created\n \n The asset will only be available to content with the same  Group  unless the attachment or image has been given a group of  Free Access \n Freemarker Tags and Consuming Protected Resources \n The WCMS provides a set of freemarker tags to assist in consuming protected assets in widgets and pages. The  if-authorized  and  tag-nav  tags can help in rendering page lists and fetching assets. \n The  content  and  content-list  tags also provide the ability to fetch and render protected content and protected lists of content. \n Additionally, the   REST APIs  allow clients to fetch protected pages and assets by group via query parameters. The content REST APIs also include the ability to filter by group and access level. \n"},{title:"Widgets and Fragments",frontmatter:{},regularPath:"/v7.0/tutorials/compose/widgets-fragments.html",relativePath:"v7.0/tutorials/compose/widgets-fragments.md",key:"v-575b6d30",path:"/v7.0/tutorials/compose/widgets-fragments.html",headers:[{level:2,title:"Create a Widget",slug:"create-a-widget"},{level:2,title:"Create a UX Fragment",slug:"create-a-ux-fragment"},{level:2,title:"FreeMarker Basics in Entando",slug:"freemarker-basics-in-entando"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Widgets and Fragments \n This tutorial will take you through the basics of creating an Entando\nwidget and placing it on a page. This document will also review the\nbasics of fragments which are re-usable pieces of a user interface. \n Create a Widget \n For this example you will use the Entando App Builder to build and\ndisplay a simple widget on a page. In a production system or a larger\ndevelopment environment you would build and deploy widgets differently,\nhowever this example provides a quick idea of the building blocks. For a more advanced example you can try  this tutorial  which includes building and deploying a micro frontend as a widget in Entando. \n \n \n In the App Builder menu, go to:  Components → Micro frontends & Widgets \n \n At bottom of the page, select ADD \n \n \n \n Now create a widget with the sample HTML code.  Enter into the following fields: \n \n Code:  MyHelloWorld \n en Title:  Hello World \n it Title:  Ciao Mondo \n Custom UI field:  <h2>Hello World</h2> \n Select SAVE \n Note: the Custom UI Field is a freemarker template where you can put raw html and include freemarker logic. This allows you to import javascript, css, or any normal HTML. \n \n \n \n Select a new Home Page \n \n Go To:  Pages → Settings \n From the “Home Page” dropdown menu, select “Home / Service” and select SAVE \n \n \n \n Place the widget on the page \n \n Go To:  Pages → Management \n On the row that says "Service", on the far right side, select the Kebab button and select DESIGN \n From the right hand column, drag and drop the new widget into an open frame in the page \n From the top of the page, select PREVIEW \n You should see "Hello World" on the page \n \n \n \n Publish the updated page \n \n Go To:  Pages → Management \n Note for the row showing the Services page, the Status is now yellow \n Select the Kebab button and select PUBLISH \n Create a UX Fragment \n A UX Fragment is a way to take a common piece of front end code and reuse\nit across multiple pages or widgets. Common elements such as basic HTML,\njavascript, or freemarker logic can be stored as fragments and\nreferenced via the  <@wp.fragment …  tag. \n Starting from the simple widget tutorial above: \n \n \n Create a new fragment: \n \n In the App Builder Go To:  Components → UX Fragments \n At bottom of page, select ADD, and enter the following fields \n Code:  test \n Gui Code:  <h2>Hello World</h2> \n Select SAVE \n \n \n \n Place the fragment in a template: \n \n Go To:  Pages → Page Templates \n On the row for service, select EDIT \n In the  Template  text box, add   <@wp.fragment code="test"/>  on a new line between the  <body>  and   </body>  tags \n SAVE the page template \n \n \n \n View the page with the new fragment: \n \n Go To:  Pages → Management \n On the row that says "Service", on the far right side, select the Kebab button and select CONFIGURE \n From the top of the page, select PREVIEW \n Note: You will see the fragment  <h2> This is a fragment. </h2>  which includes the HTML tags. By default html embedded via a fragment tag is escaped so you get it rendered exactly as you enter it. You’ll need to un-escape it to get it to render correctly. \n \n \n \n Update the Fragment: \n \n Go To:  Pages → Page Templates \n On the row for service, select EDIT \n Change the tag to:  <@wp.fragment code="test" escapeXml=false/> \n \n \n \n View the page with the updated fragment: \n \n Go To:  Pages → Management \n On the row that says "Service", on the far right side, select the Kebab button and select CONFIGURE \n From the top of the page, select PREVIEW \n See correctly rendered fragment \n FreeMarker Basics in Entando \n The FreeMarker templating language gives you a lot of flexibility and\npower in how pages are rendered. You can include conditional logic,\ninject information from the backend, check for query parameters and\nroute to different pages. \n For example, to check for a query parameter you can use:\n <#if RequestParameters.myParam?exists > … \n To check the current username, use:\n <#if (Session.currentUser.username != "guest") > \n When you need dynamic behavior in your widgets consider using the power\nof FreeMarker. \n https://freemarker.apache.org \n'},{title:"Digital Assets",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/compose/digital-assets-tutorial.html",relativePath:"v7.0/tutorials/compose/digital-assets-tutorial.md",key:"v-2ae5af0c",path:"/v7.0/tutorials/compose/digital-assets-tutorial.html",headers:[{level:2,title:"Manage Assets:",slug:"manage-assets"},{level:3,title:"Add a New Asset",slug:"add-a-new-asset"},{level:2,title:"Edit Assets",slug:"edit-assets"},{level:2,title:"Edit Images",slug:"edit-images"},{level:2,title:"Embed an Asset on a Page",slug:"embed-an-asset-on-a-page"},{level:2,title:"Include an Asset in a Content",slug:"include-an-asset-in-a-content"},{level:2,title:"Configure File Extensions for Upload",slug:"configure-file-extensions-for-upload"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Digital Assets \n The Entando Web Content Management System (WCMS) includes capabilities that let you manage contents and digital assets. Digital Assets are images, documents, and other media files in specific formats. \n Default Supported Document Formats:   pdf ,  xls ,  doc ,  ppt ,  txt ,  rtf ,  sxw ,  sxc ,  odt ,  ods ,  odp ,  tar ,  gz ,  zip ,  rar ,  flv ,  swf ,  avi ,  wmv ,  ogg ,  mp3 ,  wav ,  ogm ,  mov ,  iso ,  nrg ,  docx ,  docm ,  xlsx ,  xlsm ,  xlsb ,  pptx ,  pptm ,  ppsx ,  ppsm ,  sldx ,  sldm \nThe Entando WCMS can be configured to allow or exclude any type of file extension\nto your site. For the App Builder, you should also include the MIME type for the assets you want to allow. \n Default Supported Image Formats :  jpg ,  jpeg ,  png ,  svg ,  svg+xml \n Manage Assets: \n \n Login to the App Builder. \n From the left sidebar, go to  Content  →  Assets . \n \n \n \n View  Images  or  Attachments  with the tabs at the top of the page. \n Search by name or use the  Advanced filters  function to search by  Group ,  Filename , and/or  Category . \n Assets are displayed and ordered by Name.  Choose View  to toggle between a list or grid format. The order can also be changed. \n For each resource, click on the action menu (indicated by three vertical dots) to the right to Edit, Delete and preview available sizes. \n Add a New Asset \n \n From the Content Assets page in the App Builder, click  Add  on the right to add a new image or document file. \n \n \n \n Group : Choose from the drop-down menu. This is a required field and defaults to  Free Access . Additional groups can be defined in the Users section. \n Categories : Add your asset to the appropriate category with the  +  symbol under  Join . Categories are used in searching and sorting, but this is not a mandatory field. New Categories can be created in  Content  →  Categories . \n Drag and Drop your files into the window or click  Browse . The file you choose should appear in the Name field. You can choose multiple files at one time. You can also click  Add Another Resource  and  Choose file (s) individually. \n After all files have been chosen, click  Add  to upload. This takes you back to the main assets page where your uploaded files will be listed in the table. If you have an image file, see Edit Assets below. \n If a Name field is left blank, you will receive an error message. Simply go to the actions menu (indicated by three vertical dots) next to the empty file and select Delete. This action menu includes an  Edit  option. \n Edit Assets \n Changes to the Asset name and categories can be made on the Edit page. \n \n From  Content  →  Assets  page, in the list of assets, click on the Asset\'s actions menu (indicated by vertical dots) and select  Edit . \n Edit the Name field. For Categories, use the  +  button under  Join  to add the  Asset  to any category. \n Once all changes are made, click the  Add  button to finish. \n \n To organize or download assets, go to  Administration  →  File browser  and navigate to  /public/cms  to find your documents and images. \n Edit Images \n You can flip, rotate and crop newly uploaded images. \n \n Go to  Content  →  Assets  →  Add . \n After uploading an image, click on the actions menu to the right of the image and select  Edit .\n \n Use the arrows to flip, rotate or recenter your image. When done, click the  Crop  check button. Multiple resized images can be created at this time. Click  Free  to remove resizing ratio restrictions. \n Click  Done  at the top. \n Click  Add  to save all versions. \n Embed an Asset on a Page \n The uploaded asset can be embedded on a page by using: \n <@wp.resourceUrl>YOUR-PATH/YOUR-ASSET.jpg\n \n This path can be found in the App Builder at  Administration  →  File Browser . \ne.g.  <img src="<@wp.resourceUrl>cms/images/YOUR_FILENAME.jpg"> \n Include an Asset in a Content \n The Asset can be included in a Content Type that has an  Attach  or  Image  attribute. Follow the  Content Type tutorial  for detailed steps or follow the briefly outlined steps here. \n Create a Content Type with an image  Attribute . \n \n From the left sidebar, select  Content  →  Types  →  Add . \n \n \n \n Fill out  Code ,  Name  and click  Add . \n This takes you to the  Add Attribute  page. For this example, the Attribute Type is image. Enter the  Code  and  Name  as required.  All other fields are optional. Click  Continue  at bottom of the page. Note the Attribute Code field is used below to reference the image in the Template.\n \n To create the Template or Model where this  Content Type  can be inserted, go to  Content  →  Template  →  Add .\n \n From the drop-down menu for  Type , select the one just created. \n Enter the  Code  and  Name  fields as required. \n Complete the Model HTML layout in Velocity. The Inline Editing Assist tool is available by using the Ctl-Space buttons on your keyboard. Your image tag should look something like this:\n <img src="$content.your-attribute-code.getImagePath("0")"/>  \n Click  Save . The new Content Model is complete and should appear in the list to be used anywhere in your application. \n Configure File Extensions for Upload \n The types of files that can be uploaded to an Entando Application are controlled by the\nconfiguration of the server side of the App Builder. If you\'re using the quickstart version, this is  entando-de-app . \n There are two properties that control these settings set in  src/main/conf/systemParams.properties . This file is a comma delimitted list of values. The property keys are: \n \n jacms.imageResource.allowedExtensions= \n jacms.attachResource.allowedExtensions= \n \n To configure the uploads for the App Builder and Admin Console, include both the MIME type and the file extension of the asset. The APIs that support resources check the MIME type of the uploaded asset. \n An example configuration for images: \n \n jacms.imageResource.allowedExtensions=jpg,jpeg,png,svg,svg+xml \n \n Where  svg+xml  is the MIME type for an svg image. \n The  systemParams.properties  file is bundled into the WAR and the image for the application, so you need to create and deploy an image to reflect the changes to these properties in your application. \n'},{title:"Page Management",frontmatter:{},regularPath:"/v7.0/tutorials/compose/page-management.html",relativePath:"v7.0/tutorials/compose/page-management.md",key:"v-4a508620",path:"/v7.0/tutorials/compose/page-management.html",headers:[{level:2,title:"Create a Page",slug:"create-a-page"},{level:2,title:"Page Templates",slug:"page-templates"},{level:3,title:"JSON Configuration",slug:"json-configuration"},{level:3,title:"Template",slug:"template"},{level:3,title:"Create a Page Template",slug:"create-a-page-template"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Page Management \n The  Entando App Builder  provides the capability to publish application pages containing content as well as other Entando components. Page Templates are used to define the layout of available frames on a page. \n Create a Page \n Follow the steps below to create a Page with a Content widget. \n 1. Go to  Pages  →  Management . \n \n 2. Click the  Add  button. \n This generates a form where the following fields are mandatory: \n \n Title : used for SEO \n Code : must be unique \n Page placement : the location of the Page in the Page Tree \n Owner Group : the Group that has access to the Page \n Page Template : the structure and presentation of the Page \n \n \n 3. Click the  Save and Design  button. \n This loads the Designer UI, which lets you place widgets into the Page Template frames. \n \n 4. Add a widget. \n This is done by dragging a widget from the right panel into the desired frame. Adding the Content widget will load the configuration page shown below. \n \n 5. Click  Add existing content . \n This generates the content selection pop-up. \n \n You can search for the name of the content that you would like to publish. Remember that content must be saved and approved before it can be published to a page. \n 6. Select the desired content item(s) from the list. \n 7. Click the  Continue  button. \n The selected  Content  item will now be displayed. \n \n 8. Click the  Save  button. \n The following actions are now available: \n \n Click on the  Preview  button to show the page preview with the updated settings. \n Click on the  Publish  button to publish the page. \n Click on the  View published page  button to view the published page in your application. \n Page Templates \n Page Templates provide the scaffolding of a Page and are constructed using two main elements: \n \n A  JSON configuration  field which lists the set of frames that can be used on a page. \n A  Template  field which uses Freemarker code to setup the HTML page itself. \n JSON Configuration \n Each item in the  frames  array of the JSON configuration represents a frame or slot in the page, characterized by the following values: \n \n pos : A zero-based position index (starts from zero). This value is used by APIs to address a specific widget on the page. \n descr : The frame description displayed in the Page Design view. \n mainFrame : This designates the primary frame in the Page Template. \n defaultWidget : The code for a default widget to use in this frame. Page Template developers can use this field to provide suggestions for common widgets, e.g. header and footer widgets. \n sketch : An object with 4 coordinates (x1,x2,y1,y2) to allow the developer to place the widgets in the Page preview. The x and y values go from 0 to 11 (similar to columns in Bootstrap), so if you want to place a 2x2 frame at the top left corner of the page, the values would be  x1: 0 ,  x2: 1 ,  y1: 0  and  y2: 1 . \n Template \n To add a frame in a specific place of the page, input  <@wp.show frame=0 /> , where  frame  is the  pos  variable from the  JSON configuration . To setup the  wp  variable,  <#assign wp=JspTaglibs["/aps-core"]>  is required at the top of the template. \n Common code can be shared across Pages by using  UX Fragments  and  <@wp.fragment code="\\<FRAGMENT\\_CODE\\>" escapeXml=false /\\> . \n Create a Page Template \n Follow the steps below to prepare a Page Template with two frames on it. \n 1. Go to  Pages  →  Templates  →  Add \n \n 2. Enter the field information below: \n \n Code : double_frame (Note: Dashes are not allowed) \n Name : Double Frame \n JSON Configuration: \n \n { \n   "frames" :   [ \n     { \n       "pos" :   0 , \n       "descr" :   "Frame 1" , \n       "mainFrame" :   false , \n       "defaultWidget" :   null , \n       "sketch" :   { "x1" :   0 ,   "y1" :   0 ,   "x2" :   11 ,   "y2" :   1 } \n     } , \n     { \n       "pos" :   1 , \n       "descr" :   "Frame 2" , \n       "mainFrame" :   false , \n       "defaultWidget" :   null , \n       "sketch" :   { "x1" :   0 ,   "y1" :   2 ,   "x2" :   11 ,   "y2" :   3 } \n     } \n   ] \n } \n \n \n Template: \n \n < #assign  wp = JspTaglibs [ "/aps-core" ] > \n <! DOCTYPE   HTML   PUBLIC   "-//W3C//DTD HTML 4.0 Transitional//EN" > \n < html > \n   < head > \n       < title > < @wp . currentPage param = "title"   /> </ title > \n   </ head > \n   < body > \n     < h1 > < @wp . currentPage param = "title"   /> </ h1 > \n     < div > < @wp . show frame = 0   /> </ div > \n     < div > < @wp . show frame = 1   /> </ div > \n   </ body > \n </ html > \n \n Include the following fragment in the  head  section to make use of the user\'s Keycloak identity information. \n < @wp . fragment code = "keycloak_auth"  escapeXml = false   /> \n \n 3. Verify that the  Template preview  is reflecting the desired two frame layout. \n 4. Click the  Save  button. \n'},{title:"Micro Frontends",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/create/mfe/",relativePath:"v7.0/tutorials/create/mfe/README.md",key:"v-d238dffc",path:"/v7.0/tutorials/create/mfe/",headers:[{level:2,title:"Introduction",slug:"introduction"},{level:2,title:"Tutorials",slug:"tutorials"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Micro Frontends \n Introduction \n \n The idea behind Micro Frontends is to think about a website or web app as  a composition of features  which are owned by  independent teams . Each team has a  distinct area of business  or  mission  it cares about and specialises in. A team is  cross functional  and develops its features  end-to-end , from database to user interface. \n —  Michael Geers,  micro-frontends.org \n \n Think of micro frontends as the implementation of a microservices architecture applied to the full web application that extends all the way to the frontend. \n Entando implements micro frontends based on  Web Components , a set of technologies that allow developers to create reusable custom elements supported by all major internet browsers. \n Web Components can work with vanilla JavaScript as well as with the most popular web frameworks (e.g., React, Angular, and Vue). \n Entando's microservice and micro frontend architecture allows developers to work with their favorite technology stack, and makes it easier for companies to integrate disparate applications. \n Tutorials \n \n \n Create a React Micro Frontend \n \n \n Create an Angular Micro Frontend \n \n \n Add an App Builder configuration screen to a\nwidget \n \n \n Display widget configuration \n \n \n Communicate Between Micro Frontends \n \n \n Widget authentication with Keycloak \n \n \n"},{title:"Create an Angular Micro Frontend",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/create/mfe/angular.html",relativePath:"v7.0/tutorials/create/mfe/angular.md",key:"v-79cc9f79",path:"/v7.0/tutorials/create/mfe/angular.html",headers:[{level:2,title:"Create Angular App",slug:"create-angular-app"},{level:3,title:"Convert to Custom Element",slug:"convert-to-custom-element"},{level:3,title:"Test Micro Frontend",slug:"test-micro-frontend"},{level:2,title:"Build It",slug:"build-it"},{level:2,title:"Host Micro Frontend",slug:"host-micro-frontend"},{level:3,title:"Create Public Folder",slug:"create-public-folder"},{level:3,title:"Add Widget",slug:"add-widget"},{level:3,title:"See It in Action",slug:"see-it-in-action"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Create an Angular Micro Frontend \n Prerequisites \n \n A working instance of Entando. \n \n \n Tested Versions \n node v13.8.0 → We suggest using  nvm  to handle node installations. \n Create Angular App \n Install Angular CLI. \n npm   install  -g @angular/cli\n \n Generate a new angular application. \n ng new angular-widget\n \n Choose the following options: \n ? Would you like to  add  Angular routing? No\n? Which stylesheet  format  would you like to use? CSS\n \n Serve the application. \n cd  angular-widget\n \n ng serve\n \n This is the expected output: \n angular-widget\n├── e2e\n│   └── src\n│       ├── app.e2e-spec.ts\n│       └── app.po.ts\n│\n├── node_modules\n├── src\n│   ├── app\n│   │   ├── app.component.css\n│   │   ├── app.component.html\n│   │   ├── app.component.spec.ts\n│   │   ├── app.component.ts\n│   │   └── app.module.ts\n│   │\n│   ├── assets\n│   │   └── .gitkeep\n│   │\n│   ├── environment\n│   │   ├── environment.prod.ts\n│   │   └── environment.ts\n│   │\n│   ├── favicon.ico\n│   ├── index.html\n│   ├── main.ts\n│   ├── polyfills.ts\n│   ├── styles.css\n│   └── test.ts\n│\n├── .editorconfig\n├── .gitignore\n├── angular.json\n├── browserlist\n├── karma.conf.js\n├── package.json\n├── README.md\n├── tsconfig.app.json\n├── tsconfig.json\n├── tsconfig.spec.json\n└── tslint.json\n Convert to Custom Element \n Next, let's convert our Angular app into a custom element. We'll use  Angular elements  to transform components into custom elements. \n ng  add  @angular/elements\n \n WARNING \n Install the Angular elements package using  ng add , not with  npm install  as it runs additional steps behind the scenes like adding the  document-register-element  polyfill. \n \n TIP \n Angular elements are Angular components packaged as custom elements (also called Web Components), a web standard for defining new HTML elements in a framework-agnostic way. \n \n Open  angular-widget/src/app/app.module.ts . \n \n Here's what the initial file looks like: \n \n import   {  BrowserModule  }   from   '@angular/platform-browser' ; \n import   {  NgModule  }   from   '@angular/core' ; \n\n import   {  AppComponent  }   from   './app.component' ; \n\n@ NgModule ( { \n   declarations :   [ \n    AppComponent\n   ] , \n   imports :   [ \n    BrowserModule\n   ] , \n   providers :   [ ] , \n   bootstrap :   [ AppComponent ] \n } ) \n export   class   AppModule   {   } \n \n Replace the entire file with: \n import   {  BrowserModule  }   from   '@angular/platform-browser' ; \n import   {  NgModule ,  Injector  }   from   '@angular/core' ; \n import   {  createCustomElement  }   from   '@angular/elements' ; \n import   {  AppComponent  }   from   './app.component' ; \n\n@ NgModule ( { \n   declarations :   [ \n    AppComponent\n   ] , \n   imports :   [ \n    BrowserModule\n   ] , \n   providers :   [ ] , \n   entryComponents :   [ AppComponent ] \n } ) \n export   class   AppModule   { \n   constructor ( private   injector :  Injector )   { } \n\n   ngDoBootstrap ( )   { \n     const  el  =   createCustomElement ( AppComponent ,   {   injector :   this . injector  } ) ; \n    customElements . define ( 'angular-widget' ,  el ) ; \n   } \n } \n \n \n In the initial file,  AppModule  is bootstrapped directly during application launch. \n In the updated file, we booststrap our custom element using the  ngDoBootstrap()  method . \n \n Custom Elements \n \n Must contain a hyphen  -  in the name. : \n Cannot be a single word. \n Should follow  kebab-case  for naming convention. \n Test Micro Frontend \n Now, let's check our custom element to see if it's working. \n Open  angular-widget/src/index.html . \n In the  <body> , replace  <app-root></app-root>  with your custom element  <angular-widget /> . \n <! doctype   html > \n < html   lang = \" en \" > \n < head > \n   < meta   charset = \" utf-8 \" > \n   < title > AngularWidget </ title > \n   < base   href = \" / \" > \n   < meta   name = \" viewport \"   content = \" width=device-width, initial-scale=1 \" > \n   < link   rel = \" icon \"   type = \" image/x-icon \"   href = \" favicon.ico \" > \n </ head > \n < body > \n   < angular-widget   /> \n </ body > \n </ html > \n \n Congratulations! \n You’re now running  Angular  in a micro frontend. \n Build It \n From the project root, type: \n ng build --prod --outputHashing = none\n \n This will generate an  angular-widget/dist  directory. \n If we assume browser support for  ES6 (ECMAScript 2015) , we can focus on the following JavaScript files to publish our app: \n \n main-es2015.js \n polyfills-es2015.js \n runtime-es2015.js \n \n Generated Build Files \n --outputHashing=none  generates files without hashes so we can deploy new versions of the micro frontend without having to reconfigure our widget in Entando to point to the newly built files. \n \n If you want to use file names with content hashes to avoid potential caching issues in your browser, you can update the  Custom UI  field of your widget after building new versions of your micro frontend. Widget configuration is covered in the next section. \n Host Micro Frontend \n Now we're ready to host our micro frontend in Entando. \n Create Public Folder \n \n \n Navigate to  Entando App Builder  in your browser. \n \n \n Click  Administration  at the lower left hand side of the screen. \n \n \n Click the  File Browser  tab. \n \n \n Click the  public  folder. \n \n \n Click  Create Folder . \n \n \n Enter  angular-widget \n \n \n Click  Save . \n \n \n Click  angular-widget . \n \n \n Click 'Upload Files`. \n \n \n Upload the following files from  angular-widget/dist/angular-widget : \n \n \n \n main-es2015.js \n polyfills-es2015.js \n runtime-es2015.js \n \n Additional Deployment Options \n \n Install the micro frontend from a bundle in the  Entando Component Repository . \n Add the micro frontend to  Entando App Builder . \n Load the micro frontend from an API. \n Add Widget \n \n Go to  Components > Micro frontends & Widgets  in the Entando App Builder. \n Click  Add  at the lower right. \n \n \n \n Enter the following: \n \n \n Code: angular_widget  → note: dashes are not allowed \n Title: Angular Widget  → for both English and Italian languages \n Group: Free Access \n Custom UI: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < script   async   src = \" < @wp . resourceURL  /> angular-widget/main-es2015.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> angular-widget/polyfills-es2015.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> angular-widget/runtime-es2015.js \" > </ script > \n\n < angular-widget   /> \n \n \n Click  Save . \n \n TIP \n <#assign wp=JspTaglibs[ \"/aps-core\"]>  gives you access to the  @wp  object where you can use environment variables like  resourceURL . \n See It in Action \n Let's see the Angular micro frontend in action on our page. \n Add Page \n Note \n If you've already configured your home page: \n \n   Next to the  Home  folder, under  Actions , click  Configure . \n   Skip to the  Add Widget  section. \n \n \n Let's add our widget to the  Home  page. \n \n \n Go to  Pages  →  Management \n \n \n Next to the  Home  folder, under  Actions , click  Edit . \n \n \n Next to  Page Template  select  Service Page . \n \n \n Click  Save and Configure . \n Add Widget \n \n \n In the Search field in right-hand sidebar, enter  Angular Widget . \n \n \n Drag and drop  Angular Widget  into the  Sample Frame  in the main body of the page. \n \n \n Click  Publish . \n \n \n At the upper right, click  Go to Homepage . \n \n \n \n Congratulations! \n You now have an Angular micro frontend running in Entando. \n \n"},{title:"Authentication",frontmatter:{},regularPath:"/v7.0/tutorials/create/mfe/authentication.html",relativePath:"v7.0/tutorials/create/mfe/authentication.md",key:"v-455c4095",path:"/v7.0/tutorials/create/mfe/authentication.html",lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Authentication \n Keycloak is used for authentication. \n To set up keycloak server, please refer to Keycloak\n documentation . \n As all MFE widgets use the same Keycloak instance, it should be\ninitialized on a container of all widgets. \n Using Details widget generated using Entando JHipster blueprint as an\nexample, let’s get familiar with authentication implementation. \n As mentioned before, widget auth implementation assumes that Keycloak is\ninitialized outside of the widget. In Details example, it is done in\nindex.html where Keycloak server’s keycloak.js is used. \n <head>\n    <script src=\"keycloak.js\"><\/script>\n    <script>\n        var keycloak = new Keycloak();\n        keycloak\n          .init({ onLoad: 'check-sso' })\n          .success(onInit);\n    <\/script>\n</head>\n \n \n Note \n keycloak.js is provided by your Keycloak server at\n <SERVER_URL:PORT>/auth/js/keycloak.js \n \n Keycloak is initialized by passing Keycloak server path, realm and\nclient ID and calling  init({/* options */})  function. \n const keycloak = Keycloak({\n  url: 'http://localhost:9080/auth',\n  realm: 'jhipster',\n  clientId: 'jhipster-entando-react-client',\n});\n\nkeycloak\n  .init({ onLoad: 'check-sso' })\n  .success(onInit);\n \n Depending on Keycloak version you are using,  init()  function can\nreturn a Promise (newer versions support  promiseType: 'native' \noption). \n keycloak\n  .init({ onLoad: 'check-sso', promiseType: 'native' })\n  .then(authenticated => {\n    alert(authenticated ? 'Authenticated' : 'Not authenticated');\n  })\n  .catch(() => {\n    alert('Failed to initialize');\n  });\n \n All the Keycloak events are made custom events - this way widgets could\nreact to them if a need arises. \n function createKcDispatcher(payload) {\n  return () => window.dispatchEvent(new CustomEvent('keycloak', { detail: payload }));\n}\n\nkeycloak.onReady = createKcDispatcher({ eventType: 'onReady' });\nkeycloak.onAuthSuccess = createKcDispatcher({ eventType: 'onAuthSuccess' });\nkeycloak.onAuthError = createKcDispatcher({ eventType: 'onAuthError' });\nkeycloak.onAuthRefreshSuccess = createKcDispatcher({ eventType: 'onAuthRefreshSuccess' });\nkeycloak.onAuthRefreshError = createKcDispatcher({ eventType: 'onAuthRefreshError' });\nkeycloak.onAuthLogout = createKcDispatcher({ eventType: 'onAuthLogout' });\nkeycloak.onTokenExpired = createKcDispatcher({ eventType: 'onTokenExpired' });\nconst onInit = createKcDispatcher({ eventType: 'onInit' });\n \n Keycloak object is then stored into  window.entando  object for widgets\nto have access to. \n window.entando = {\n  ...(window.entando || {}),\n  keycloak,\n};\n \n On the widget side inside the custom element creation logic Keycloak\nobject is accessed and passed into the component via Keycloak context \n const getKeycloakInstance = () =>\n  (window &&\n    window.entando &&\n    window.entando.keycloak &&\n    { ...window.entando.keycloak, initialized: true }\n  ) || { initialized: false };\n\n\n// ...\n\nconstructor(...args) {\n  // ...\n  this.keycloak = getKeycloakInstance();\n}\n\nconnectedCallback() {\n  // ...\n  ReactDOM.render(\n    <KeycloakContext.Provider value={this.keycloak}>\n      <ConferenceDetailsContainer />\n    </KeycloakContext.Provider>,\n    this.mountPoint\n  );\n}\n \n And on the component side you can show different content depending on\nthe authentication status \n At  auth/KeycloakViews.js \n export const AuthenticatedView = ({ children, keycloak }) => {\n  const authenticated = keycloak.initialized && keycloak.authenticated;\n  return authenticated ? children : null;\n};\n\nexport const UnauthenticatedView = ({ children, keycloak }) => {\n  const authenticated = keycloak.initialized && keycloak.authenticated;\n  return !authenticated ? children : null;\n};\n \n At  components/ConferenceDetailsContainer.js \n render() {\n  const { conference, loading } = this.state;\n  const { t, keycloak } = this.props;\n\n  return (\n    <ThemeProvider theme={this.theme}>\n      <UnauthenticatedView keycloak={keycloak}>\n        {t('common.notAuthenticated')}\n      </UnauthenticatedView>\n      <AuthenticatedView keycloak={keycloak}>\n        {loading && t('common.loading')}\n        {!loading && <ConferenceDetails conference={conference} />}\n      </AuthenticatedView>\n    </ThemeProvider>\n  );\n}\n \n \n Note \n Keycloak object is accessible via props because of  withKeycloak  HOC:\n export default withKeycloak(ConferenceDetailsContainer); \n \n Next Steps \n To apply more fine-grained access controls, see  this tutorial . \n"},{title:"Communicate Between Micro Frontends",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/create/mfe/communication.html",relativePath:"v7.0/tutorials/create/mfe/communication.md",key:"v-dc031c0e",path:"/v7.0/tutorials/create/mfe/communication.html",headers:[{level:2,title:"Publisher",slug:"publisher"},{level:3,title:"Create Custom Event",slug:"create-custom-event"},{level:3,title:"Update React App to Dispatch Event",slug:"update-react-app-to-dispatch-event"},{level:3,title:"Test Event Dispatcher",slug:"test-event-dispatcher"},{level:2,title:"Subscriber",slug:"subscriber"},{level:3,title:"Add Event Listener",slug:"add-event-listener"},{level:3,title:"Display Custom Event",slug:"display-custom-event"},{level:3,title:"Test Event Listener",slug:"test-event-listener"},{level:2,title:"Add Widgets to App Builder",slug:"add-widgets-to-app-builder"},{level:3,title:"Create Environment File",slug:"create-environment-file"},{level:3,title:"Run npm build",slug:"run-npm-build"},{level:3,title:"Create Public Folder",slug:"create-public-folder"},{level:3,title:"Add Widgets",slug:"add-widgets"},{level:3,title:"View on a Page",slug:"view-on-a-page"},{level:2,title:"Angular to React",slug:"angular-to-react"},{level:3,title:"Create Angular Publisher",slug:"create-angular-publisher"},{level:3,title:"Add to App Builder",slug:"add-to-app-builder"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Communicate Between Micro Frontends \n Recommended Learning \n \n Tutorial:  Create a React Micro Frontend \n Tutorial:  Create an Angular Micro Frontend \n \n \n Entando supports communication between micro frontends using  Custom Events , an established web standard. In this tutorial, we build: \n \n A React micro frontend that publishes an event \n A React micro frontend that listens to an event \n An Angular micro frontend that publishes an event to a React micro frontend \n Publisher \n Create a simple app to publish an event. \n npx create-react-app publisher-widget --use-npm\n \n Start the app. \n cd  publisher-widget\n \n npm  start\n Create Custom Event \n Next, add event firing logic. \n Add a new file  publisher-widget/src/PublisherWidgetElement.js . \n import  React  from   'react' ; \n import  ReactDOM  from   'react-dom' ; \n import  App  from   './App' ; \n\n const   EVENTS   =   { \n   greeting :   'greeting' , \n } ; \n\n class   PublisherWidgetElement   extends   HTMLElement   { \n\n   constructor ( )   { \n     super ( ) ; \n     this . onGreet   =   name   =>   this . publishWidgetEvent ( EVENTS . greeting ,   {  name  } ) ; \n   } \n\n   connectedCallback ( )   { \n     this . mountPoint  =  document . createElement ( 'div' ) ; \n     this . appendChild ( this . mountPoint ) ; \n     this . render ( ) ; \n   } \n\n   publishWidgetEvent ( eventId ,  detail )   { \n     const  widgetEvent  =   new   CustomEvent ( eventId ,   {  detail  } ) ; \n    window . dispatchEvent ( widgetEvent ) ; \n   } \n\n   render ( )   { \n    ReactDOM . render ( < App onGreet = { this . onGreet }   / > ,   this . mountPoint ) ; \n   } \n } \n\ncustomElements . define ( 'publisher-widget' ,  PublisherWidgetElement ) ; \n\n export   default  PublisherWidgetElement ; \n \n \n In the  CustomEvent  constructor,  detail  is the specific name to use in the event payload, as per the  DOM specification . \n Import Custom Element \n Update  publisher-widget/src/index.js . \n import   './index.css' ; \n import   './PublisherWidgetElement' ; \n Test Custom Element \n Update  publisher-widget/public/index.html , and view it in the browser. \n    < body > \n     < noscript > You need to enable JavaScript to run this app. </ noscript > \n     < publisher-widget   /> \n    ...\n   </ body > \n Update React App to Dispatch Event \n Update  publisher-widget/src/App.js . \n import  React  from   'react' ; \n import   './App.css' ; \n\n class   App   extends   React . Component   { \n   constructor ( props )   { \n     super ( props ) ; \n     this . state  =   {   name :   '' } ; \n   } \n\n   handleNameChange ( value )   { \n     this . setState ( prevState   =>   ( { \n       ... prevState , \n       name :  value , \n     } ) ) ; \n   } \n\n   render ( )   { \n     const   {  name  }   =   this . state ; \n     const   {  onGreet  }   =   this . props ; \n     return   ( \n       < div > \n         < h1 > Send a greeting < / h1 > \n         < label htmlFor = \"name\" > Name < / label > \n         < input id = \"name\"  onChange = { e   =>   this . handleNameChange ( e . target . value ) }  value = { name }   / > \n         < button onClick = { ( )   =>   onGreet ( name ) } > Say hello ! < / button > \n       < / div > \n     ) ; \n   } \n } \n\n export   default  App ; \n Test Event Dispatcher \n In the JavaScript console of your browser, enter: \n window . addEventListener ( 'greeting' ,   ( evt )   =>  console . log ( 'Hello' ,  evt . detail . name ) ) \n \n Write something in the text field. Click the \"Say hello!\" button and take a look at the JS console. It will show the event message. \n Congratulations! \n You’ve now published a custom event. \n Subscriber \n Next, let’s create the subscriber. \n npx create-react-app subscriber-widget --use-npm\n \n Start the app. \n cd  subscriber-widget\n \n npm  start\n Add Event Listener \n Add a new file  subscriber-widget/src/SubscriberWidgetElement.js . \n import  React  from   'react' ; \n import  ReactDOM  from   'react-dom' ; \n import  App  from   './App' ; \n\n const   EVENTS   =   { \n   greeting :   'greeting' , \n } ; \n\n class   SubscriberWidgetElement   extends   HTMLElement   { \n\n   constructor ( )   { \n     super ( ) ; \n     this . name  =   null ; \n     this . subscribeToWidgetEvent ( EVENTS . greeting ,   ( evt )   =>   this . onGreeting ( evt . detail . name ) ) ; \n   } \n\n   connectedCallback ( )   { \n     this . mountPoint  =  document . createElement ( 'div' ) ; \n     this . appendChild ( this . mountPoint ) ; \n     this . render ( ) ; \n   } \n\n   subscribeToWidgetEvent ( eventType ,  eventHandler )   { \n    window . addEventListener ( eventType ,  eventHandler ) ; \n   } \n\n   onGreeting ( name )   { \n     this . name  =  name ; \n     this . render ( ) ; \n   } \n\n   render ( )   { \n    ReactDOM . render ( < App name = { this . name }   / > ,   this . mountPoint ) ; \n   } \n } \n\ncustomElements . define ( 'subscriber-widget' ,  SubscriberWidgetElement ) ; \n\n export   default  SubscriberWidgetElement ; \n Import Custom Element \n Update  subscriber-widget/src/index.js . \n import   './index.css' ; \n import   './SubscriberWidgetElement' ; \n Test Micro Frontend \n Update  subscriber-widget/public/index.html , and view it in the browser. \n    < body > \n     < noscript > You need to enable JavaScript to run this app. </ noscript > \n     < subscriber-widget > \n    ...\n   </ body > \n Display Custom Event \n Update  subscriber-widget/src/App.js . \n import  React  from   'react' ; \n import   './App.css' ; \n\n function   App ( {  name  } )   { \n   return  name  ?   ( < h2 > Just got a greeting from  { name } < / h2 > ) \n     :   ( < h2 > Waiting  for  a greeting ... < / h2 > ) ; \n } \n\n export   default  App ; \n Test Event Listener \n In the JavaScript console of your browser, enter: \n const  widgetEvent  =   new   CustomEvent ( 'greeting' ,   { \n   detail :   { \n     name :   'Pippo' \n   } , \n } ) ; \nwindow . dispatchEvent ( widgetEvent ) ; \n \n The custom event should now display in the  subscriber-widget . \n Congratulations! \n You’ve now created a micro frontend that listens to custom events. \n Add Widgets to App Builder \n Now let's add the publisher and subscriber micro frontends in Entando. \n \n Note: These follow the same steps as in the  Create a React Micro Frontend  tutorial. \n Create Environment File \n Publisher Widget \n \n \n Create an  .env  file in the project root for the  publisher-widget . \n \n \n Open the  .env  file, and enter the  PUBLIC_URL  where the micro frontend will be hosted. \n \n \n Example: \n PUBLIC_URL=http://quickstart.192.168.64.34.nip.io/entando-de-app/cmsresources/publisher-widget\n \n Notes \n \n Replace  quickstart.192.168.64.34.nip.io  with the ingress you use to access Entando from your local browser. \n /entando-de-app/cmsresources/  is your Resource URL. \n publisher-widget  is the public folder we'll create to host the publisher micro frontend. \n Subscriber Widget \n \n \n Create an  .env  file in the project root for the  subscriber-widget . \n \n \n Open the  .env  file, and enter the  PUBLIC_URL  where the micro frontend will be hosted. \n \n \n \n Use  subscriber-widget  for the name of the public folder we'll create to host the subscriber micro frontend. \n \n Example: \n PUBLIC_URL=http://quickstart.192.168.64.34.nip.io/entando-de-app/cmsresources/subscriber-widget\n Run npm build \n Publisher Widget \n \n \n Open a command line, and navigate to the project root of the  publisher-widget . \n \n \n Run build. \n \n \n npm  run build\n \n \n Rename the following generated files in the  build  directory. \n \n \n \n \n Example of Generated Build File \n Rename to \n Function \n \n \n \n \n build/static/js/2.f14073bd.chunk.js \n static/js/vendor.js \n Third-party libraries \n \n \n build/static/js/runtime-main.8a835b7b.js \n static/js/runtime.js \n Bootstrapping logic \n \n \n build/static/js/main.4a514a6d.chunk.js \n static/js/main.js \n App \n \n \n build/static/css/main.5f361e03.chunk.css \n static/css/main.css \n Stylesheet \n Subscriber Widget \n \n Repeat steps 1-3 for the  subscriber-widget . \n Create Public Folder \n Publisher Widget \n \n \n Navigate to  Entando App Builder  in your browser. \n \n \n Go to  Configuration  →   File Browser   →  public \n \n \n Click  Create Folder . \n \n \n Enter  publisher-widget . \n \n \n Click  Save . \n \n \n Click  public  →  publisher-widget . \n \n \n Create the same folder structure as your generated build directory \n \n \n \n publisher-widget/static/css \n publisher-widget/static/js \n \n \n Upload the files we renamed in the corresponding  js  and  css  folders. \n \n \n publisher-widget/static/css/main.css \n publisher-widget/static/js/main.js \n publisher-widget/static/js/runtime.js \n publisher-widget/static/js/vendor.js \n Subscriber Widget \n \n Repeat steps 1-8 for the  subscriber-widget . \n Add Widgets \n Publisher Widget \n \n \n Go to  Entando App Builder  in your browser. \n \n \n Go to  Components  →  Micro Frontends & Widgets  at the top nav. \n \n \n Click  Add . \n \n \n Enter the following: \n \n \n \n Code: publisher_widget  → note: dashes are not allowed \n Title: Publisher Widget  → for both English and Italian languages \n Group: Free Access \n Custom UI: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < link   rel = \" stylesheet \"   type = \" text/css \"   href = \" < @wp . resourceURL  /> publisher-widget/static/css/main.css \" > \n < script   async   src = \" < @wp . resourceURL  /> publisher-widget/static/js/runtime.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> publisher-widget/static/js/vendor.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> publisher-widget/static/js/main.js \" > </ script > \n < publisher-widget   /> \n \n \n Click  Save . \n Subscriber Widget \n Repeat steps 1-5 for the subscriber widget. \n \n Code: subscriber_widget  → note: dashes are not allowed \n Title: Subscriber Widget  → for both English and Italian languages \n Group: Free Access \n Custom UI: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < link   rel = \" stylesheet \"   type = \" text/css \"   href = \" < @wp . resourceURL  /> subscriber-widget/static/css/main.css \" > \n < script   async   src = \" < @wp . resourceURL  /> subscriber-widget/static/js/runtime.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> subscriber-widget/static/js/vendor.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> subscriber-widget/static/js/main.js \" > </ script > \n < subscriber-widget   /> \n View on a Page \n You can setup the widgets on an existing page (such as the Home page) or  create your own page . The following steps assume you'll use the Home page. \n \n \n Go to  Pages  →  Management \n \n \n For the  Home  page  (folder icon) , in the  Actions  column, click the  ⋮  icon \n \n \n Click  Edit . \n \n \n In the  Settings  section, select a Page Template with more than one frame, e.g.  1-column : \n \n \n \n Page Template: 1 Column \n \n \n \n Click  Save and Configure . \n \n \n In the  WIDGETS  sidebar on the right: \n \n \n \n Drag  Publisher Widget  and  Subscriber Widget  into  Frame 1  and  Frame 2 . \n \n \n \n Click  Publish . \n \n \n To view the home page, scroll to the top of the page, and click  Go to Homepage . \n \n \n Enter a greeting in the input field. Press the submit button. The subscriber widget will update with the greeting. Done! \n \n \n Congratulations! \n You can now communicate between micro frontends with  Custom Events . \n Angular to React \n We can also communicate between micro frontends using different JavaScript frameworks. \n In this next example, we’ll create an Angular micro frontend to publish an event, and we'll use the React micro frontend we created in the previous section to receive the event. \n Create Angular Publisher \n ng new angular-publisher-widget\n \n Choose the following options: \n ? Would you like to  add  Angular routing? No\n? Which stylesheet  format  would you like to use? CSS\n \n Serve the application. \n cd  angular-publisher-widget\n \n ng serve\n Convert to Custom Element \n Next, let's convert our Angular app into a custom element. We'll use  Angular elements  to transform components into custom elements. \n ng  add  @angular/elements\n \n Replace the contents of  angular-publisher-widget/src/app/app.module.ts . \n \n In this file, we bootstrap the custom element using the  ngDoBootstrap  method. \n \n import   {  BrowserModule  }   from   '@angular/platform-browser' ; \n import   {  NgModule ,  Injector  }   from   '@angular/core' ; \n import   {  createCustomElement  }   from   '@angular/elements' ; \n import   {  AppComponent  }   from   './app.component' ; \n import   {  ReactiveFormsModule  }   from   '@angular/forms' ; \n\n@ NgModule ( { \n   declarations :   [ \n    AppComponent\n   ] , \n   imports :   [ \n    BrowserModule , \n    ReactiveFormsModule\n   ] , \n   providers :   [ ] , \n   entryComponents :   [ AppComponent ] \n } ) \n export   class   AppModule   { \n   constructor ( private   injector :  Injector )   { } \n\n   ngDoBootstrap ( )   { \n     const  el  =   createCustomElement ( AppComponent ,   {   injector :   this . injector  } ) ; \n    customElements . define ( 'angular-publisher-widget' ,  el ) ; \n   } \n } \n Create Custom Event \n Replace the contents of  angular-publisher-widget/src/app/app.component.ts . \n \n Here, we're adding code to dispatch the custom event. \n \n import   {  Component  }   from   '@angular/core' ; \n import   {  FormControl ,  FormGroup  }   from   '@angular/forms' ; \n\n const   EVENTS   =   { \n   greeting :   'greeting' , \n } ; \n\n@ Component ( { \n   selector :   'app-root' , \n   templateUrl :   './app.component.html' , \n   styleUrls :   [ './app.component.css' ] \n } ) \n export   class   AppComponent   { \n  greetingForm  =   new   FormGroup ( { \n     name :   new   FormControl ( '' ) , \n   } ) ; \n\n   publishWidgetEvent ( eventId ,  detail )   { \n     const  widgetEvent  =   new   CustomEvent ( eventId ,   {  detail  } ) ; \n    window . dispatchEvent ( widgetEvent ) ; \n   } \n\n   onSubmit ( )   { \n     const  name  =   this . greetingForm . get ( 'name' ) . value ; \n     this . publishWidgetEvent ( EVENTS . greeting ,   {  name  } ) ; \n   } \n } \n Add HTML Form \n Replace the contents of  angular-publisher-widget/src/app/app.component.html . \n \n In the app component html, we're adding a simple form to call our component class  app.component.ts . \n \n < h1 > Send a greeting </ h1 > \n < form   [formGroup] = \" greetingForm \"   (ngSubmit) = \" onSubmit() \" > \n   < label > \n    Name\n     < input   type = \" text \"   formControlName = \" name \" > \n   </ label > \n   < button   type = \" submit \" > Say hello! </ button > \n </ form > \n View Micro Frontend \n Open  angular-publisher-widget/src/index.html . \n In the  <body> , replace  <app-root></app-root>  with your custom element  <angular-publisher-widget /> . \n < body > \n   < angular-publisher-widget   /> \n </ body > \n \n You can check to see if your micro frontend is working in your browser (e.g., localhost:4200) \n Add to App Builder \n Now we're ready to host our micro frontend in Entando. \n Build It \n From the project root, type: \n ng build --prod --outputHashing = none\n \n This will generate a  dist  directory. \n Create Public Folder \n \n \n Navigate to  Entando App Builder  in your browser. \n \n \n Click  Configuration  →   File Browser   →  public . \n \n \n Create a folder named  angular-publisher-widget . \n \n \n Click  Upload Files . \n \n \n From your generated  dist  folder, upload: \n \n \n \n main-es2015.js \n polyfills-es2015.js \n runtime-es2015.js \n Add Widget \n \n \n Go to  Components > Micro frontends & Widgets  in the Entando App Builder. \n \n \n Click  Add  at the lower right. \n \n \n Enter the following: \n \n \n \n Code: angular_publisher_widget  → note: dashes are not allowed \n Title: Angular Publisher Widget  → for both English and Italian languages \n Group: Free Access \n Custom UI: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < script   async   src = \" < @wp . resourceURL  /> angular-publisher-widget/main-es2015.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> angular-publisher-widget/polyfills-es2015.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> angular-publisher-widget/runtime-es2015.js \" > </ script > \n\n < angular-publisher-widget   /> \n \n \n Click  Save . \n View on Homepage \n \n \n Go to  Pages  →  Management \n \n \n Next to the  Home  page  (folder icon) , in the  Actions  column, click the  ⋮  icon \n \n \n In the Search field in right-hand sidebar, enter  Angular Publisher Widget . \n \n \n Drag and drop  Angular Publisher Widget  into the  Sample Frame  in the main body of the page. \n \n \n \n Replace  Publisher Widget . \n \n \n \n Click  Publish . \n \n \n In the top navigation, on the right, click  Go to Homepage . \n \n \n Enter a greeting in the input field. Press the submit button. The subscriber widget will update with the greeting. Done! \n \n \n \n Note: If you don't see an input field, refresh the page. \n \n Congratulations! \n You've now created an Angular micro frontend that can communicate with a React micro frontend. \n \n"},{title:"Create a React Micro Frontend",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/create/mfe/react.html",relativePath:"v7.0/tutorials/create/mfe/react.md",key:"v-52359299",path:"/v7.0/tutorials/create/mfe/react.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Create React App",slug:"create-react-app"},{level:3,title:"Wrap with Custom Element",slug:"wrap-with-custom-element"},{level:3,title:"Import Custom Element",slug:"import-custom-element"},{level:3,title:"Test Micro Frontend",slug:"test-micro-frontend"},{level:2,title:"Build the Resource URL",slug:"build-the-resource-url"},{level:3,title:"Add Widget",slug:"add-widget"},{level:3,title:"Add Page",slug:"add-page"},{level:3,title:"Build It",slug:"build-it"},{level:3,title:"npm build",slug:"npm-build"},{level:2,title:"Host Micro Frontend",slug:"host-micro-frontend"},{level:3,title:"Create Public Folder",slug:"create-public-folder"},{level:3,title:"Update Custom UI Field",slug:"update-custom-ui-field"},{level:3,title:"View the Widget",slug:"view-the-widget"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Create a React Micro Frontend \n Prerequisites \n \n A working instance of Entando. \n Use the Entando CLI to verify all dependencies are installed with the command  ent check-env develop . \n Create React App \n We'll use  Create React App  to generate a simple app in seconds. \n \n Create 'my-widget' directory structure with the following: \n \n npx create-react-app my-widget --use-npm\n \n This is the expected output: \n my-widget\n├── README.md\n├── node_modules\n├── package.json\n├── .gitignore\n├── public\n│   ├── favicon.ico\n│   ├── index.html\n│   ├── logo192.png\n│   ├── logo512.png\n│   ├── manifest.json\n│   └── robots.txt\n└── src\n    ├── App.css\n    ├── App.js\n    ├── App.test.js\n    ├── index.css\n    ├── index.js\n    ├── logo.svg\n    ├── serviceWorker.js\n    └── setupTests.js\n \n \n Start the app \n \n cd  my-widget\n npm  start\n Wrap with Custom Element \n \n Add a new file  src/WidgetElement.js  with the following custom element to wrap the entire React app \n \n import  React  from   'react' ; \n import  ReactDOM  from   'react-dom' ; \n import  App  from   './App' ; \n\n class   WidgetElement   extends   HTMLElement   { \n     connectedCallback ( )   { \n         this . mountPoint  =  document . createElement ( 'div' ) ; \n         this . appendChild ( this . mountPoint ) ; \n        ReactDOM . render ( < App  / > ,   this . mountPoint ) ; \n     } \n } \n\ncustomElements . define ( 'my-widget' ,  WidgetElement ) ; \n\n export   default  WidgetElement ; \n \n The React  root  node is programatically generated in the  connectedCallback  method when the custom element is added to the DOM. \n TIP \n connectedCallback  is a lifecycle hook that  runs each time the element is added to the DOM. \n \n Custom Elements \n \n Must contain a hyphen  -  in the name. \n Cannot be a single word. \n Should follow  kebab-case  for naming convention. \n Import Custom Element \n \n Open  src/index.js . The initial file looks like: \n \n import  React  from   'react' ; \n import  ReactDOM  from   'react-dom' ; \n import   './index.css' ; \n import  App  from   './App' ; \n import   *   as  serviceWorker  from   './serviceWorker' ; \n\nReactDOM . render ( < App  / > ,  document . getElementById ( 'root' ) ) ; \n\n // If you want your app to work offline and load faster, you can change \n // unregister() to register() below. Note this comes with some pitfalls. \n // Learn more about service workers: https://bit.ly/CRA-PWA \nserviceWorker . unregister ( ) ; \n \n \n Replace the entire file with these two lines \n \n import   './index.css' ; \n import   './WidgetElement' ; \n Test Micro Frontend \n \n \n Open  public/index.html \n \n \n Replace  <div id=\"root\"></div>  with the custom element  <my-widget /> \n \n \n    < body > \n     < noscript > You need to enable JavaScript to run this app. </ noscript > \n     < my-widget   /> \n    ...\n   </ body > \n \n Congratulations! \n You’re now running  React  in a containerized micro frontend. \n Build the Resource URL \n Add your micro frontend to Entando by uploading the JavaScript and CSS files to the  public  folder. This is the way Entando makes files available to the public. \n Add Widget \n First, add a widget to get the resource URL for the  public  folder. Then use the same widget to add the Micro Frontend to Entando. \n \n \n Go to  Components > Micro frontends & Widgets  in the App Builder \n \n \n Click  Add  in the lower right corner \n \n \n \n \n Enter the following: \n \n \n Title: My Widget  → enter both English and Italian languages \n Code: my_widget  → dashes are not allowed \n Group: Free Access \n Icon :  → upload an icon of your choice \n In the center panel under  Custom UI , enter the following: \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < @wp . resourceURL  /> \n \n \n Click  Save \n \n TIP \n <#assign wp=JspTaglibs[ \"/aps-core\"]>  gives you access to the  @wp  object where you can use environment variables like  resourceURL . \n Add Page \n Next, add the widget to a page to view the  Resource URL .\nIf you're getting started with a new install of Entando, add the widget to the  Home  page. \n \n \n For Experienced Entando users: Add a new page → Add your widget to the page \n \n \n \n \n Go to  Pages  →  Management \n \n \n Next to the  Home  folder, under  Actions , →  Edit \n \n \n In the  Title  field, choose  My Widget \n \n \n In the Code field, choose  my_widget \n \n \n Under Page groups, in the Owner group field, choose  Free Access \n \n \n Scroll down to  Page Template  and select  Single Frame Page . Leave all other fields blank or in the default setting. \n \n \n Click  Save and Design . You are now in the page Designer. \n \n \n In the Search field of the right sidebar, type  My Widget . It will show as an option. \n \n \n Drag and drop  My Widget  into the  Sample Frame  in the body of the page \n \n \n Click  Publish \n \n \n In the top right corner, click  View Published Page . This will take you to a blank home page with your widget. \n \n \n Copy the  Resource URL  at the top. For example, this is the URL in a quickstart environment set up via the Getting Started guide: \n \n \n /entando-de-app/cmsresources/\n Build It \n With the Resource URL where the new React App will be hosted, you are ready to build. \n \n \n Create an  .env.production  file in the root of  my-widget  project \n \n \n Add the  PUBLIC_URL  into the file. \n \n \n PUBLIC_URL=/entando-de-app/cmsresources/my-widget\n \n Notes \n \n /entando-de-app/cmsresources/  is the Resource URL for your Entando application \n /my-widget  is the public folder that's created to host the files. \n npm build \n \n \n Open a command line and navigate to the project root of your  my-widget \n \n \n Run the command: \n \n \n npm  run build\n \n \n Rename the following files generated in the  build  directory \n \n \n \n \n Example of Generated Build File \n Rename to \n Function \n \n \n \n \n build/static/js/2.f14073bd.chunk.js \n static/js/vendor.js \n Third-party libraries \n \n \n build/static/js/runtime-main.8a835b7b.js \n static/js/runtime.js \n Bootstrapping logic \n \n \n build/static/js/main.4a514a6d.chunk.js \n static/js/main.js \n App \n \n \n build/static/css/main.5f361e03.chunk.css \n static/css/main.css \n Stylesheet \n \n \n \n Generated Build Files \n The JavaScript and CSS files are renamed so App Builder can deploy the new versions of the micro frontend without having to update the  Custom UI  field of the widget. \n \n If you want to use the original  file names with the content hashes to avoid potential caching issues in your browser , update the  Custom UI  field of your widget when deploying new versions of your micro frontend. The  Custom UI  settings will be covered in the next section. \n Additional Deployment Options \n \n Install the micro frontend from a bundle in the  Entando Component Repository . \n Add the micro frontend to  Entando App Builder . \n Load the micro frontend from an API. \n Host Micro Frontend \n Now you are ready to host the micro frontend in Entando. \n Create Public Folder \n \n \n Navigate to  Entando App Builder  in your browser \n \n \n Click  Administration  at the lower left hand side of the screen \n \n \n Click the  File browser  tab \n \n \n Choose the  public  folder \n \n \n Click  Create folder \n \n \n Enter  my-widget \n \n \n Click  Save \n \n \n Click  my-widget \n \n \n Create the same folder structure as your generated build directory \n \n \n \n my-widget/static/css \n my-widget/static/js \n my-widget/static/media \n \n \n Upload the renamed files in the corresponding  js  and  css  folders \n \n \n my-widget/static/css/main.css \n my-widget/static/js/main.js \n my-widget/static/js/runtime.js \n my-widget/static/js/vendor.js \n \n Note: You can drag and drop the files in your browser \n \n Upload the  React  logo \n \n \n my-widget/static/media/logo.5d5d9eef.svg  → You don't need to rename this file \n Update Custom UI Field \n \n \n Go to  Components  →  Micro frontends & Widgets \n \n \n Under the  My Widgets  category → next to  My Widget  → under  Action  → select  Edit \n \n \n Update  Custom UI  field: \n \n \n < #assign  wp = JspTaglibs [   \"/aps-core\" ] > \n < link   rel = \" stylesheet \"   type = \" text/css \"   href = \" < @wp . resourceURL  /> my-widget/static/css/main.css \" > \n < script   async   src = \" < @wp . resourceURL  /> my-widget/static/js/runtime.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> my-widget/static/js/vendor.js \" > </ script > \n < script   async   src = \" < @wp . resourceURL  /> my-widget/static/js/main.js \" > </ script > \n < my-widget   /> \n \n \n Click  Save \n View the Widget \n View the React micro frontend in action on your page. \n \n \n In the  Entando App Builder  go back to  Pages  →  Management \n \n \n Next to the page you created, under  Actions →  Design . This takes you back to the page Designer. \n \n \n Click on  View Published Page  on the top right side \n \n \n \n Congratulations! \n You now have a React micro frontend running in Entando. \n \n"},{title:"Add a Configuration Screen in App Builder",frontmatter:{},regularPath:"/v7.0/tutorials/create/mfe/widget-configuration.html",relativePath:"v7.0/tutorials/create/mfe/widget-configuration.md",key:"v-10352daa",path:"/v7.0/tutorials/create/mfe/widget-configuration.html",headers:[{level:2,title:"Create React App",slug:"create-react-app"},{level:2,title:"Add Input Field",slug:"add-input-field"},{level:2,title:"Custom Element",slug:"custom-element"},{level:2,title:"Configuration Screen",slug:"configuration-screen"},{level:2,title:"Add Attribute",slug:"add-attribute"},{level:2,title:"Display Input",slug:"display-input"},{level:2,title:"Build It",slug:"build-it"},{level:2,title:"Update Widget in App Builder",slug:"update-widget-in-app-builder"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Add a Configuration Screen in App Builder \n Entando widgets can be customized through an App Builder configuration screen that is itself a micro frontend. It can be developed and tested in isolation without a running Entando instance. \n Create React App \n Let’s start with the boilerplate provided by  Create React\nApp , probably the most popular one. \n npx create-react-app my-widget-config --use-npm \n my-widget-config\n├── README.md\n├── node_modules\n├── package.json\n├── .gitignore\n├── public\n│   ├── favicon.ico\n│   ├── index.html\n│   ├── logo192.png\n│   ├── logo512.png\n│   ├── manifest.json\n│   └── robots.txt\n└── src\n    ├── App.css\n    ├── App.js\n    ├── App.test.js\n    ├── index.css\n    ├── index.js\n    ├── logo.svg\n    ├── serviceWorker.js\n    └── setupTests.js\n \n Then, type  cd my-widget-config  and  npm start  to start the app. \n Add Input Field \n Let’s start with a simple form: only an input with a label. So, let’s\nedit  App.js \n import React from \'react\';\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { name: \'\'};\n  }\n\n  handleNameChange(value) {\n    this.setState(prevState => ({\n      ...prevState,\n      name: value,\n    }));\n  }\n\n  render() {\n    const { name } = this.state;\n    return (\n      <div>\n        <h1>Sample Entando Widget Configuration</h1>\n        <label htmlFor="name">Name</label>\n        <input id="name" onChange={e => this.handleNameChange(e.target.value)} value={name} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n \n You are free to use your favorite form handling library e.g.,\n Formik ,\n redux-form  (that requirese redux) or others. \n In regards to styling, since this is going to be an App Builder screen,\nwe strongly suggest using  PatternFly\nv3  ( patternfly  and  patternfly-react \npackages) to keep UX coherence. \n Custom Element \n Now, let’s add the web component that will wrap the entire React app.\nLet’s name it  WidgetElement \n import React from \'react\';\nimport ReactDOM from \'react-dom\';\nimport App from \'./App\';\n\nclass WidgetElement extends HTMLElement {\n  constructor() {\n    super();\n    this.reactRootRef = React.createRef();\n    this.mountPoint = null;\n  }\n\n  get config() {\n    return this.reactRootRef.current ? this.reactRootRef.current.state : {};\n  }\n\n  set config(value) {\n    return this.reactRootRef.current.setState(value);\n  }\n\n  connectedCallback() {\n    this.mountPoint = document.createElement(\'div\');\n    this.appendChild(this.mountPoint);\n    ReactDOM.render(<App ref={this.reactRootRef} />, this.mountPoint);\n  }\n}\n\ncustomElements.define(\'my-widget-config\', WidgetElement);\n\nexport default WidgetElement;\n \n Its responsibility is rendering the React app and syncing the React app\nstate in a  config  property. That  must  be named that way. The key to\nApp Builder communication is that it works in three steps: \n \n \n App Builder reads  config  property when the widget config screen is\nrendered \n \n \n config  property is mutated when a user configures the widget \n \n \n When a user saves the config, App Builder retrieves it (again, from\nthe  config  property) and persists it through Entando APIs \n \n \n This means the widget developer can focus on the configuration screens\nwithout having to call Entando APIs to read or write configuration. \n One more JS file to update:  index.js . Starting from this \n import React from \'react\';\nimport ReactDOM from \'react-dom\';\nimport \'./index.css\';\nimport App from \'./App\';\nimport * as serviceWorker from \'./serviceWorker\';\n\nReactDOM.render(<App />, document.getElementById(\'root\'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n \n You only have to import  WidgetElement  plus the css, if needed.\nSomething like \n import \'./index.css\';\nimport \'./WidgetElement\';\n \n We assume we don’t need a service worker for the widget, so we can\ndelete serviceWorker.js. \n To ensure our web component is working we have to edit\n public/index.html . Remove  <div id="root"></div>  from the  body  (we\nprogrammatically generated the react root in the  connectedCallback \nmethod of  WidgetElement ) and add our new web component tag\n <my-widget /> . \n <!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" />\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\n    <title>React App</title>\n  </head>\n  <body>\n    <my-widget-config />\n  </body>\n</html>\n \n \n Note \n the web component tag name ( my-widget-config  in this tutorial)\n must  match the first parameter of the  customElements.define \nmethod. \n \n The page should auto reload and... congrats, you’re running an Entando\nwidget in isolation. \n Configuration Screen \n Next, we’ll build our widget before embedding it into the Entando\ninstance. From the react project root, type \n npm run build \n and a  build/static  directory will be generated. For convenience in this tutorial, rename the generated files: \n \n \n a file like  js/runtime~main.c7dcdf0b.js  to  js/runtime.js \n(bootstrapping logic) \n \n \n a file like  js/2.230b21ef.chunk.js  to  js/vendor.js  (third-party\nlibraries) \n \n \n a file like  js/main.1fd3965a.chunk.js  to  js/main.js  (app) \n \n \n Next load these files into Entando under  public/my-widget-config/static  using  Administration  →  File Browser . \n Now go to  Components  →  Micro frontends & Widgets  and find the original widget we\'re creating the configuration screen for. Edit the widget and update the\n configUI  field. \n {\n  "customElement": "my-widget-config",\n  "resources": [\n    "my-widget-config/static/js/runtime.js",\n    "my-widget-config/static/js/vendor.js",\n    "my-widget-config/static/js/main.js"\n  ]\n}\n \n \n Note \n \n \n It is possible to keep the original names in order to avoid\npotential caching issues, but then you will have to update the\n Config UI  field in the App Builder widget screen each time a new\nversion of the widget is deployed. \n \n \n configUI  is a JSON object, so pay attention to save a\nwell-formed one (the integrated JSON editor will help you) \n \n \n value for  customElement  must match the name of custom tag in\n index.html  and the one passed as parameter to\n customElements.define  in  WidgetElement \n \n \n \n You can now add a page in App Builder, drag the widget into the page template slot and you’ll see the configuration screen we just built. \n Display Widget Configuration \n So, we already created a React micro frontend widget and configuration\nscreen to customize a  name  field. \n In this tutorial we will display that field in our micro frontend\nwidget. \n Add Attribute \n Edit  WidgetElement  to add attribute handling to the custom element,\nand re-render our app when an attribute changes. Now, the  name \nattribute is being read from the custom element and passed as a prop to\nthe react root component ( App ). \n import React from \'react\';\nimport ReactDOM from \'react-dom\';\nimport App from \'./App\';\n\nconst ATTRIBUTES = {\n  name: \'name\',\n};\n\nclass WidgetElement extends HTMLElement {\n\n  static get observedAttributes() {\n    return Object.values(ATTRIBUTES);\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (!Object.values(ATTRIBUTES).includes(name)) {\n      throw new Error(`Untracked changed attribute: ${name}`);\n    }\n    if (this.mountPoint && newValue !== oldValue) {\n      this.render();\n    }\n  }\n\n  connectedCallback() {\n    this.mountPoint = document.createElement(\'div\');\n    this.appendChild(this.mountPoint);\n    this.render();\n  }\n\n  render() {\n    const name = this.getAttribute(ATTRIBUTES.name);\n    ReactDOM.render(<App name={name} />, this.mountPoint);\n  }\n}\n\ncustomElements.define(\'my-widget\', WidgetElement);\n\nexport default WidgetElement;\n \n \n Note \n attributeChangedCallback  is also a custom elements lifecycle hook\nmethod. \n Display Input \n Edit the  App  component now, to make it display the  name  prop. \n import React from \'react\';\nimport \'./App.css\';\n\nfunction App({name}) {\n  return (\n    <div className="App">\n      <header className="App-header">\n        <p>\n          Hello, {name}!\n        </p>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n \n Now, to ensure our custom element is working, we can edit\n public/index.html  and set a value for the  name  attribute of the\ncustom element. \n <!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" />\n    <meta name="viewport" content="width=device-width, initial-scale=1" />\n    <title>React App</title>\n  </head>\n  <body>\n    <my-widget name="Marco" />\n  </body>\n</html>\n \n After page reload, you should be able to display a simple "Hello,\nMarco!" message. \n Build It \n From the react project root, type: \n npm run build \n and the  build/static  directory will be regenerated. Again, for convenience, rename the files and then update them in Entando under  public/my-widget/static  using  Administration  →  File Browser : \n \n \n a file like  js/runtime~main.c7dcdf0b.js  to  js/runtime.js \n(bootstrapping logic) \n \n \n a file like  js/2.230b21ef.chunk.js  to  js/vendor.js  (third-party\nlibraries) \n \n \n a file like  js/main.1fd3965a.chunk.js  to  js/main.js  (app) \n \n \n a file like  css/main.d1b05096.chunk.js  to  css/main.css \n(stylesheet) \n \n \n \n Note \n you could keep the original names in order to avoid potential caching\nissues, but then you will have to update the  Custom UI  field in the\nApp Builder widget screen every time a new version of the widget is\ndeployed. \n \n If the application server you’re running does not have hot deploy\nenabled, restart it. \n Update Widget in App Builder \n Open the  Entando App Builder , go to  Components  →  Micro frontends & Widgets , find the widget  My Widget  and click to edit it. \n Update the  Custom UI  field from: \n <#assign wp=JspTaglibs[ "/aps-core"]>\n<link rel="stylesheet" type="text/css" href="<@wp.resourceURL />my-widget/static/css/main.css">\n<script async src="<@wp.resourceURL />my-widget/static/js/runtime.js"><\/script>\n<script async src="<@wp.resourceURL />my-widget/static/js/vendor.js"><\/script>\n<script async src="<@wp.resourceURL />my-widget/static/js/main.js"><\/script>\n<my-widget />\n \n to \n <#assign wp=JspTaglibs[ "/aps-core"]>\n<link rel="stylesheet" type="text/css" href="<@wp.resourceURL />my-widget/static/css/main.css">\n<script async src="<@wp.resourceURL />my-widget/static/js/runtime.js"><\/script>\n<script async src="<@wp.resourceURL />my-widget/static/js/vendor.js"><\/script>\n<script async src="<@wp.resourceURL />my-widget/static/js/main.js"><\/script>\n<@wp.currentWidget param="config" configParam="name" var="configName" />\n<my-widget name="${configName}" />\n \n We basically added a JSTL tag to extract a field (under  configParam )\nfrom the config field of the current widget and put it in a  configName \nvariable, that we pass to the custom element. \n Save the widget and reload the page that contains the widget. You should see\n Hello, Marco!  as expected. \n'},{title:"Role Based Access Controls",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/create/ms/add-access-controls.html",relativePath:"v7.0/tutorials/create/ms/add-access-controls.md",key:"v-2f589b71",path:"/v7.0/tutorials/create/ms/add-access-controls.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Tutorial",slug:"tutorial"},{level:2,title:"Notes",slug:"notes"},{level:3,title:"Realm Roles versus Client Authorities",slug:"realm-roles-versus-client-authorities"},{level:3,title:"Local versus Kubernetes Testing",slug:"local-versus-kubernetes-testing"},{level:3,title:"Debugging",slug:"debugging"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Role Based Access Controls \n Overview \n This tutorial guides you through adding access controls to your existing Entando project. Security experts recommend following a practice known as  Defense in Depth  where security controls are placed in each layer of an architecture. This tutorial will help you setup such controls in both the frontend and backend of your Entando application. \n For the purpose of this tutorial we'll use the simple Conference application from  this tutorial  as a starting point. Please work through that tutorial if you have not already. \n The basic security setup for a blueprint-generated application allows any authenticated user to access the functionality contained in the MFEs and/or microservices. Our business requirement for this tutorial is to define two kinds of users in our application -  Conference Users  who can view the Conferences in the tableWidget, and  Conference Admins  who can view and also delete Conferences from the tableWidget. \n Tutorial \n Let's start by securing the list of Conferences so only our two user roles can view the list. \n \n Edit  ConferenceResource.java  located in the  src/main/java/com/<ORG>/<NAME>.web.rest  directory. Modify the REST API  Conference:getAllConferences  method by adding the following annotation. \n \n     @PreAuthorize(\"hasAnyAuthority('conference-user','conference-admin')\")\n    public List<Conference> getAllConferences() {\n \n See the  Spring Security documentation  for more details but this restricts use of the  getConference  method to users who have been assigned either the  conference-user  or the  conference-admin  role on the Keycloak client configured for the microservice. In local testing this defaults to the  internal  client but see notes below on how that works in production. \n Now we should verify this security check is working. \n \n Start up your Keycloak, tableWidget MFE, and microservice. See  these instructions  if you need a refresher but these are the basic commands using the ent CLI and Docker for keycloak. \n \n ent prj ext-keycloak start\nent prj be-test-run\n \n Using a separate cmdline: \n ent prj fe-test-run\n \n \n Access the tableWidget MFE, typically on  http://localhost:3000 , using the default admin/admin account. \n \n Once authenticated, you'll get the message \"No conferences are available\" and, if you check your browser console, you should see a  403 (Forbidden)  error for the request made to  localhost:8080/services/conference/api/conferences . This is expected because we have not yet granted the new role to the admin user. \n Now let's give the admin user the correct role. \n \n Login to keycloak on  http://localhost:9080  using the  admin/admin  credentials. \n \n First we need to create the two roles per our requirements. We're going to add the roles to the  internal  client because it's the one configured by default in the Spring Boot application.yml. \n \n Go to  Clients → internal → Roles  and click  Add Role \n Fill in the  Role Name  with  conference-admin  and click  Save \n Repeat steps 5-6 to create the  conference-user  role. \n \n Now we need to map this role to our user. \n \n Go to  Users → View all users → admin → Role Mappings \n Select  internal  for the  Client Roles  and then move  conference-user  from  Available Roles  to  Assigned Roles \n Go back to the MFE and you should now see the full list of Conferences. \n \n We've now successfully secured the  getAllConferences  API but we have more to do. The admin user was granted just the  conference-user  role but still has access to delete Conferences. We need to lock that down. \n \n Go back into the  ConferenceResource.java  file and add this annotation to the  deleteConference  method: \n \n     @PreAuthorize(\"hasAuthority('conference-admin')\")\n    public ResponseEntity<Void> deleteConference(@PathVariable Long id) {\n \n Here we're restricting the delete method to only the  conference-admin  role. \n \n Restart the microservice. By default this will include rebuilding any changed source files. \n Once the microservice is available, go back to the MFE and try deleting one of the Conferences in the list. You should be able to attempt the delete in the UI but you'll get a 403 error in the browser console and an error like this in the service logs: \n \n 2021-03-22 15:56:16.205  WARN 3208 --- [  XNIO-1 task-3] o.z.problem.spring.common.AdviceTraits   : Forbidden: Access is denied\n \n That's exactly what we wanted! This demonstrates that a user without  conference-admin  is unable to call the delete API. \n Next, let's update the MFE so a user without the  conference-admin  authority cannot even see the delete button in the UI. \n \n Edit the  ConferenceTableContainer.js  under  ui/widgets/conference/tableWidget/src/components . Replace the onDelete logic with an additional check on the user's authorities. \n \n     const isAdmin = (keycloak && keycloak.authenticate) ? keycloak.hasResourceRole(\"conference-admin\", \"internal\"): false;\n    const showDelete = onDelete && isAdmin;\n\n    const Actions = ({ item }) =>\n      showDelete ? (\n \n The key logic there is the hasResourceRole call which checks whether the  internal  client role  conference-admin  was mapped to the current user. \n \n View the MFE (whch should have automatically reloaded) and you should see that the delete icon is no longer visible, matching the admin's current permissions.  We've now verified that a user with just  conference-user  can neither see the delete action in the UI nor call its corresponding API. \n \n Next, let's promote the admin user to a full  conference-admin  so they can delete Conferences. \n \n \n Go back into Keycloak at  http://localhost:9080 , then go to  Users → View all users → admin → Role Mappings , and also give the user the  conference-admin  role. \n \n \n Reload the MFE. The delete icons should now be visible and you should be able to successfully delete a Conference from the list. This satisfies our original business requirement. \n Notes \n Realm Roles versus Client Authorities \n This tutorial made use of authorities which in Keycloak are Roles mapped to a User for a specific Client. You could also make use of higher-level Realm Roles assigned directly to users, e.g.  ROLE_ADMIN . That will work but can result in collisions between applications if they happen to use the same roles. \n If you choose to use Realm-assigned roles then the code above would need to change. In the backend, use the following annotations:  @Secured('ROLE_ADMIN)  or  @PreAuthorize(hasRole('ROLE_ADMIN')) . In the frontend, use  keycloak.hasRealmRole  instead of  keycloak.hasResourceRole . See the  Spring Security page  for more examples. \n Local versus Kubernetes Testing \n This tutorial also makes use of the  internal  client configured in the microservice via the application.yml with roles manually created and assigned in Keycloak. In Kubernetes, Entando will automatically create client roles per the bundle plugin definition (see the plugin definition  here  for more information). Those roles will be created for the client specific to the microservice itself, e.g.  <docker username>-conference-server . This client name will be injected as an environment variable into the plugin container itself so the annotations noted above will work both in local and Kubernetes environments. \n The MFE authorization checks in the tutorial explicitly note the client id,  e.g.  internal , which won't work in Kubernetes. There are a couple options here: \n \n Change the application.yml clientId under  security.oauth2.client.registration.oidc  to match the Kubernetes clientId. That's the most secure and allows the MFE checks to work the same in both local and Kubernetes environments. However, you not be be able to use the same clientId depending on how the microservice is deployed \n An alternative is to broaden the MFE authorization check to look for a named role on any client. This could result in overlap with other clients but with appropriately named roles (e.g. prefixed by feature, e.g.  conference-admin ) this could be the most flexible option. This can be provided via a helper function, e.g. in  api/helpers.js : \n \n //Check if the authenticated user has the clientRole for any keycloak clients\nexport const hasKeycloakClientRole = clientRole => {\n  if (getKeycloakToken()) {\n    const { resourceAccess } = window.entando.keycloak;\n    if (resourceAccess) {\n      for (const client in resourceAccess) {\n        // eslint-disable-line no-unused-vars\n        const roles = resourceAccess[client].roles;\n        if (roles && roles.includes(clientRole)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\n \n This would result in a simpler role check: \n     const isAdmin = hasKeycloakClientRole('conference-admin');\n Debugging \n In both local and Kubernetes environments, the default blueprint javascript will make a global variable available in the browser, e.g.  window.entando.keycloak . Examining this variable can help diagnose issues with assigned roles and authorities. In some cases you may need to logout of Entando and re-authenticate in order to get the latest role assignments. \n"},{title:"Generate Microservices and Micro Frontends",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/create/ms/generate-microservices-and-micro-frontends.html",relativePath:"v7.0/tutorials/create/ms/generate-microservices-and-micro-frontends.md",key:"v-06f2bc13",path:"/v7.0/tutorials/create/ms/generate-microservices-and-micro-frontends.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Generate the Project",slug:"generate-the-project"},{level:3,title:"Project Structure",slug:"project-structure"},{level:2,title:"Next Steps",slug:"next-steps"}],lastUpdated:"4/21/2022, 4:11:11 PM",lastUpdatedTimestamp:1650571871e3,content:' Generate Microservices and Micro Frontends \n Overview \n This tutorial describes how to use the Entando Component Generator (ECG) to create microservices and micro frontends for deployment to the  Entando Component Repository  and Entando Applications. The ECG is powered by  JHipster  and leverages the Entando Blueprint. \n \n The general flow of component generation is: \n \n Run the Entando Blueprint to create your components (Spring Boot microservice and optionally React micro frontends) \n Customize and enhance your generated code \n Build an Entando Bundle from your components \n Deploy a  custom resource  for your bundle into Kubernetes \n Install your Entando Bundle into your Entando Application(s) \n Prerequisites \n Use the  Entando CLI  to verify environmental dependencies (e.g. Java, npm, git, JHipster, Entando Blueprint). \n ent check-env develop\n Generate the Project \n Create a project with microservices. \n \n Setup a new project directory \n \n mkdir  testProject  &&   cd  testProject\n \n \n Use  ent jhipster  to generate the project skeleton via the Entando Blueprint \n \n ent jhipster --blueprints entando\n \n \n This triggers a project initialization prompt. Enter "Yes" in response. \n \n The project dir doesn\'t seem to be initialized, should I do it now?  ( Yes ) \n \n Enter "Yes" when prompted with the following overwrite to resolve the conflict: \n \n Overwrite .gitignore? \n \n \n You\'ll be presented with a series of additional prompts pertaining to project configuration. These are echoed below, with the base values for this tutorial in parentheses. Input your preferences, except where a required entry is identified in  bold . Note that the  Enter  key will select the default option. \n \n \n Please provide the project name:  (Up to you) \n \n \n What is the base name of your application?  (Up to you) \n \n \n As you are running in a microservice architecture, on which port would like your server to run? It should be unique to avoid port conflicts.  (8081) \n \n \n What is your default Java package name?  (Up to you) \n \n \n Which *type* of database would you like to use?  (SQL)\n- If no database is selected you\'ll be building a stateless microservice, which is a valid choice, but the rest of this tutorial won\'t work. \n \n \n Which *production* database would you like to use?  (PostgreSQL or MySQL) \n \n \n Which *development* database would you like to use?  (H2 with disk-based persistence) \n \n \n Which cache do you want to use? (Spring cache abstraction)  (Caffeine (local cache, for a single node)) \n \n \n Do you want to use Hibernate 2nd level cache?  (Yes) \n \n \n Which other technologies would you like to use?  ( Don\'t select any other technologies ) \n \n \n Which BE dependencies do you want to use?  (Dependencies maintained by Entando (entando/entando-bundle-bom)) \n \n \n What name would you give to the bundle to share on an Entando Component Repository?  (Up to you) \n \n \n Which is the organization name to use when publishing the docker image?  ( Enter the name of the organization where you are going to push your Docker image. If you\'re using your personal Docker hub account enter your username. ) <-- this can be changed later as needed \n \n \n Would you like to generate micro frontends when creating entities?  (Always) \n \n \n Would you like to enable internationalization support  (Up to you) \n \n \n Please choose the native language of the application  (Up to you) \n \n \n Besides JUnit and Jest, which testing frameworks would you like to use?  (Up to you) \n \n \n Would you like to install other generators from the JHipster Marketplace?  (No) \n \n \n \n \n Next, add an Entity to your microservice and create the corresponding micro frontends. In this tutorial,  Conference  is the name of the entity that will be added to the application. \n \n \n ent jhipster entity Conference\n \n \n \n You\'ll be presented with a series of prompts to add fields to your entity. These are echoed below, with the base values for this tutorial in parentheses. Input your preferences, and note that the  Enter  key will select the default option. \n \n \n Do you want to add a field to your entity?  (Yes) \n \n \n What is the name of your field?  (name) \n \n \n What is the type of your field?  (String) \n \n \n Do you want to add validation rules to your field?  (No) \n \n \n Do you want to add a field to your entity?  (Yes) \n \n \n What is the name of your field?  (location) \n \n \n What is the type of your field?  (String) \n \n \n Do you want to add validation rules to your field?  (No) \n \n \n Do you want to add a field to your entity?  (No) \n \n \n Do you want to add a relationship to another entity?  (No) \n \n \n Do you want to use separate service class for your business logic?  (Up to you) \n \n \n If "yes": \n \n \n Do you want to use a Data Transfer Object (DTO)?  (Up to you) \n \n \n Do you want to add filtering?  (Up to you) \n \n \n \n \n Is this entity read-only?  (Up to you) \n \n \n Do you want pagination and sorting on your entity?  (Yes, with infinite scroll) \n \n \n (If you chose to be prompted to generate micro frontends)  Do you want to generate micro frontends?  (Up to you) \n \n \n \n \n Affirm each overwrite prompt (echoed below) to resolve conflicts as the Blueprint generates controllers, repositories, services and micro frontends for your entity.  Note: Enter "a" in response to the initial prompt to authorize all overwrites to existing files with the necessary configuration changes. \n \n \n Overwrite src/main/resources/config/liquibase/master.xml? \n \n \n Overwrite package.json? \n \n \n Overwrite bundle/descriptor.yaml? \n \n \n Overwrite bundle/plugins/jhipster-plugin.yaml? \n \n \n Overwrite src/main/resources/config/liquibase/master.xml? \n \n \n Overwrite src/main/java/com/mycompany/myapp/config/CacheConfiguration.java? \n \n \n \n \n You have now generated an Entando project, including a Spring Boot microservice with database integration and React-based micro frontends. \n Project Structure \n \n /src/main/docker  contains Docker files to help with local development environments. \n /src/main/java  and  src/main/resources  contain the microservice codebase and configuration. \n /ui  holds the React-based micro frontends. By default, JHipster generates 3 MFEs per entity to contain the details, form, and table. \n /bundle  is used to assemble the project code into an Entando Bundle. \n Next Steps \n Follow one of the links below to learn how to assemble and run a bundle locally or deploy it. \n \n Build and publish a project bundle  to deploy your microservice and micro frontends to the Entando Component Repository \n Learn how to  run Blueprint-generated components locally in dev mode \n Discover the benefits and features of  the Entando Blueprint \n Iterate on your data model  using the JHipster Domain Language (JDL) \n \n'},{title:"Run Blueprint-generated Microservices and Micro Frontends in Dev Mode",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/create/ms/run-local.html",relativePath:"v7.0/tutorials/create/ms/run-local.md",key:"v-17e34c85",path:"/v7.0/tutorials/create/ms/run-local.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"CLI Steps",slug:"cli-steps"},{level:2,title:"Manual Steps",slug:"manual-steps"},{level:3,title:"Start Keycloak using docker-compose",slug:"start-keycloak-using-docker-compose"},{level:3,title:"Start the microservice",slug:"start-the-microservice"},{level:3,title:"Start the table widget",slug:"start-the-table-widget"},{level:3,title:"Start the form widget",slug:"start-the-form-widget"},{level:3,title:"Start the details widget",slug:"start-the-details-widget"},{level:3,title:"Widget Details notes:",slug:"widget-details-notes"},{level:2,title:"Notes",slug:"notes-3"},{level:3,title:"Change Keycloak dev settings",slug:"change-keycloak-dev-settings"},{level:3,title:"The service-url Variable",slug:"the-service-url-variable"},{level:3,title:"User is not authenticated message",slug:"user-is-not-authenticated-message"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Run Blueprint-generated Microservices and Micro Frontends in Dev Mode \n Overview \n This tutorial will take you through running an Entando project (microservice and micro frontends) in a local development environment. If you haven\'t generated your Entando project yet, start with the  Generate Microservices and Micro Frontend  tutorial first. \n The steps below assume you are working in the top-level project directory. \n CLI Steps \n The following steps make use of the Entando  ent prj  command. See the  Manual Steps  section below for a more detailed description of what the individual commands do. \n \n Startup Keycloak. This uses docker-compose under the hood. Since this is using Docker it will continue to run in the background until you stop it via  ent prj ext-keycloak stop . You can also view its logs using  ent prj ext-keycloak logs . \n \n ent prj ext-keycloak start\n \n \n Startup the Spring Boot application containing your microservices. The logs will be shown on the console and you can stop the application via  CTRL+C . \n \n ent prj be-test-run\n \n \n Startup one or more of the frontend widgets, each from its own shell. You can stop the application using  Ctrl+C . This command runs React in development mode so any changes you make to the source files should be immediately seen in the browser. \n \n ent prj fe-test-run\n Manual Steps \n Start Keycloak using docker-compose \n \n Startup the Keycloak server: \n \n    docker-compose  -f src/main/docker/keycloak.yml up\n Notes: \n \n If you have to install docker-compose you can follow this guide:\n https://docs.docker.com/compose/install/ \n By default docker-compose will recreate the Keycloak container (and reset the H2 database) each time it is started. You can make the following changes to persist Keycloak changes across restarts:\n \n Modify the following line in your  src/main/docker/keycloak.yml \n \n \n \n \'-Dkeycloak.migration.strategy=OVERWRITE_EXISTING\',\n \n and replace it with this \n \'-Dkeycloak.migration.strategy=IGNORE_EXISTING\',\n \n \n In the same file, add a persistent volume under  volumes : \n \n  - ./keycloak-db:/opt/jboss/keycloak/standalone/data\n \n Keycloak changes should now be persistent. You can reset your Keycloak database by emptying the  src/main/docker/keycloak-db  directory and restarting the container. \n Start the microservice \n \n \n Start the generated Microservice executing the command: \n ./mvnw\n Notes: \n If you want to reset the widget data (as example if you deleted all rows from the table widget) if during the generation of the microservice you selected "H2 with disk-based persistence" you can delete the target folder, restart the microservice and the data will be regenerated. \n Start the table widget \n Now you can start your generated table widget: \n \n \n Go to the table widget folder in your project: \n cd ui/widgets/YOUR-ENTITY-NAME/tableWidget\n \n \n \n Then install and start your widget executing the command: \n npm install && npm start\n \n \n \n When the widget is started a browser window is opened and the widget URL is loaded \n \n \n If you’re not logged in you’re redirected to the login page. \n \n \n Log in using: \n Username: user\nPassword: user\n \n \n \n After the login process you’ll be redirected to the widget page and you can see the table widget with some generated data. \n Start the form widget \n Now you can start your generated form widget: \n \n \n If you are running another widget, stop it clicking  Ctrl+C  in your widget command line window \n \n \n Go to the form widget folder in your project: \n cd ui/widgets/YOUR-ENTITY-NAME/formWidget\n \n \n \n Then install and start your widget executing the command: \n npm install && npm start\n \n \n \n When the widget is started a browser window is opened with and the widget URL is loaded \n \n \n If you’re not logged in you’re redirected to the login page. \n \n \n Log in using: \n Username: user\nPassword: user\n \n \n \n You’ll be redirected to the widget page and you can see the widget form with the ID 1 loaded. \n Form widget notes: \n If you want to load other data you have to change the index.html file in the folder: \n cd ui/widgets/YOUR-ENTITY-NAME/formWidget/public\n \n and change the id attribute in this line: \n <my-entity-form service-url="%REACT_APP_SERVICE_URL%" id="1" />\n Start the details widget \n You can also start your generated details widget: \n \n \n If you are running another widget, stop it clicking  Ctrl+C  in your widget command line window \n \n \n Go to the details widget folder in your project: \n cd ui/widgets/YOUR-ENTITY-NAME/detailsWidget\n \n \n \n Then install and start your widget executing the command: \n npm install && npm start\n \n \n \n When the widget is started a browser window is opened with and the widget URL is loaded \n \n \n If you’re not logged in you’re redirected to the login page. \n \n \n Log in using: \n Username: user\nPassword: user\n \n \n \n You’ll be redirected to the widget page and you can see the widget form with the ID 1 loaded. \n Widget Details notes: \n If you want to load other data you have to change the index.html file in the public folder: \n cd ui/widgets/YOUR-ENTITY-NAME/detailsWidget/public\n \n and change the "id" attribute in this line: \n <my-entity-details service-url="%REACT_APP_SERVICE_URL%" id="1" />\n Notes \n Change Keycloak dev settings \n If you want to change your Keycloak settings to use another keycloak installation (not the docker-compose pre-configured one) or if you want to change the service-url of your widget you can change the parameters set in the  .env.local  file that was generated by the Entando Blueprint in the root folder of your react widgets: \n cd ui/widgets/YOUR-ENTITY-NAME/tableWidget\n \n then edit the file  .env.local \n By default this variables are set to: \n REACT_APP_SERVICE_URL=http://localhost:8081/services/YOUR-APPLICATION-NAME/api\nREACT_APP_KEYCLOAK_URL=http://localhost:9080/auth\nREACT_APP_KEYCLOAK_REALM=jhipster\nREACT_APP_KEYCLOAK_CLIENT_ID=web_app\n The service-url Variable \n The  service-url  variable is the Microservice API URL. \n User is not authenticated message \n When you run the widgets if you see the message:  User is not authenticated . This means that probably your keycloak application is not running so please check if the docker-compose command is still in execution. \n'},{title:"Update the Project Data Model",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/create/ms/update-data-model.html",relativePath:"v7.0/tutorials/create/ms/update-data-model.md",key:"v-15033c43",path:"/v7.0/tutorials/create/ms/update-data-model.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Update the Project Data Model \n Overview \n This tutorial explains how to use the  Entando Component Generator  powered by  JHipster  to quickly update the data model for your Entando project. \n Prerequisites \n Leverage an existing project or  create a project  and navigate to the root folder. The steps below assume you're working in the top-level project directory. \n Tutorial \n \n Use JHipster to extract the current application description. The resulting JHIpster Domain Language (JDL) file contains your project's application configuration and entity definitions. \n \n ent jhipster export-jdl export.jdl\n \n \n To strip unnecessary information, create a new file comprising only the elements that describe entities. If you followed the  project generation tutorial , that could be as simple as \n \n entity Conference {\n  name String\n}\n \n \n \n You can enhance this definition by adding fields, entities, table mappings, field validation, etc. This is easily accomplished with the  online JDL-Studio or corresponding JHipster IDE plugins/extensions . \n \n \n Create a new file containing your enhanced data model, e.g.  conference.jdl . \n \n \n entity Conference {\n  name String required\n  location String\n  date ZonedDateTime\n}\n\nentity Session {\n  name String required\n  track Track required\n}\n\nenum Track {\n  BUSINESS, TECHNICAL\n}\n\nrelationship OneToMany {\n   Conference to Session\n}\n \n The above adds two fields to the Conference entity, introduces the Session entity plus an enum, and creates a mapping between the two entities. Below is the updated data model in JDL-Studio: \n \n \n Import the JDL file into your application. You will be prompted with the option to generate MFEs if this was requested during project generation. \n \n ent jhipster import-jdl conference.jdl\n \n If the original project structure has been retained, this step will update your data model, add entries to Liquibase to upgrade database schema during deployment, add service methods to your microservice, add fields to your MFEs, etc. \n \n You can now build your updated project and  run it locally  or  deploy it to Entando . To execute a comprehensive local test, use the following commands to build the project \n \n ent prj build\nent prj xk start\nent prj be-test-run\nent prj fe-test-run\n \n then start Keycloak, the microservice, and one of the MFEs. \n Definition enhancement through build and test can be repeated as many times as needed throughout the life of your project. \n"},{title:"Export and Publish a Bundle",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/create/pb/export-bundle-from-application.html",relativePath:"v7.0/tutorials/create/pb/export-bundle-from-application.md",key:"v-5f395013",path:"/v7.0/tutorials/create/pb/export-bundle-from-application.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:3,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Export an Entando Bundle",slug:"export-an-entando-bundle"},{level:3,title:"Setup the Keycloak client",slug:"setup-the-keycloak-client"},{level:3,title:"Create env.json",slug:"create-env-json"},{level:3,title:"Run the Bundler",slug:"run-the-bundler"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Export and Publish a Bundle \n Overview \n Use the Entando bundler command to export a bundle of Entando components from an existing Entando application. An Entando bundle can be used to do the initial install of Entando components into an Entando application, migrate Entando components from one environment to another (e.g. Dev to QA), to provide a template for building a new Entando application, or as the skeleton of an Entando solution. The output of this command is the same bundle directory structure created by an Entando project including a bundle descriptor file. \n Prerequisites \n \n Use the  Entando CLI  to verify you have the prerequisites in place for this tutorial (e.g. git, entando-bundler). \n \n ent check-env develop \n \n \n You\'ll also need a running Entando application. \n You\'ll need admin access to Keycloak or admin access to Kubernetes to set it up. \n \n The tutorial assumes you\'re using an Entando quickstart application. You may need to adjust the specific URLs, credentials, namespaces, etc. for a custom application. \n Export an Entando Bundle \n Setup the Keycloak client \n You\'ll need to setup a Keycloak client with the appropriate permissions for the bundler to access all of the necessary Entando APIs. \n \n Find the Secret for the Keycloak admin account. If you already have the admin credentials, then you can skip to step 3. \n \n kubectl get secrets -n entando \n \n In a quickstart application, the Secret is named. default-sso-in-namespace-admin-secret \n \n Determine the admin password using the Secret name. \n \n kubectl get secret default-sso-in-namespace-admin-secret -n entando -o go-template = "{{println}}Username: {{.data.username | base64decode}}{{println}}Password: {{.data.password | base64decode}}{{println}}{{println}}" \n \n Example output: \n Username: entando_keycloak_admin\nPassword: 1pTZev82Ee\n \n \n Login to Keycloak using the admin credentials. The URL will be something like  http://YOUR-HOST-NAME/auth/ . You can use this command to verify the URL. \n \n kubectl describe ingress/quickstart-ingress\n \n \n Go to  Clients  →  Create . \n Enter a  Client ID  of your choice, e.g.  entando-bundler , and click  Save . \n The  Settings  tab should be shown. Edit the following values: \n \n \n Access Type:  confidential \n Service Accounts Enabled:  On \n Valid Redirect URLs:  * \n Web Origins:  * \n \n \n Click  Save \n Go to the  Service Account Roles  tab \n Select  Client Roles  →  quickstart-server \n Select  Available Roles  →  superuser . \n Click  Add Selected  to add  superuser  to the  Assigned Roles . This change will be saved automatically. \n Go to the  Credentials  tab and copy the  Secret  shown there. You\'ll need this in the next section. \n Create env.json \n \n Create a directory where you\'ll run the bundler and change to that directory. \n \n mkdir  testBundle ;   cd  testBundle\n \n \n Create an  env.json  file with the environment URLs and client credentials. The  clientId  and  clientSecret  are from steps 5 and 12 above. \n \n { \n    "coreBaseApi" :   "http://YOUR-HOST-NAME/entando-de-app" , \n    "k8ssvcApi" :   "http://YOUR-HOST-NAME/k8s" , \n    "clientId" :   "YOUR-CLIENT-ID" , \n    "clientSecret" :   "YOUR-CLIENT-SECRET" \n } \n Run the Bundler \n \n Create a child directory to hold the bundler output. Using the name  bundle  allows you to easily use the  ent prj  command with this bundle. \n \n mkdir  bundle\n \n \n Run the bundler command with your preferred settings. \n \n ent bundler from-env --location bundle --code my-test-bundle --description “My Test Bundle”\n \n The bundler will inspect the application using the Entando APIs, collect information about the individual components, construct the appropriate descriptor files, and finally assemble the top-level descriptor file. \n $ ls bundle\nassets      contentModels  contents         fragments  labels     pageModels  resources\ncategories  contentTypes   descriptor.yaml  groups     languages  pages       widgets\n \n At this point you have a full Entando project structure. You can inspect the output to edit the exported components or you could  deploy it to another Entando application . \n'},{title:"Use Postman with OAuth2 APIs",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/create/ms/use-postman-with-oauth2.html",relativePath:"v7.0/tutorials/create/ms/use-postman-with-oauth2.md",key:"v-5ad381f6",path:"/v7.0/tutorials/create/ms/use-postman-with-oauth2.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Create a new Postman Collection",slug:"create-a-new-postman-collection"},{level:2,title:"Define Collection variables",slug:"define-collection-variables"},{level:2,title:"Configure new token generation",slug:"configure-new-token-generation"},{level:2,title:"Update your Keycloak configuration (Postman Web only)",slug:"update-your-keycloak-configuration-postman-web-only"},{level:2,title:"Generate a new token",slug:"generate-a-new-token"},{level:2,title:"Add a request",slug:"add-a-request"},{level:2,title:"Troubleshooting",slug:"troubleshooting"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Use Postman with OAuth2 APIs \n Overview \n The tutorial will help you to configure Postman to reach your APIs secured with OAuth2 and Keycloak. \n In this tutorial, we will call an API from an application generated with the  Entando JHipster blueprint . \n Prerequisites \n Get the  Postman  application or create an account to use it on the web.\nThe screenshots in this tutorial have been made with the current web version. \n Create a new Postman Collection \n According to the official website \n \n Postman's collection folders make it easy to keep your API requests and elements organized. \n \n This helps us to gather different requests under the same folder but also to share the configuration and the Auth mode among them. \n Click on the button when you are on the collection left menu. \n \n Name it as you want, we usually try to create a collection per application. \n Define Collection variables \n Postman allows us to define variables for a given collection, and we can use them at the collection level to configure the OAuth2 settings but also at the request level. \n \n Please note you can choose the variable names you want, according to what makes sense to you. \n \n \n \n Variable \n Default value in a Blueprint-based Entando App \n Details \n \n \n \n \n client_id \n web_app \n The client id account used to authenticate the user \n \n \n client_secret \n web_app \n The secret for the client_id \n \n \n scope \n openid profile email \n The scope to retrieve during the auth \n \n \n access_token_url \n http://localhost:9080/auth/realms/jhipster/protocol/openid-connect/token \n The token endpoint \n \n \n auth_url \n http://localhost:9080/auth/realms/jhipster/protocol/openid-connect/auth \n The authorization endpoint \n \n \n base_url \n http://localhost:8081/api \n The url all the requests start with \n \n \n \n Notes: \n \n The base_url variable is added for convenience, but is not mandatory for authentication purposes \n \n \n Use the .well-known endpoint to retrieve these values if you don't have them\n http://keycloak_host:keycloak_host/auth/realms/<realm>/.well-known/openid-configuration \nFor a local running app it should be  http://localhost:9080/auth/realms/jhipster/.well-known/openid-configuration \n \n \n In the Postman application, you may need to save the Collection in order to make the variables available in the following steps. \n Configure new token generation \n In your collection view, click on the  Authorization  tab and define the type to  OAuth 2.0  as-is:\n \n Enter the fields with the variables previously defined. You can define the  Token Name  with the value you want: \n \n Please note, regarding you are using the Postman Web or the app, the  Callback URL  field contains different values.\nBasically, the Web solution needs to use a specific value while the App just need to use a value already\npresent in the Keycloak configuration (e.g.  http://locahost:8081 ) \n This is the reason why we need to update the Keycloak configuration with Postman Web. \n Update your Keycloak configuration (Postman Web only) \n To generate a new token you need to ensure the Postman redirect URL is configured in the Keycloak admin panel. There  https://oauth.pstmn.io/v1/browser-callback  (or a wildcard  * ) should be present in the  Valid Redirect URIs  list for your client.\nThis URL is used to redirect to the Postman app after authentication successfully completes. \n Generate a new token \n Clicking on the  Get New Access Token  will open the Keycloak login form and then you can authenticate with the user to be used when testing the API. The user will need to already be assigned the appropriate roles.\n \n After the authentication succeeds, you should be redirected to the Postman app.\n \n The token is then displayed in a window and you can confirm its use by clicking on the  Use Token  button.\n Add a request \n The next step is to add a request to the collection, using the previous OAuth2 config as an authorization method.\nIn your collection name click on the  Add request  entry\n \n In the  Auth  tab select  Inherit auth from parent . Requests in the collection can then inherit those settings,\nallowing you to execute a configuration step every time you add a new one.\n \n Postman will then automatically add an Authorization header with a Bearer  Token  value where  Token  is the token value generated in the previous step. \n \n Note: \n \n By default, these headers are hidden. A button allows you to display them. \n \n Finally, you can define the endpoint you want to consume, the HTTP method to use and add more headers if needed. \n \n The expected result should be a 2XX code from our API.\nIf you experience a 401 error, this probably means that the token is not valid anymore.\nBecause the token has an expiration period, it's mandatory to refresh it frequently.\nTo get a new token execute the  Generate a new token  section again. \n Troubleshooting \n For security reasons, the access token timeout should always be short to avoid security issues if someone steals the token.\nThe refresh token can be used to acquire a new access token when the access token has expired. The process would be: \n \n Get the Access token (and the Refresh Token) \n Call the API \n Check if the token is still valid\n \n The token is valid: execute the call \n The token has expired: use the refresh token to generate a new Token and execute the call \n \n \n \n Unfortunately, Postman doesn't handle the refresh action if the token has expired, and you need to generate a new one by yourself by clicking on the  Get new access token  button.\nTo avoid this manual action you can make the token longer by updating the timeout over 5 min. However, we do not recommend this solution outside of a local development environment. \n The Postman team is tracking this issue and plans to include this feature in a future release:  https://github.com/postmanlabs/postman-app-support/issues/10112 . \n"},{title:"Add a GitHub Actions CI Workflow",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/create/pb/github-actions-workflow.html",relativePath:"v7.0/tutorials/create/pb/github-actions-workflow.md",key:"v-54e2540d",path:"/v7.0/tutorials/create/pb/github-actions-workflow.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Create a Backend Workflow",slug:"create-a-backend-workflow"},{level:2,title:"Add a Frontend Job",slug:"add-a-frontend-job"},{level:2,title:"Extend the Frontend Job for Multiple MFEs",slug:"extend-the-frontend-job-for-multiple-mfes"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Add a GitHub Actions CI Workflow \n Overview \n This tutorial shows how to use the JHipster  ci-cd  sub-generator to quickly create a basic GitHub Actions Workflow for the microservices and micro frontends (MFEs) generated by the Entando Component Generator. \n Prerequisites \n \n An existing project with a GitHub repository. See the  Entando Component Generator  to create a new one. \n GitHub Actions . These are enabled by default without additional configuration. Please note public repositories currently qualify for unlimited usage but private repositories can encounter usage restrictions. \n Use the  Entando CLI  to verify you have the command line prerequisites in place for this tutorial (e.g. npm, git, JHipster). \n Create a Backend Workflow \n \n Go to your main project folder in the shell \n Run the JHipster  ci-cd  subgenerator \n \n ent jhipster ci-cd\n \n \n Select  GitHub Actions \n Click ENTER to choose no  tasks/integrations  and generate the default workflow \n The initial workflow file is available at  .github/workflows/github-ci.yml \n Commit the workflow file and push it to GitHub. \n \n git   add  .github\n git  commit -m  \"Add the backend CI job\" \n git  push\n \n \n Since the workflow runs on  push  or  pull-request , you can immediately check the GitHub  Repository → Actions  tab to see the status of the corresponding jobs. The standard tests in a Blueprint-generated project can take a few minutes to run. \n \n \n You can review the logs for each step to diagnose CI failures. \n If the workflow fails or times out, you should receive an email notification. \n You can choose to skip the CI workflow by including  skip ci  or  ci skip  in your commit message. This can be customized in the job definition. \n See the  GitHub Actions  documentation for more information on alternative trigger options. \n \n Next, let's expand the workflow to also include the micro frontends. \n Add a Frontend Job \n We'll now add a second job to the workflow definition, specifically for the micro frontends. Optionally, you could also create a completely separate workflow file if you'd prefer. \n \n Add a new entry under  jobs: , paying attention to the YAML indentation. \n \n      micro-frontends : \n      name :  micro frontend job\n      runs-on :  ubuntu - latest\n      if :   \"!contains(github.event.head_commit.message, '[ci skip]') && !contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.pull_request.title, '[skip ci]') && !contains(github.event.pull_request.title, '[ci skip]')\" \n      steps : \n        -   uses :  actions/checkout@v2\n        -   uses :  actions/setup - node@v2.1.4\n          with : \n            node-version :   '14.15.0' \n        -   name :  Run tests\n          run :   | \n           cd ui/widgets/conference/detailsWidget\n           npm install\n           npm test \n \n \n (Optional) If your widget path differs from the standard Blueprint example, you should change the first command in  Run tests  to match your path. \n Commit and push the changes to GitHub. \n \n    git add .github\n   git commit -m \"Add the microfrontend CI job\"\n   git push\n \n \n Now check the GitHub  Repository → Actions  tab to see the status of the jobs. When the  micro-frontends  job is complete, you should see something like this: \n \n Test Suites: 2 passed, 2 total\nTests:       4 passed, 4 total\nSnapshots:   0 total\nTime:        2.911s\nRan all test suites.\n Extend the Frontend Job for Multiple MFEs \n You may have multiple micro frontends or widgets in your project. One option is to duplicate the job for each MFE, but you can also use the GitHub Actions matrix feature to avoid duplicating those definitions. \n \n Change your job definition to the following. Note the changes: \n \n \n The  job.name  is dynamically set using the MFE matrix name \n The  job.strategy  has been set to  fail-fast:false  so all MFEs will be tested, rather than stopping the job on the first failure \n The  job.strategy.matrix.mfe  provides the list of MFEs in this project. You should update this list to match your project. \n The first command in  Run tests  is parametrized to use the MFE matrix name \n \n      micro-frontends : \n      name :  $ { {  matrix.mfe  } }  micro frontend\n      runs-on :  ubuntu - latest\n      if :   \"!contains(github.event.head_commit.message, '[ci skip]') && !contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.pull_request.title, '[skip ci]') && !contains(github.event.pull_request.title, '[ci skip]')\" \n      strategy : \n        fail-fast :   false \n        matrix : \n          mfe : \n            -  ui/widgets/conference/detailsWidget\n            -  ui/widgets/conference/formWidget\n            -  ui/widgets/conference/tableWidget\n      steps : \n        -   uses :  actions/checkout@v2\n        -   uses :  actions/setup - node@v2.1.4\n          with : \n            node-version :   '14.15.0' \n        -   name :  Run tests\n          run :   | \n           cd ${{ matrix.mfe }}\n           npm install\n           npm run test \n \n \n Now check the GitHub  Repository → Actions  tab to see the status of the jobs. You should see that the tests were run for all configured MFEs with a summary message like this:  3 jobs completed . \n \n"},{title:"Install Plugins and Micro Frontends without a Bundle",frontmatter:{},regularPath:"/v7.0/tutorials/create/pb/deploy-components-without-bundle.html",relativePath:"v7.0/tutorials/create/pb/deploy-components-without-bundle.md",key:"v-55d3d333",path:"/v7.0/tutorials/create/pb/deploy-components-without-bundle.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Generate a Docker image",slug:"generate-a-docker-image"},{level:2,title:"Publish the Docker image",slug:"publish-the-docker-image"},{level:2,title:"Deploy the plugin",slug:"deploy-the-plugin"},{level:2,title:"Link the plugin to the App",slug:"link-the-plugin-to-the-app"},{level:2,title:"Upload the Static Resources",slug:"upload-the-static-resources"},{level:2,title:"Use the Micro Frontend and Microservice",slug:"use-the-micro-frontend-and-microservice"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Install Plugins and Micro Frontends without a Bundle \n Overview \n In this tutorial you will learn how to install a plugin and micro frontend, generated with the Entando Blueprint, without the need to include the components in a bundle. Once the plugin is deployed into a cluster, link it to the EntandoApp, upload the static resources, and create the widgets for your app from the Entando App Builder. \n Prerequisites \n \n \n An Entando plugin built with the Entando Component Generator and populated with Micro\nFrontends.  Generate a plugin and Micro Frontend here . \n \n \n Node and npm installed (use the LTS version) \n \n \n Docker installed and able to upload images to Docker Hub or a repository of your choice \n \n \n An instance of the Entando platform running on Kubernetes. See  Getting Started . \n \n \n Note \n Here is a definition of an Entando plugin , including information on the runtime contract required for using non-Java based plugins. \n Generate a Docker image \n JHipster uses the JIB Maven plugin to generate a Docker image for your\nmicroservice. \n The name of the output image generated with JIB during the setup wizard is defined with: \n \n The organization name you chose; default is set to  entando \n The name of the application \n Version  0.0.1-SNAPSHOT \n \n For example, a custom organization name of  myorg  and an application name of  jhipster  will result in a Docker image named  myorg/jhipster:0.0.1-SNAPSHOT . \n \n Build the Docker image: ./mvnw -Pprod clean package jib:dockerBuild\n \n \n \n The output image name can also be set by customizing the  ./mvnw  command using the  -Djib.to.image  parameter. With the organization name  myneworg , name  myapp  and version  latest , use: \n  ./mvnw -Pprod clean package jib:dockerBuild -Djib.to.image=myneworg/myapp:latest\n \n Note \nThe output image name can be changed in the  pom.xml  file by configuring the  plugins.plugin.jib-maven-plugin.configuration.to.image  tag as follows: \n  <plugin>\n   <groupId>com.google.cloud.tools</groupId>\n   <artifactId>jib-maven-plugin</artifactId>\n   <configuration>\n     \x3c!-- ... --\x3e\n     <to>\n       <image>\x3c!-- use a custom value here --\x3e</image>\n     </to>\n     \x3c!-- ... --\x3e\n   </configuration>\n </plugin>\n \n Warning \n If you change the target image of the Docker build, remember to update\nthe plugin metadata in the bundle accordingly. Once you deploy the plugin, you will also have to change the plugin Custom Resource in the  bundle/plugins  folder to point to the correct image. \n Publish the Docker image \n Publish the Docker image for the microservice to make it\navailable for the bundle installation in the cluster. Docker Hub or an equivalent registry will do. \n docker push <name-of-the-image:tag>\n Deploy the plugin \n You can now deploy the plugin Custom Resource generated by the Entando Blueprint in the  bundle/plugins  folder. \n From the JHipster project directory, deploy the plugin: \n cd  bundle/plugins\n\nkubectl create -f  < plugin-file.yaml >  -n entando\n Link the plugin to the App \n Once the plugin server deployment is up and running, create an  EntandoAppPluginLink Custom Resource \nto make the plugin API available from the EntandoApp domain. \n Here is an example of a EntandoAppPluginLink Custom Resource. Some defaults are: \n \n The EntandoPlugin generated with the Blueprint is  my-demo-plugin \n The EntandoApp exposing  my-demo-plugin  API is  quickstart . This is the app name in the environment built with the Getting Started instructions. \n Both are deployed on the  entando  namespace \n The link is named  quickstart-to-my-demo-plugin-link \n The name of the link yaml is  my-link.yaml \n \n TIP \n Change the defaults as needed if you used your own custom names for any of these fields. \n \n apiVersion: entando.org/v1\nkind: EntandoAppPluginLink\nmetadata:\n  name: quickstart-to-my-demo-plugin-link\n  namespace: entando\nspec:\n  entandoAppName: quickstart\n  entandoAppNamespace: entando\n  entandoPluginName: my-demo-plugin\n  entandoPluginNamespace: entando\n \n \n Add this link to your environment \n \n kubectl create -f my-link.yaml -n entando\n \n A new link deployer will start and work behind the scenes to add your plugin  ingressPath  (part of the plugin  spec ) to the EntandoApp ingress. \n Upload the Static Resources \n Now that the plugin and app are linked, generate the Micro Frontend from the App Builder\nand upload the static resources like  js  and  css  files. \n \n \n From the App Builder, go to  Configuration -> File Browser \n \n \n Navigate to the  public  folder. Create a new folder using the name of the bundle (the value is in the  code  field available in the  /bundle/descriptor.yaml  file of the blueprint project) or use a custom name such as  demo-widget . \n \n \n Upload all the resources in the  /bundle/resources  folder of the project into the new folder \n \n \n Warning \n If you do not duplicate the folder name and structure of  /bundle/resources , you will need to update the references to them in the customUI/configUI of the widget. \n \n \n \n In the App Builder, go to  Components → Micro frontends & Widgets \n \n \n Select  Add  to create the widget \n \n \n Enter the following with your choices for  anyname : \n \n \n \n Title: anyname1  → enter for both English and Italian languages \n Code: anyname2  → dashes are not allowed \n Group: Free Access \n Icon :  → upload an icon of your choice \n \n \n \n Under customUI, copy one of the widgets you generated with the Blueprint.\nFor example, the customUI for the  detailWidget  of the Conference entity is available in\n /bundle/ui/widgets/conference/detailsWidget/conference-details-widget.ftl \n \n \n If your path differs from the default, update the service URL to match the location where the ingress for your microservice was deployed. \n \n \n For example, update the service-URL value with the relative path of your service if you\'re deploying a bundle  <car-table service-url="/newBp/api"  /> . \n Or use the full path if you\'re deploying the BE and FE individually\n <car-table service-url="http://newbp-plugin-entando.192.168.64.7.nip.io/newBp/api"/> . \n \n If you\'re creating a new page from scratch or your page is missing the Keycloak fragment, you can add it with this freemarker snippet: \n \n <@wp.fragment code="keycloak_auth" escapeXml=false />\n \n Note \n Your Entando application includes a  keycloak_auth  fragment that will inject the token\nand connection to Keycloak that your Micro Frontends need to invoke the protected APIs. To view the token, go to  Components → UX Fragments  in the App Builder and search for  keycloak_auth . \n Use the Micro Frontend and Microservice \n Now the Micro Frontends and microservice is available for use in your Entando App Builder. \n'},{title:"Build and Publish a Project Bundle",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/create/pb/publish-project-bundle.html",relativePath:"v7.0/tutorials/create/pb/publish-project-bundle.md",key:"v-b645419a",path:"/v7.0/tutorials/create/pb/publish-project-bundle.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"CLI Steps",slug:"cli-steps"},{level:2,title:"Manual Steps",slug:"manual-steps"},{level:3,title:"Build a Docker Image for Microservices",slug:"build-a-docker-image-for-microservices"},{level:3,title:"Build Your Bundle and Publish to Git",slug:"build-your-bundle-and-publish-to-git"},{level:2,title:"Install the Bundle into an Application",slug:"install-the-bundle-into-an-application"},{level:2,title:"Use the Entando CLI",slug:"use-the-entando-cli"},{level:2,title:"Use the App Builder",slug:"use-the-app-builder"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Build and Publish a Project Bundle \n Overview \n This tutorial demonstrates how to deploy an existing Entando project directory into the  Entando Component Repository  (ECR). This involves building a Docker image from your microservice, creating an Entando Bundle, checking your Bundle artifacts into Git, and deploying the Bundle into Kubernetes. \n The Entando CLI (ent) automates many of the tasks involved in deploying an Entando Bundle, but you can also choose to perform these tasks manually. \n Prerequisites \n \n Use the  Entando CLI  to verify you have the prerequisites in place (e.g. Java, npm, git) \n \n ent check-env develop\n \n \n Your Git credentials \n A Git repository \n An Entando instance \n An Entando project directory, either  developed by hand  or  generated by the Entando Component Generator \n CLI Steps \n The following steps make use of the Entando  ent prj  command and its publication system (pbs) convenience methods. See the  Manual Steps  section below for a more detailed description of the underlying tasks. \n \n Build the project using the  ent prj  command. This saves you from having to build each part of the project individually. If you are using a project directory with just a bundle child directory (e.g. a bundle with hand-built components or exported from another environment), then there is nothing to build and you should skip this step. \n \n ent prj build\n \n TIP \n The first run can take longer due to node downloads for any MFE widgets. You can use  ent prj fe-build  or  ent prj be-build  for subsequent runs to independently build just the frontend or backend components. \n \n \n Initialize the bundle directory \n \n ent prj pbs-init\n \n \n Publish the build artifacts to GitHub and Docker Hub \n \n ent prj pbs-publish\n \n \n Deploy the bundle into the ECR \n \n ent prj deploy\n \n Jump to  Install the Bundle into an Application  below to finish installing your bundle. \n Manual Steps \n Build a Docker Image for Microservices \n \n Build the project from the project directory \n \n ./mvnw -Pprod clean package jib:dockerBuild\n \n \n Note \n By default, the organization used to generate the Docker image is  entando . You can customize this value during project initialization by either changing the  pom.xml  file or providing the  -Djib.to.image=<org>/<name>:<version>  to the  jib:dockerBuild  command. \n \n \n Note \n The output image name is generated using the organization value defined during project initialization. You can override the provided values by altering the  pom.xml  file or by customizing the  -Djib.to.image  parameter used by the  ./mvnw  command. \n \n \n Warning \n If you manually override the target image of the Docker build, remember to update the plugin metadata accordingly. \n \n \n View your image and tag \n \n docker  images\n \n Output: \n REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE\nmyusername/example-app   0.0.1-SNAPSHOT      4ec7f05b2b27        33 seconds ago      213MB\n \n \n Publish the Docker image to Docker repository (Docker Hub or equivalent). You may need to first login via  docker login . \n \n docker  push  < name-of-the-image:tag > \n \n For example:  docker push myusername/example-app:0.0.1-SNAPSHOT \n \n Note \n All of the layers are pushed the first time you run this command, which takes time. Subsequent runs are much faster. \n \n Output: \n docker push myusername/example-app:0.0.1-SNAPSHOT\nThe push refers to repository [docker.io/myusername/example-app]\n545361404af4: Pushed\n...\nf1b5933fe4b5: Pushed\n0.0.1-SNAPSHOT: digest: sha256:804b3b91b83094c45020b4748b344f7199e3a0b027f4f6f54109cbb3b8a1f867 size: 2626\n Build Your Bundle and Publish to Git \n \n Populate the bundle with the generated micro frontends using  ./buildBundle.sh  or  npm run populate-bundle \n \n ./buildBundle.sh\n \n \n Important \nIt takes time to populate the bundle with micro frontends. You can watch the progress of this process on the console. \n \n \n \n The output of your bundle is in the top-level  bundle  directory of your microservice \n \n \n Commit your bundle files to Git, separate from the top-level project files \n \n \n echo  bundle  >>  .gitignore\n cd  bundle/\n git  init\n git   add   . \n git  commit -m  "Init Git repository" \n \n \n \n Create a new Git repository, e.g.  my-bundle \n \n \n Add your remote repository as origin and push the bundle \n \n \n git  remote  add  origin https://your/remote/repository.git\n git  push -u origin master\n \n \n Publish a Git tag \n \n git tag -a "v0.0.1" -m "My first tag"\ngit push --tags\n \n \n Generate a custom resource for your bundle. Update the following command with your bundle name, namespace and repository URL. \n \n ent bundler from-git --name = < bundle-name >  --namespace = entando --repository = < your-repository-url >  --dry-run  >  example-bundle.yaml\n \n \n Make your bundle available in Kubernetes \n \n kubectl apply -f example-bundle.yaml -n entando\n Install the Bundle into an Application \n You can either install the bundle through the ent CLI or the  App Builder . \n Use the Entando CLI \n \n In your project folder, run the following command \n \n ent prj  install \n \n \n If you have already installed the bundle, you can use  --conflict-strategy  to adopt a strategy for existing components (CREATE, SKIP, OVERRIDE) \n \n ent prj  install  --conflict-strategy = OVERRIDE\n \n \n Note \n In the event of a timeout or pod failure, refer to the errors captured by the quickstart-cm-deployment and plugin deployer logs. \n Use the App Builder \n \n \n Log into your App Builder and select  Repository  in the lower left \n \n \n Find your bundle and select  Install \n \n \n The Entando Platform downloads and installs the Docker image for your microservice and installs your micro frontends into the Entando Application. You can add these micro frontend widgets to the page(s) of your choice. You can either leverage a page provided by Entando or follow our  Page Management tutorial  to create your own page or page template. Note that your page template must include the UX fragment  keycloak_auth  because an application based on the Entando Blueprint expects a user to be authenticated. \n'},{title:"Install Bundles from a Private Git Repository",frontmatter:{},regularPath:"/v7.0/tutorials/curate/ecr-private-git-repo.html",relativePath:"v7.0/tutorials/curate/ecr-private-git-repo.md",key:"v-c5e75eb8",path:"/v7.0/tutorials/curate/ecr-private-git-repo.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Using SSH keys with Git",slug:"using-ssh-keys-with-git"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Install Bundles from a Private Git Repository \n Overview \n The standard deployment of the Entando Component Repository (ECR) assumes that bundles are checked out from public Git repositories. Public repositories do not require user authentication, but if a customer chooses to limit repository access to specific Git accounts, a private key is required. This document details how to allow the ECR to access a private Git repository. \n For more background information please consult \n \n Entando custom resource reference \n Entando Component Repository overview \n Using SSH keys with Git \n Entando supports connecting to Git repositories with SSH keys. While SSH Git URLs are accepted, HTTPS git URLs are not. For the private key to work correctly, the SSH syntax of  git@github.com:THE-REPO-OWNER-NAME/THE-REPO-NAME.git  must be used (the HTTPS syntax of  https://github.com/THE-REPO-OWNER-NAME/THE-REPO-NAME.git  is not permitted). \n Using the SSH method a developer can generate a public/private keypair, then register the public key with the Git server while securely storing the private key locally. An operation requiring authentication will trigger the Git command line utility to perform a search and compare between the local private key and the public key provided by the server. If the two keys are identical, the operation is allowed to complete. \n Entando allows a Kubernetes Secret containing a Git SSH private key to be mounted in the container hosting the Entando Component Manager service. This container is deployed with the EntandoApp and can be configured from the EntandoApp Custom Resource. To prepare a Secret, first generate the keypair locally using a Docker image, then create the Secret from the directory where the keypair was generated. \n Tutorial \n Below is the recommended flow on Linux. \n \n \n Navigate to a local folder where you intend to create the Secret \n \n \n Generate the SSH keypair from the known SSH client Docker image \n \n \n Run the Docker container in interactive mode and mount the default user SSH directory to a local directory \n docker run -it -v $PWD/entando_ssh:/root/.ssh kroniak/ssh-client /bin/bash \n \n \n \n Generate the keypair from the shell of the resulting container \n ssh-keygen\n \n Select all of the default options, e.g. no passphrase, etc. \n \n \n Attempt to add the fingerprint to the known_hosts file by connecting to your Git server and responding "yes" to the prompt \n ssh git@github.com\n \n This command is expected to fail. \n \n \n Run  exit \n \n \n \n \n Create the Secret. \n \n \n You are now back in the local operating system\'s shell and can navigate to the directory that was mounted using Docker. \n To give yourself access to this folder and create a Secret with the content\n\n1. Change the folder permissions\n\n    ```\n    sudo chmod ag+r entando_ssh -R\n    ```\n    \n2. Create a Secret from the directory\n\n    ```\n    kubectl create secret generic my-git-secret --from-file=entando_ssh -n <<your-namespace>>\n    ```\n    \n3. Confirm that the Secret exists and has at least two keys: known_hosts, and id_rsa. Without these two keys Entando cannot log into Git.\n    \n    ```\n    kubectl get secret my-git-secret -n <<your-namespace>> -o yaml\n    ```\n \n \n \n Link the resulting private key to the account of a user who has access to the applicable Git repositories. Ideally\nthis should be a dedicated service account user with restricted read only access. For GitHub\naccounts, you can follow the  official GitHub instructions. \nWhen prompted, provide the public key that was generated in the entando_ssh directory\n entando_ssh/id_rsa.pub \n \n \n Modify the EntandoApp resource you are deploying to mount the Secret in the  spec.ecrGitSshSecretName  property. Note: In Entando 7 the EntandoApp resource must be configured prior to installation. \n \n \n       kind: "EntandoApp"\n      metadata:\n        annotations: {}\n        labels: {}\n        name: "quickstart"\n      spec:\n        dbms: none\n        replicas: 1\n        ecrGitSshSecretName: my-git-secret\n        standardServerImage: wildfly\n        ingressPath: /entando-de-app\n        ingressHostName: ampie.apps.serv.run\n        environmentVariables:\n          - name: SPRING_PROFILES_ACTIVE\n            value: "default,swagger"\n \n '},{title:"Build and Publish a Simple Bundle",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/create/pb/publish-simple-bundle.html",relativePath:"v7.0/tutorials/create/pb/publish-simple-bundle.md",key:"v-cac1f57e",path:"/v7.0/tutorials/create/pb/publish-simple-bundle.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Create the Project Structure",slug:"create-the-project-structure"},{level:2,title:"Add a Simple Widget",slug:"add-a-simple-widget"},{level:2,title:"Create the Bundle Descriptor",slug:"create-the-bundle-descriptor"},{level:2,title:"Publish the Bundle",slug:"publish-the-bundle"},{level:3,title:"CLI Steps",slug:"cli-steps"},{level:3,title:"Manual Steps",slug:"manual-steps"},{level:2,title:"Install the Bundle into an Application",slug:"install-the-bundle-into-an-application"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Build and Publish a Simple Bundle \n Overview \n In this tutorial, you will learn how to create a simple Entando Bundle and deploy it into the  Entando Component Repository  (ECR). This involves manually defining a bundle with a single widget, checking the bundle artifacts into Git, applying the Entando Bundle custom resource to Kubernetes, and then installing the bundle into an application. \n Prerequisites \n \n Use the  Entando CLI  to verify all dependencies are installed (e.g. Java, npm, Git). \n \n ent check-env develop\n \n \n Authenticated Git credentials, an empty Git repository and an available Entando instance are required for the commands below to execute without errors. \n \n Publishing a bundle can be simplified by using the  ent prj  command and its publication system (pbs) convenience methods. Both the CLI and manual commands are provided. \n Create the Project Structure \n First, create a parent project directory (e.g.  example-bundle ) along with a child bundle directory. In a project generated by the  Entando Component Generator , the microservice and micro frontend source files live under the parent directory. \n mkdir  -p example-bundle/bundle ;   cd  example-bundle/bundle\n Add a Simple Widget \n Create a widget directory \n mkdir  widgets\n \n Create a widget descriptor file within that directory \n touch  widgets/example-widget.yaml\n \n Populate the widget descriptor file  example-widget.yaml  with a simple definition. Make sure to retain the correct YAML indentation of 2 or 4 spaces. \n code :  example - widget\n titles : \n    en :  Example Widget\n    it :  Widget d\'esempio\n group :  free\n customUi :  <h2 > Hi from Example Widget</h2 > \n Create the Bundle Descriptor \n The main file processed by the Entando Component Repository is  descriptor.yaml , which describes all of the components within the bundle. The name of the bundle descriptor file must be  descriptor.yaml  and it must be stored in the child bundle directory (e.g.  example-bundle/bundle ). \n touch  descriptor.yaml\n \n Populate the bundle descriptor file with the following YAML definition \n code :  example - bundle\n description :  This is an example of an Entando bundle\n components : \n   widgets : \n     -  widgets/example - widget.yaml\n \n Component descriptor file names and locations (e.g.  widgets/example-widget.yaml ) are arbitrary since the bundle descriptor explicitly points to those files. Convention is to group components by type with all widgets in one directory, all page templates in another, etc. \n Publish the Bundle \n The bundle can be published using the CLI or the steps can be performed manually. \n CLI Steps \n \n Change to the project directory if needed \n \n cd  example-bundle\n \n \n Initialize the Entando project and accept the defaults \n \n ent prj init\n \n \n Initialize the publication system. This step requires the empty Git repository URL (ending in .git) and your Git credentials. \n \n ent prj pbs-init\n \n \n Publish the bundle to Git. By convention, the first version is assigned the tag  v0.0.1 , but the prefix "v" is optional. \n \n ent prj pbs-publish\n \n Running just the command  ent prj pbs-publish  will quickly push subsequent iterations of the bundle to Git. You will be asked to input the bundle version each time. You must be consistent with versioning format and alphanumeric precedence to ensure that iterations are listed in the correct order. \n \n The bundle can now be deployed into the Entando Component Repository with one command \n \n ent prj deploy\n \n The  prj deploy  command uses the Git repository URL and project name (e.g.  example-bundle ) to create the custom resource. \n Jump to  Install the Bundle into an Application  to finish installing your bundle. \n Manual Steps \n \n Change to the bundle directory if needed \n \n cd  example-bundle/bundle\n \n \n Run the following commands to initialize Git and commit the files \n \n git  init\n git   add   . \n git  commit -m  "Init Git repository" \n \n \n Add your remote repository as origin and push the bundle \n \n git  remote  add  origin https://your/remote/repository.git\n git  push -u origin master\n \n \n Publish a Git tag \n \n git  tag -a  "v0.0.1"  -m  "My first tag" \n git  push --tags\n \n \n Now that you\'ve published your bundle to Git, you can create the Kubernetes custom resource for it. \n \n Run the  ent bundler from-git  command, providing your remote Git repository URL via the  --repository  option and the correct namespace via  --namespace . You can also include a thumbnail for your bundle with  --thumbnail-file  or  --thumbnail-url . \n ent bundler from-git --name = example-bundle --namespace = entando --repository = https://your/remote/repository.git --dry-run  >  example-bundle.yaml\n \n \n Apply this definition to Kubernetes. You may need to first transfer the file to your VM, e.g with  multipass transfer . \n \n kubectl -n entando apply -f example-bundle.yaml\n \n \n Confirm the presence of your custom resource with the command  kubectl get EntandoDeBundle -n entando . \n Install the Bundle into an Application \n Your bundle should appear in  App Builder  →  Component Repository  in your Entando instance. Clicking  Install  should allow version selection if your bundle has multiple iterations. \n The Entando Platform will then download and install the components contained in the bundle. Once complete, you should see the  Install  button change to give you the option to  Uninstall  that specific version. If you navigate to  Components  →  Micro Frontends & Widgets , you should find your custom widget within the  User  section. \n'},{title:"Install Bundle Plugins from a Private Image Repository",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/curate/ecr-private-images.html",relativePath:"v7.0/tutorials/curate/ecr-private-images.md",key:"v-29b00b4e",path:"/v7.0/tutorials/curate/ecr-private-images.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Tutorial",slug:"tutorial"},{level:2,title:"Troubleshooting",slug:"troubleshooting"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Install Bundle Plugins from a Private Image Repository \n Overview \n The standard deployment of the Entando Component Repository assumes that plugin images are pulled from public repositories. Public repositores do not require user authentication in order to pull an image. The following tutorial will show you how to add secrets to your Kubernetes environment so you can successfully pull images from private repositories. \n Prerequisites \n \n A running Entando application \n A bundle containing a microservice plugin based on an image from a private repository. You can set this up by  creating a microservice bundle  and making the corresponding Docker Hub repository private. \n Tutorial \n The first step demonstrates how to create a Secret for Docker Hub but please see the  corresponding Kubernetes documentation  for other options. \n 1. Create the secret \nSupply the following parameters: \n \n the name of the new Secret, e.g.  my-docker-secret . \n the URL to your registry server. For Docker Hub this is currently  https://index.docker.io/v1/ \n your Docker Hub username, password, and email. \n the Entando namespace, e.g.  entando  for a quickstart environment. \n \n kubectl create secret docker-registry YOUR-SECRET-NAME --docker-server = YOUR-REGISTRY-SERVER --docker-username = YOUR-USERNAME --docker-password = YOUR-PASSWORD --docker-email = YOUR-EMAIL -n entando\n \n 2b. Deploy a new Entando Application \n If you're setting up a new Entando Application, you can  add the secret to the Entando Operator ConfigMap  under the property  entando.k8s.operator.image.pull.secrets . This is just a list containing the names of Docker Secrets in the operator's namespace. \n data :  \n   entando.k8s.operator.image.pull.secrets :   [ YOUR - SECRET - NAME ] \n \n 2b. Update an existing Entando Application \n If you're updating an existing Entando Application, you can add the new Secret to the  entando-plugin  serviceaccount. \n kubectl edit serviceaccount entando-plugin -n entando\n \n Add the secret to the serviceaccount. You can either add a new section if it's the first Secret or add another Secret to the list. \n apiVersion :  v1\n imagePullSecrets : \n   -   name :  YOUR - SECRET - NAME\n kind :  ServiceAccount\n metadata : \n   name :  entando - plugin\n \n If you describe the serviceaccount, it should list the Secret. \n kubectl describe serviceaccount entando-plugin -n entando\n \n Output: \n Name :                 entando - plugin\n Namespace :            entando\n Image pull secrets :   YOUR - SECRET - NAME\n \n If  (not found)  is listed next to the Secret name, then you may have added the Secret to the wrong namespace. \n 3. Install the Entando Bundle \n You can now install Entando Bundles from the  Entando App Builder  →  Entando Component Repository . The microservice plugin should now be able to successfully pull the image. \n Troubleshooting \n You may see an  ErrImagePull  status in  kubectl get pods  if a plugin is based on an image from a private repository and if there are any issues with the image URL or credentials, including a missing or incorrect Secret. \n"},{title:"Adding a new API to the core app",frontmatter:{},regularPath:"/v7.0/tutorials/devops/add-rest-api.html",relativePath:"v7.0/tutorials/devops/add-rest-api.md",key:"v-2e351e00",path:"/v7.0/tutorials/devops/add-rest-api.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Overview",slug:"overview"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Adding a new API to the core app \n Prerequisites \n \n \n Java 11 \n \n \n maven \n Overview \n This guide will take you through adding a new REST API to the Entando\ncore app. In some cases it is better to add new APIs to the core rather\nthan creating a new microservice. Some example cases where adding new\nAPIs to the core is recommended are: \n \n \n When extending or adding functionality to the WCMS \n \n \n When you have a simple use case requiring persistence that is\nspecific to only the application you’re working within \n \n \n When exposing configurations that are needed by the portal-ui during\npage rendering \n \n \n For small changes that don’t warrant a full stand-alone microservice \n \n \n You can build widgets and micro frontends that take advantage of these\nAPIs in the same way that your micro-frontends can invoke APIs exposed\nby other services. \n Tutorial \n Creating a controller and services \n \n \n Create a new java package in the project using your favorite IDE at\nthe path  org.entando.training . \n \n \n Under that package add packages for  controllers  and  services . \n \n \n Create a class called  DemoController.java  from the\ntraining package into the controllers package. \n \n This is a normal Spring rest controller and it will be\ndiscovered by annotations. \n \n \n \n Copy  DemoService.java  from the\ntraining package into the services package. \n \n This is a normal Spring service that will be autowired into the\ncontroller. The data in this service is hardcoded but this is\nwhere you can wire in external services or other parts of the\nEntando architecture to fetch the data. \n \n \n \n Copy  commonConfig.xml  to\n src/main/resources/spring/aps/managers . \n \n \n The goal is to enable package scanning for annotation driven\nspring services. This includes the package scan for your package\ndefined above. If you want to scan another package, then you\nneed to add another path to this file. This is the only spring\nXML you will need to change if you want to build annotation\ndriven beans in Entando. \n \n \n See also web.xml for deeper details. \n \n \n \n \n Review the code and annotations in the controller to understand how\nthe APIs are protected and integrated. \n \n \n @RestAccessControl  is a custom Entando annotation that can be used\nto restrict APIs by role. \n \n The rest of the annotations are normal Spring annotations. \n \n \n \n Restart your app using jetty. \n \n \n if you get an error add the entries below to\n src/main/conf/systemParams.properties  This is temporary \nParameters for Argon2 algorithm encryption\nalgo.argon2.type=ARGON2i\nalgo.argon2.hash.length=32\nalgo.argon2.salt.length=16\nalgo.argon2.iterations=4\nalgo.argon2.memory=65536\nalgo.argon2.parallelism=4\nalgo.default.key=changeit\n \n \n \n \n \n Go to Swagger \n \n \n Find the demo-controller and try your new endpoints out using\nswagger \n \n \n"},{title:"Backing Up and Restoring Keycloak",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/devops/backing-restoring-keycloak.html",relativePath:"v7.0/tutorials/devops/backing-restoring-keycloak.md",key:"v-01f14850",path:"/v7.0/tutorials/devops/backing-restoring-keycloak.html",headers:[{level:2,title:"Prerequisites:",slug:"prerequisites"},{level:2,title:"Create a Backup of Keycloak Realm",slug:"create-a-backup-of-keycloak-realm"},{level:2,title:"Import the Keycloak Realm",slug:"import-the-keycloak-realm"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Backing Up and Restoring Keycloak \n This tutorial describes how to backup an active Entando Identity Management Keycloak instance and restore it in another environment. \n Prerequisites: \n A Keycloak instance running on Entando with a database management system (DBMS) in the backend. This procedure will not work with an embedded database. \n Create a Backup of Keycloak Realm \n \n \n From the command line, get the pod name of the Keycloak server you wish to back up. In a quickstart environment, the pod name will begin with  default-sso-in-namespace-deployment . \n \n \n Use kubectl to start a bash shell in the pod: \n \n \n  kubectl exec -it YOUR-KEYCLOAK-POD-NAME -- /bin/bash\n \n \n Create a new directory in /tmp with: \n \n mkdir -p /tmp/export \n \n \n Run the following script to retrieve the data for the Entando realm and save it to a JSON file in the  export  directory. A new Keycloak server will run on a different port (offset=200) to avoid conflicts with the original Entando Keycloak instance. \n \n /opt/jboss/keycloak/bin/standalone.sh\n-Djboss.socket.binding.port-offset=200\n-Dkeycloak.migration.action=export \n-Dkeycloak.migration.provider=singleFile \n-Dkeycloak.migration.realmName=entando\n-Dkeycloak.migration.usersExportStrategy=DIFFERENT_FILES \n-Dkeycloak.migration.file=/tmp/export/entando-prod-realm.json\n \n \n If there are no errors, press Ctrl+C to stop the process. \n Type  exit  to close the bash shell in the pod. \n Execute this command to copy the realm data file to the proper location: \n \n kubectl cp YOUR-KEYCLOAK-POD-NAME:/tmp/export/ keycloak-backup\n Import the Keycloak Realm \n \n \n Login to the new Entando Keycloak server where the realm is to be restored. \n \n \n From the left sidebar, go to  Import . \n \n \n Click  Select file  button and  upload  the JSON file from the  keycloak-backup  directory. You will see the following page: \n \n \n \n \n You have now successfully imported the Keycloak realm to a new environment. \n \n Note \n If you are using a different environment, with a different hostname, you should import only users or set the flag for  If a resource exists  to  Skip . \n \n"},{title:"Backing Up and Restoring an Entando Application",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/devops/backing-up-and-restoring-your-environment.html",relativePath:"v7.0/tutorials/devops/backing-up-and-restoring-your-environment.md",key:"v-473b1d34",path:"/v7.0/tutorials/devops/backing-up-and-restoring-your-environment.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Create a Backup",slug:"create-a-backup"},{level:2,title:"Restore a Backup",slug:"restore-a-backup"},{level:3,title:"Build the Custom Image",slug:"build-the-custom-image"},{level:3,title:"Install the Application",slug:"install-the-application"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Backing Up and Restoring an Entando Application \n Overview \n This tutorial demonstrates how to use an existing Entando Application as a launching point for creating new applications. An alternative is to  use the Entando Bundler  to extract specific content and functionality from an existing application. Entando Bundles are recommended as a more flexible option when a full copy of an application is not required. \n Prerequisites \n \n Java 11 \n Docker \n Maven \n Access to a Docker repository (docker.io or other) \n Create a Backup \n This step requires using a running Entando environment to take an application backup.\nThe output of this step is a local directory with the files (database and static assets) needed to restore the application later. \n \n \n Log into the App Builder \n \n \n Go to  Administration → Database \n \n \n Click on  Create A Backup  and wait for the process to complete. The static assets and database backup will be saved to a persistent volume on the server pod under  /entando-data . \n \n \n Transfer the files from the  server-deployment . The exact command will depend on your Kubernetes environment. \n \n \n \n \n \n kubectl \n OpenShift \n \n \n \n \n kubectl cp <pod>:<path> <local-path> \n oc rsync <pod>:<path> <localPath> \n \n \n e.g.  kubectl cp quickstart-deployment-7b8c699599-f84zq:/entando-data backup \n e.g. oc rsync app-entando-deployment-67fd5b9954-s72mb:/entando-data \n \n \n \n \n You should see 3 directories -  databases ,  protected , and  resources .\nThe  protected  directory contains the timestamped backup you triggered from the App Builder. The  resources  directory contains the static assets. \n Restore a Backup \n Restoring a backup requires creating and then deploying a custom image of an Entando Application with the\nbackup files included. \n Build the Custom Image \n \n Clone the Entando Application repository \n \n git  clone https://github.com/entando/entando-de-app\n \n \n Change into the  entando-de-app  directory: \n \n cd  entando-de-app\n \n \n (Optional) Checkout a branch for your desired Entando version. You can review  https://github.com/entando/entando-de-app/releases  to determine the correct tag to use. \n \n git  checkout -b my-test v7.0.0\n \n WARNING \n If you don\'t perform this step, you\'ll be creating an Entando Application based on the latest  entando-de-app  code, which may not yet be released. \n \n \n \n Move the  resources  and  protected  directory from your Entando backup into  src/main/webapp . You should override any existing content. \n \n \n Build the application \n \n \n mvn clean package\n \n \n \n Create a repository named  entando-de-app-wildfly  in Docker for the new application. The Entando Operator will expect this name when performing the initial install. \n \n \n Create a Docker image for the application. You\'ll need to provide your user name and version. \n \n \n docker  build  .  -f Dockerfile.wildfly -t YOUR- USER /entando-de-app-wildfly:YOUR-VERSION\n \n \n Push the image to Docker \n \n docker  push YOUR- USER /entando-de-app-wildfly:YOUR-VERSION\n Install the Application \n You can use your typical install steps (or the standard  Manual Install steps ) with one adjustment. When you get to the  Install namespace scoped resources  step, you\'ll need to configure the  namespace-resources.yaml  to use your image. \n \n Retrieve a copy of the  namespace-resources.yaml  for your Entando version \n \n   curl  -sfL https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/namespace-scoped-deployment/namespace-resources.yaml  >  namespace-resources.yaml\n \n \n Edit  namespace-resources.yaml  and update the  entando-de-app-wildfly  configuration with your user name and version \n \n entando-de-app-wildfly :   > - \n     { "version" : "YOUR-VERSION" , "executable - type" : "jvm" , "registry" : "docker.io" , "organization" : "YOUR-USER" } \n \n \n Now apply the namespace resources to K8s \n \n sudo  kubectl apply -n entando -f namespace-resources.yaml\n \n \n \n You can now continue with the rest of the install instructions \n \n \n Once deployed, review the App Builder or running application to confirm the backup was restored correctly. You can check the deployment logs for possible errors. \n \n \n'},{title:"Building a Docker Image for the Entando Core",frontmatter:{},regularPath:"/v7.0/tutorials/devops/build-core-image.html",relativePath:"v7.0/tutorials/devops/build-core-image.md",key:"v-6a1fdcc2",path:"/v7.0/tutorials/devops/build-core-image.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Introduction",slug:"introduction"},{level:2,title:"Setup",slug:"setup"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Building a Docker Image for the Entando Core \n Prerequisites \n \n \n Java 11 \n \n \n Docker installed locally\n( https://docs.docker.com/docker-for-windows/install/ ) \n \n \n maven \n \n \n Access to a docker repository (docker.io or other) \n Introduction \n This tutorial will take you through the basic steps to create a docker\nimage from an Entando core application. A more detailed guide with\nadditional commands and configuration can be found here: \n https://github.com/entando/entando-de-app \n Setup \n \n \n Clone the application at:\n https://github.com/entando/entando-de-app  using \n git clone https://github.com/entando/entando-de-app\n \n \n \n On a command line, cd into the entando-de-app you just cloned: \n cd entando-de-app\n \n \n \n Build a docker image from the core app replacing the value of the tag in the  -t   with the tag you want to use for your image. \n mvn clean package\ndocker build . -f Dockerfile.wildfly -t <YOUR-USER>/<YOUR-REPO-NAME>:<YOUR-VERSION>\n \n \n \n Create a repository on your docker repository to house your new\napplication \n \n \n Push the Image to your Repository \n docker push <YOUR-USER>/<YOUR-REPO-NAME>:<YOUR-VERSION>\n \n \n \n"},{title:"Caching and Clustering",frontmatter:{},regularPath:"/v7.0/tutorials/devops/caching-and-clustering.html",relativePath:"v7.0/tutorials/devops/caching-and-clustering.md",key:"v-08df2e42",path:"/v7.0/tutorials/devops/caching-and-clustering.html",headers:[{level:2,title:"Storage Requirements for Clustered Entando Apps",slug:"storage-requirements-for-clustered-entando-apps"},{level:2,title:"Clustering",slug:"clustering"},{level:3,title:"Prerequisites",slug:"prerequisites"},{level:3,title:"Creating a Clustered App Instance",slug:"creating-a-clustered-app-instance"},{level:3,title:"Validating Clustered Instances",slug:"validating-clustered-instances"},{level:3,title:"Caching Validation",slug:"caching-validation"},{level:2,title:"Configuring and Deploying with Redis",slug:"configuring-and-deploying-with-redis"},{level:3,title:"Deploy Redis to Kubernetes",slug:"deploy-redis-to-kubernetes"},{level:3,title:"Configure implementation",slug:"configure-implementation"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Caching and Clustering \n The tutorial below covers the basic steps to setup and validate a clustered instance of the Entando App Engine. \n NOTE \n When building your deployment architecture, it is important to review your goals, hardware, networking and application-specific setup. You must also optimize App Engine deployment for your environment. The configurations and tests below do not address every type of application or deployment, but they can be used as building blocks to create a deployment architecture that works for your application. \n Storage Requirements for Clustered Entando Apps \n In order to scale an Entando Application across multiple nodes, you must provide a storage class that supports\na  ReadWriteMany  access policy. There are many ways to accomplish this, including using dedicated storage providers like GlusterFS. Cloud Kubernetes providers also offer clustered storage options specific to their implementation, such as Google Cloud File in GKE or Azure Files in AKS. \n You can use two different storage classes for your clustered vs. non-clustered storage if your default class doesn't support  ReadWriteMany . Add the following properties to your ConfigMap for the operator: \n entando.k8s.operator.default.clustered.storage.class: [your clustered RWX storage class]\nentando.k8s.operator.default.non.clustered.storage.class: [your RWO storage class]\n \n Set both values to the appropriate storage class for your configuration. \n TIP \n A  ReadWriteOnce (RWO)  policy that ensures instances are all scheduled to the same node will scale an Entando Application without clustered storage and is accomplished via taints on other nodes. Be aware of the pros and cons of scheduling instances to the same node so you can maximize utilization of node resources and recover from an unreachable application instance. If the node terminates or is shutdown, your application will be down while Kubernetes reschedules the pods to a different node. \n Clustering \n This tutorial reviews setting up a clustered Entando App Engine in  entando-de-app . The goal is to deploy a clustered instance of the App Engine and verify the high availability and scalable deployment of the application. \n Prerequisites \n \n An existing deployment of an Entando App or the ability to create one.\n \n If you haven't created a deployment or don't have a YAML file for an Entando deployment, follow the  Quickstart instructions . \n \n \n The Entando deployment must use a Relational Database Management System (RDBMS) to organize data in a table structure. Clustered instances will not work correctly with in-memory databases. \n Sticky sessions are recommended when enabling a clustered Entando Application. For example, see  Manage NGINX  for related affinity settings. \n Creating a Clustered App Instance \n \n Create an Entando deployment via the operator config file or edit an existing deployment YAML file. \n Scale your Entando server application: \n \n kubectl scale deployment quickstart-deployment -n entando --replicas = 2 \n \n \n \n Run  kubectl get pods -n YOUR-NAMESPACE  to view the pods in your deployment. \n \n \n You should have two  quickstart-deployment  pods in your namespace. \n \n \n Look in the logs of the  quickstart-deployment  in either pod to see logging information related to different instances joining the cluster and balancing the data between the instances. See the screenshot for an example. Your actual logs will vary. \n Validating Clustered Instances \n This is an advanced exercise and not required or recommended for most deployment scenarios. The steps below validate that the clustered instances are working in your environment and that you have created a high availability deployment. \n \n Complete the  creating a clustered instance tutorial  above or have an existing clustered Entando App instance available for testing. \n Get the URL for your  entando-de-app  with  kubectl get ingress -n YOUR-NAMESPACE . \n Open the URL in the browser of your choice and ensure that the application is working. \n Open a new browser window in incognito or private browsing mode to ensure that no data is cached and you're receiving a copy of the running application.  Do not navigate to the app. \n Delete one of the server deployment pods in your clustered instance with  kubectl delete YOUR-POD-NAME -n YOUR-NAMESPACE .\n \n There are other ways to do this. You could also shell into the server-container and manually kill the running app process with  kill -9 357 . \n If you want to test at the hardware level, you could manually terminate a node in your cluster (ensuring that the pods are scheduled to different nodes). \n \n \n In your private/incognito browser window, open the URL to your  entando-de-app . \n Check that the application continues to render while the pod you deleted is no longer present. \n Wait for Kubernetes to restore your deleted pod. \n Check that the application continues to render after the pod is restored. \n Caching Validation \n Validating the shared cache can be done in a similar process to the clustered instance validation. The high level steps are: \n \n Deploy a clustered instance (see  creating a clustered instance tutorial ). \n Create data with the App Builder (pages, page templates, content etc.), using the external route for the application. \n Refer to the logs to note which instance processed the request. \n Terminate that instance. \n Fetch the recently created data and verify that the data are returned. \n Configuring and Deploying with Redis \n In this section, an Entando App Engine instance is deployed using Redis as a cache for data served by the App Engine. For more information on the cache configuration for the App Engine, see the  Caching and Clustering documentation . \n Deploy Redis to Kubernetes \n \n Create the Redis deployment and expose the endpoints: \n \n kubectl create deployment redis --image = redis:6\n \n \nkubectl expose deployment redis --port = 6379  --target-port = 6379  -n YOUR-NAMESPACE\n\n \n \n Install the Redis CLI for your environment per  https://redis.io/topics/rediscli . \n Get the IP for your Redis deployment: \n \n kubectl get  service  -n YOUR-NAMESPACE\n \n \n Validate your deployment: \n \n redis-cli -h  10.43 .99.198 -p  6379   ping \n \n \n Should respond PONG. \n \n redis-cli -h  10.43 .99.198 -p  6379  incr mycounter\n \n \n Should increment each time. \n Configure implementation \n \n Use git to clone the  entando-de-app  repository: \n \n git  clone https://github.com/entando/entando-de-app\n \n \n Fetch the tags, checkout the release tag and create a branch for your customization: \n \n git  fetch --tags\n \n git  checkout tags/v7.0.0 -b YOUR-7.0.0-redis\n \n \n \n Open the pom.xml file of the  entando-de-app . \n \n \n Add the Redis caching plugin to the pom.xml: \n \n \n <dependency>\n    <groupId>org.entando.entando.plugins</groupId>\n    <artifactId>entando-plugin-jpredis</artifactId>\n    <type>war</type>\n</dependency>\n \n \n Save the pom. \n Build and push a custom image for the  entando-de-app  with  Building a Docker Image Tutorial . \n Download the operator configuration deployment file: \n \n curl  -L -C - -O https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/namespace-scoped-deployment/orig/namespace-resources.yaml  >  namespace-resources.yaml\n \n \n \n Update the image for  entando-de-app-wildfly  in the  namespace-resources.yaml  file to point to your custom  entando-de-app  image with Redis. The line to change is in the ConfigMap named  entando-docker-image-info . \n \n \n Deploy your edited file with  kubectl . \n \n \n kubectl apply -f namespace-resources.yaml\n \n \n Download the  entando-app.yaml  template \n \n curl  -sLO  \"https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/samples/entando-app.yaml\" \n \n \n Add environment variables to the  EntandoApp  definition to match your Redis instance. The variables to create are REDIS_ACTIVE, REDIS_ADDRESS (e.g.  redis://localhost:6379 ), and REDIS_PASSWORD. \n \n \n NOTE: This example uses a Secret for the  REDIS_PASSWORD , which is recommended. You can also hardcode the password in the YAML for testing purposes, but the use of clear text passwords in deployment files is not recommended.  Create and use a Secret for the password as a best practice. \n \n data : \n   environmentVariables : \n     -   name :  REDIS_ACTIVE\n       value :   \"true\" \n     -   name :  REDIS_ADDRESS\n       value :  YOUR - REDIS - URL\n     -   name :  REDIS_PASSWORD\n       valueFrom : \n         secretKeyRef : \n           key :  password\n           name :  YOUR - REDIS - SECRET - NAME\n           optional :   false  \n \n \n Deploy your file \n \n kubectl apply -f entando-app.yaml\n \n "},{title:"Configure the Entando Operator",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/devops/entando-operator.html",relativePath:"v7.0/tutorials/devops/entando-operator.md",key:"v-2c5c21fe",path:"/v7.0/tutorials/devops/entando-operator.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Add a new ConfigMap",slug:"add-a-new-configmap"},{level:2,title:"Update an existing ConfigMap",slug:"update-an-existing-configmap"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Configure the Entando Operator \n This tutorial demonstrates how to provide the Entando Operator with a ConfigMap to customize its behavior. See the template file below for possible settings related to image timeouts, TLS/SSL configuration, and the default image repository. Some specific tutorials (e.g.  Plugin Configuration Profiles ) also require updates to the Entando Operator configuration. \n Prerequisites \n The Entando Operator makes use of an optional ConfigMap named  entando-operator-config . The ConfigMap must be present in the same namespace as the operator. In a quickstart environment, you can check for its presence with this command: \n kubectl get configmap -n entando\n Add a new ConfigMap \n If the ConfigMap doesn\'t already exist, you can use a template as a starting point. \n curl  -sfL  "https://raw.githubusercontent.com/entando/entando-releases/v7.0.0/dist/ge-1-1-6/samples/entando-operator-config.yaml" \n \n Edit  entando-operator-config.yaml  to adjust existing settings or add new ones. You can then apply it to Kubernetes. \n kubectl apply -f entando-operator-config.yaml -n entando\n \n The Entando Operator automatically reloads settings from the ConfigMap when the ConfigMap is created. You can verify the reload by checking the logs in the operator pod. \n Update an existing ConfigMap \n You can edit an existing ConfigMap to add or update settings. \n kubectl edit configmap/entando-operator-config -n entando\n \n The Entando Operator automatically reloads settings from the ConfigMap whenever it is modified. You can verify the reload by checking the logs in the operator pod. Some settings may only take effect when a deployment is first created, e.g. timeout settings or CPU limits. \n'},{title:"Selecting the Default Databases",frontmatter:{},regularPath:"/v7.0/tutorials/devops/default-database.html",relativePath:"v7.0/tutorials/devops/default-database.md",key:"v-992c93e8",path:"/v7.0/tutorials/devops/default-database.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Selecting the Default Databases \n Overview \n This document provides a guide to changing an Entando environment by selecting the default databases used.\nSee  External Database  to connect to a database outside of the cluster. \n Prerequisites \n \n An environment to install your Entando application \n Network access from your Kubernetes cluster to your database \n Tutorial \n If needed, you can set the desired component to use a specific DBMS by updating the Helm-generated yaml file from  Getting Started  as follows: \n \n open the chosen file and search for  EntandoApp  custom resource \n identify the component to update in the related list \n update the  spec.dbms  property with the desired value (you can specify different DBMS for different components) \n \n Repeat previous steps for all components you need to change used DBMS on. \n Valid values for  spec.dbms  property are:  none ,  embedded ,  postgresql ,  mysql ,  oracle . \n embedded  value will result in using an embedded database with in-file persistence strategy. \n Please note that using embedded databases into distributed systems forces to have only 1 replica per pod.\nThis happens because the volume claimed by each replica points to the same files,\nso the first container locking the files will prevent next replicas to obtain access to the DB files.\nNote that this affects also deployments rolling updates \n If you need to update your deployment, there is a known workaround consisting in setting the replicas number to 0, waiting for pod shutdown completion, update the deployment yaml file, then updating again to 1 the replicas value. In this way, the newly created containers will be able to startup correctly and access the embedded database files on the filesystem. \n These considerations lead us to discourage embedded database use into production environments. \n"},{title:"Change Default Datasources and Connections",frontmatter:{},regularPath:"/v7.0/tutorials/devops/change-default-datasource.html",relativePath:"v7.0/tutorials/devops/change-default-datasource.md",key:"v-751ba286",path:"/v7.0/tutorials/devops/change-default-datasource.html",headers:[{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Create a Docker project for your own base image to Entando's standard base image(s)",slug:"_1-create-a-docker-project-for-your-own-base-image-to-entando-s-standard-base-image-s"},{level:3,title:"2. Customize the standalone.xml/standalone-openshift.xml file using environment variables.",slug:"_2-customize-the-standalone-xml-standalone-openshift-xml-file-using-environment-variables"},{level:3,title:"3. Build your own Docker base image",slug:"_3-build-your-own-docker-base-image"},{level:3,title:"4. Modify your Entando App project to use the new Docker base image",slug:"_4-modify-your-entando-app-project-to-use-the-new-docker-base-image"},{level:3,title:"5. Build and push your custom Docker image",slug:"_5-build-and-push-your-custom-docker-image"},{level:3,title:"6. Deploy your EntandoApp with the correct environment variables",slug:"_6-deploy-your-entandoapp-with-the-correct-environment-variables"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Change Default Datasources and Connections \n Purpose \n This tutorial explains how to customize our EAP and Wildfly base Docker images, and then configure the EntandoApp custom resource to use these customizations. \n Requirements \n \n \n The Entando Operator is running in the target names \n \n \n Keycloak and the Entando Cluster Infrastructure have been deployed \n \n \n The required external databases and other services are up and running. \n \n \n Your own custom project as described in  the tutorial \n Steps \n 1. Create a Docker project for your own base image to Entando\'s standard base image(s) \n Create a project, ideally in Git repository, and put the following files in the folder \n 1.1. The standalone.xml/standalone-openshift.xml file of choice \n It is essential for your custom Docker image to use a file from one of the official Entando Docker base images. \n If you intend to use provide your own EAP based image, please use this\n standalone-openshift.xml \nfile. \n If you intend to use provide your own Wildfly based image, please use this\n standalone.xml \nfile. \n Please note that if you create your own base image with a different version of EAP or Wildfly, using these files\nmay have unintended consequences. \n 1.2. Any modules that may be required for your datasource or other connection resource \n If the resource you need to connect to requires some custom classes, such as JDBC drivers, please add these as \na module to Wildfly/EAP. \n 1.3 Dockerfile \n In your Dockerfile, please be sure to extend the correct base image, and add the correct configuration file to\nthe correct location in the target image. \n For EAP, a most basic Dockerfile would look like this: \n FROM entando/entando-eap71-clustered-base:6.1.2\nCOPY --chown=185:0 ./standalone-openshift.xml /opt/eap/standalone/configuration\n \n For Wildfly, a most basic Dockerfile would look like this: \n FROM entando/entando-eap71-clustered-base:6.1.2\nCOPY --chown=1001:0 ./standalone.xml /wildfly/standalone/configuration\n \n Please take note of the user ownership in these different Dockerfiles. This is quite important as Openshift will\nexpect the user/group ownership to be respected. \n 2. Customize the standalone.xml/standalone-openshift.xml file using environment variables. \n You can now modify your Wildfly/EAP configuration to meet your requirements. Where the configuration could differ\nfrom one environment to a next, we strongly advise using environment variable expressions ( ${env.VAR_NAME} ). The most likely change\nthat would be required in this file is the addition of a datasource. Here is an example of how to add a datasource\nto the datasources subsystem. All the environment variables starting with \'YOURDB\' can be specified from the Docker\ncontainer. \n    ...\n    <subsystem xmlns="urn:jboss:domain:datasources:5.0">\n      <datasources>\n        <datasource jndi-name="${env.YOURDB_JNDI}" enabled="true" use-java-context="true" pool-name="yourDbDataSource" use-ccm="true">\n          <connection-url>${env.YOURDB_URL}</connection-url>\n          <driver>${env.YOURDB_DRIVER}</driver>\n          <security>\n            <user-name>${env.YOURDB_USERNAME}</user-name>\n            <password>${env.YOURDB_PASSWORD}</password>\n          </security>\n        </datasource>\n \n Please take extra care not to remove any lines from these files. This is of particular importance in the case of the\nEAP image as, on startup, scripts in the official EAP look for certain placeholders in this file and populates them\nfrom other environment variables. \n 3. Build your own Docker base image \n You can now build your Docker base image. It is highly recommended that you consider using a dedicated CI/CD build\ntool such as Jenkins X to build the base image and maintain traceability between your source code and the resulting\nDocker image. One possible build command could look like this: \n docker build . -t your-docker-registry.com/your-org/your-base-image:1.0.0 \n 4. Modify your Entando App project to use the new Docker base image \n You can now modify your Entando App project that you have forked as described in the\n relevant tutorial . You would require two changes to the pom.xml file\nof the sample project. \n \n Firstly, you would need to change the variable  server.base.image  to reflect the fully\nqualified URI of your Docker image for EAP and/or Wildfly. For example, if you decided to extend the Wildfly image,\ngo to the Maven profile with the id  wildfly  and change the   server.base.image  to look like this: \n \n <server.base.image>your-docker-registry.com/your-org/your-base-image:1.0.0</server.base.image> \n \n Then you need to change the  <from>  element in the Fabric8 Maven Docker Plugin to reflect this variable.\nNavigate to the first  <image>  element in the pom.xml file. You have found the correct one\nif it contains the following xml: \n \n <from>entando/${server.base.image}:${entando.version}</from> \n Delete the  entando/  prefix and the  :${entando.version}  suffix: \n <from>${server.base.image}</from> \n Please note that, should you still require support for both Wildfly and EAP in your Maven pom, you may need to\nrepeat this exercise for both the  eap  and  wildfly  profiles. \n 5. Build and push your custom Docker image \n Before building your Docker image, it would be a good idea to change the name of the image you want to build. Navigate\nto the previously modified  <image>  element in the Fabric8 Maven Docker Plugin.You can change the  <name>  element\nto reflect your preferred name, e.g. \n <name>your-docker-registry.com/your-org/your-entando-app:1.0.0</name> \n Run: \n mvn clean package -Pwildfly -Pderby \n A new Docker image should now be available named  your-docker-registry.com/your-org/your-entando-app:1.0.0 \n Log into the Docker registry in question and then push the image: \n docker push your-docker-registry.com/your-org/your-entando-app:1.0.0 \n You are now ready to deploy this image. \n 6. Deploy your EntandoApp with the correct environment variables \n The final step is to configure your EntandoApp deployment with the correct environment variables. As is the case with\nall the Entando Custom Resources that result in actual deployments, the property  spec.environmentVariables  will be translated\ninto environment variables on each of the Containers in the Deployment\'s Pod. For an EntandoApp named \'my-app\',\nthe new state of the EntandoApp would could be placed in a file named  my-app.yaml  that would look something like this: \n       kind: "EntandoApp"\n      metadata:\n        name: "my-app"\n      spec:\n        dbms: postgresql\n        replicas: 1\n        customServerImage: your-docker-registry.com/your-org/your-entando-app:1.0.0\n        ingressPath: /your-entando-app\n        environmentVariables:\n          - name: YOURDB_JNDI\n            value: java/your-ds\n          - name: YOURDB_URL\n            value: "jdbc:postgresql://somehost.com:5432/mydb"\n          - name: YOURDB_DRIVER\n            value: postgresql\n          - name: YOURDB_USERNAME\n            value: my_user\n          - name: YOURDB_PASSWORD\n            value: mypassword\n      entandoStatus:\n        entandoDeploymentPhase: requested\n\n \n Notice how this Custom Resource specifies a  parameter  for each environment variable that was referenced from the\n standalone.xml  file referenced earlier. \n To apply the changes to your deployment, change the  entandoStatus.entandoDeploymentPhase  property to requested and\napply the file: \n kubectl apply -f my-app.yaml\n \n '},{title:"Tutorial: Connecting to an External Database",frontmatter:{},regularPath:"/v7.0/tutorials/devops/external-db.html",relativePath:"v7.0/tutorials/devops/external-db.md",key:"v-00c45ac6",path:"/v7.0/tutorials/devops/external-db.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Tutorial",slug:"tutorial"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Tutorial: Connecting to an External Database \n Overview \n This document provides a guide to connecting an Entando Application to an external database. In\nmany production configurations, it is recommended to use a DBMS\noutside of the cluster where your Entando Application is running to\nsimplify maintenance, minimize duplication of resources, and establish a\nbackup workflow to scale with your application. \n Prerequisites \n \n \n An environment to install your Entando Application \n \n \n A running PostgreSQL, MySQL, or Oracle environment \n \n \n Administrator access to the database \n \n \n Network access from your Kubernetes cluster to your database \n Tutorial \n \n Create and install a secret or secrets for your database credentials \n Edit the EntandoApp and EntandoKeycloakServer custom resources. \n Set the value for  dbms  to  none  in both resources. \n Under  environmentVariables , you will need to provide database connection information for two Entando server databases and one connection for the Entando Component Repository. Example connection information for each of those databases is provided below: \n ECR \n - name: SPRING_DATASOURCE_URL\n  value: {ECRDB_URL}\n- name: SPRING_DATASOURCE_USERNAME\n  valueFrom:\n    secretKeyRef:\n      name: {ECRDB_DBMS_SECRET_NAME}\n      key: username\n      optional: false\n- name: SPRING_DATASOURCE_PASSWORD\n  valueFrom:\n    secretKeyRef:\n      name: {ECRDB_DBMS_SECRET_NAME}\n      key: password\n      optional: false\n- name: SPRING_JPA_DATABASE_PLATFORM\n  value: {ECRDB_DIALECT}\n Portal DB \n - name: PORTDB_URL\n  value: {PORTDB_URL}\n- name: PORTDB_USERNAME\n  valueFrom:\n    secretKeyRef:\n      name: {PORTDB_DBMS_SECRET_NAME}\n      key: username\n      optional: false\n- name: PORTDB_PASSWORD\n  valueFrom:\n    secretKeyRef:\n      name: {PORTDB_DBMS_SECRET_NAME}\n      key: password\n      optional: false\n- name: PORTDB_CONNECTION_CHECKER\n  value: {PORTDB_CONNECTION_CHECKER}\n- name: PORTDB_EXCEPTION_SORTER\n  value: {PORTDB_EXCEPTION_SORTER}\n Server DB \n - name: SERVDB_URL\n  value: {SERVDB_URL}\n- name: SERVDB_USERNAME\n  valueFrom:\n    secretKeyRef:\n      name: {SERVDB_DBMS_SECRET_NAME}\n      key: username\n      optional: false\n- name: SERVDB_PASSWORD\n  valueFrom:\n    secretKeyRef:\n      name: {SERVDB_DBMS_SECRET_NAME}\n      key: password\n      optional: false\n- name: SERVDB_CONNECTION_CHECKER\n  value: {SERVDB_CONNECTION_CHECKER}\n- name: SERVDB_EXCEPTION_SORTER\n  value: {SERVDB_EXCEPTION_SORTER}\n \n Set the values for placeholders in the templates above based on your database configuration. Here are examples: \n Postgresql \n XXX_URL:                      jdbc:postgresql://{DBMS_ADDRESS}:{DBMS_PORT}/{DBMS_DBNAME}\nXXX_CONNECTION_CHECKER:        org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLValidConnectionChecker\nXXX_EXCEPTION_SORTER:         org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLExceptionSorter\nSPRING_JPA_DATABASE_PLATFORM: org.hibernate.dialect.PostgreSQLDialect\n MySql \n XXX_URL:                      jdbc:mysql://{DBMS_ADDRESS}:{DBMS_PORT}/{DBMS_DBNAME}\nXXX_CONNECTON_CHECKER:        org.jboss.jca.adapters.jdbc.extensions.mysql.MySQLValidConnectionChecker\nXXX_EXCEPTION_SORTER:         org.jboss.jca.adapters.jdbc.extensions.mysql.MySQLExceptionSorter\nSPRING_JPA_DATABASE_PLATFORM: org.hibernate.dialect.MySQLDialect \n Oracle \n XXX_URL:                      jdbc:oracle:{driver_type}:@//{DBMS_ADDRESS}:{DBMS_PORT}/{DBMS_SERVICE_NAME}\nXXX_CONNECTON_CHECKER:        org.jboss.jca.adapters.jdbc.extensions.oracle.OracleValidConnectionChecker\nXXX_EXCEPTION_SORTER:         org.jboss.jca.adapters.jdbc.extensions.oracle.OracleExceptionSorter\nSPRING_JPA_DATABASE_PLATFORM: org.hibernate.dialect.Oracle \n \n "},{title:"Connect to an External Keycloak Instance",frontmatter:{},regularPath:"/v7.0/tutorials/devops/external-id-management.html",relativePath:"v7.0/tutorials/devops/external-id-management.md",key:"v-49a30018",path:"/v7.0/tutorials/devops/external-id-management.html",headers:[{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Get keycloak information",slug:"_1-get-keycloak-information"},{level:3,title:"2. Generate the secret",slug:"_2-generate-the-secret"},{level:3,title:"3. Upload the secret",slug:"_3-upload-the-secret"},{level:3,title:"4. Deploy the Entando application",slug:"_4-deploy-the-entando-application"},{level:2,title:"Conclusion",slug:"conclusion"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Connect to an External Keycloak Instance \n Purpose \n This tutorial enables the Entando administrator to leverage an existing\nKeycloak instance. \n Requirements \n \n \n A Keycloak instance \n \n \n A realm named "entando" on that instance \n \n \n An admin user for the "entando" realm \n Steps \n 1. Get keycloak information \n Retrieve the relevant information from the Keycloak instance you want to\nuse. \n Specifically you will need: \n \n \n The username of the Keycloak admin that has admin rights to the\n"entando" realm, e.g entando-keycloak-admin \n \n \n The Keycloak admin password, e.g. password123 \n \n \n The base url for the Keycloak server, including the auth value, e.g.\nhttps://your-keycloak-instance.com/auth \n 2. Generate the secret \n You now need to generate a secret with name  keycloak-admin-secret \nusing the information retrieved from step 1. The Entando administrator\nwill automatically detect this secret by name, and use it to log onto\nthe provided Keycloak server. \n Here is an example of the secret you will need to construct: \n ---\napiVersion: v1\nstringData:\n    username: #the username of the Keycloak admin user for the "entando" realm\n    password: #the password of this Keycloak admin user\n    url: #the base url of the Keycloak service, typically ending with the path /auth\nkind: Secret\nmetadata\n    name: keycloak-admin-secret\n    namespace: YOUR-APP-NAMESPACE\ntype: Opaque\n \n \n Note \n To encode your values, in bash, you can do\n echo YOUR-VALUE | base64 \n 3. Upload the secret \n Next upload the secret to the namespace where you want to deploy your\nEntando instance. \n oc create -f YOUR-SECRET.yaml -n MY-APP-NAMESPACE\n 4. Deploy the Entando application \n Now you are ready to deploy your Entando application and the\nadministrator will reuse the  keycloak-admin-secret  secret to populate\nthe environment correctly. \n Conclusion \n You should now have a working Entando instance using an external\nKeycloak server. \n'},{title:"Tutorial: Invoking Entando Core APIs",frontmatter:{},regularPath:"/v7.0/tutorials/devops/invoking-api.html",relativePath:"v7.0/tutorials/devops/invoking-api.md",key:"v-240e1c96",path:"/v7.0/tutorials/devops/invoking-api.html",headers:[{level:2,title:"General Overview",slug:"general-overview"},{level:2,title:"Purpose",slug:"purpose"},{level:2,title:"Requirements",slug:"requirements"},{level:2,title:"Steps",slug:"steps"},{level:3,title:"1. Set up a Postman environment",slug:"_1-set-up-a-postman-environment"},{level:3,title:"2. Get an access token",slug:"_2-get-an-access-token"},{level:3,title:"2. Prepare a generic API request",slug:"_2-prepare-a-generic-api-request"},{level:2,title:"QE ready APIs",slug:"qe-ready-apis"},{level:2,title:"Notes on QE requests collections structure",slug:"notes-on-qe-requests-collections-structure"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Tutorial: Invoking Entando Core APIs \n General Overview \n Entando supports Swagger and it is accessible, if activated, from its\nweb interface from the base application URL at /api/swagger-ui.html. A\ncomplete list of all available core APIs can be obtained from Swagger. \n Core APIs can be invoked directly from Swagger or from any other\nsuitable tool, i.e., curl or Postman are two common ones. Postman has\nbeen extensively used in API testing and automated API testing because\nof the possibilities it offers and it is the suggested tool. \n All Entando core APIs are accessible from the base URL, for example:\nlocalhost:8080/entando-de-app/api. For example, the Page Controller will\nbe available under /pages from the Base URL (i.e.\nlocalhost:8080/entando-de-app/api/pages), or the Page Template Controller\nwill available under /pageModels (i.e.\nlocalhost:8080/entando-de-app/api/pageModels) and so on. \n Before being able to perform any API request, we will first need to\nobtain an  authorization token , that is achieved with a specific POST\nrequest sent to the oauth/token endpoint, after successful\nauthentication, an access token is returned which grants access to all\nAPI endpoints and actions for which the authenticated user has defined\nprivileges. \n (Refer to  User Management Roles  for details) \n The best way to proceed in case of extensive testing with APIs with\nPostman, is to set up an environment and define a variable that will\nkeep the access token saved from the POST request to /oauth/token. \n Purpose \n Set up an environment ready to invoke Entando core APIs \n Requirements \n To complete this tutorial you will need: \n \n \n Postman \n \n \n A running Entando instance \n Steps \n 1. Set up a Postman environment \n Create a new Postman environment and define the following variables: \n access_token: #no value\nrefresh_token: #no value\nurl: #URL of your application (i.e. http://localhost:8080/entando-de-app)\n \n Be careful with the URL variable and make sure you do not have a\ntrailing slash. \n Set Postman to use this environment. \n 2. Get an access token \n Getting an access token is a prerequisite to be able to invoke any API.\nThe following is the required activity. \n \n \n create a Postman collection, name it for example "Access Token" \n \n \n create a new POST request with the following parameters: \n \n \n \n URL field\n{{url}}/api/oauth/token\n \n Note that we are calling the "url" environmental variable for\nconvenience. \n Autorization section\n   Type: Basic Auth\n   Username: #a valid Entando consumer must be defined in Entando (Refer to appropriate documentation on how to do that) (i.e. appbuilder)\n   Password: #password of the defined consumer (i.e. appbuilder_secret)\n\nHeaders section\n    Content-Type: application/x-www-form-urlencoded\n\nBody section\nSelect from the radio button the option: x-www-form-urlencoded\n    username: #valid Entando user (i.e. admin)\n    password: #password of the valid user\n    grant_type: password\n \n The tests section is convenient as we can then set any new API request\nin such a way to make use of that access token. The first line of code\ndefines a variable called "data", which hosts the JSON parsed\nresponseBody from the POST request just sent to /oauth/token; The second\nline sets the environment variable "access_token" to the value returned\nby the POST request. \n Tests section\n    var data = JSON.parse(responseBody);\n    postman.setEnvironmentVariable("access_token", data.access_token);\n \n Launch the POST request to test it, and if successful, you should get a\nresponse like this: \n {\n    "access_token": "b96096493a40b1a7364bd54a6ffb609b",\n    "token_type": "bearer",\n    "refresh_token": "79ff84062b5dc13663961a833b0788f9",\n    "expires_in": 3599\n}\n \n also if you open in edit the Postman environment, you should see that\nthe access_token and the refresh_token variables values have been\nupdated. \n 2. Prepare a generic API request \n Create a new request with the following parameters: \n Authorization section: Inherit auth from parent\n\nHeaders section:\n create the key Authorization with Value: Bearer{{access_token}}\n create the key Content-Type with Value: application/json\n \n Select the appropriate method (GET, DELETE, POST etc.) for your request\nand fill up the URL with appropriate values i.e.\n(localhost:8080/entando-de-app/api/pages) then add to the Body section,\nif needed, the appropriate payload in JSON format, remember to select\nraw and JSON (application/json). \n QE ready APIs \n QE has developed a set of collection requests to automate API testing,\nexamples of that are available on github at\n https://github.com/entando/entando-QE/tree/master/postman_API . \n To use them, first git clone the project and use the built in Postman\nimporting features. \n Import first the Postman Environment file which can be found under the\nenvironment folder. When imported, from Postman, open in edit that\nenvironment and change the "url" variable to the appropriate value for\nyour specific installation, i.e http://localhost:8080/entando-de-app/\nand save it. \n Import from Postman the collections you would like to use and they will\nbecome available in the Postman collections Panel ready to be run. \n Notes on QE requests collections structure \n Each collection is so designed to test a particular use case i.e.\n"Delete an existent page", "Delete a page which has children" etc. \n By design each QE Postman collection is: \n \n \n independent (does not require other collections) \n \n \n general (does not make any assumption on the specific Entando\napplication) \n \n \n can be run automatically, with Newman, please refer to\n https://github.com/entando/entando-QE  for details \n \n \n Following those requirements, each collection will need to "prepare" the\nenvironment for the actual test. That is achieved by using specific\nrequests, called "helpers", and their only purpose is to create/delete\nall the needed objects. \n Another class of helpers is used to check the persistence of the actions\nperformed by the APIs, i.e. check that after a DELETE, something really\nhas been deleted. \n The request that implements the use case, we can call it main request,\ndoes not contain the word "HELPER" in its name, and it is the only one\ninside a given collection. \n Because collections are designed primarily to run automatically, we have\ndone extensive use of collection variables, so variables like the API\nURL, object names, object codes or payloads are usually defined as a\ncollection variable and can be accessed by all requests inside the\ncollection. \n'},{title:"Plugin Configuration Profiles",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/devops/plugin-configuration.html",relativePath:"v7.0/tutorials/devops/plugin-configuration.md",key:"v-173773e2",path:"/v7.0/tutorials/devops/plugin-configuration.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Profile Options",slug:"profile-options"},{level:2,title:"Configuration",slug:"configuration"},{level:3,title:"Retrieve the Plugin ID",slug:"retrieve-the-plugin-id"},{level:3,title:"Method 1: Inline Profile",slug:"method-1-inline-profile"},{level:3,title:"Method 2: Mapped Profile",slug:"method-2-mapped-profile"},{level:3,title:"Method 3: Default Profile",slug:"method-3-default-profile"},{level:2,title:"References",slug:"references"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Plugin Configuration Profiles \n This tutorial describes three methods to utilize configuration profiles to specify resource allocation for Entando plugins. This provides a simple way to customize plugin deployment parameters for improved efficiency. \n Prerequisites \n \n Add an Entando Operator ConfigMap  if needed \n Enable this property under the  data  section so that the Entando Operator can manage resource settings. \n \n   entando.k8s.operator.impose.limits :   "true" \n Profile Options \n The three methods to insert configuration profiles are: \n \n Inline Profile \n Mapped Profile \n Default Profile \n \n Currently, the following resources for memory and CPU can be specified. When you specify a  limit  on a resource, it is the maximum allowed for the container. Resource settings help Kubernetes determine in which node a pod should be created. \n resources.limits.cpu :        integer ,  millicpus\n resources.limits.memory :     integer ,  mebibytes\n Configuration \n A profile is a set of configurations encoded as YAML but embedded in the  OperatorConfigMap  as a string, since ConfigMaps cannot be multilevel. The examples below use  YOUR-PLUGIN-ID  and  YOUR-PROFILE-NAME  as placeholders for your names. Also note  |-  in the sample codes to specify each new line is read as such. \n Retrieve the Plugin ID \n You will need to  retrieve the Plugin ID  which is calculated during installation and written to the EntandoPlugin Custom Resource as part of the deployment of the plugin microservice. Use the following command from the project directory \n ent prj get-plugin-id --auto\n \n If you just have a bundle, use this command with the appropriate parameters \n ent ecr get-plugin-id --autho --repo = YOUR-BUNDLE-REPO-URL\n \n Example: \n $ ent ecr get-plugin-id --auto --repo = https://github.com/entando-samples/entando-hub-application-bundle.git\npn-cee95efc-77ff566e-entandopsdh-entando-hub-catalog-ms\n Method 1: Inline Profile \n Add the parameters to the  OperatorConfigMap  as an inline profile at  data/entando.profile.plugins.YOUR-PLUGIN-ID . \n Example: \n data : \n   entando.profile.plugins.YOUR-PLUGIN-ID :   | - \n     resources.limits.cpu :   "1000" \n     resources.limits.memory :   "2000" \n Method 2: Mapped Profile \n \n Create the parameter profile in the  OperatorConfigMap  of the data profile at  data/entando.profile.YOUR-PROFILE-NAME . \n \n Example: \n data : \n   entando.profile.YOUR-PROFILE-NAME :   | - \n     resources.limits.cpu :   "1000" \n     resources.limits.memory :   "2000" \n \n \n Add a reference in the  profileMapping  file at  data/entando.plugins.profileMapping : \n \n data : \n   entando.plugins.profileMapping :   | - \n     your-plugin-id :  YOUR - PROFILE - NAME\n Method 3: Default Profile \n \n Add the profile to the  OperatorConfigMap  in the data section at  data/entando.profile.YOUR-PROFILE-NAME . \n \n data : \n   entando.profile.YOUR-PROFILE-NAME :   | - \n     resources.limits.cpu :   "1000" \n     resources.limits.memory :   "2000" \n \n \n Add a reference to the profile at  data/entando.plugins.defaultProfile : \n \n data : \n   entando.plugins.defaultProfile :  YOUR - PROFILE - NAME\n References \n Please refer to the  Kubernetes documentation on Resources  for more details. \n'},{title:"Use Plugin Environment Variables to Customize Microservices",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/devops/plugin-environment-variables.html",relativePath:"v7.0/tutorials/devops/plugin-environment-variables.md",key:"v-1e637d54",path:"/v7.0/tutorials/devops/plugin-environment-variables.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Add Environment Variables to the Plugin Descriptor File",slug:"add-environment-variables-to-the-plugin-descriptor-file"},{level:2,title:"Verify the Environment Variables",slug:"verify-the-environment-variables"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Use Plugin Environment Variables to Customize Microservices \n This tutorial describes how to use environment variables to customize the behavior of plugin microservices. Using environment variables as a configuration mechanism allows the same Linux image to run in development and production environments. This is especially useful when managing sensitive information via Kubernetes Secrets. \n Version 4 of the Entando plugin descriptor adds the ability to make environment variables available to a microservice via the plugin  descriptor.yaml  file. There are two options. \n \n Inject the variables using a key-value pair \n Inject a reference to an existing Kubernetes Secret \n \n This tutorial will demonstrate both of these options. The Entando Plugin will receive one environment value directly as plain text in the Pod YAML and the other indirectly via a referenced Secret. \n Prerequisites \n \n A project bundle  using the latest Entando Blueprint. \n Add Environment Variables to the Plugin Descriptor File \n \n Determine YOUR-BUNDLE-ID. You can do this from your project directory using this command: \n \n ent prj get-bundle-id\n \n Alternatively, supply the full bundle URL (including the .git suffix): \n ent ecr get-bundle-id https://github.com/YOUR-ACCOUNT/YOUR-PLUGIN-BUNDLE.git\n \n For example, here's the bundle ID for the first  Standard Banking Demo bundle : \n $ent ecr https://github.com/entando-samples/standard-demo-banking-bundle.git\n343826ca\n \n \n Now create a Secret named  YOUR-BUNDLE-ID-my-secret  with a key-value pair  mySecretKey=mySecretValue . Make sure to replace YOUR-BUNDLE-ID with the value from the previous step. \n \n kubectl create secret generic YOUR-BUNDLE-ID-my-secret --from-literal = mySecretKey = mySecretValue -n entando\n \n \n Verify that the plugin file  bundle/plugins/YOUR-PLUGIN.yaml  specifies  descriptorVersion: v4  or add it if you're upgrading an existing bundle. \n Insert the following  environmentVariables  section into  YOUR-PLUGIN.yaml  after replacing  YOUR-BUNDLE-ID  with the correct value. By convention, environment variables are all caps and K8s resource names are hyphenated. \n \n environmentVariables : \n   -   name :  SIMPLE_VAR\n     value :  mySimpleValue\n   -   name :  SECRET_VAR\n     valueFrom : \n       secretKeyRef : \n         name :  YOUR - BUNDLE - ID - my - secret\n         key :  mySecretKey\n \n \n Build and deploy  the updated bundle. \n Verify the Environment Variables \n \n When the installation is complete, open a terminal into the pod created by the plugin.  YOUR-PLUGIN-POD-NAME  will begin with  pn-  plus  YOUR-BUNDLE-ID  from above. \n \n kubectl  exec  -it YOUR-PLUGIN-POD-NAME -- /bin/bash\n \n \n Check for the environment variables using the command  env  or this command: \n \n echo   SIMPLE_VAR = $SIMPLE_VAR ,  SECRET_VAR = $SECRET_VAR \n \n Expected output: \n SIMPLE_VAR=mySimpleValue, SECRET_VAR=mySecretValue\n \n You have now learned to use environment variables with plugin microsevices on the Entando Platform. \n"},{title:"Manage NGINX",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/devops/manage-nginx.html",relativePath:"v7.0/tutorials/devops/manage-nginx.md",key:"v-3accb136",path:"/v7.0/tutorials/devops/manage-nginx.html",headers:[{level:2,title:"Verify the NGINX Ingress Install",slug:"verify-the-nginx-ingress-install"},{level:2,title:"Customize the NGINX Configuration",slug:"customize-the-nginx-configuration"},{level:2,title:"Add the cert-manager for TLS Support",slug:"add-the-cert-manager-for-tls-support"},{level:3,title:"Installation",slug:"installation"},{level:3,title:"Configuration",slug:"configuration"},{level:3,title:"cert-manager References",slug:"cert-manager-references"}],lastUpdated:"4/21/2022, 1:23:40 PM",lastUpdatedTimestamp:165056182e4,content:' Manage NGINX \n There are environments where it\'s useful to use NGINX rather than the default ingress controller. This page shows how to verify and refine your NGINX configuration. \n See the following install guides if needed: \n \n Amazon Elastic Kubernetes Service (EKS) \n Azure Kubernetes Service (AKS) \n Google Kubernetes Engine (GKE) \n Verify the NGINX Ingress Install \n To verify that the ingress is working properly you can set up a test application. \n \n Create a simple application: \n \n kubectl create deployment hello-server --image=us-docker.pkg.dev/google-samples/containers/gke/hello-app:1.0\n \n \n Expose the  hello-app  deployment as a Service: \n \n kubectl expose deployment hello-server --type LoadBalancer --port 80 --target-port 8080\n \n \n Create this  ingress-resource.yaml  file: \n \n apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: ingress-resource\n  annotations:\n    kubernetes.io/ingress.class: nginx\n    nginx.ingress.kubernetes.io/ssl-redirect: "false"\nspec:\n  rules:\n  - http:\n      paths:\n      - path: /hello\n        pathType: Prefix\n        backend:\n          service:\n            name: hello-server\n            port: \n              number: 80\n \n \n Create the Ingress Resource: \n \n kubectl apply -f ingress-resource.yaml\n \n \n Verify that the Ingress Resource has been created: \n \n kubectl get ingress ingress-resource\n \n It may take several minutes to populate the  Address . \n \n Verify access to the web application using the  EXTERNAL-IP/hello  address of the  nginx-ingress-controller . You should see the following: \n \n Hello, world!\nVersion: 1.0.0\nHostname: hello-app\n \n Note that you will need the EXTERNAL-IP address of your ingress controller to configure the application. \n \n Verify that you configured the ingress class in the Operator  ConfigMap  so Entando knows which ingress controller should be used: \n \n entando.ingress.class: "nginx" \n \n To reduce costs, remove the test deployment, service, and ingress: \n \n kubectl delete deploy/hello-server service/hello-server ing/ingress-resource\n Customize the NGINX Configuration \n There are situations where the default NGINX ingress configuration isn\'t optimized for Entando, e.g. JWT tokens can be too large or  proxy-buffer-size  can be too small. A  502 Bad Gateway  error may indicate that the config needs to be modified. \n The NGINX controller can be configured for the entire cluster by editing the default NGINX  ConfigMap , called  ingress-nginx-controller  in the  ingress-nginx  namespace. Add the following to the data parameter: \n apiVersion: v1\ndata:\n  allow-snippet-annotations: "true"\n  proxy-buffer-size: 24k\nkind: ConfigMap\n \n Production environments may require additional common annotations: \n nginx.ingress.kubernetes.io/proxy-body-size: 200m # to upload large files (default is 10M)\nnginx.ingress.kubernetes.io/proxy-buffer-size: 64k # for the Keycloak auth-token (default is 16K)\nnginx.ingress.kubernetes.io/proxy-read-timeout: "600" # to increase the timeout when uploading large files\n \n Sticky sessions may be useful for  entando-de-app  deployments with multiple replicas. If you  set up clustering , the following options will enable sticky sessions in NGINX: \n nginx.ingress.kubernetes.io/affinity: cookie\nnginx.ingress.kubernetes.io/affinity-mode: balanced\n Add the  cert-manager  for TLS Support \n Follow the instructions below to install and configure  cert-manager  in Kubernetes environments.\n​ \n Installation \n ​\nCreate a namespace dedicated to  cert-manager : \n kubectl create ns cert-manager\n \n ​\nComplete the installation: \n kubectl apply  - f https : //github.com/jetstack/cert - manager/releases/download/v1.7.0/cert - manager.yaml\n Configuration \n ​\nTo enable  cert-manager  to generate certificates, add these annotations to the ingress:\n​ \n \n cert-manager.io/issuer: "[name of the issuer]"  for namespace-based issuers \n cert-manager.io/cluster-issuer: "[name of cluster issuer]"  for cluster-wide issuers \n \n and modify  spec : \n spec : \n   tls : \n   -   hosts : \n     -  example.example.com\n     secretName :  quickstart - example - tls  # this Secret will be autogenereted by cert-manager. \n Namespace Level Issuer \n ​\nUse the following configuration when deploying an issuer per namespace. This is useful for higher levels of customization.\n​ \n apiVersion :  cert - manager.io/v1\n kind :  Issuer\n metadata : \n   name :  letsencrypt - prod\n spec : \n   acme : \nThe ACME server URL \n     server :  https : //acme - v02.api.letsencrypt.org/directory\n     preferredChain :   "ISRG Root X1" \nEmail address used for ACME registration \n     email :  <your email > \nName of a secret used to store the ACME account privare key \n     privateKeySecretRef : \n       name :  letsencrypt - prod\nEnable the http-01 challenge provider \n     solvers : \n     -   http01 : \n         ingress : \n           class :  nginx\n​\n Cluster Level Issuer \n Use the following configuration when deploying an issuer per cluster: \n apiVersion :  cert - manager.io/v1\n kind :  ClusterIssuer\n metadata : \n   name :  letsencrypt - prod - cluster\n   namespace :  cert - manager\n spec : \n   acme : \nThe ACME server URL \n     server :  https : //acme - v02.api.letsencrypt.org/directory\n     preferredChain :   "ISRG Root X1" \nEmail address used for ACME registration \n     email :  <your email > \nName of a secret used to store the ACME account privare key \n     privateKeySecretRef : \n       name :  letsencrypt - cluster - prod\nEnable the http-01 challenge provider \n     solvers : \n     -   http01 : \n         ingress : \n           class :  nginx\n​\n  cert-manager  References \n \n Installation \n Supported releases \n \n'},{title:"Installation on Amazon Elastic Kubernetes Service (EKS)",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/getting-started/eks-install.html",relativePath:"v7.0/tutorials/getting-started/eks-install.md",key:"v-dc748a20",path:"/v7.0/tutorials/getting-started/eks-install.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Create and Connect the EKS Cluster",slug:"create-and-connect-the-eks-cluster"},{level:3,title:"Configure an Identity and Access Management (IAM) Role",slug:"configure-an-identity-and-access-management-iam-role"},{level:3,title:"Create the EKS Cluster",slug:"create-the-eks-cluster"},{level:3,title:"Add a Node Group to the Cluster",slug:"add-a-node-group-to-the-cluster"},{level:3,title:"Connect to the Cluster",slug:"connect-to-the-cluster"},{level:3,title:"Install the NGINX Ingress Controller",slug:"install-the-nginx-ingress-controller"},{level:3,title:"Install the Entando Custom Resources",slug:"install-the-entando-custom-resources"},{level:3,title:"Configure the Entando Application",slug:"configure-the-entando-application"},{level:2,title:"Deploy your Entando Application",slug:"deploy-your-entando-application"},{level:2,title:"Appendix A - Troubleshooting",slug:"appendix-a-troubleshooting"}],lastUpdated:"4/20/2022, 3:15:21 PM",lastUpdatedTimestamp:1650482121e3,content:' Installation on Amazon Elastic Kubernetes Service (EKS) \n This tutorial walks you through installing the Entando Platform in an EKS cluster. The steps are: \n \n Configure an IAM Role  to allow Kubernetes to manage the cluster \n Create the EKS cluster \n Install NGINX  as an ingress controller \n Install the Entando Custom Resources \n Configure the Entando Application \n Deploy the Entando Application \n \n If you\'re already comfortable setting up an EKS cluster and installing NGINX, then you may be able to skip to  setting up Entando . \n Prerequisites \n \n AWS CLI \n AWS account \n kubectl \n Create and Connect the EKS Cluster \n These steps use the AWS console to create the cluster. Experienced AWS users may choose to use the equivalent CLI commands. \n Configure an Identity and Access Management (IAM) Role \n \n \n Login to AWS  as a non- super admin  user \n \n It is not recommended to use a  super admin  account since clusters created that way may have restrictions that complicate your installation. \n The user account needs access to EKS and the minimum permissions to create a cluster. You may need additional policies for Amazon Route 53 or other services, depending on your configuration. \n \n \n \n Create an IAM role for the cluster so that AWS can provision assets \n \n From Services,  IAM  →  Create Role \n Select  AWS Service  for the type of trusted entity \n Click  EKS  from the  Use cases \n Check  EKS - Cluster \n Click  Next \n Verify that the  AmazonEKSClusterPolicy  is set \n Click  Next \n Name your role (you’ll need this later), e.g. YOUR-EKS-ROLE \n Click  Create role \n \n \n \n Refine the role to enable  Node Group  management and add elastic load balancer (ELB) access so the cluster can deploy the ELB for NGINX \n \n Go to  IAM  →  Roles  →  YOUR-EKS-ROLE \n Under  Add permissions , click  Attach policies \n Find each of these named policies and then click  Attach policies   \n AmazonEKSWorkerNodePolicy   \n AmazonEKS_CNI_Policy   \n AmazonEC2ContainerRegistryReadOnly   \n ElasticLoadBalancingFullAccess \n Go to  Trust Relationships  →  Edit trust policy  →  Add new statement . Add  ec2.amazonaws.com  so the cluster can manage the EC2 resources. \n \n \n \n Go to  Identity Management and Access on EKS  for more details on roles. \n Create the EKS Cluster \n \n Go to  Services  and select  Elastic Kubernetes Service \n Click  Add cluster  →  Create \n Add a cluster name, e.g. YOUR-CLUSTER-1 \n Select 1.21 for the Kubernetes version \n For  Cluster Service Role , select the role you created above, e.g. YOUR-EKS-ROLE \n Click  Next \n Use the defaults for  Networking  (Step 2) and click  Next \n Use the defaults for  Configure Logging  (Step 3) and click  Next \n Review your settings and then click  Create . Cluster provisioning may take several minutes. \n \n See  Creating an Amazon EKS Cluster  for more detailed information. \n Add a Node Group to the Cluster \n \n Go to  Services  →  Elastic Kubernetes Service  →  Clusters  and select YOUR-CLUSTER-NAME \n Go to  Configuration  →  Compute \n Click  Add Node Group  and supply the following fields\n \n Name : Give your group a name, e.g. YOUR-NODE-1 \n Node IAM Role : Select the cluster role you created above. If the role doesn\'t appear, verify that you modified the trust policy as noted above. \n Click  Next \n \n \n Review the  Node Group compute and scaling configuration . These AWS defaults will work fine:\n \n AMI type:  Amazon Linux 2 \n Instance type:  t3.medium \n \n \n Set the  Maximum size  to  5 . This is over-resourced for a Getting Started instance but offers capacity for adding microservices to your cluster without modifying the Node Group.\n \n Click  Next \n \n \n For  Node Group network configuration , the subnets should already be set up and selected \n Select  Configure SSH access to nodes . Follow the links to create a new SSH key pair if you don\'t already have one. \n Select  All  to allow all source IPs \n Click  Next \n Review your settings and then click  Create . It may take a few minutes for the Node Group to be created. \n Connect to the Cluster \n \n Note:  If this is a brand new setup, you will need to configure the AWS CLI using the user account from the steps above. You\'ll need to provide your Access Key ID, Secret Key, and Region. \n \n aws configure\n \n \n Set up your Kubernetes context \n \n aws eks --region REGION-CODE update-kubeconfig --name YOUR-CLUSTER-1\n \n For example:  aws eks --region us-east-2 update-kubeconfig --name cluster-1 . More details and troubleshooting can be found here.  https://docs.aws.amazon.com/eks/latest/userguide/create-kubeconfig.html \n \n Your current context should now be configured for your AWS cluster. Run the command below to check. \n \n kubectl config current-context\n \n Your output should look something like this:  arn:aws:eks:us-east-2:483173223614:cluster/cluster-1 \n Install the NGINX Ingress Controller \n Add the NGINX controller for the ingress. This step relies on your role having permissions for Elastic Load Balancing (ELB). \n \n Create the NGINX ingress controller \n \n kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.1.3/deploy/static/provider/aws/deploy.yaml\n \n \n Get the ELB external URL for your NGINX install \n \n kubectl get services -n ingress-nginx\n \n For example: \n NAME                                 TYPE           CLUSTER-IP       EXTERNAL-IP                        \ningress-nginx-controller             LoadBalancer   10.100.102.83    ad234bd11a1ff4dadb44639a6bbf707e-0e0a483d966405ee.elb.us-east-2.amazonaws.com\n \n The value of the external URL (EXTERNAL-IP) should be available within a few minutes. You\'ll use this address for YOUR-HOST-NAME in the steps below. \n TIP \n NGINX is working correctly if a  404 Not Found  NGINX error page is generated when accessing  http://YOUR-HOST-NAME  from your browser. For a more complete test, you can  set up a simple test application  using your local  kubectl . You can also  customize the NGINX ingress  to optimize the configuration for Entando. \n \n See the  NGINX AWS Guide  and  NGINX EKS Guide  for more details. \n Install the Entando Custom Resources \n \n Apply the cluster-scoped custom resource definitions (CRDs). This is required only once per cluster. \n \n kubectl apply -f https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/namespace-scoped-deployment/cluster-resources.yaml\n \n \n Create the namespace for the Entando Application \n \n kubectl create namespace entando\n \n \n Download the  entando-operator-config  template so you can configure the  Entando Operator . \n \n curl  -sLO  "https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/samples/entando-operator-config.yaml" \n \n \n Edit the  entando-operator-config.yaml  to set  data/entando.requires.filesystem.group.override: "true" \n \n data : \n    entando.requires.filesystem.group.override :   "true" \n    entando.ingress.class :   "nginx" \n \n \n Apply the  ConfigMap \n \n kubectl apply -f entando-operator-config.yaml -n entando\n \n \n Apply the namespace-scoped custom resources \n \n kubectl apply -n entando -f https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/namespace-scoped-deployment/namespace-resources.yaml\n \n \n You can use  kubectl get pods -n entando --watch  to see the initial pods start up. Use  Ctrl+C  to exit. \n \n $ kubectl get pods -n entando\nNAME                                   READY   STATUS    RESTARTS   AGE\nentando-k8s-service-86f8954d56-mphpr   1/1     Running   0          5m53s\nentando-operator-5b5465788b-ghb25      1/1     Running   0          5m53s\n Configure the Entando Application \n \n Download the  entando-app.yaml  template \n \n curl  -sLO  "https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/samples/entando-app.yaml" \n \n \n Edit  entando-app.yaml  and replace YOUR-HOST-NAME with the NGINX address from above. See the  Custom Resources overview  for details on other  EntandoApp  options. \n \n spec : \n   ingressHostName :  YOUR - HOST - NAME\n Deploy your Entando Application \n \n You can now deploy your application to your EKS cluster \n \n kubectl apply -n entando -f entando-app.yaml\n \n \n It can take around 10 minutes for the application to fully deploy. You can watch the pods warming up with this command: \n \n kubectl get pods -n entando --watch\n \n Use  Ctrl+C  to exit the command. \n \n Once all the pods are in a running state, access the Entando App Builder at the following address: \n \n http://YOUR-HOST-NAME/app-builder/\n \n Congratulations! To continue your journey with Entando, see the  Getting Started guide  for helpful login instructions and next steps. \n Appendix A - Troubleshooting \n IAM and Roles \n \n Installing aws-iam-authenticator \n AccessDenied error during AssumeRole operation \n \n NGINX \n \n Using NGINX as the ingress controller on EKS \n \n For more details and troubleshooting, see  Create a kubeconfig for Amazon EKS . \n'},{title:"Installation on Kubernetes",frontmatter:{},regularPath:"/v7.0/tutorials/getting-started/kubernetes-install.html",relativePath:"v7.0/tutorials/getting-started/kubernetes-install.md",key:"v-261acd60",path:"/v7.0/tutorials/getting-started/kubernetes-install.html",headers:[{level:2,title:"Infrastructure Requirements",slug:"infrastructure-requirements"},{level:2,title:"Minimum Hardware Requirements",slug:"minimum-hardware-requirements"},{level:3,title:"For Entando install only:",slug:"for-entando-install-only"},{level:3,title:"For Entando + Microservices:",slug:"for-entando-microservices"},{level:3,title:"For Entando with CMS:",slug:"for-entando-with-cms"},{level:2,title:"Backup Strategies",slug:"backup-strategies"},{level:2,title:"Notes",slug:"notes"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Installation on Kubernetes \n Infrastructure Requirements \n These are the minimum infrastructure requirements to install Entando directly on a Kubernetes (K8s) cluster: \n \n A working DNS server configured to resolve internal and external names. If you choose to configure K8s with a global wildcard domain name for the entire cluster, be sure it points to the public IP address of the external Load Balancer of the worker nodes. \n A default  Storage Class  is needed for the Entando Operator to create the correct Persistent Volume Claims (PVC) for each pod. \n Nginx  Ingress-Controller  is needed to expose the Entando applications. \n Minimum Hardware Requirements \n The minimum hardware requirements depend on how you intend to use Entando. The more functionality you need, such as a content management system (CMS), the more you will need. \n For Entando install only: \n \n 6 vCPU or virtual central processing unit  (6000 millicores) \n 6 GB of RAM \n 5 GB of allocated storage distributed in many PVCs \n \n Configure a single worker node with the requirements above or designate 3 worker nodes with the minimum of 2 PVC and 4 GB of RAM each. \n For Entando + Microservices: \n \n 500 millicores per microservice or \n 1000 millicores per microservice with a database \n \n The tested instance was generated with a JHipster Entando blueprint. \n For Entando with CMS: \n To install Entando with CMS, the hardware requirements depend on the complexity and number of pages and contents. The minimum requirements are: \n \n 9 vCPU for a single CMS instance. To scale up, you need 4 vCPU per replica. \n 8 GB of RAM for a single CMS instance. To scale up, you need 4 GB of RAM per replica. \n A minimum of 50 GB of storage for all the static resources generated by the use of Entando CMS. \n Backup Strategies \n The recommended method to secure your content is to use database services that automate backups and restores on a Kubernetes cluster like Azure, Red Hat OpenShift, Google K8s Service or Amazon Elastic. If this is not an option, there are tools like  Velero  and  Cloudcase  to manage them. \n Note: Some DevOps teams warn against running databases inside pods in production environments. \n If using the Entando CMS, be sure to protect related schemas ( port  and  serv ) with a valid disaster recovery plan. Protect all volumes containing your static resources with daily snapshots. \n Notes \n See the  Entando compatibility guide  for compatible Kubernetes versions. \n"},{title:"Installation on Azure Kubernetes Service (AKS)",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/getting-started/azure-install.html",relativePath:"v7.0/tutorials/getting-started/azure-install.md",key:"v-392f6e6c",path:"/v7.0/tutorials/getting-started/azure-install.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Cluster Setup",slug:"cluster-setup"},{level:3,title:"Setup and Connect to the Cluster",slug:"setup-and-connect-to-the-cluster"},{level:3,title:"Deploy NGINX Ingress Controller",slug:"deploy-nginx-ingress-controller"},{level:3,title:"Install the Entando Custom Resources",slug:"install-the-entando-custom-resources"},{level:3,title:"Configure the Entando Application",slug:"configure-the-entando-application"},{level:2,title:"Deploy your Entando Application",slug:"deploy-your-entando-application"},{level:2,title:"Appendix A - Troubleshooting",slug:"appendix-a-troubleshooting"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Installation on Azure Kubernetes Service (AKS) \n The steps below walk you through installing the Entando Platform in an Azure Kubernetes Services (AKS) cluster. \n \n Create a single AKS cluster \n Install NGINX as an ingress controller \n Install the Entando Custom Resources \n Configure the Entando Application \n Deploy Entando \n \n If you're already comfortable setting up an AKS cluster and installing NGINX, then you may be able to skip to  setting up Entando . \n Prerequisites \n \n Azure account \n If you choose not to use the Azure Cloud Shell, you'll also need the Azure command line tool. \n \n TIP \n If you're using an Azure free account, you may need to upgrade your account to enable pay-as-you-go billing. The Azure free account default quota allows just 1-4 vCPU which is not sufficient for this tutorial. There may be a delay before the quotas are updated when you upgrade your account. \n Cluster Setup \n Setup and Connect to the Cluster \n \n Login to Azure:  https://portal.azure.com/ \n Select the  Kubernetes services  icon\n \n If the icon isn't visible, click  More services  on the right and search for Kubernetes \n \n \n Click  Create  in the upper left corner \n Select  Create a Kubernetes cluster . You'll start with the  Basics  tab. \n Select a  Resource group  or create one with the  Create new  link, e.g. YOUR-RESOURCE-GROUP \n Enter a name of your choice for the Kubernetes cluster name, e.g. YOUR-CLUSTER \n Pick your  Region  if it wasn't automatically selected for you. \n In the  Availability zones  dropdown, pick  one and only one  availability zone\n \n Generally, you could pick more than one but it will result in a failure in a quickstart environment. If you chose more than one availability zone you will have to provision storage, manage node affinity, and provide the correct network configuration to ensure your application deploys. We recommend only doing this for production clusters. \n \n \n Select an  Entando-compatible Kubernetes version , e.g. 1.21.x \n Keep the default  Node size , e.g. Standard DS2 v2 \n Keep the  Scale Method  set to  Autoscale  and the  Node count range  set from  1  to  5 \n (Optional) If you're familiar with AKS, you can change settings under other tabs (e.g.  Node Pools ,  Access ) as desired but the defaults should work. Entando uses base Kubernetes APIs, so as long as you follow the Entando configuration instructions below, you can tune your cluster infrastructure to meet your goals. \n Click  Review + Create  then  Create . It may take several minutes for your cluster to initialize. \n \n Note: A different storage class can be configured for  Clustered Storage . \n Deploy NGINX Ingress Controller \n \n Navigate to your cluster by clicking  Go to Resource  from the results page, or go to  Home  →  Kubernetes service  and click on your cluster. \n Select  Connect \n Select  Open Cloud Shell \n \n With a new Azure account, you may see a warning:  You have no storage mounted . Follow the instructions to create a new storage account. \n \n \n If it wasn't done automatically, run the first two commands (e.g.  az account set...  and  az aks get-credentials... ) to connect to your cluster. This should only be needed the first time you run the Azure Cloud Shell.\n \n The following instructions assume you will use the Azure Cloud Shell but you can also run the commands in a local environment via  kubectl \n \n \n Deploy the NGINX controller to enable access to the cluster \n \n kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.1.3/deploy/static/provider/aws/deploy.yaml \n \n \n Get the external IP address for your ingress controller \n \n kubectl get services -n ingress-nginx\n \n For example: \n NAME                      TYPE          CLUSTER-IP    EXTERNAL-IP                        \ningress-nginx-controller  LoadBalancer  10.0.28.197   20.120.54.243\n \n The value of the external URL (EXTERNAL-IP) should be available within a few minutes. You'll need this address for  YOUR-HOST-NAME  in the steps below. \n TIP \n NGINX is working correctly if a  404 Not Found  error page is generated when accessing  YOUR-HOST-NAME  from your browser. For a more complete test, you can  set up a simple test application  using Azure Cloud Shell or your local  kubectl . You can also  customize the NGINX ingress  to optimize the configuration for Entando. \n \n See the  Install Guide for NGINX on Azure  for more information. \n Install the Entando Custom Resources \n \n Apply the cluster-scoped custom resource definitions (CRDs). This is required only once per cluster. \n \n kubectl apply -f https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/namespace-scoped-deployment/cluster-resources.yaml\n \n \n Create the namespace for the Entando Application \n \n kubectl create namespace entando\n \n \n Download the  entando-operator-config  template so you can configure the  Entando Operator \n \n curl  -sLO  \"https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/samples/entando-operator-config.yaml\" \n \n \n Edit the  entando-operator-config.yaml  to add two properties \n \n data : \n    entando.requires.filesystem.group.override :   \"true\" \n    entando.ingress.class :   \"nginx\" \n \n \n Apply the  ConfigMap \n \n kubectl apply -f entando-operator-config.yaml -n entando\n \n \n Apply the namespace-scoped custom resources \n \n kubectl apply -n entando -f https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/namespace-scoped-deployment/namespace-resources.yaml\n \n \n You can use  kubectl get pods -n entando --watch  to see the initial pods start up. Use  Ctrl+C  to exit. \n \n $ kubectl get pods -n entando\nNAME                                   READY   STATUS    RESTARTS   AGE\nentando-k8s-service-86f8954d56-mphpr   1/1     Running   0          5m53s\nentando-operator-5b5465788b-ghb25      1/1     Running   0          5m53s\n Configure the Entando Application \n \n Download the  entando-app.yaml  template \n \n curl  -sLO  \"https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/samples/entando-app.yaml\" \n \n \n Edit  entando-app.yaml . Replace  YOUR-HOST-NAME  with  EXTERNAL-IP + .nip.io . See  the EntandoApp custom resource overview  for additional options. \n \n spec : \n   ingressHostName :  YOUR - HOST - NAME\n \n e.g.  ingressHostName: 20.120.54.243.nip.io \n Deploy your Entando Application \n \n You can now deploy your application to your AKS cluster \n \n kubectl apply -n entando -f entando-app.yaml\n \n \n It can take around 10 minutes for the application to fully deploy. You can watch the pods warming up with the command below. Use  Ctrl+C  to exit the command. \n \n kubectl get pods -n entando --watch\n \n \n Once all the pods are in a running state, access the Entando App Builder at the following address \n \n http://YOUR-HOST-NAME/app-builder/\n \n See the  Getting Started guide  for helpful login instructions and next steps. \n Appendix A - Troubleshooting \n If you get an error like:  0/5 nodes are available: 5 node(s) had volume node affinity conflict  or if several deployments fail to start, then you should check your availability zones. By default, an Azure cluster will include nodes from multiple zones, but Azure may not automatically provision their storage. \n You can confirm this error in the AKS console as well: \n \n In your cluster, select  Workloads  in the left nav \n Click on the deployment for your server application. This is  quickstart-deployment  by default. \n Click on the deployment name inside that application. \n Click on the tab labeled  Conditions \n If you see an error that says  0/5 nodes are available: 5 node(s) had volume node affinity conflict , then you need to reconfigure your cluster to have nodes in one zone, or work with your Azure operations team to provision storage to match node affinity. \n \n"},{title:"Installation on Google Kubernetes Engine (GKE)",frontmatter:{},regularPath:"/v7.0/tutorials/getting-started/gke-install.html",relativePath:"v7.0/tutorials/getting-started/gke-install.md",key:"v-61df9ff0",path:"/v7.0/tutorials/getting-started/gke-install.html",headers:[{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Cluster Setup",slug:"cluster-setup"},{level:3,title:"Install the NGINX Ingress Controller",slug:"install-the-nginx-ingress-controller"},{level:3,title:"Install the Entando Custom Resources",slug:"install-the-entando-custom-resources"},{level:3,title:"Configure the Entando Application",slug:"configure-the-entando-application"},{level:2,title:"Deploy Your Entando Application",slug:"deploy-your-entando-application"},{level:2,title:"Appendix: Configuring Clustered Storage",slug:"appendix-configuring-clustered-storage"},{level:3,title:"Clustered Storage Using GCP Cloud Filestore",slug:"clustered-storage-using-gcp-cloud-filestore"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Installation on Google Kubernetes Engine (GKE) \n Prerequisites \n \n Google Cloud account:  http://cloud.google.com \n If you choose not to use the Google Cloud Shell, install the  Google Cloud SDK \n Cluster Setup \n These steps only need to be completed once per cluster. \n \n \n Login to your Google Cloud account:  https://cloud.google.com/ \n \n \n Go to  Kubernetes Engine  →  Clusters \n \n \n Select an existing project or create a new one \n \n \n Click  Enable  for the  Kubernetes Engine API \n \n \n Once the API is enabled, click  Create  to create a cluster \n \n \n Click the  Configure  button for the  GKE Standard  option. Unless otherwise indicated, you can keep the default configuration options. \n \n \n In the left menu, select  default-pool  →  Nodes \n \n \n Select "e2-standard-2" as the  Machine Type  if you are setting up a basic test cluster for a single Entando Application. Additional CPU and memory may be required for a shared cluster containing multiple Entando Applications or to improve performance. Refer to  Appendix A  for details on clustered storage. \n \n \n Click  Create . It may take a few minutes for the cluster to initialize. \n \n \n Click  Connect \n \n \n Click  Run in Cloud Shell . Alternatively, connect your local  kubectl  to the GKE cluster. \n \n \n Run  kubectl get node  to verify your connection. The output should list the nodes in your cluster. \n Install the NGINX Ingress Controller \n The following steps install the NGINX ingress controller to manage the ingresses for Entando services deployed by the operator. This is a simpler and more adaptable configuration for most users and environments. Users who require the GKE ingress controller (this is rare) can follow\n the integration instructions provided by GKE  and then customize the service definition created by the Entando operator. \n These are the mimimum instructions to prepare the NGINX ingress using the Google Cloud Shell.\nFor installation using your local  kubectl  or to vary other settings, refer to the  Ingress with NGINX guide  or the  GCE-GKE tutorial . \n \n Initialize your user as a cluster-admin \n \n kubectl create clusterrolebinding cluster-admin-binding --clusterrole cluster-admin  \\ \n--user  $( gcloud config get-value account ) \n \n \n Install the ingress controller pods \n \n kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/provider/cloud/deploy.yaml\n \n \n Get the external IP address for your ingress controller, e.g. the EXTERNAL-IP value of  nginx-ingress-controller , once the ingress-nginx pods are all running. Use  Ctrl+C  to exit the command once the EXTERNAL-IP is displayed. \n \n kubectl get  service  -n ingress-nginx --watch\n \n TIP \n NGINX is working correctly if a  404 Not Found  NGINX error page is generated when accessing the EXTERNAL-IP from your browser. For a more complete test, you can  set up a simple test application  using your local  kubectl . You can also  customize the NGINX ingress  to optimize the configuration for Entando. \n Install the Entando Custom Resources \n \n Download and apply the custom resource definitions (CRDs) to the cluster. This must be done once per cluster. \n \n kubectl apply -f https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/namespace-scoped-deployment/cluster-resources.yaml\n \n \n Create a namespace for the Entando Application. Here we call the namespace "entando". If you choose a different name, update the following commands whenever a namespace is provided. \n \n kubectl create namespace entando\n \n \n Download the  entando-operator-config  template so you can configure the  Entando Operator \n \n curl  -sLO  "https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/samples/entando-operator-config.yaml" \n \n \n Edit the  entando-operator-config.yaml  to add two properties \n \n data : \n    entando.requires.filesystem.group.override :   "true" \n    entando.ingress.class :   "nginx" \n \n \n Apply the  ConfigMap \n \n kubectl apply -f entando-operator-config.yaml -n entando\n \n \n Install the namespace-scoped resources \n \n kubectl apply -n entando -f https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/namespace-scoped-deployment/namespace-resources.yaml\n \n \n You can use  kubectl get pods -n entando --watch  to see the initial pods start up. Use  Ctrl+C  to exit. \n \n $ kubectl get pods -n entando\nNAME                                   READY   STATUS    RESTARTS   AGE\nentando-k8s-service-86f8954d56-mphpr    1 /1     Running    0           95s\nentando-operator-5b5465788b-ghb25       1 /1     Running    0           95s\n Configure the Entando Application \n \n Download the  entando-app.yaml  template \n \n curl  -sLO  "https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/samples/entando-app.yaml" \n \n \n Edit  entando-app.yaml . Replace  YOUR-HOST-NAME  with  EXTERNAL-IP + .nip.io . See  the EntandoApp custom resource overview  for additional options. \n \n spec : \n   ingressHostName :  YOUR - HOST - NAME\n \n e.g.  ingressHostName: 20.120.54.243.nip.io \n Deploy Your Entando Application \n You can now deploy your application to your GKE cluster. \n \n Deploy the Entando Application \n \n kubectl apply -n entando -f entando-app.yaml\n \n \n It can take around 10 minutes for the application to fully deploy. You can watch the pods warming up with the command below. Use  Ctrl+C  to exit. \n \n kubectl get pods -n entando --watch\n \n \n Once all the pods are in a running state, access the Entando App Builder at the following address \n \n http://YOUR-HOST-NAME/app-builder/\n \n See the  Getting Started guide  for helpful login instructions and next steps. \n Appendix: Configuring Clustered Storage \n In order to scale an Entando Application across multiple nodes, you must provide a storage class that supports\na  ReadWriteMany  access policy, e.g. by using a dedicated storage provider like GlusterFS. \n The example below uses the GCP Cloud Filestore to provide clustered storage. However, it is best practice to expose an existing enterprise clustered file solution as a StorageClass. \n TIP \n You do not need clustered storage to scale an Entando Application if you schedule all instances to the same node using a  ReadWriteOnce (RWO)  policy and taints on other nodes. Be aware of the impact to node resource allocation, as well as recovery if your application fails or becomes unreachable. Note that if the node fais or is shutdown, your application will be unresponsive while Kubernetes reschedules the pods to a different node. \n Clustered Storage Using GCP Cloud Filestore \n \n \n In the left menu of the GCP portal, find the Storage section and select  Filestore  ->  Instances \n \n \n Enable the Filestore if you haven\'t already \n \n \n Select  Create Instance \n \n \n Adjust the field values from the defaults as needed. Take note of your instance ID. \n \n \n Once the instance is created on the Filestore main page, note the IP address of your NFS \n \n \n Install the provisioner that creates the StorageClass to enable deployment of Entando Applications. Use the commands below, replacing YOUR-NFS-IP and YOUR-NFS-PATH with your instance ID and the IP address of your cluster. \n \n \n helm repo add nfs-subdir-external-provisioner https://kubernetes-sigs.github.io/nfs-subdir-external-provisioner/\n \n helm install nfs-subdir-external-provisioner nfs-subdir-external-provisioner/nfs-subdir-external-provisioner \\\n    --set nfs.server=YOUR-NFS-IP \\\n    --set nfs.path=YOUR-NFS-PATH\n \n Learn about the provisioner and additional configuration options here:\n https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner \n \n Verify that your client provisioned successfully by running the following command and looking for the storage class  nfs-client \n \n kubectl get sc\n \n Example output: \n NAME                 PROVISIONER                                     RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE\nnfs-client           cluster.local/nfs-subdir-external-provisioner   Delete          Immediate              true                   37m\npremium-rwo          pd.csi.storage.gke.io                           Delete          WaitForFirstConsumer   true                   27h\nstandard (default)   kubernetes.io/gce-pd                            Delete          Immediate              true                   27h\nstandard-rwo         pd.csi.storage.gke.io                           Delete          WaitForFirstConsumer   true                   27h\n \n \n Add these two variables to your operator  ConfigMap : \n \n entando.k8s.operator.default.clustered.storage.class: "nfs-client"\nentando.k8s.operator.default.non.clustered.storage.class: "standard"\n \n \n Deploy your Entando Application using the  instructions above . The server instances will automatically use the clustered storage. \n \n'},{title:"Installation on Red Hat OpenShift using the Operator",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/getting-started/openshift-install-by-operator.html",relativePath:"v7.0/tutorials/getting-started/openshift-install-by-operator.md",key:"v-f7011000",path:"/v7.0/tutorials/getting-started/openshift-install-by-operator.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:2,title:"Add the Entando Operator to the OperatorHub",slug:"add-the-entando-operator-to-the-operatorhub"},{level:2,title:"Scenario 1 - Embedded Database",slug:"scenario-1-embedded-database"},{level:2,title:"Scenario 2 - PostgreSQL",slug:"scenario-2-postgresql"},{level:2,title:"Scenario 3 - PostgreSQL plus OpenShift SSL",slug:"scenario-3-postgresql-plus-openshift-ssl"},{level:2,title:"Scenario 4 - PostgreSQL plus Self-Signed SSL",slug:"scenario-4-postgresql-plus-self-signed-ssl"},{level:2,title:"Next Steps",slug:"next-steps"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Installation on Red Hat OpenShift using the Operator \n Overview \n The following tutorial shows how to install an Entando Application using the Entando Operator and covers a few common enterprise configurations. You may also find the alternative  manual instructions  useful. \n Scenario 1 is similar to the Entando quickstart style of deployment which can be applied in many environments, including on developer laptops. The subsequent scenarios build on that initial setup but can also be performed independently. Unless otherwise noted, you have the freedom to keep or modify the default options when installing the Entando Operator and other resources. \n Prerequisites \n \n OpenShift 4.8.x \n Cluster-admin access to OpenShift for initial installation of the Entando Operator \n Familiarity with the OpenShift console and operation \n Add the Entando Operator to the OperatorHub \n A cluster admin can add the 7.0 version of the Entando Operator into the local OperatorHub using the following command. \n oc apply -f https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/samples/openshift-catalog-source.yaml\n Scenario 1 - Embedded Database \n The initial scenario deploys the operator and Entando Application into a single namespace. We start with the smallest application footprint by using an embedded database, although this is not recommended for production use cases. \n \n Locate the Entando Operator in the  Operators  →  OperatorHub . Make sure to select the appropriate version. \n Click  Install  to view the Entando Operator install options \n Select  A specific namespace on the cluster  for the  Installation mode \n Choose an empty namespace for  Installed Namespace . You can create one from  Home  →  Projects  first, if needed, e.g.  entando-one . \n Click  Install  to install the operator into your target namespace \n The install may take a few minutes to complete, after which you can click  View Operator  to see the operator in your namespace. You can also go to  Operators  →  Installed Operators  at any time and select it from there. \n Now go to  EntandoApp  and click  Create EntandoApp \n \n Keep the default  my-app  as your application name or select your own \n Select the EntandoApp version:  7.0 \n \n \n Provide an  Ingress Host Name  specific to your namespace, e.g.  my-app.YOUR-BASE-OPENSHIFT-URL . In CRC you can keep the default  entando.apps-crc.testing  for your first project. \n Change the  DBMS  value to  embedded . This is the lightest and quickest way to test a full Entando Application. However, a non-embedded relational database is strongly recommended for production use. \n Click  Create . The Entando Operator proceeds to deploy the appropriate resources. \n Go to  EntandoApp  →  my-app  to check the status of the deploy \n \n See the  Next Steps  below to continue your work with Entando. \n Scenario 2 - PostgreSQL \n For this scenario we prepare a more production-like configuration. Here we switch from an embedded on-disk database to a dedicated PostgreSQL database. This scenario starts where step 6 ends in the previous scenario. If you already ran Scenario 1, you can either go to that project and remove the EntandoApp and ProvidedCapabilities via  Installed Operators  →  Entando Operator  or prepare a new project using steps 1-5 above. \n Now create a new application, this time using PostgreSQL. \n \n Go to  EntandoApp  and click  Create instance \n \n Keep the default  my-app  as your application name or select your own \n Select the EntandoApp version:  7.0 \n \n \n Set the  Ingress Host Name  as in Scenario 1 above \n Keep the default  DBMS  value of  postgresql \n Click  Create . The Entando Operator now deploys the appropriate resources as in Scenario 1 but with the addition of a PostgreSQL database deployment. \n \n See the  Next Steps  below to continue your work with Entando. \n Scenario 3 - PostgreSQL plus OpenShift SSL \n This scenario sets up PostgreSQL, like Scenario 2, but also enables SSL using OpenShift's internal Certificate Authority (CA). As a starting point, you can either remove the EntandoApp and ProvidedCapabilities using the Entando Operator or you can prepare a new project per steps 1-5 in Scenario 1. \n \n Using your browser, examine and save the SSL certificate for your environment\n \n In Chrome, go to any OpenShift console page and click on  View Site Information  next to the URL. Note that it may be labeled  Not secure . \n Go to  Details  ->  Copy to File  and save the certificate as a Base-64 encoded X.509 file, e.g.  openshift.cer . \n \n \n Go to  Workloads  →  Secrets  →  Create  and select  Key/value secret \n Set the  Secret Name , e.g.  entando-ca-cert-secret \n Set the  Key , e.g.  openshift.cer \n Set the  Value  by clicking  Browse...  and loading the file you saved in Step 1 \n Click  Create \n Next, go to  Workloads  →  ConfigMaps  and create or update the ConfigMap named  entando-operator-config . This is the ConfigMap used by the operator to configure the deployments. You can  download the Entando Operator template  as a starting point. Set the \"data/entando.ca.secret.name\" to match the name from step 3. \n \n data : \n  entando.ca.secret.name :  entando - ca - cert - secret\n  entando.use.auto.cert.generation :   'true' \n \n \n Click  Create \n \n Now let's create a new application similar to Scenario 2, but with OpenShift SSL in place. \n \n Go to  EntandoApp  and click  Create instance \n \n Keep the default  my-app  as your application name or select your own \n Select the EntandoApp version:  7.0 \n Set the  Ingress Host Name  as in Scenario 1 above \n Keep the default  DBMS  value of  postgresql \n \n \n Click  Create . The Entando Operator proceeds to deploy the appropriate resources. \n \n Once the deployment is complete, you can confirm that all routes use HTTPS with OpenShift's CA. You may still see security warnings in the browser. \n See the  Next Steps  below to continue your work with Entando. \n Scenario 4 - PostgreSQL plus Self-Signed SSL \n This scenario is similar to Scenario 3, but here you'll use a self-signed certificate instead of a certificate provided by OpenShift's internal Certificate Authority. As a starting point, you can either remove the EntandoApp and Provided Capabilities from the previous scenarios or prepare a new project per steps 1-5 in Scenario 1. \n Start by creating a self-signed certificate and then prepare the Secrets and ConfigMap to match. There are various ways to create an X.509 self-signed certificate, so you can use your preferred mechanism. \n \n Using  OpenSSL , create a certificate for your application. You'll need to adjust the Common Name (CN) value to match the  Ingress Host Name  for your project. \n \n openssl req -nodes -x509 -newkey rsa:4096 -keyout tls.key -out tls.crt -days  365  -subj  \"/CN=entando.apps-crc.testing\" \n \n You should see output similar to this: \n Generating a RSA private key\n .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .++++\n .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ++++\nwriting new private key to  'tls.key' \n-----\n \n Now you can create a TLS Secret using the generated files. \n \n Go to  Workloads  →  Secrets  →  Create  and select  From YAML . Use the following YAML as a starting point and then click  Create . \n \n kind :  Secret\n apiVersion :  v1\n metadata : \n   name :  entando - tls - secret\n data : \n   tls.key :   '' \n   tls.crt :   '' \n type :  kubernetes.io/tls\n \n \n Click on  Actions  →  Edit Secret  and use the  Browse...  buttons to upload the key and cert files. \n \n Now create the  entando-ca-cert-secret  Secret, similar to what was done in Scenario 3, but this time using the self-signed certificate. \n \n Go to  Workloads  →  Secrets  →  Create  and select  Key/value secret \n Set the  Secret Name , e.g.  entando-ca-cert-secret \n Set the  Key , e.g.  tls.crt \n Set the  Value  by clicking  Browse...  and loading the cert file from Step 1, e.g.  tls.crt \n Click  Create \n Next, go to  Workloads  →  ConfigMaps  and update or create a ConfigMap named  entando-operator-config . This is the ConfigMap used by the operator to configure the deployments. You can  download the Entando Operator template  as a starting point. Set the \"data/entando.ca.secret.name\" and \"data/entando.tls.secret.name\" to match the names from above. \n \n data : \n  entando.ca.secret.name :  entando - ca - cert - secret\n  entando.tls.secret.name :  entando - tls - secret\n \n \n Click  Create \n \n Now let's create a new application similar to Scenario 3, but with the self-signed SSL certificate. \n \n Go to  EntandoApp  and click  Create instance \n \n \n Keep the default  my-app  as your application name or select your own \n Select the EntandoApp version:  7.0 \n Set the  Ingress Host Name  as in Scenario 1 above. It should match the CN used to generate the certificate in step 1. \n Keep the default  DBMS  value as  postgresql \n \n \n Click  Create . The Entando Operator now proceeds to deploy the appropriate resources. \n \n Once the deployment is complete, you can confirm that all routes use HTTPS with the self-signed certificate. You may still see security warnings in the browser. \n See the  Next Steps  below to continue your work with Entando. \n Next Steps \n Once you've completed any of the scenarios above, you have several options. \n \n Check out  Networking  →  Routes  to see the URLs for the running services. Common starting points include the Entando App Builder (e.g.  http://entando.apps-crc.testing/app-builder/ ) or the Entando Application itself (e.g.  http://entando.apps-crc.testing/entando-de-app/ ). \n See the  Entando Operator Configuration  for options related to timeout settings and the default image registry. \n This suggested  list of next steps  could also be useful. \n \n \n"},{title:"Installation on OpenShift",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/getting-started/openshift-install.html",relativePath:"v7.0/tutorials/getting-started/openshift-install.md",key:"v-06f2ad5a",path:"/v7.0/tutorials/getting-started/openshift-install.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Prerequisites",slug:"prerequisites"},{level:3,title:"Local Installation",slug:"local-installation"},{level:2,title:"Create the Project",slug:"create-the-project"},{level:2,title:"Configure the Project",slug:"configure-the-project"},{level:2,title:"Configure the Entando Application",slug:"configure-the-entando-application"},{level:2,title:"Deploy the Entando Application",slug:"deploy-the-entando-application"},{level:2,title:"Next Steps",slug:"next-steps"},{level:2,title:"Appendix - Troubleshooting and Common Errors",slug:"appendix-troubleshooting-and-common-errors"},{level:3,title:"Permission Errors",slug:"permission-errors"},{level:3,title:"Forbidden Error Installing Entando Custom Resource Definitions in CRC",slug:"forbidden-error-installing-entando-custom-resource-definitions-in-crc"},{level:3,title:"Network Issues",slug:"network-issues"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Installation on OpenShift \n Overview \n This tutorial shows how to manually install Entando into OpenShift 4.8.x.  Installation via the  Entando Operator is highly recommended for OpenShift 4.6+.  See the  Installation on Red Hat OpenShift using the Operator tutorial  for specific instructions. \n Prerequisites \n \n An OpenShift 4.8.x installation \n The  OpenShift CLI , e.g.  oc \n Local Installation \n You can run OpenShift 4.8.x in your local development environment with Code Ready Containers (CRC). Use the local development version for the cluster where you intend to deploy your application. See  https://developers.redhat.com/products/codeready-containers/download  for more details. \n Create the Project \n The steps in this section require cluster admin access. If you are using CRC, make sure to use the administrator login provided when you started your local instance. \n \n Login to your OpenShift environment. There are two options: \n \n \n Use the  oc login  command, which can be found under the profile menu in OpenShift. \n \n oc login --token = sha256~TO3QCeoLSbprlGZARBOBVAoaKFeb9Ag0RxztYifAcjE --server = https://api.cluster-4bb2.4bb2.example.opentlc.com:6443\n \n \n Use the command line interface from the OpenShift Console . \n \n \n Install the cluster-scoped custom resource definitions (CRDs). This step is only required once per cluster. \n \n oc apply -n entando -f https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/namespace-scoped-deployment/cluster-resources.yaml\n \n \n Create the project for your application \n \n oc new-project entando\n \n Note: If you choose a different name for your project, adjust the commands below to supply your project name (e.g.  -n YOUR-PROJECT ) or use the  oc project  command to select the project. \n The remaining steps in this tutorial can be performed by a user with project-level access, rather than a cluster admin. \n Configure the Project \n \n Install the namespace-scoped custom resources \n \n oc apply -n entando -f https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/namespace-scoped-deployment/namespace-resources.yaml\n \n \n (Optional) A ConfigMap can be used to modify the behavior of the Entando Operator. Refer to the  Entando Operator  page for more information. \n Configure the Entando Application \n \n Download the  entando-app.yaml  template \n \n curl  -sLO  \"https://raw.githubusercontent.com/entando/entando-releases/v7.0.1/dist/ge-1-1-6/samples/entando-app.yaml\" \n \n \n Determine the hostname for your application, YOUR-HOST-NAME \n \n \n If you're deploying to a managed cluster:\n \n Determine the default hostname of your cluster. If you're unsure of the default hostname, please check with your cluster administrator. \n Add a prefix with the name of your project or application. For example, YOUR-HOST-NAME could be  my-app.apps.cluster-4bb2.4bb2.example.opentlc.com , where  apps.cluster-4bb2.4bb2.example.opentlc.com  is the hostname of the OpenShift cluster. \n Entando creates the application using this address and relies on wildcard DNS resolution. \n \n \n If you're using CRC:\n \n Determine the IP address (YOUR-IP) of your cluster with  crc ip \n Your IP-based YOUR-HOST-NAME should follow this pattern:  quickstart.YOUR-IP.nip.io , e.g.  quickstart.192.168.64.33.nip.io . The suffix  .nip.io  makes use of the free  nip.io  DNS service so that any requests to this host name will resolve to your CRC instance. The prefix  quickstart  is arbitrary. \n \n \n \n \n Edit  entando-app.yaml  and replace YOUR-HOST-NAME with the address from above. See the  Custom Resources overview  for details on other  EntandoApp  options. \n \n spec : \n   ingressHostName :  YOUR - HOST - NAME\n \n \n (Optional) If you used a name other than \"entando\" for your project, you'll also want to update the metadata/namespace property in  entando-app.yaml  to match. \n Deploy the Entando Application \n \n Deploy Entando \n \n oc apply -n entando -f entando-app.yaml\n \n \n It can take around 10 minutes for the application to fully deploy. You can watch the pods warming up with this command: \n \n oc get pods -n entando --watch\n \n Use  Ctrl+C  to exit the command. \n \n Once all the pods are in a running state, access the Entando App Builder at the following address: \n \n http://YOUR-HOST-NAME/app-builder/\n Next Steps \n Congratulations! To continue your journey with Entando, see the  Getting Started guide  for helpful login instructions and next steps. \n Appendix - Troubleshooting and Common Errors \n Permission Errors \n If deploying your Entando Application into your OpenShift namespace generates permission errors, make sure the namespace you're deploying to has the  escalate  and  bind  verbs on Roles. Before installing Entando, run  oc auth can-i escalate role  with your given user in the targeted namespace. If  yes  is returned, the installation should complete. Note that access is only required in the namespace where you are deploying your Entando Application. No cluster level access is required. \n Check with your cluster administrator if you need help assigning Roles. Generally, this requires the creation of a Role, preferably a ClusterRole with the above permissions. Your Entando installer needs to be given this Role in the target namespace, in accordance with how administrators manage security. For example, if the ClusterRole is  entando-installer  and the user's name is John, you can add the Role to the user with this command:\n oc policy add-role-to-user entando-installer john -n <your-namespace> . \n Forbidden Error Installing Entando Custom Resource Definitions in CRC \n If installing the CRDs in your local instance generates an error like the one below, you need to login as an administrator. \n /opt/ocInstallLocal$ oc create -f dist/crd/\nError from server (Forbidden): error when creating \"dist/crd/EntandoAppCRD.yaml\": customresourcedefinitions.apiextensions.k8s.io is forbidden: User \"developer\" cannot create resource \"customresourcedefinitions\" in API group \"apiextensions.k8s.io\" at the cluster scope\n \n Administrator credentials are printed when you start your local cluster. For example: \n To access the cluster, first set up your environment by following 'crc oc-env' instructions\nINFO Then you can access it by running 'oc login -u developer -p developer https://api.crc.testing:6443'\nINFO To login as an admin, username is 'kubeadmin' and password is xxxx-xxxx-xxxx-xxxx\n Network Issues \n If you see errors when images are being retrieved (such as ErrImagePull or ImagePullBackOff), you may want to start CRC using  crc start -n \"8.8.8.8 , or configure the nameserver with  crc config set nameserver 8.8.8.8  before running  crc start . This will allow the cluster to perform DNS lookups via Google's public DNS server. \n If you're on Windows, you should also check out these  Tips and Tricks  since CRC relies on Windows Hyper-V by default. This can result in network issues when the host computer is restarted. \n"},{title:"Entando Hub",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/solution/entando-hub.html",relativePath:"v7.0/tutorials/solution/entando-hub.md",key:"v-84091f34",path:"/v7.0/tutorials/solution/entando-hub.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Installation",slug:"installation"},{level:3,title:"Prerequisites",slug:"prerequisites"},{level:3,title:"Automatically Access the Hub from the App Builder",slug:"automatically-access-the-hub-from-the-app-builder"},{level:3,title:"Manual Installation Steps",slug:"manual-installation-steps"},{level:2,title:"Configuration",slug:"configuration"},{level:2,title:"Using the Hub",slug:"using-the-hub"},{level:3,title:"Concepts",slug:"concepts"},{level:3,title:"Roles",slug:"roles"},{level:3,title:"Bundle Group Version Status",slug:"bundle-group-version-status"},{level:3,title:"Bundle Group Creation",slug:"bundle-group-creation"},{level:3,title:"Bundle Group Versions",slug:"bundle-group-versions"},{level:2,title:"Application Details",slug:"application-details"},{level:3,title:"Micro Frontends / Widgets",slug:"micro-frontends-widgets"},{level:3,title:"Microservices",slug:"microservices"},{level:3,title:"Content",slug:"content"},{level:3,title:"Integration",slug:"integration"},{level:2,title:"Resources",slug:"resources"},{level:3,title:"Source Code",slug:"source-code"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Entando Hub \n Overview \n The Entando Hub enables a team to share components across Entando Applications. It can be installed in Entando 6.3.2 or higher and includes API-level integration with the Entando 7.0 App Builder. \n The Hub allows users to: \n \n Centralize components and business capabilities for use across teams, groups, or clients. \n Publish, manage and communicate component features, versions and metadata. \n Perform business-level assessment of component readiness. \n \n This tutorial covers: \n \n Installation \n Configuration \n Using the Hub \n Application Details \n Resources \n Installation \n The Hub is installed using the Entando Component Repository (ECR) and two Entando Bundles.  The first bundle contains the Hub micro frontends and microservices, and the second sets up the initial content and pages for the Hub user experience. \n Prerequisites \n \n An Entando Application on any Kubernetes provider. Follow the  tutorials  appropriate to your environment to install the Entando platform. \n The  ent command line tool , installed and connected to your Kubernetes instance. \n Automatically Access the Hub from the App Builder \n \n Login to your App Builder \n Go to  Repository  →  Select Registry \n Choose  New Registry \n In the pop-up window, enter  Entando Hub  and  https://entando.com/entando-hub-api/appbuilder/api  for the URL, then  Save \n Click on the Hub in the Registry and continue with the tutorial at Step 4 below \n Manual Installation Steps \n \n Apply the Custom Resource Definitions for the Hub component bundles. \n \n ent ecr deploy --repo="https://github.com/entando-samples/entando-hub-application-bundle.git"\n \n ent ecr deploy --repo="https://github.com/entando-samples/entando-hub-content-bundle.git"\n \n \n \n Log into your App Builder instance. \n \n \n Select  Repository  from the menu on the left. Your bundles will be visible in the repository as shown in the screenshot below. \n \n \n \n \n \n Select  Install  for each bundle, where order of installation is important. The  entando-hub-application-bundle  must be installed first because it provides the  entando-hub-content-bundle  with MFEs. It may take several minutes to download the Docker images for the microservices and install related assets. \n \n \n Set up permissions to configure the service: \n \n Login to your Keycloak instance  as an admin. \n Give at least one user the ability to manage the Hub by granting the  eh-admin  role. Assign the  eh-admin  role for the  pn-cee95efc-77ff566e-entandopsdh-entando-hub-catalog-ms-server  client. See  Role Assignment in ID Management  for more details. \n Give the generated plugin client permission to manage users.\n \n From the left sidebar, go to  Clients  and select client ID  pn-cee95efc-77ff566e-entandopsdh-entando-hub-catalog-ms-server . \n Click the  Service Account  tab at the top of the page and select  realm-management  from the  Client Roles  field. \n Choose  realm-admin  from  Available Roles . Click  Add selected . It should appear as an  Assigned Role . \n \n \n \n \n \n Access the Hub from the App Builder by navigating to  Pages → Management , finding  Entando Hub  in the page tree, and clicking  View Published Page  from its actions. \n Configuration \n TIP \n (New with Entando 7.0.0) Any Hub instance can be accessed from the Entando App Builder of another Entando Application. Configure the App Builder to access the desired Hub instance via the endpoint  BASEURL/entando-hub-api/appbuilder/api , where the BASEURL is the URL for the Entando Application. \n Using the Hub \n Concepts \n The key entities in the Entando Hub are: \n \n Bundle Group : A Bundle Group is a group of one or more Entando Bundles. \n Bundle Group Version : A Bundle Group can have one or more versions, each with a particular status. \n Bundle : A Bundle is the deployment unit within an Entando Application. A Bundle can contain one or multiple components such as micro frontends, microservices, or any of the  component types  available in Entando. \n Category : Each Bundle Group belongs to a specific category. The initial possible categories are Solution Template, Packaged Business Capability (PBC), or Component Collection. An admin of an Entando Hub can refine the available categories as desired. \n Organization : Bundle Groups belong to a single organization. Authors and managers can only update Bundle Groups for their own organization. \n User : User identity is managed within Keycloak, where users are granted roles within the Hub. Users must be assigned to a specific organization. \n \n Notes: \n \n A private repository can be used for a Bundle, but this requires  an additional Kubernetes secret  before deployment via the App Builder. \n Roles \n Three roles are used to provide access to the Hub features: \n \n eh-author : An author can create and edit Bundle Groups for their organization and submit them for publication. \n eh-manager : A manager has the permissions of an author, but can also approve a publication request for their organization. \n eh-admin : An admin has full access to create, update, and delete Bundle Groups for the entire Hub instance. An admin can also create categories and organizations, and assign users to an organization. \n guest : Any user without one of the preceding roles is considered a guest in the Entando Hub and is given a read-only view of the public catalog. This is also true for unauthenticated users. \n Bundle Group Version Status \n The possible statuses for the versions of a Bundle Group are: \n \n Draft : This is the default status for the first version of a Bundle Group. \n Publication Request : An eh-author sets a version to this status to request an eh-manager or eh-admin to review the version and mark it for publication. An eh-manager or eh-admin may edit versions with this status. \n Published : Versions with this status are visible in the home page list of available Bundle Groups and also available in the App Builder-facing API. An eh-manager or eh-admin may edit Published versions. \n Archived : Previously Published versions are assigned this status. No edits can be made on an Archived version. \n Deletion Request : An eh-manager or eh-admin can delete versions once this status has been set. \n \n Notes: \n \n An eh-author can change any field except Organization while a version is in Draft. \n There is no automated notification process when a Publication Request is made for a Bundle Group version. \n Bundle Group Creation \n Clicking the  Add +  button at the top of the page displays the form for creating a new Bundle Group: \n Bundle Group Versions \n The list of Bundle Group Versions can be seen by clicking  View Versions  on any entry in the catalog: \n \n Notes: \n \n Once the first version of a group is published, the organization, name, and category can no longer be changed. \n A new version of a Bundle Group can be created (via the  New Version  option) after the first version has been published. \n There can be at most two active versions: one Draft or Publication Requested version and one Published version. \n When a new version is published, the previous version is set to Archived. \n Archived versions are only visible in the versions view and are not shown elsewhere in the user interface. \n Application Details \n The Hub includes the following key components: \n Micro Frontends / Widgets \n \n Entando Hub App : This is the main micro frontend which contains the management UI for the Hub entities noted above. \n Entando Hub Login : This is an optional login component which can be used in a page’s top navigation. \n Microservices \n A single Spring Boot microservice provides two REST endpoints: \n \n The first is a backend-for-a-frontend (BFF) service for the Hub UI and contains the various entity APIs. \n The second provides methods that support the Entando App Builder integration (7.0.0+). \n Content \n The Hub content bundle ( entando-hub ) includes a custom template and a page preconfigured with the main Hub micro frontends. \n Integration \n The Entando App Builder should be configured using the endpoint  BASEURL/entando-hub-api/appbuilder/api , where the BASEURL is the URL for the Entando Application. \n Resources \n Source Code \n Entando open source examples and tutorials are available on GitHub. Reference the Hub sample project for instructions to build the project from source code: \n \n https://github.com/entando-samples/entando-hub \n \n'},{title:"Entando Customer Portal",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/solution/customer-portal.html",relativePath:"v7.0/tutorials/solution/customer-portal.md",key:"v-2133de34",path:"/v7.0/tutorials/solution/customer-portal.html",headers:[{level:2,title:"Overview",slug:"overview"},{level:2,title:"Installation",slug:"installation"},{level:3,title:"Prerequisites",slug:"prerequisites"},{level:3,title:"Automatic Install via the Entando Hub",slug:"automatic-install-via-the-entando-hub"},{level:3,title:"Manual Install",slug:"manual-install"},{level:2,title:"Configuration",slug:"configuration"},{level:3,title:"Administrators",slug:"administrators"},{level:3,title:"Jira Service Management",slug:"jira-service-management"},{level:3,title:"Configure the Customer Portal",slug:"configure-the-customer-portal"},{level:3,title:"Entando Identity Management System",slug:"entando-identity-management-system"},{level:2,title:"Managing the Customer Portal",slug:"managing-the-customer-portal"},{level:2,title:"Using the Customer Portal",slug:"using-the-customer-portal"},{level:2,title:"Resources",slug:"resources"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Entando Customer Portal \n Overview \n The Entando Customer Portal enables an organization to quickly provide a modern, self-service customer-facing application for managing subscriptions. It includes a lightweight integration to Jira Service Management for access to service tickets and a role based access control (RBAC) design for granting users varying levels of access. \n Key Features: \n \n Customizable service ticket tracking system with Jira Service Management \n Role based access control with Entando Identity Management System \n Integrated user, customer, project, and subscription management \n \n This tutorial covers: \n \n Installation \n Configuration \n Managing the Customer Portal \n Using the Customer Portal \n Resources \n Installation \n Prerequisites \n \n A working instance of Entando running on Kubernetes. See  Getting Started  for more information or  install Entando on any Kubernetes provider . \n Use the Entando CLI command  ent check-env develop  to verify all dependencies. \n A Jira Service Management account. \n Automatic Install via the Entando Hub \n Install the Customer Portal in two steps by integrating the Entando Hub into your App Builder. \n \n \n Log into your  App Builder  →  Repository  →  Select Registry  → choose  Entando Hub  if it has been configured. \n \n If not, choose  New Registry \n In the pop-up window, enter  Entando Hub  and  https://entando.com/entando-hub-api/appbuilder/api  for the URL, then  Save \n Click on the Hub in the Registry \n \n \n \n From the Hub Catalog,  Deploy  and  Install  the Customer Portal application first, then the content bundle. \n \n \n Set up permissions to configure the service: \n \n Login to your Keycloak instance  as an admin. \n Give at least one user the ability to manage the Customer Portal by granting the  cp-admin  role. Assign the  cp-admin  role for the  pn-a71d68dd-166dc0f4-entandodemo-customerportal-server  client. See  Role Assignment in ID Management  for more details. \n Give the generated plugin client permission to manage users.\n \n From the left sidebar, go to  Clients  and select client ID  pn-a71d68dd-166dc0f4-entandodemo-customerportal-server . \n Click the  Service Account  tab at the top of the page and select  realm-management  from the  Client Roles  field. \n Choose  realm-admin  from  Available Roles . Click  Add selected . It should appear as an  Assigned Role . \n \n \n \n \n \n To navigate to your CP: \n \n From the sidebar →   Page  →  Management \n Find the  Customer Portal  folder \n From the  Actions  pull-down menu →   View Published Page \n Manual Install \n \n To install the Customer Portal manually, run the following commands. \n \n ent ecr deploy --repo = "https://github.com/entando-samples/customerportal-application-bundle.git" \n \n ent ecr deploy --repo = "https://github.com/entando-samples/customerportal-content-bundle.git" \n \n \n \n Log into the App Builder. \n \n \n Go to the  Repository  from the left sidebar. Two Customer Portal bundles will be visible there.  Install  the  customerportal-application-bundle  first, then the  customerportal-content-bundle . \n \n \n To navigate to your CP: \n \n From the sidebar →  Page  →  Management \n Find the  Customer Portal  folder \n From the  Actions  pull-down menu →  View Published Page \n Configuration \n Administrators \n In order to configure the Customer Portal and its users, the administrator will need Jira Service Management and Entando Identity Management System credentials. In this step, the admin connects the CP to Jira and customizes its features. \n Note: \n \n The built-in mapper for email must be enabled on the server client so that user accounts can be retrieved from Jira and new tickets can use that account information. \n Jira Service Management \n The administrator utilizes Jira Service Management to create users and projects, define the organization, and configure the service ticket system. \n Users who need access to the Customer Portal, beyond subscription and project information, must have a Jira Service Management account. \n \n Go to Customers to add organizations and projects. Once added, click on the name of the organization to get the ID, needed later, from the URL.  \ne.g. example.com/jira/servicedesk/projects/ECS/organization/3 → the Organization ID is “3” \n Configure the Customer Portal \n The Customer Portal must be configured to accommodate a specific Jira Service Management instance. The  CP Admin Config  page is where you will establish the Jira connection, manage product versions, define subscription levels, and customize ticket types. \n To access the  CP Admin Config  page, you must be given the  cp-admin  role in the  Entando Identity Management System  as outlined below. \n Go to the  CP Admin Config  page: \n \n In the App Builder, go to  Pages  and select  Management . \n Open the Customer Portal folder and find  CP Admin Config . \n From the  Action  drop-down menu on the right, go to  View Published Page . \n \n \nOnce the Ticketing System Connection is set up with Jira and the correct URL, default parameters such as product versions and ticket types will be displayed. Open each section with the down arrow to add and edit the fields as needed. \n Entando Identity Management System \n Logging into the Entando Identity Management System, you will see the landing page shown here. Like the App Builder, the left navigation bar is your guide for managing users, groups, and most importantly, roles. Using the RBAC model, define what access users have by the roles and groups they are assigned. Some important guidelines are noted below. \n \n \n \n Define the Realm Setting .  \nThe  Realm  is a set of users, credentials, roles, and groups. A user belongs to and logs into a  Realm . \n \n \n Create Roles \nYou can use the default roles by clicking on  Client Roles  and choosing  entandodemo-customerportal-server . Access for each role is defined as follows: \n \n cp-customer  -  assigned directly to specific projects for a single customer \n cp-partner  - assigned directly to specific projects for multiple customers \n cp-support  -  read only view of all customer projects \n cp-admin  - admin access for the Customer Portal \n \n \n \n Create New Users : \n \n \n \n \n From the sidebar, go to  Users . Click  Add User  at right. \n \n \n Complete the form as needed but note the requirements for these fields: \n Username : a unique name \n Email : must use the same address used in Jira \n User Enabled  → On \n Save \n \n \n Send an email to the user to activate their account and set a new password:  \nGo to the  Credentials  header  \nUnder  Credential Reset , in the  Reset Actions  →  Update Password    \nClick  Send Email \n \n \n Go to Role Mapping: \n \n Select the appropriate roles from  Available Roles  and click  Add Selected  to assign. \n Choose  entandodemo-customerportal-server  from the  Client Roles  pull-down options to assign default roles. \n A full administrative user will need the  realm-admin  role under  Client Roles  →  realm-management  in order to manage users in the Portal. \n Check the  Effective Roles  column on the right to ensure the correct roles have been assigned. \n \n \n \n \n \n Under  Groups , assign roles to groups as needed. Roles are additive. \n Managing the Customer Portal \n As administrator for the Customer Portal, you can create and manage users, customers, projects, and subscriptions. You can assign projects to users who have activated their account on Jira and have been assigned roles in the Entando Identity Management System. \n \n \n Create a Customer or Partner \nCreating a  Customer  and  Partner  is a similar process. Below are the steps for adding a  Customer . Follow the same procedure for adding a  Partner . \n \n \n Click  Add a Customer \n Fill in the details. Note the following:\n \n The  Customer Number  must be unique \n The  Notes  field is visible only to  support  and  admin  users \n \n \n \n \n \n Create and Assign Projects \n \n \n From the CP landing page, click on any customer to see the associated project list. \n To create a new project:\n \n Click  Add a Project . \n Enter the  Project  information. \n Provide the Organization ID from Jira. Each project must have a unique Organization ID. \n Click  Save . \n \n \n To assign  Projects :\n \n From the  Action  drop-down menu →   Manage Users . \n Select the user for the  Project . \n Click  Submit . \n \n \n \n \n Manage Partners and Subscriptions   \nUse the  Action  drop-down menu to manage Partners, and request and manage subscriptions. \n Using the Customer Portal \n To access the Customer Portal, your organization administrator needs to provide you with the proper user credentials. You can then create and track service tickets as well as request subscriptions. \n Once you login to the Customer Portal, you will see a list of customers. Click on a customer to view details and track their projects. \n \n To create a  Service Ticket  for a project:  \nfrom the  Action  pull-down menu →  Open Ticket . \n \n \n \n To request a Subscription or track Tickets:  \nuse the  Action  pull-down menu and select the corresponding option. \n Resources \n \n \n Go to  Jira Service Management  for more information. \n \n \n The  source code  for the Entando Customer Portal can be found with our other open source examples and tutorials on GitHub at:  https://github.com/entando-samples/customer-portal/ \n \n \n'},{title:"Entando Standard Banking Demo",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/solution/install-standard-demo.html",relativePath:"v7.0/tutorials/solution/install-standard-demo.md",key:"v-32044be6",path:"/v7.0/tutorials/solution/install-standard-demo.html",headers:[{level:2,title:"Installation",slug:"installation"},{level:3,title:"Prerequisites",slug:"prerequisites"},{level:3,title:"Automatic Install via the Entando Hub",slug:"automatic-install-via-the-entando-hub"},{level:3,title:"Manual Install",slug:"manual-install"},{level:2,title:"Application Details",slug:"application-details"},{level:3,title:"Micro Frontends (MFE)",slug:"micro-frontends-mfe"},{level:3,title:"Configuration Micro Frontends",slug:"configuration-micro-frontends"},{level:3,title:"Microservices",slug:"microservices"},{level:3,title:"Static Widgets",slug:"static-widgets"},{level:3,title:"Static CMS Content",slug:"static-cms-content"},{level:2,title:"Source Code",slug:"source-code"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Entando Standard Banking Demo \n This tutorial will guide you through installing a demo application using the Entando Component Repository (ECR) and a set of Entando\nbundles. This solution template includes: \n \n microservices \n micro frontends \n multiple pages \n CMS content \n \n The goal of this exercise is to demonstrate how Entando bundles can be used to: \n \n quickly install and create functionality in an Entando Application \n enable packaged business capabilities \n allow developers to reuse full stack operations via bundles \n \n Some of the key elements of the template are reviewed in the  Application Details section  below. \n Installation \n There are numerous assets installed as part of the Standard Banking Demo. Entando Bundles can include more or less components, depending on objectives. It is recommended that organizations develop guidelines for bundle sizing that fit the goals of their applications and teams. \n Prerequisites \n \n A working instance of Entando running on Kubernetes.  Install Entando on any Kubernetes provider  or see  Getting Started  for more information. \n The ent command line tool, installed and connected to your Kubernetes instance. \n Automatic Install via the Entando Hub \n Install the Standard Banking Demo by integrating the Entando Hub into your App Builder. \n \n \n Log into your  App Builder  →  Repository  →  Select Registry  → choose  Entando Hub  if it has been configured. \n \n If not, choose  New Registry \n In the pop-up window, enter  Entando Hub  and https://entando.com/entando-hub-api/appbuilder/api for the URL, then  Save \n Click on the Hub in the Registry \n \n \n \n From the Hub Catalog,  Deploy  and  Install  the four Standard Banking Demo bundles, where order of installation is important. The  standard-demo-content-bundle  will need to be installed last, as it relies on MFEs from the other bundles to set up each of the pages. \n \n standard-demo-banking-bundle \n standard-demo-customer-bundle \n standard-demo-manage-users-bundle \n standard-demo-content-bundle \n \n \n \n To navigate to the Standard Demo: \n \n From the sidebar →   Page  →  Management \n Find  Home SD  in the page tree \n From the  Actions  pull-down menu →   View Published Page \n Manual Install \n \n Apply the definitions for the four bundles that comprise the Standard Banking Demo. \n \n ent ecr deploy --repo="https://github.com/entando-samples/standard-demo-banking-bundle.git"\n \n ent ecr deploy --repo="https://github.com/entando-samples/standard-demo-customer-bundle.git"\n \n ent ecr deploy --repo="https://github.com/entando-samples/standard-demo-manage-users-bundle.git"\n \n ent ecr deploy --repo="https://github.com/entando-samples/standard-demo-content-bundle.git"\n \n \n \n Log into your App Builder instance. \n \n \n Select  Repository  from the menu on the left. Your bundles will be visible in the repository as shown in the screenshot below.\n \n \n \n Select  Install  for each bundle, where order of installation is important. The  standard-demo-content-bundle  will need to be installed last, as it relies on MFEs from the other bundles to set up each of the pages.\n \n \n \n Each installation can take several minutes while the application downloads the Linux images for the microservices and installs the related assets. The  standard-demo-banking-bundle  and  standard-demo-customer-bundle  include microservices that require the initialization of containers and will take longer to install. \n In the unlikely event you encounter conflicts during an initial installation, you will be presented with an Installation Plan like the one shown below. Select  Update All  in the upper right after making your selections.\n \n \n Access the Standard Banking Demo via one of the following options: \n \n Option 1  If you\'d like to make the Standard Banking Demo your default home page, go to  App Builder → Pages → Settings . In\nthe dropdown for Home Page, select  Home / Home SD  and click  Save .\n \n You can now navigate to your application\'s home page using the home icon in the upper right of the App Builder. \n Option 2  Alternatively, you can view the Standard Banking Demo home page by going to  Pages → Management , finding  Home SD  in the page tree, and clicking  View Published Page  from its actions. \n Application Details \n The Entando Standard Banking Demo application demonstrates a number of the major features of the Entando platform, including: \n \n Keycloak integration for role based access controls \n Micro frontends implemented using React and Angular and co-existing on the same dashboard page \n Micro frontend communication techniques \n Microservices via Spring Boot \n Entando Content Management \n Micro Frontends (MFE) \n The application includes six MFEs in which the above features complement one another to achieve custom functionality. These are described below. \n 1. Card \n \n \n The Card MFE is a React micro frontend that is visible on the My Dashboard page. The MFE makes an API call to the banking microservice to fetch a numeric result depending on the configured card type. The displayed value will change as the configuration is changed. \n The MFE is authorization-aware and will pass the bearer token to the microservice for authorization and authentication. If you render the dashboard page and you aren\'t authenticated, the widget displays an error message. \n This MFE emits events that are consumed by the Transaction Table widget. \n 2. Card NG \n \n \n The Card NG MFE is an Angular widget that is similar to the Card widget above, except for the choice of frontend technology. \n This MFE communicates with the Transaction Table widget, which is implemented in React. \n 3. Manage Users \n \n The Manage Users MFE makes an API call to Keycloak to fetch user information. When the user is logged into the app, the MFE is visible from the dropdown under the username. \n By default, application users are not granted Keycloak authorization to manage users. This demonstrates role based access control for an MFE using Keycloak. To enable the Manage Users widget, login to Keycloak and assign the realm-management client\'s  view-users  and  manage-users  roles to the desired user. \n \n Authorized View\n \n Not Authorized View\n 4. Transaction Table \n \n This MFE is a React micro frontend that consumes events from the Card MFEs detailed above. \n The Transaction Table widget makes an API call to the banking microservice to fetch transaction data for the user. \n 5. Sign Up \n \n \n The Sign Up MFE is a form widget that makes an API call to the customer microservice to create a new user. The Sign Up MFE is visible on the sign up page, and can be accessed from any page when a user is not authenticated. \n 6. Alert Icon \n \n The Alert Icon MFE displays an icon on the dashboard page. It includes a configuration MFE to allow the user to select the appropriate icon and datatype to display. \n In the default deployment, the Alert Icon MFE makes an API call to the banking microservice to fetch data. \n Configuration Micro Frontends \n When placed on a page, many of the MFEs detailed above include configuration screens visible in the App Builder at  Components → Micro frontends & Widgets . To see the rendered config screen, place the MFE on a new page. \n Microservices \n The application includes two microservices (service paths:  /banking  and  /customer ) to support the data visible in the MFEs detailed above. Both microservices demonstrate the automated deployment and linking of a microservice to an Entando Application via the Entando Operator. \n The data for the microservices are created with Liquibase, demonstrating the use of the Operator and Liquibase + Spring Boot to automatically provision data into an environment. The demo data is available in the source code for the microservices on GitHub. \n Static Widgets \n The application uses static HTML, FreeMarker, and JavaScript widgets to display content, e.g. headers, footers, images, etc. To view the static widgets, log into the App builder and select  Components → Micro frontends & Widgets . \n Static CMS Content \n The application makes extensive use of the Entando CMS. This includes the creation of content templates, content types, and content. If you want to learn more about the Entando CMS in the application, log into the App Builder and select  Content →  Templates ,  Content → Management , or  Content → Types . \n Source Code \n The source code for the Entando Standard Banking Demo can be found on GitHub  here , along with our other open source examples and tutorials. \n'},{title:"Entando Solution Templates",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/solution/landing-page.html",relativePath:"v7.0/tutorials/solution/landing-page.md",key:"v-f7ea08f0",path:"/v7.0/tutorials/solution/landing-page.html",headers:[{level:2,title:"Entando Customer Portal",slug:"entando-customer-portal"},{level:2,title:"Entando Hub",slug:"entando-hub"},{level:2,title:"Entando Process Driven Applications Plugin",slug:"entando-process-driven-applications-plugin"},{level:2,title:"Entando Standard Banking Demo",slug:"entando-standard-banking-demo"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" Entando Solution Templates \n The Entando Application Composition Platform offers several Solution Templates to demonstrate various business capabilities and integrations: \n \n Entando Customer Portal \n Entando Hub \n Entando Process Driven Applications Plugin \n Entando Standard Banking Demo \n \n Each open source Solution Template was built with Entando and can be used as-is, reviewed for common development practices, or leveraged as a useful starting point for a related application. \n The following Solution Templates and other sets of components are available in the  public Entando Hub  for installation in a user environment, where turnkey functionality can be customized and extended. \n Entando Customer Portal \n The  Entando Customer Portal  streamlines development of a customer-facing, self-service subscription management application. The platform integrates Keycloak role based access control and Jira Service Management as a ticket tracking system. \n Entando Hub \n The  Entando Hub  empowers a team to share and collaborate on proprietary or Entando open source components. Capabilities, versions and metadata can be transparently analyzed, managed and published. \n Entando Process Driven Applications Plugin \n The  Entando Process Driven Applications Plugin  provides a comprehensive and versatile automation scheme for Business Process Management. It comprises a custom UX layer, a Spring Boot Backend for Frontend microservice interface, and integration with the  Red Hat Process Automation Manager . \n Entando Standard Banking Demo \n The  Entando Standard Banking Demo  showcases the benefits and possibilities of a composable application built from modular components. The example banking environment integrates a transaction table, sign up form, alert icon, and summary cards to demonstrate MFE communication and capabilities. Prominent features include Keycloak role based access control, coexistence of React and Angular MFEs, and pluggable Spring Boot microservices. \n \n TIP \n Check out our  Concepts  page to explore Entando's approach to composability, or visit  Getting Started  to put these components and capabilities in action! \n \n"},{title:"PDA Plugin Technical Guide",frontmatter:{},regularPath:"/v7.0/tutorials/solution/pda-technical-guide.html",relativePath:"v7.0/tutorials/solution/pda-technical-guide.md",key:"v-ce94d8f4",path:"/v7.0/tutorials/solution/pda-technical-guide.html",headers:[{level:2,title:"Task Forms",slug:"task-forms"},{level:2,title:"Widgets",slug:"widgets"},{level:2,title:"Code Style",slug:"code-style"},{level:2,title:"Sonar",slug:"sonar"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' PDA Plugin Technical Guide \n This page explores PDA plugin structure and functionality in greater detail. The sample code and linked resources instruct the user in the versatility and usability of: \n \n Task Forms \n Widgets \n Code Style \n Sonar \n Task Forms \n Widgets employ JSON schema to dynamically create any forms they contain. The JSON schemas are converted into React components using the  react-jsonshema-form  library. Entando\'s initial implementation utilizes Material UI components derived from the Material UI theme library ( rjsf-material-ui ) as a baseline, and includes templates, widgets and fields ( react-jsonshema-form  terms for forms components) that are specific to Entando. \n This section will introduce the basic form configuration, but if you would like to learn more, please refer to the  react-jsonshema-form   documentation . \n The themed JSON Form is created using the  withTheme()  method from the  react-jsonschema-form  package: \n import { withTheme } from \'react-jsonschema-form\';\nimport { Theme as MuiRJSForm } from \'rjsf-material-ui\';\n\nconst JSONForm = props => {\n\n  const ThemedForm = withTheme(MuiRJSForm);\n\n  // ...\n\n  return (\n    <ThemedForm\n    schema={formSchema}\n    uiSchema={uiSchema}\n    {...customTemplates}\n    widgets={customWidgets}\n    formData={formData}\n    onSubmit={e => onSubmitForm(e)}\n    >\n  );\n};\n\nexport default JSONForm;\n \n A form schema provides the JSON definition of the form’s structure and is mandatory for a JSON Form to function. Users can supply form data via the  formData  variable, which should follow the structure of JSON schema. UI schema can be supplied via the  uiSchema  variable, which allows users to customize the form’s UI (e.g. components, rules, types). \n You can test the JSON schema, UI schema and form data in the  react-jsonschema-form  sandbox environment. Entando templates, widgets, and fields allow customization of form layout using Grid components. The size parameter in the UI schema’s  ui:options  object specifies the fill area of a field or subform. \n Size refers to the Material UI’s grid column widths (see the Material UI documentation), where the area the form can occupy is divided into 12 columns. A value of 12 (the default value if size is not provided) means the field or subform should take up all 12 columns. If two adjacent fields have size values of 8 and 4, respectively, they will share one row and the first field will be twice as wide as the second. \n In addition, the user can provide an innerSize parameter to scale the input fields inside the columns. This helps with formatting when a user wants to make nonuniform adjustments to sizing. \n Multicolumn layout can also be achieved via  generateColumnedOFT  ( columnSize ) functionality, which assigns the default  columnSize  to the created form. The function  generateColumnedOFT  returns an  ObjectFieldTemplate  that is used as a template for all object fields (fields that contain properties). \n To explain the mapping between JSON schema and UI schema let\'s define an example\nschema: \n {\n  "$schema": "http://json-schema.org/draft-07/schema#",\n  "$id": "http://entando.org/schemas/pda-form.json",\n  "title": "Mortgage Application Form",\n  "type": "object",\n  "properties": {\n    "Application": {\n      "title": "Application",\n    "type": "object",\n    "required": [],\n    "properties": {\n        "mortgageamount": {\n          "type": "integer",\n          "title": "Mortgage amount",\n          "description": "Mortgage amount"\n        },\n        "downpayment": {\n          "type": "integer",\n          "title": "Down Payment",\n          "description": "Down Payment"\n        },\n        "applicant": {\n          "title": "Applicant",\n          "type": "object",\n          "required": [],\n          "properties": {\n            "name": {\n              "type": "string",\n              "title": "Name",\n              "description": "Name",\n              "maxLength": 100\n            },\n            "annualincome": {\n              "type": "integer",\n              "title": "Annual Income",\n              "description": "Annual Income"\n            }\n          }\n        },\n        "property": {\n          "title": "Property",\n          "type": "object",\n          "required": [],\n          "properties": {\n            "age": {\n              "type": "integer",\n              "title": "Age of property",\n              "description": "Age of property"\n            },\n            "address": {\n              "type": "string",\n              "title": "Address of property",\n              "description": "Address of property",\n              "maxLength": 100\n                }\n          }\n        }\n      }\n    },\n    "inlimit": {\n      "type": "boolean",\n    "title": "Is mortgage application in limit?"\n    }\n  }\n}\n \n From this JSON (you can copy & paste it into the  react-jsonschema-form \nsandbox) we can see that there is a main form with a title “Mortgage\nApplication Form." The root form  Mortgage Application Form  has two\nproperties: one is a subform called  Application  and the other is a\ncheckbox field (field ID is  inlimit ). \n The  Application  subform contains two fields:  Mortgage Amount  with field ID  mortgageamount  and  Down Payment  with field ID  downpayment . It also contains two subforms:  Applicant  with field ID  applicant  and  Property  with field ID  property . \n The  Applicant  subform contains two fields:  Name  with field ID  name  and  Annual Income  with field ID  annualincome . The  Property  subform also contains two fields:  Age of property  with field ID  age  and  Address of property  with field ID  address . \n By default (without providing UI schema), these are listed as one field per row. To use Entando’s implementation of Grid layout, users have to\nprovide UI schema with details about each field. For example, if we\nwould like to have a layout that looks like this (fields are marked\n [ field name ] ): \n +----------------------------------------------------------------------------+\n| Mortgage Application Form                                                  |\n+----------------------------------------------------------------------------+\n| Application                                                                |\n+----------------------------------+-----------------------------------------+\n| [Mortgage amount]                | [Down Payment]                          |\n+----------------------------------+-----------------+-----------------------+\n| Applicant                                          | Property              |\n+----------------------------------+-----------------+-----------------------+\n| [Name]                           | [Annual Income] | [Age of property]     |\n+----------------------------------+-----------------+-----------------------+\n|                                                    | [Address of property] |\n+----------------------------------------------------+-----------------------+\n \n To set up the UI schema, you need to use field IDs to define each field you want to customize. For example, to add options to the  Name  field, create an object tree beginning at the root:  Application  —>  Applicant  —>  Name  (equivalent to  Application.Applicant.Name ). The UI schema for the table layout defined above looks like this: \n {\n  Application: {\n    \'ui:options\': {\n      size: 12, // <-- this value is not mandatory; size is 12  columns wide by default\n    },\n    mortgageamount: {\n      \'ui:disabled\': true, // <-- user can define fields disabled at UI schema level\n      \'ui:options\': {\n        size: 6, // <-- Mortgage Amount field should take up half of the row\n      },\n    },\n    downpayment: {\n      \'ui:options\': {\n         size: 4, // <-- Down Payment field should take up the other half of the row\n       },\n    },\n    applicant: {\n      \'ui:options\': {\n         size: 8, // <-- Applicant subform should take up 8 out of 12 columns\n      },\n      name: {\n        \'ui:options\': {\n          size: 8, // <-- Applicant Name field should take up 8 of the 8 columns that Applicant subform occupies\n        },\n      },\n      annualincome: {\n        \'ui:options\': {\n           size: 4, // <-- Annual Income field should take up the remaining 4 columns\n        },\n      },\n    },\n     property: {\n      \'ui:options\': {\n        size: 4, // <-- Property subform should take up the remaining 4 out of 12 columns\n      },\n      // note that Property field occupancy is not specified, defaulting to use all 12 of the columns available\n    },\n  },\n};\n \n As Material UI components are used for field templates, there might be a need to pass some Material UI options into the field. This can be done by adding the  muiProps  object to  ui:options . \n For example, if you would like to make the down payment field resizable, you can add  multiline: true  to the  muiProps  option. If you want the field to take up multiple rows by default, add the fields  rows  and  rowsMax . The latter limits how many rows can be added until the scroll bar is shown. \n downpayment: {\n  \'ui:options\': {\n    size: 4,\n    muiProps: {\n      multiline: true,\n      rows: 2,\n      rowsMax: 4\n    }\n  }\n}\n Widgets \n Different types of widgets can be applied by passing the type via\n ui:widget . This property specifies the widget to use when the form\nrenders a UI field. See the documentation to learn about widgets supported by the  react-jsonschema-form . \n Code Style \n Refer to:  https://github.com/entando/entando-code-style \n Sonar \n Refer to:  https://sonarcloud.io/organizations/entando/projects \n'},{title:"PDA Architecture",frontmatter:{},regularPath:"/v7.0/tutorials/solution/pda-architecture.html",relativePath:"v7.0/tutorials/solution/pda-architecture.md",key:"v-ae3e69a8",path:"/v7.0/tutorials/solution/pda-architecture.html",headers:[{level:2,title:"PDA MFEs",slug:"pda-mfes"},{level:2,title:"PDA API",slug:"pda-api"},{level:2,title:"PDA Core",slug:"pda-core"},{level:2,title:"PAM Impl",slug:"pam-impl"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:" PDA Architecture \n This document describes the components that comprise the Process Driven Applications (PDA) plugin architecture with respect to\ndeployment, as well as how they interact with each other. \n The image below shows the high level components. \n PDA MFEs \n The PDA micro frontends run on the browser, rendering the custom UI\ncomponents the user interacts with. These components are written in React and fetch data from the PDA API, passing the Keycloak token for authentication. \n The MFEs also make calls to the Entando Core API to retrieve the\nsettings required for the UI configuration. These components are available to assist with page creation after the PDA plugin bundle is installed. \n The source code for this component:\n https://github.com/entando/entando-process-driven-plugin/tree/master/widgets \n PDA API \n The PDA API is a Spring Boot application that communicates with the BPM engine, and BPM engine data is made available in a Rest API. Subject to deployment configuration, the PDA API interacts with Keycloak to validate the token, retrieving the connection and sensitive data. Instead of calling specific engine classes directly, the application calls the abstractions defined in the PDA Core library. \n The engine implementation is determined at runtime based on the connection details provided. It is important to note that the PDA API does not have a database and is therefore stateless. All data available in the API are retrieved\nfrom the BPM engine. After bundle installation, the API is deployed as a\nmicroservice in the Kubernetes infrastructure. An Ingress is also created to\nmake the API available to the MFEs, as described by the Entando Plugin custom\nresource. \n The source code for this component:\n https://github.com/entando/entando-process-driven-plugin \n PDA Core \n The PDA Core is the library that defines the interface and abstraction implementations that interact with specific BPM engines. It allows multiple engine implementations to exist simultaneously. \n The source code for this component:\n https://github.com/entando/pda-core-engine \n PAM Impl \n The PAM Impl is the Red Hat PAM implementation for the PDA Core library. If the connection maps\nto a PAM engine, these are the classes that are executed when the\nPDA API requests engine operations. This implementation communicates with\nthe Kie Server, which executes the defined process operations. \n The source code for this component:\n https://github.com/entando/pda-redhatpam-engine \n"},{title:"Entando Process Driven Applications Plugin",frontmatter:{sidebarDepth:2},regularPath:"/v7.0/tutorials/solution/pda-tutorial.html",relativePath:"v7.0/tutorials/solution/pda-tutorial.md",key:"v-c6d19f54",path:"/v7.0/tutorials/solution/pda-tutorial.html",headers:[{level:2,title:"Introduction",slug:"introduction"},{level:2,title:"Installation",slug:"installation"},{level:3,title:"Prerequisites",slug:"prerequisites"},{level:3,title:"Automatic Install via the Entando Hub",slug:"automatic-install-via-the-entando-hub"},{level:3,title:"Manual Install",slug:"manual-install"},{level:2,title:"Configuration",slug:"configuration"},{level:2,title:"Application Details",slug:"application-details"},{level:3,title:"Micro Frontends (MFEs)",slug:"micro-frontends-mfes"},{level:3,title:"Process Automation Manager (PAM)",slug:"process-automation-manager-pam"},{level:3,title:"Backend for Frontend (BFF)",slug:"backend-for-frontend-bff"},{level:2,title:"Customization and Extension",slug:"customization-and-extension"},{level:3,title:"Styling",slug:"styling"},{level:3,title:"Implementing a New Engine or Integrating a New Task Source",slug:"implementing-a-new-engine-or-integrating-a-new-task-source"},{level:2,title:"Resources",slug:"resources"},{level:3,title:"Source Code",slug:"source-code"}],lastUpdated:"4/19/2022, 4:57:15 PM",lastUpdatedTimestamp:1650401835e3,content:' Entando Process Driven Applications Plugin \n Introduction \n The Entando Process Driven Applications (PDA) plugin is engineered to provide a rich and full-featured user experience while facilitating the management and completion of business processes and automation.  This solution template includes: \n \n A general purpose UX layer created from micro frontends that can be implemented for any business process or task engine. The UX layer can serve data via the included Entando integration adapter or by implementing a set of interfaces on the server side. \n A Spring Boot microservice backend providing a pluggable interface for the injection of underlying processes or automation toolkits. The interfaces and steps for creating a new PDA backend implementation are described in further detail  here . \n \n This tutorial will guide you through installing the PDA plugin using the Entando Component Repository (ECR) and an Entando Bundle. This exercise demonstrates the scope of process automation enabled by integrating the following: \n \n Custom Micro Frontends (MFEs) \n Backend for Frontend (BFF) microservice \n Red Hat Process Automation Manager  (PAM) \n \n Key elements of the template are reviewed in the  Application Details section  below. \n Installation \n There are numerous assets installed as part of the Entando PDA plugin. Entando Bundles can include more or less components, depending on objectives. It is recommended that organizations develop guidelines for bundle sizing that fit the goals of their applications and teams. \n Prerequisites \n \n An Entando Application on any Kubernetes provider. Follow one of the  tutorials  appropriate to your environment to install the Entando platform. \n The ent command line tool, installed and connected to your Kubernetes instance. \n Red Hat PAM \n Automatic Install via the Entando Hub \n \n \n Log into your  App Builder  →  Repository  →  Select Registry  → choose  Entando Hub  if it has been configured. \n \n If not, choose  New Registry \n In the pop-up window, enter  Entando Hub  and https://entando.com/entando-hub-api/appbuilder/api for the URL, then  Save \n Click on the Hub in the Registry \n \n \n \n From the Hub Catalog,  Deploy  and  Install  the PDA bundle. The installation may take several minutes while the application downloads the Linux image for the microservice and installs the related assets. \n \n \n To finish the tutorial, skip to the  Configuration Steps  below. \n Manual Install \n \n Apply the Custom Resource Definition for the PDA plugin component bundle. \n \n ent ecr deploy --repo="https://github.com/entando-samples/entando-process-driven-plugin-bundle.git"\n \n \n \n Log into your App Builder instance. \n \n \n Select  Repository  from the menu on the left. Your bundles will be visible in the repository as shown in the screenshot below. \n \n \n \n \n Select  Install  to install the bundle. The installation may take several minutes while the application downloads the Linux image for the microservice and installs the related assets. \n Configuration \n Follow the steps below to configure service permissions and connections. \n \n \n Login to your Keycloak instance  as an admin. \n \n \n Set up permissions to configure the service: \n \n Select  pn-efbd66b6-b0ceabd7-entando-pda-plugin-server  from  Client Roles . \n Select all roles from  Available Roles  and click  Add selected . See  Role Assignment in ID Management  for more details. \n \n \n \n Log in to the App Builder and configure the PDA connection. \n \n \n \n Go to  Pages  →  Management , find  PDA Connections  in the page tree and select  View Published Page  from the Actions. This redirects you to the browser tab opened for PDA Connections. \n Click on  Create new connection  in the upper right corner. The  Name* ,  Engine*  and  Timeout*  fields are prepopulated with base values.\n \n The default name value  pam-demo  may be edited, but the datasource names of other widgets must match your edit. Go to  Pages  →  Management  and select  Design  from the Actions of each page below. The Actions of affected widgets will include a  Settings  option, from which you can update the  Knowledge Source  field.\n \n PDA Dashboard \n PDA Process Definition \n PDA Smart Inbox \n PDA Task Details \n \n \n Leave  pam  as the engine name. This value is appropriate for jBPM or PAM. \n Leave the timeout as  60000 , which is in milliseconds. \n Provide your connection URL to the KIE Server rest services, e.g. \'http://my.server.net:8080/kie-server/services/rest/server\'. \n Username/password should be for a jBPM or PAM service account user, e.g. \'krisv\'. \n \n \n \n Go to the Smart Inbox to begin working with the PDA plugin. It can be accessed from the App Builder by navigating to  Pages → Management , finding  PDA Smart Inbox  in the page tree and clicking  View Published Page  from its Actions. \n Application Details \n The Entando PDA plugin demonstrates several of the major features of the Entando platform, the configuration and capabilities of which are summarized below. For a discussion of these components in the context of deployment, see  PDA Deployment Architecture . \n Micro Frontends (MFEs) \n This section provides a brief description of each MFE available to the PDA plugin. Details specific to the PAM implementation of an MFE are included where appropriate. MFE behavior and datasources must be defined if the integration layer is extended to other engines or custom implementations. \n Task List \n The Task List MFE provides the user with a list of visible tasks that are\neither assigned to or could be claimed by that user. In the default implementation, the visible tasks are limited to a\nsingle process instance. At configuration time, the application designer\nis given the option to select a set of columns that will be visible in\nthe task list for that page. \n \n The default PAM implementation exposes the top level task fields in the task list for selection. It is possible to fetch task and process variables from the task list for rendering, but this is disabled by default to optimize performance. \n Task Details \n The Task Details MFE renders detailed information about a task in a read only grid. It is intended to give the end user the information necessary to process the task. See the Styling section below to customize the layout. \n \n The PAM implementation renders task variables in the task details widget. \n Task Comments \n The Task Comments MFE enables the user to view and add the notes attached\nto a task. \n \n The PAM implementation reads and publishes notes to the comments endpoint. \n Task Form \n The Task Form can be accessed by clicking on the Task Overview link found in the Task Details MFE. Its implementation renders a form specific to a task and enables\nthe user to complete that form. It is a\nwrapper around a JSON schema that describes the layout, style and\ncontent of the form. The backend implementation provides the mapping\nto the schema and default UX layout needed to render the form. See the\n technical documentation  for more on the JSON schema\nimplementation. \n The PAM implementation of forms depends on the presence of a form definition for the PAM task. The Entando PAM engine implementation transforms the PAM format to the JSON schema to render the form. It also transforms the API format back to the PAM format. There are some limitations on form customization due to the format required to return data to PAM. See the Task Forms section in the technical documentation for more information. \n Attachments \n The Attachments MFE enables the user to view and add documents attached to a task, case or process. After selecting an entry in the Smart Inbox task list, use the App Builder to add the Attachment MFE to that entry\'s page by navigating to  Pages → Management ; select  Design  from the  PDA Smart Inbox  actions and drag the "PDA - Task Attachments" widget into its placeholder. \n \n The PAM implementation posts the documents to the PAM endpoints for storage. \n New Process Form \n The New Process Form renders a form enabling the end user to instantiate a new business process instance. The same technology is used to generate a New Process Form and the JSON schema definition for a Task Form. \n \n The PAM implementation relies on a form definition attached to the process definition. Entando transforms the PAM representation into a JSON schema form that can be rendered to the end user. \n Summary Cards \n The Summary Card MFEs provide a view into aggregate data for the process\nimplementation. The rendered information includes a total value, a trend\nvalue, and a timeframe selector. The Summary Card provides the\nthe option to request rendering information. This request maps to a call in the underlying engine and provides the summarized data. \n \n The PAM implementation of the Summary Card widget relies on the PAM custom query functionality. The PAM PDA engine exposes a configuration file where the custom query can be defined. This allows user customization of the data rendered on the summary cards. The application contains a "properties" file where the user can submit a custom query for each of the cards. \n Totals Over Time \n The Totals Over Time MFE provides a dual axis line/bar graph displaying\ntrend information about the process environment. Three summary values can be compared over a single time period. \n \n The PAM implementation of the Totals Over Time MFE utilizes custom queries to fetch the summary data rendered in the chart. The queries used in the implementation are defined in configuration files in the MFE and can be updated to render implementation specific data. \n Process Automation Manager (PAM) \n The Entando PDA is built on Process Automation Manager, which is a business process automation engine built and maintained by Red Hat. \n Backend for Frontend (BFF) \n A microservice architecture allows teams to iterate quickly and\ndevelop technology to scale rapidly. Backend for Frontend\nis an architecture pattern built with microservices. The key\ncomponent of this pattern is an application connecting the frontend\nof an application with the backend. The BFF Code Pattern helps to build that component according to IBM’s best practices. \n Customization and Extension \n This section describes how the PDA plugin can be customized and extended via: \n \n Styling \n Implementing a new engine \n Integrating a new task source \n \n For an in-depth discussion of the PDA architecture, refer to the  PDA Technical Guide . \n Styling \n The Entando PDA MFEs are styled via a Material UI theme. That theme can\nbe downloaded and updated  here . \n Implementing a New Engine or Integrating a New Task Source \n Implementing a new engine for Process Driven Applications means\ncreating a new Java project and implementing the interfaces defined in the\n pda-core-engine  project. The new project should therefore include the\n pda-core-engine  as a dependency. \n To see an implementation in action, consider the  pda-redhatpam-engine  project, which implements the Red Hat PAM engine integration. The resultant JAR file should be available in the classpath for the  entando-process-driven-plugin , which is the project that\nis ultimately executed and exposes the Rest APIs for the frontend\napplication. \n One way to achieve this is by publishing the engine\nimplementation to a Maven repository and adding it as a dependency to\nthe  entando-process-driven-plugin  project. Below are the descriptions of\nthe engine class and key interfaces in the  pda-core-engine  project that must be inherited or implemented when creating a new engine\nimplementation. \n Classes \n Engine : represents a Business Process Management (BPM) engine and exposes the services that are available for that specific implementation. It is intended to be inherited, and the subclass should provide the implementation for each service by calling the superclass constructor with the service implementations as arguments. If any service is not supported, a null value should be passed to the corresponding constructor argument. The engine can provide implementations for service interfaces. \n Interfaces \n TaskService : defines service methods for task retrieval from the BPM engine. \n TaskDefinitionService : defines service methods related to task definition. A task definition specifies which fields or columns are available for all task instances. \n TaskCommentService : defines service methods related to task comment manipulation. It should be implemented if the task comment is supported by the engine. \n TaskAttachmentService : defines service methods to operate on task attachments. It should be implemented if the engine supports file attachment on the task. \n TaskFormService : defines service methods for task form operations, like retrieving the form definition and submitting a form. The Form object can be used to render a form dynamically. \n TaskLifecycleService : defines service methods related to the task lifecycle. The lifecycle operations move the task from one state to another. \n TaskLifecycleBulkService : defines methods for bulk lifecycle operations. Like the TaskLifecycleService, these methods move the task from one state to another, but this interface works with multiple tasks at a time. \n ProcessService : defines service methods for process definitions operations. \n ProcessFormService : defines service methods for process form operations, like retrieving the form definition and submitting a form. The Form object can be used to render a form dynamically. \n GroupService : defines service methods related to groups in the BPM engine. \n Resources \n Source Code \n The source code for the Entando PDA plugin can be found on GitHub, along with our other open source examples and tutorials. Reference the component projects for instructions to build from source code: \n \n https://github.com/entando/entando-process-driven-plugin \n https://github.com/entando/entando-process-driven-plugin/tree/master/widgets \n https://github.com/entando/pda-redhatpam-engine \n https://github.com/entando/pda-core-engine \n \n'}],themeConfig:{logo:"/theme/Entando_Logo_Dark_Blue.svg",repo:"entando/entando-docs",editLinks:!0,docsDir:"vuepress/docs",docsBranch:"main",editLinkText:"Edit this page on GitHub",lastUpdated:"Last Updated",nav:[{text:"What We Do",type:"links",items:[{text:"Platform Overview",link:"https://entando.com/page/en/platform-overview"},{text:"Use Cases",link:"https://entando.com/page/en/solutions"}]},{text:"Services",type:"links",items:[{text:"Subscriptions",link:"https://entando.com/page/en/subscriptions"},{text:"Professional Services",link:"http://entando.com/page/en/professional-services"}]},{text:"Developers",type:"links",items:[{text:"Getting Started",link:"https://developer.entando.com/"},{text:"Docs",link:"https://developer.entando.com/docs/"},{text:"Tutorials",link:"https://developer.entando.com/tutorials/"},{text:"Forum",link:"https://forum.entando.org"},{text:"Webinars",link:"https://entando.com/page/en/webinars"}]},{text:"Partners",type:"links",items:[{text:"Partner Portal",link:"https://www.entando.com/page/en/partner-portal"},{text:"Partner Program",link:"https://www.entando.com/page/en/partners"},{text:"OpenShift",link:"https://www.entando.com/en/openshift.page"}]},{text:"News",type:"links",items:[{text:"Blog",link:"https://www.entando.com/page/en/blog"},{text:"Press Release",link:"https://www.entando.com/page/en/pr"},{text:"Press Kit",link:"https://www.entando.com/page/en/press-kit"}]}],landingSecondaryNav:[{text:"Docs",link:"/v7.0/docs/",target:"_self"},{text:"Tutorials",link:"/v7.0/tutorials/",target:"_self"},{text:"Forum",link:"https://forum.entando.org"},{text:"Blog",link:"https://www.entando.com/page/en/blog"}],secondaryNav:[{text:"Docs",link:'javascript:Entando.versionedLink("/docs");',target:"_self"},{text:"Tutorials",link:'javascript:Entando.versionedLink("/tutorials");',target:"_self"},{text:"Forum",link:"https://forum.entando.org"},{text:"Blog",link:"https://www.entando.com/page/en/blog"}],serviceWorker:{updatePopup:!0},sidebar:{"/next/docs/":[{title:"Introduction",children:[{title:"Overview",path:"/next/docs/"},{title:"Getting Started",path:"/next/docs/getting-started/"},{title:"Solution Templates",path:"/next/docs/getting-started/landing-page.md"},{title:"Development Process",path:"/next/docs/getting-started/development-concepts.md"},{title:"Entando Architecture",path:"/next/docs/getting-started/concepts-overview.md"}]},{title:"Create Components",children:[{title:"Entando Component Generator",path:"/next/docs/create/component-gen-overview.md"},{title:"Entando Blueprint Features",path:"/next/docs/create/blueprint-features.md"},{title:"Component Generation Technologies",path:"/next/docs/create/component-gen-tech.md"},{title:"Customizing The Component Generator",path:"/next/docs/create/component-gen-customize.md"}]},{title:"Curate and Share Components",children:[{title:"Bundle and Component Descriptors",path:"/next/docs/curate/ecr-bundle-details.md"},{title:"Filtering Bundles",path:"/next/docs/curate/ecr-bundle-filters.md"},{title:"Customize Bundle Info in App Builder",path:"/next/docs/curate/ecr-bundle-presentation-config.md"},{title:"Bundle Version and Updates - FAQ",path:"/next/docs/curate/ecr-bundle-versions-faq.md"},{title:"How Microservices connect to Entando Apps",path:"/next/docs/curate/ecr-how-microservices-connect-to-apps.md"},{title:"Bundle Uninstall",path:"/next/docs/curate/ecr-uninstall-flow.md"},{title:"Troubleshooting ECR",path:"/next/docs/curate/ecr-troubleshooting-guide.md"}]},{title:"Compose an Application",children:[{title:"Welcome Wizard",path:"/next/docs/compose/welcome-wizard.md"},{title:"Entando App Builder",path:"/next/docs/compose/app-builder.md"},{title:"Entando Component Repository",path:"/next/docs/compose/ecr-overview.md"},{title:"Entando Component Manager",path:"/next/docs/compose/ecm-overview.md"}]},{title:"Consume Applications",children:[{title:"Accessibility",path:"/next/docs/consume/accessibility.md"},{title:"Entando Operator",path:"/next/docs/consume/operator-intro.md"},{title:"Entando APIs",path:"/next/docs/consume/entando-apis.md"},{title:"Custom Resources",path:"/next/docs/consume/custom-resources.md"},{title:"Entando Identity Management System",path:"/next/docs/consume/identity-management.md"}]},{title:"Reference",children:[{title:"Entando CLI",path:"/next/docs/reference/entando-cli.md"},{title:"Deployment Structure",path:"/next/docs/reference/deployment-structure.md"},{title:"Cluster Resource Limits",path:"/next/docs/reference/cluster-resource-limits.md"},{title:"Databases",path:"/next/docs/reference/databases.md"},{title:"Caching and Clustering",path:"/next/docs/reference/caching-and-clustering.md"},{title:"Freemarker Core Tags",path:"/next/docs/reference/freemarker-tags/freemarker-core-tags.md"},{title:"Freemarker CMS Tags",path:"/next/docs/reference/freemarker-tags/freemarker-JACMS-tags.md"},{title:"Development Tips and Tricks",path:"/next/docs/reference/local-tips-and-tricks.md"}]},{title:"Community",children:[{title:"Contributing",path:"/next/docs/community/contributing.md"},{title:"Code of Conduct",path:"/next/docs/community/code-of-conduct.md"}]},{title:"Release Notes",children:["/next/docs/releases/"]}],"/next/tutorials/":[{title:"Get Started",children:[{title:"Learning Paths",path:"/next/tutorials/"},{title:"Install Entando",children:[{title:"Red Hat OpenShift",path:"/next/tutorials/getting-started/openshift-install.md"},{title:"Red Hat OpenShift using the Operator",path:"/next/tutorials/getting-started/openshift-install-by-operator.md"},{title:"Amazon Elastic Kubernetes Service (EKS)",path:"/next/tutorials/getting-started/eks-install.md"},{title:"Azure Kubernetes Service (AKS)",path:"/next/tutorials/getting-started/azure-install.md"},{title:"Google Kubernetes Engine (GKE)",path:"/next/tutorials/getting-started/gke-install.md"},{title:"Kubernetes",path:"/next/tutorials/getting-started/kubernetes-install.md"}]}]},{title:"Solution Templates",children:[{title:"Introduction",path:"/next/tutorials/solution/landing-page.md"},{title:"Customer Portal",path:"/next/tutorials/solution/customer-portal.md"},{title:"Entando Hub",path:"/next/tutorials/solution/entando-hub.md"},{title:"PDA Plugin",path:"/next/tutorials/solution/pda-tutorial.md"},{title:"Standard Banking Demo",path:"/next/tutorials/solution/install-standard-demo.md"}]},{title:"Create Components",children:[{title:"Micro Frontends",children:[{title:"Introduction",path:"/next/tutorials/create/mfe/"},{title:"React",path:"/next/tutorials/create/mfe/react.md"},{title:"Angular",path:"/next/tutorials/create/mfe/angular.md"},{title:"Communication",path:"/next/tutorials/create/mfe/communication.md"},{title:"Configuration",path:"/next/tutorials/create/mfe/widget-configuration.md"},{title:"Authentification",path:"/next/tutorials/create/mfe/authentication.md"}]},{title:"Microservices",children:[{title:"Generate Microservices and Micro Frontends",path:"/next/tutorials/create/ms/generate-microservices-and-micro-frontends.md"},{title:"Run Generated Components Locally",path:"/next/tutorials/create/ms/run-local.md"},{title:"Update Project Data Model",path:"/next/tutorials/create/ms/update-data-model.md"},{title:"Add Access Controls",path:"/next/tutorials/create/ms/add-access-controls.md"},{title:"Use Postman with OAuth2 APIs",path:"/next/tutorials/create/ms/use-postman-with-oauth2.md"}]},{title:"Publish Bundles",children:[{title:"Build and Publish a Simple Bundle",path:"/next/tutorials/create/pb/publish-simple-bundle.md"},{title:"Build and Publish a Project Bundle",path:"/next/tutorials/create/pb/publish-project-bundle.md"},{title:"Export and Publish a Bundle",path:"/next/tutorials/create/pb/export-bundle-from-application.md"},{title:"Add a GitHub Actions CI Workflow",path:"/next/tutorials/create/pb/github-actions-workflow.md"},{title:"Install Plugins and Micro Frontends without a Bundle",path:"/next/tutorials/create/pb/deploy-components-without-bundle.md"}]}]},{title:"Curate and Share Applications",children:["/next/tutorials/curate/ecr-private-git-repo.md","/next/tutorials/curate/ecr-private-images.md"]},{title:"Compose an Application",children:["/next/tutorials/compose/page-management.md","/next/tutorials/compose/widgets-fragments.md","/next/tutorials/compose/content-tutorial.md","/next/tutorials/compose/content-types-tutorial.md","/next/tutorials/compose/content-attributes.md","/next/tutorials/compose/content-templates-tutorial.md","/next/tutorials/compose/digital-assets-tutorial.md","/next/tutorials/compose/creating-protected-resources.md"]},{title:"Configure and Customize an Application",children:[{title:"Default Database",path:"/next/tutorials/devops/default-database.md"},{title:"External Database",path:"/next/tutorials/devops/external-db.md"},{title:"External Identity Management System",path:"/next/tutorials/devops/external-id-management.md"},{title:"Entando Docker Image",path:"/next/tutorials/devops/build-core-image.md"},{title:"Backing Up and Restoring Your Environment",path:"/next/tutorials/devops/backing-up-and-restoring-your-environment.md"},{title:"Backing Up and Restoring Keycloak",path:"/next/tutorials/devops/backing-restoring-keycloak.md"},{title:"Caching and Clustering",path:"/next/tutorials/devops/caching-and-clustering.md"},{title:"Add REST API",path:"/next/tutorials/devops/add-rest-api.md"},{title:"Invoke Entando Core APIs",path:"/next/tutorials/devops/invoking-api.md"},{title:"Change Default Datasource",path:"/next/tutorials/devops/change-default-datasource.md"},{title:"Manage NGINX",path:"/next/tutorials/devops/manage-nginx.md"},{title:"Plugin Configuration",path:"/next/tutorials/devops/plugin-configuration.md"},{title:"Plugin Environment Variables",path:"/next/tutorials/devops/plugin-environment-variables.md"},{title:"Configure the Entando Operator",path:"/next/tutorials/devops/entando-operator.md"}]}],"/v7.0/docs/":[{title:"Introduction",children:[{title:"Overview",path:"/v7.0/docs/"},{title:"Getting Started",path:"/v7.0/docs/getting-started/"},{title:"Solution Templates",path:"/v7.0/docs/getting-started/landing-page.md"},{title:"Development Process",path:"/v7.0/docs/getting-started/development-concepts.md"},{title:"Entando Architecture",path:"/v7.0/docs/getting-started/concepts-overview.md"}]},{title:"Create Components",children:[{title:"Entando Component Generator",path:"/v7.0/docs/create/component-gen-overview.md"},{title:"Entando Blueprint Features",path:"/v7.0/docs/create/blueprint-features.md"},{title:"Component Generation Technologies",path:"/v7.0/docs/create/component-gen-tech.md"},{title:"Customizing The Component Generator",path:"/v7.0/docs/create/component-gen-customize.md"}]},{title:"Curate and Share Components",children:[{title:"Bundle and Component Descriptors",path:"/v7.0/docs/curate/ecr-bundle-details.md"},{title:"Filtering Bundles",path:"/v7.0/docs/curate/ecr-bundle-filters.md"},{title:"Customize Bundle Info in App Builder",path:"/v7.0/docs/curate/ecr-bundle-presentation-config.md"},{title:"Bundle Version and Updates - FAQ",path:"/v7.0/docs/curate/ecr-bundle-versions-faq.md"},{title:"How Microservices connect to Entando Apps",path:"/v7.0/docs/curate/ecr-how-microservices-connect-to-apps.md"},{title:"Bundle Uninstall",path:"/v7.0/docs/curate/ecr-uninstall-flow.md"},{title:"Troubleshooting ECR",path:"/v7.0/docs/curate/ecr-troubleshooting-guide.md"}]},{title:"Compose an Application",children:[{title:"Welcome Wizard",path:"/v7.0/docs/compose/welcome-wizard.md"},{title:"Entando App Builder",path:"/v7.0/docs/compose/app-builder.md"},{title:"Entando Component Repository",path:"/v7.0/docs/compose/ecr-overview.md"},{title:"Entando Component Manager",path:"/v7.0/docs/compose/ecm-overview.md"}]},{title:"Consume Applications",children:[{title:"Accessibility",path:"/v7.0/docs/consume/accessibility.md"},{title:"Entando Operator",path:"/v7.0/docs/consume/operator-intro.md"},{title:"Entando APIs",path:"/v7.0/docs/consume/entando-apis.md"},{title:"Custom Resources",path:"/v7.0/docs/consume/custom-resources.md"},{title:"Entando Identity Management System",path:"/v7.0/docs/consume/identity-management.md"}]},{title:"Reference",children:[{title:"Entando CLI",path:"/v7.0/docs/reference/entando-cli.md"},{title:"Deployment Structure",path:"/v7.0/docs/reference/deployment-structure.md"},{title:"Cluster Resource Limits",path:"/v7.0/docs/reference/cluster-resource-limits.md"},{title:"Databases",path:"/v7.0/docs/reference/databases.md"},{title:"Caching and Clustering",path:"/v7.0/docs/reference/caching-and-clustering.md"},{title:"Freemarker Core Tags",path:"/v7.0/docs/reference/freemarker-tags/freemarker-core-tags.md"},{title:"Freemarker CMS Tags",path:"/v7.0/docs/reference/freemarker-tags/freemarker-JACMS-tags.md"},{title:"Development Tips and Tricks",path:"/v7.0/docs/reference/local-tips-and-tricks.md"}]},{title:"Community",children:[{title:"Contributing",path:"/v7.0/docs/community/contributing.md"},{title:"Code of Conduct",path:"/v7.0/docs/community/code-of-conduct.md"}]},{title:"Release Notes",children:[{title:"Entando 7.0 Release Notes",path:"/v7.0/docs/releases/"}]}],"/v7.0/tutorials/":[{title:"Get Started",children:[{title:"Learning Paths",path:"/v7.0/tutorials/"},{title:"Install Entando",children:[{title:"Red Hat OpenShift",path:"/v7.0/tutorials/getting-started/openshift-install.md"},{title:"Red Hat OpenShift using the Operator",path:"/v7.0/tutorials/getting-started/openshift-install-by-operator.md"},{title:"Amazon Elastic Kubernetes Service (EKS)",path:"/v7.0/tutorials/getting-started/eks-install.md"},{title:"Azure Kubernetes Service (AKS)",path:"/v7.0/tutorials/getting-started/azure-install.md"},{title:"Google Kubernetes Engine (GKE)",path:"/v7.0/tutorials/getting-started/gke-install.md"},{title:"Kubernetes",path:"/v7.0/tutorials/getting-started/kubernetes-install.md"}]}]},{title:"Solution Templates",children:[{title:"Introduction",path:"/v7.0/tutorials/solution/landing-page.md"},{title:"Customer Portal",path:"/v7.0/tutorials/solution/customer-portal.md"},{title:"Entando Hub",path:"/v7.0/tutorials/solution/entando-hub.md"},{title:"PDA Plugin",path:"/v7.0/tutorials/solution/pda-tutorial.md"},{title:"Standard Banking Demo",path:"/v7.0/tutorials/solution/install-standard-demo.md"}]},{title:"Create Components",children:[{title:"Micro Frontends",children:[{title:"Introduction",path:"/v7.0/tutorials/create/mfe/"},{title:"React",path:"/v7.0/tutorials/create/mfe/react.md"},{title:"Angular",path:"/v7.0/tutorials/create/mfe/angular.md"},{title:"Communication",path:"/v7.0/tutorials/create/mfe/communication.md"},{title:"Configuration",path:"/v7.0/tutorials/create/mfe/widget-configuration.md"},{title:"Authentification",path:"/v7.0/tutorials/create/mfe/authentication.md"}]},{title:"Microservices",children:[{title:"Generate Microservices and Micro Frontends",path:"/v7.0/tutorials/create/ms/generate-microservices-and-micro-frontends.md"},{title:"Run Generated Components Locally",path:"/v7.0/tutorials/create/ms/run-local.md"},{title:"Update Project Data Model",path:"/v7.0/tutorials/create/ms/update-data-model.md"},{title:"Add Access Controls",path:"/v7.0/tutorials/create/ms/add-access-controls.md"},{title:"Use Postman with OAuth2 APIs",path:"/v7.0/tutorials/create/ms/use-postman-with-oauth2.md"}]},{title:"Publish Bundles",children:[{title:"Build and Publish a Simple Bundle",path:"/v7.0/tutorials/create/pb/publish-simple-bundle.md"},{title:"Build and Publish a Project Bundle",path:"/v7.0/tutorials/create/pb/publish-project-bundle.md"},{title:"Export and Publish a Bundle",path:"/v7.0/tutorials/create/pb/export-bundle-from-application.md"},{title:"Add a GitHub Actions CI Workflow",path:"/v7.0/tutorials/create/pb/github-actions-workflow.md"},{title:"Install Plugins and Micro Frontends without a Bundle",path:"/v7.0/tutorials/create/pb/deploy-components-without-bundle.md"}]}]},{title:"Curate and Share Applications",children:["/v7.0/tutorials/curate/ecr-private-git-repo.md","/v7.0/tutorials/curate/ecr-private-images.md"]},{title:"Compose an Application",children:["/v7.0/tutorials/compose/page-management.md","/v7.0/tutorials/compose/widgets-fragments.md","/v7.0/tutorials/compose/content-tutorial.md","/v7.0/tutorials/compose/content-types-tutorial.md","/v7.0/tutorials/compose/content-attributes.md","/v7.0/tutorials/compose/content-templates-tutorial.md","/v7.0/tutorials/compose/digital-assets-tutorial.md","/v7.0/tutorials/compose/creating-protected-resources.md"]},{title:"Configure and Customize an Application",children:[{title:"Default Database",path:"/v7.0/tutorials/devops/default-database.md"},{title:"External Database",path:"/v7.0/tutorials/devops/external-db.md"},{title:"External Identity Management System",path:"/v7.0/tutorials/devops/external-id-management.md"},{title:"Entando Docker Image",path:"/v7.0/tutorials/devops/build-core-image.md"},{title:"Backing Up and Restoring Your Environment",path:"/v7.0/tutorials/devops/backing-up-and-restoring-your-environment.md"},{title:"Backing Up and Restoring Keycloak",path:"/v7.0/tutorials/devops/backing-restoring-keycloak.md"},{title:"Caching and Clustering",path:"/v7.0/tutorials/devops/caching-and-clustering.md"},{title:"Add REST API",path:"/v7.0/tutorials/devops/add-rest-api.md"},{title:"Invoke Entando Core APIs",path:"/v7.0/tutorials/devops/invoking-api.md"},{title:"Change Default Datasource",path:"/v7.0/tutorials/devops/change-default-datasource.md"},{title:"Manage NGINX",path:"/v7.0/tutorials/devops/manage-nginx.md"},{title:"Plugin Configuration",path:"/v7.0/tutorials/devops/plugin-configuration.md"},{title:"Plugin Environment Variables",path:"/v7.0/tutorials/devops/plugin-environment-variables.md"},{title:"Configure the Entando Operator",path:"/v7.0/tutorials/devops/entando-operator.md"}]}],"/v6.3.2/docs/":[{title:"Introduction",children:[{title:"Overview",path:"/v6.3.2/docs/"},{title:"Getting Started",path:"/v6.3.2/docs/getting-started/"},{title:"Solution Templates",path:"/v6.3.2/docs/getting-started/landing-page.md"},{title:"Development Process",path:"/v6.3.2/docs/getting-started/development-concepts.md"},{title:"Entando Architecture",path:"/v6.3.2/docs/getting-started/concepts-overview.md"}]},{title:"Create Components",children:[{title:"Entando Component Generator",path:"/v6.3.2/docs/create/component-gen-overview.md"},{title:"Entando Blueprint Features",path:"/v6.3.2/docs/create/blueprint-features.md"},{title:"Component Generation Technologies",path:"/v6.3.2/docs/create/component-gen-tech.md"},{title:"Customizing The Component Generator",path:"/v6.3.2/docs/create/component-gen-customize.md"}]},{title:"Curate and Share Components",children:[{title:"Bundle and Component Descriptors",path:"/v6.3.2/docs/curate/ecr-bundle-details.md"},{title:"Filtering Bundles",path:"/v6.3.2/docs/curate/ecr-bundle-filters.md"},{title:"Customize Bundle Info in App Builder",path:"/v6.3.2/docs/curate/ecr-bundle-presentation-config.md"},{title:"Bundle Version and Updates - FAQ",path:"/v6.3.2/docs/curate/ecr-bundle-versions-faq.md"},{title:"How Microservices connect to Entando Apps",path:"/v6.3.2/docs/curate/ecr-how-microservices-connect-to-apps.md"},{title:"Bundle Uninstall",path:"/v6.3.2/docs/curate/ecr-uninstall-flow.md"},{title:"Troubleshooting ECR",path:"/v6.3.2/docs/curate/ecr-troubleshooting-guide.md"}]},{title:"Compose an Application",children:[{title:"Welcome Wizard",path:"/v6.3.2/docs/compose/welcome-wizard.md"},{title:"Entando App Builder",path:"/v6.3.2/docs/compose/app-builder.md"},{title:"Entando Component Repository",path:"/v6.3.2/docs/compose/ecr-overview.md"},{title:"Entando Component Manager",path:"/v6.3.2/docs/compose/ecm-overview.md"}]},{title:"Consume Applications",children:[{title:"Accessibility",path:"/v6.3.2/docs/consume/accessibility.md"},{title:"Entando Operator",path:"/v6.3.2/docs/consume/operator-intro.md"},{title:"Entando APIs",path:"/v6.3.2/docs/consume/entando-apis.md"},{title:"Custom Resources",path:"/v6.3.2/docs/consume/custom-resources.md"},{title:"Entando Identity Management System",path:"/v6.3.2/docs/consume/identity-management.md"}]},{title:"Reference",children:[{title:"Entando CLI",path:"/v6.3.2/docs/reference/entando-cli.md"},{title:"Deployment Structure",path:"/v6.3.2/docs/reference/deployment-structure.md"},{title:"Cluster Resource Limits",path:"/v6.3.2/docs/reference/cluster-resource-limits.md"},{title:"Databases",path:"/v6.3.2/docs/reference/databases.md"},{title:"Caching and Clustering",path:"/v6.3.2/docs/reference/caching-and-clustering.md"},{title:"Freemarker Core Tags",path:"/v6.3.2/docs/reference/freemarker-tags/freemarker-core-tags.md"},{title:"Freemarker CMS Tags",path:"/v6.3.2/docs/reference/freemarker-tags/freemarker-JACMS-tags.md"},{title:"Development Tips and Tricks",path:"/v6.3.2/docs/reference/local-tips-and-tricks.md"}]},{title:"Community",children:[{title:"Contributing",path:"/v6.3.2/docs/community/contributing.md"},{title:"Code of Conduct",path:"/v6.3.2/docs/community/code-of-conduct.md"}]},{title:"Release Notes",children:[{title:"Entando 6.3.2 Release Notes",path:"/v6.3.2/docs/releases/"}]}],"/v6.3.2/tutorials/":[{title:"Get Started",children:[{title:"Learning Paths",path:"/v6.3.2/tutorials/"},{title:"Install Entando",children:[{title:"Red Hat OpenShift",path:"/v6.3.2/tutorials/getting-started/openshift-install.md"},{title:"Red Hat OpenShift using the OperatorHub",path:"/v6.3.2/tutorials/getting-started/openshift-install-by-operator-hub.md"},{title:"Amazon Elastic Kubernetes Service (EKS)",path:"/v6.3.2/tutorials/getting-started/eks-install.md"},{title:"Azure Kubernetes Service (AKS)",path:"/v6.3.2/tutorials/getting-started/azure-install.md"},{title:"Google Kubernetes Engine (GKE)",path:"/v6.3.2/tutorials/getting-started/gke-install.md"},{title:"Tanzu Kubernetes Grid (TKG)",path:"/v6.3.2/tutorials/getting-started/tanzu-install.md"},{title:"Kubernetes",path:"/v6.3.2/tutorials/getting-started/kubernetes-install.md"}]}]},{title:"Solution Templates",children:[{title:"Introduction",path:"/v6.3.2/tutorials/solution/landing-page.md"},{title:"Customer Portal",path:"/v6.3.2/tutorials/solution/customer-portal.md"},{title:"Entando Hub",path:"/v6.3.2/tutorials/solution/entando-hub.md"},{title:"PDA Plugin",path:"/v6.3.2/tutorials/solution/pda-tutorial.md"},{title:"Standard Banking Demo",path:"/v6.3.2/tutorials/solution/install-standard-demo.md"}]},{title:"Create Components",children:[{title:"Micro Frontends",children:[{title:"Introduction",path:"/v6.3.2/tutorials/create/mfe/"},{title:"React",path:"/v6.3.2/tutorials/create/mfe/react.md"},{title:"Angular",path:"/v6.3.2/tutorials/create/mfe/angular.md"},{title:"Communication",path:"/v6.3.2/tutorials/create/mfe/communication.md"},{title:"Configuration",path:"/v6.3.2/tutorials/create/mfe/widget-configuration.md"},{title:"Authentification",path:"/v6.3.2/tutorials/create/mfe/authentication.md"}]},{title:"Microservices",children:[{title:"Generate Microservices and Micro Frontends",path:"/v6.3.2/tutorials/create/ms/generate-microservices-and-micro-frontends.md"},{title:"Run Generated Components Locally",path:"/v6.3.2/tutorials/create/ms/run-local.md"},{title:"Update Project Data Model",path:"/v6.3.2/tutorials/create/ms/update-data-model.md"},{title:"Add Access Controls",path:"/v6.3.2/tutorials/create/ms/add-access-controls.md"},{title:"Use Postman with OAuth2 APIs",path:"/v6.3.2/tutorials/create/ms/use-postman-with-oauth2.md"}]},{title:"Publish Bundles",children:[{title:"Build and Publish a Simple Bundle",path:"/v6.3.2/tutorials/create/pb/publish-simple-bundle.md"},{title:"Build and Publish a Project Bundle",path:"/v6.3.2/tutorials/create/pb/publish-project-bundle.md"},{title:"Export and Publish a Bundle",path:"/v6.3.2/tutorials/create/pb/export-bundle-from-application.md"},{title:"Add a GitHub Actions CI Workflow",path:"/v6.3.2/tutorials/create/pb/github-actions-workflow.md"},{title:"Install Plugins and Micro Frontends without a Bundle",path:"/v6.3.2/tutorials/create/pb/deploy-components-without-bundle.md"}]}]},{title:"Curate and Share Applications",children:["/v6.3.2/tutorials/curate/ecr-private-git-repo.md","/v6.3.2/tutorials/curate/ecr-private-images.md"]},{title:"Compose an Application",children:["/v6.3.2/tutorials/compose/page-management.md","/v6.3.2/tutorials/compose/widgets-fragments.md","/v6.3.2/tutorials/compose/content-tutorial.md","/v6.3.2/tutorials/compose/content-types-tutorial.md","/v6.3.2/tutorials/compose/content-attributes.md","/v6.3.2/tutorials/compose/content-templates-tutorial.md","/v6.3.2/tutorials/compose/digital-assets-tutorial.md","/v6.3.2/tutorials/compose/creating-protected-resources.md","/v6.3.2/tutorials/compose/extend-app-builder.md"]},{title:"Configure and Customize an Application",children:[{title:"Default Database",path:"/v6.3.2/tutorials/devops/default-database.md"},{title:"External Database",path:"/v6.3.2/tutorials/devops/external-db.md"},{title:"External Identity Management System",path:"/v6.3.2/tutorials/devops/external-id-management.md"},{title:"Entando Docker Image",path:"/v6.3.2/tutorials/devops/build-core-image.md"},{title:"Backing Up and Restoring Your Environment",path:"/v6.3.2/tutorials/devops/backing-up-and-restoring-your-environment.md"},{title:"Backing Up and Restoring Keycloak",path:"/v6.3.2/tutorials/devops/backing-restoring-keycloak.md"},{title:"Caching and Clustering",path:"/v6.3.2/tutorials/devops/caching-and-clustering.md"},{title:"Add REST API",path:"/v6.3.2/tutorials/devops/add-rest-api.md"},{title:"Invoke Entando Core APIs",path:"/v6.3.2/tutorials/devops/invoking-api.md"},{title:"Change Default Datasource",path:"/v6.3.2/tutorials/devops/change-default-datasource.md"},{title:"Manage NGINX",path:"/v6.3.2/tutorials/devops/manage-nginx.md"}]}],"/v6.3/docs/":[{title:"Overview",path:"/v6.3/docs/"},{title:"Getting Started",children:[{title:"Overview",path:"/v6.3/docs/getting-started/"},{title:"Welcome Wizard",path:"/v6.3/docs/getting-started/welcome-wizard.md"}]},{title:"Concepts",children:[{title:"Overview",path:"/v6.3/docs/concepts/"},{title:"Entando Operator",path:"/v6.3/docs/concepts/operator-intro.md"},{title:"Custom Resources",path:"/v6.3/docs/concepts/custom-resources.md"},{title:"PDA Architecture",path:"/v6.3/docs/concepts/pda-architecture.md"}]},{title:"Entando Component Generator",children:["/v6.3/docs/component-generator/component-gen-overview.md","/v6.3/docs/component-generator/component-gen-tech.md","/v6.3/docs/component-generator/component-gen-customize.md"]},{title:"Entando Component Repository",children:["/v6.3/docs/ecr/ecr-overview.md","/v6.3/docs/ecr/ecr-bundle-details.md","/v6.3/docs/ecr/ecr-bundle-filters.md","/v6.3/docs/ecr/ecr-bundle-presentation-config.md","/v6.3/docs/ecr/ecr-bundle-versions-faq.md","/v6.3/docs/ecr/ecr-how-microservices-connect-to-apps.md","/v6.3/docs/ecr/ecr-uninstall-flow.md","/v6.3/docs/ecr/ecr-troubleshooting-guide.md"]},{title:"Reference",children:[{title:"Entando CLI",path:"/v6.3/docs/reference/entando-cli.md"},{title:"Entando APIs",path:"/v6.3/docs/reference/entando-apis.md"},{title:"Deployment Structure",path:"/v6.3/docs/reference/deployment-structure.md"},{title:"Cluster Resource Limits",path:"/v6.3/docs/reference/cluster-resource-limits.md"},{title:"Databases",path:"/v6.3/docs/reference/databases.md"},{title:"Identity Management",path:"/v6.3/docs/reference/identity-management.md"},{title:"Caching and Clustering",path:"/v6.3/docs/reference/caching-and-clustering.md"},{title:"Freemarker Core Tags",path:"/v6.3/docs/reference/freemarker-tags/freemarker-core-tags.md"},{title:"Freemarker CMS Tags",path:"/v6.3/docs/reference/freemarker-tags/freemarker-JACMS-tags.md"},{title:"Development Tips and Tricks",path:"/v6.3/docs/reference/local-tips-and-tricks.md"}]},{title:"Community",children:[{title:"Contributing",path:"/v6.3/docs/community/contributing.md"},{title:"Code of Conduct",path:"/v6.3/docs/community/code-of-conduct.md"}]},{title:"Release Notes",path:"/v6.3/docs/releases/"}],"/v6.3/tutorials/":[{title:"Overview",path:"/v6.3/tutorials/"},{title:"Micro Frontends",path:"/v6.3/tutorials/micro-frontends",children:[{title:"React",path:"/v6.3/tutorials/micro-frontends/react.md"},{title:"Angular",path:"/v6.3/tutorials/micro-frontends/angular.md"},{title:"Communication",path:"/v6.3/tutorials/micro-frontends/communication.md"},{title:"Config",path:"/v6.3/tutorials/micro-frontends/widget-configuration.md"},{title:"Blueprint",path:"/v6.3/tutorials/micro-frontends/generate-micro-frontends-from-a-database-entity/"},{title:"Authentication",path:"/v6.3/tutorials/micro-frontends/authentication.md"}]},{title:"Microservices",children:[{title:"Generate Microservices and Micro Frontends",path:"/v6.3/tutorials/backend-developers/generate-microservices-and-micro-frontends.md"},{title:"Run Generated Components Locally",path:"/v6.3/tutorials/backend-developers/run-local.md"},{title:"Update Project Data Model",path:"/v6.3/tutorials/backend-developers/update-data-model.md"},{title:"Add Access Controls",path:"/v6.3/tutorials/backend-developers/add-access-controls.md"}]},{title:"Pages and Content",children:["/v6.3/tutorials/cms/page-management.md","/v6.3/tutorials/cms/app-builder/hello-world.md","/v6.3/tutorials/cms/content-tutorial.md","/v6.3/tutorials/cms/content-types-tutorial.md","/v6.3/tutorials/cms/content-attributes.md","/v6.3/tutorials/cms/content-templates-tutorial.md","/v6.3/tutorials/cms/digital-assets-tutorial.md","/v6.3/tutorials/cms/creating-protected-resources.md"]},{title:"Bundles",children:["/v6.3/tutorials/ecr/publish-simple-bundle.md","/v6.3/tutorials/ecr/publish-project-bundle.md","/v6.3/tutorials/ecr/export-bundle-from-application.md","/v6.3/tutorials/ecr/deploy-components-without-bundle.md","/v6.3/tutorials/ecr/ecr-private-git-repo.md","/v6.3/tutorials/ecr/ecr-private-images.md"]},{title:"Extend the Platform",children:[{title:"Extend App Builder",path:"/v6.3/tutorials/customize-the-platform/extend-app-builder.md"},{title:"Add REST API",path:"/v6.3/tutorials/customize-the-platform/add-rest-api.md"},{title:"Process Driven Applications (PDA)",path:"/v6.3/tutorials/customize-the-platform/pda-tutorial.md"},{title:"Change Default Datasource",path:"/v6.3/tutorials/customize-the-platform/change-default-datasources-and-connections/"}]},{title:"Configuration and Operations",children:[{title:"Default Database",path:"/v6.3/tutorials/devops/default-database.md"},{title:"External Database",path:"/v6.3/tutorials/devops/external-database/"},{title:"External Identity Management System",path:"/v6.3/tutorials/devops/external-keycloak/"},{title:"Entando Docker Image",path:"/v6.3/tutorials/devops/build-core-image.md"},{title:"Caching and Clustering",path:"/v6.3/tutorials/devops/clustering-caching/caching-and-clustering.md"},{title:"Backing Up and Restoring Your Environment",path:"/v6.3/tutorials/devops/backing-up-and-restoring-your-environment.md"},{title:"Installation on Red Hat OpenShift",path:"/v6.3/tutorials/devops/installation/open-shift/openshift-install.md"},{title:"Installation on Red Hat OpenShift using the OperatorHub",path:"/v6.3/tutorials/devops/installation/open-shift/openshift-install-by-operator-hub.md"},{title:"Installation on Amazon Elastic Kubernetes Service (EKS)",path:"/v6.3/tutorials/devops/installation/elastic-kubernetes-service/eks-install.md"},{title:"Installation on Azure Kubernetes Service (AKS)",path:"/v6.3/tutorials/devops/installation/azure-kubernetes-service/azure-install.md"},{title:"Installation on Google Kubernetes Engine (GKE)",path:"/v6.3/tutorials/devops/installation/google-cloud-platform/"}]},{title:"Examples",children:[{title:"Entando Standard Demo Application",path:"/v6.3/tutorials/samples/install-standard-demo.md"}]}],"/v6.2/docs/":[{title:"Overview",path:"/v6.2/docs/"},{title:"Getting Started",path:"/v6.2/docs/getting-started/"},{title:"Concepts",children:[{title:"Overview",path:"/v6.2/docs/concepts/"},{title:"Custom Resources",path:"/v6.2/docs/concepts/custom-resources.md"},{title:"PDA Architecture",path:"/v6.2/docs/concepts/pda-architecture.md"}]},{title:"Entando Component Repository",children:["/v6.2/docs/ecr/ecr-overview.md","/v6.2/docs/ecr/ecr-bundle-details.md","/v6.2/docs/ecr/ecr-bundle-filters.md","/v6.2/docs/ecr/ecr-bundle-presentation-config.md","/v6.2/docs/ecr/ecr-bundle-versions-faq.md","/v6.2/docs/ecr/ecr-how-microservices-connects-to-apps.md","/v6.2/docs/ecr/ecr-uninstall-flow.md","/v6.2/docs/ecr/ecr-troubleshooting-guide.md"]},{title:"Reference",children:[{title:"Entando APIs",path:"/v6.2/docs/reference/entando-apis.md"},{title:"Deployment Structure",path:"/v6.2/docs/reference/deployment-structure.md"},{title:"Cluster Resource Limits",path:"/v6.2/docs/reference/cluster-resource-limits.md"},{title:"Databases",path:"/v6.2/docs/reference/databases.md"},{title:"Identity Management",path:"/v6.2/docs/reference/identity-management.md"},{title:"Freemarker Core Tags",path:"/v6.2/docs/reference/freemarker-tags/freemarker-core-tags.md"},{title:"Freemarker CMS Tags",path:"/v6.2/docs/reference/freemarker-tags/freemarker-JACMS-tags.md"}]},{title:"Community",children:[{title:"Contributing",path:"/v6.2/docs/community/contributing.md"},{title:"Code of Conduct",path:"/v6.2/docs/community/code-of-conduct.md"}]},{title:"Release Notes",path:"/v6.2/docs/releases/"}],"/v6.2/tutorials/":[{title:"Micro Frontends",path:"/v6.2/tutorials/micro-frontends",children:[{title:"React",path:"/v6.2/tutorials/micro-frontends/react.md"},{title:"Angular",path:"/v6.2/tutorials/micro-frontends/angular.md"},{title:"Communication",path:"/v6.2/tutorials/micro-frontends/communication.md"},{title:"Config",path:"/v6.2/tutorials/micro-frontends/widget-configuration.md"},{title:"Blueprint",path:"/v6.2/tutorials/micro-frontends/generate-micro-frontends-from-a-database-entity/"},{title:"Authentication",path:"/v6.2/tutorials/micro-frontends/authentication.md"}]},{title:"Microservice Applications",children:[{title:"Generate Microservices and Micro Frontends",path:"/v6.2/tutorials/backend-developers/generate-microservices-and-micro-frontends.md"},{title:"Build and Deploy",path:"/v6.2/tutorials/backend-developers/build-and-deploy.md"},{title:"Run Generated Components Locally",path:"/v6.2/tutorials/backend-developers/run-local.md"}]},{title:"Content Management",children:["/v6.2/tutorials/cms/app-builder/hello-world.md","/v6.2/tutorials/cms/content-tutorial.md","/v6.2/tutorials/cms/content-types-tutorial.md","/v6.2/tutorials/cms/list-of-Content-attributes.md","/v6.2/tutorials/cms/content-templates-tutorial.md","/v6.2/tutorials/cms/digital-assets-tutorial.md","/v6.2/tutorials/cms/publish-a-content-tutorial.md"]},{title:"Entando Component Repository",children:["/v6.2/tutorials/ecr/tutorials/create-ecr-bundle-from-git.md","/v6.2/tutorials/ecr/tutorials/ecr-deploy-use-plugin-and-mfe-without-bundle.md","/v6.2/tutorials/ecr/how-to-setup-nexus-on-kubernetes-cluster.md"]},{title:"Extend the Platform",children:[{title:"Extend App Builder",path:"/v6.2/tutorials/customize-the-platform/extend-app-builder.md"},{title:"Add REST API",path:"/v6.2/tutorials/customize-the-platform/add-rest-api.md"},{title:"Process Driven Applications (PDA)",path:"/v6.2/tutorials/customize-the-platform/pda-tutorial.md"},{title:"Change Default Datasource",path:"/v6.2/tutorials/customize-the-platform/change-default-datasources-and-connections/"}]},{title:"Configuration and Operations",children:[{title:"Default Database",path:"/v6.2/tutorials/devops/default-database.md"},{title:"External Database",path:"/v6.2/tutorials/devops/external-database/"},{title:"External Identity Management System",path:"/v6.2/tutorials/devops/external-keycloak/"},{title:"Entando Docker Image",path:"/v6.2/tutorials/devops/build-core-image.md"},{title:"Backing Up and Restoring Your Environment",path:"/v6.2/tutorials/devops/backing-up-and-restoring-your-environment.md"},{title:"Installation on Red Hat OpenShift",path:"/v6.2/tutorials/devops/installation/open-shift/openshift-install.md"},{title:"Installation on Amazon Elastic Kubernetes Service (EKS)",path:"/v6.2/tutorials/devops/installation/elastic-kubernetes-service/eks-install.md"},{title:"Installation on Azure Kubernetes Service (AKS)",path:"/v6.2/tutorials/devops/installation/azure-kubernetes-service/azure-install.md"},{title:"Installation on Google Kubernetes Engine (GKE)",path:"/v6.2/tutorials/devops/installation/google-cloud-platform/"},{title:"Local Tips and Tricks",path:"/v6.2/tutorials/devops/local-tips-and-tricks.md"}]}],"/v6.1/docs/":[{title:"Overview",path:"/v6.1/docs/"},{title:"Getting Started",path:"/v6.1/docs/getting-started/"},{title:"Concepts",children:[{title:"Overview",path:"/v6.1/docs/concepts/"},{title:"Custom Resources",path:"/v6.1/docs/concepts/custom-resources"},{title:"PDA Architecture",path:"/v6.1/docs/concepts/pda-architecture"}]},{title:"Reference",children:[{title:"Entando APIs",path:"/v6.1/docs/reference/entando-apis.md"},{title:"Deployment Structure",path:"/v6.1/docs/reference/deployment-structure.md"},{title:"Freemarker Core Tags",path:"/v6.1/docs/reference/freemarker-tags/freemarker-core-tags.md"},{title:"Freemarker CMS Tags",path:"/v6.1/docs/reference/freemarker-tags/freemarker-JACMS-tags.md"}]},{title:"Releases",path:"/v6.1/docs/releases/"}],"/v6.1/tutorials/":[{title:"Micro Frontends",path:"/v6.1/tutorials/micro-frontends",children:[{title:"React",path:"/v6.1/tutorials/micro-frontends/react.md"},{title:"Angular",path:"/v6.1/tutorials/micro-frontends/angular.md"},{title:"Communication",path:"/v6.1/tutorials/micro-frontends/communication.md"},{title:"Config",path:"/v6.1/tutorials/micro-frontends/widget-configuration/"},{title:"Blueprint",path:"/v6.1/tutorials/micro-frontends/generate-micro-frontends-from-a-database-entity/"},{title:"Authentication",path:"/v6.1/tutorials/micro-frontends/authentication/"}]},{title:"Microservice Applications",children:[{title:"Generate Microservices and Micro Frontends",path:"/v6.1/tutorials/backend-developers/generate-microservices-and-micro-frontends"}]},{title:"Content Management",children:["/v6.1/tutorials/cms/app-builder/hello-world","/v6.1/tutorials/cms/content-types-tutorial","/v6.1/tutorials/cms/list-of-Content-attributes","/v6.1/tutorials/cms/content-models-tutorial","/v6.1/tutorials/cms/contents-tutorial","/v6.1/tutorials/cms/digital-assets-tutorial","/v6.1/tutorials/cms/publish-a-content-tutorial"]},{title:"Component Repository",children:["/v6.1/tutorials/ecr/ecr-overview","/v6.1/tutorials/ecr/ecr-bundle-details","/v6.1/tutorials/ecr/ecr-bundle-filters","/v6.1/tutorials/ecr/ecr-bundle-presentation-config","/v6.1/tutorials/ecr/ecr-uninstall-flow","/v6.1/tutorials/ecr/ecr-troubleshooting-guide","/v6.1/tutorials/ecr/how-to-create-local-npm-registry","/v6.1/tutorials/ecr/how-to-setup-nexus-on-kubernetes-cluster","/v6.1/tutorials/ecr/tutorials/create-ecr-bundle-from-npm","/v6.1/tutorials/ecr/tutorials/from-blueprint-to-de","/v6.1/tutorials/ecr/tutorials/ecr-deploy-use-plugin-and-mfe-without-bundle"]},{title:"Extend the Platform",children:[{title:"Extend App Builder",path:"/v6.1/tutorials/customize-the-platform/extend-app-builder"},{title:"Add REST API",path:"/v6.1/tutorials/customize-the-platform/add-rest-api"},{title:"Process Driven Applications (PDA)",path:"/v6.1/tutorials/customize-the-platform/pda-tutorial"},{title:"Change Default Datasource",path:"/v6.1/tutorials/customize-the-platform/change-default-datasources-and-connections/"}]},{title:"Configuration and Operations",children:[{title:"External Database",path:"/v6.1/tutorials/devops/external-database/"},{title:"External Identity Management System",path:"/v6.1/tutorials/devops/external-keycloak/"},{title:"Entando Docker Image",path:"/v6.1/tutorials/devops/build-core-image"},{title:"Backing Up and Restoring Your Environment",path:"/v6.1/tutorials/devops/backing-up-and-restoring-your-environment"}]}]},entando:{section:"Docs",version:"7.0",docs:[{text:"Docs",items:[{text:"NEXT",link:"/next/docs/"},{text:"7.0",link:"/v7.0/docs/"},{text:"6.3.2",link:"/v6.3.2/docs/"},{text:"6.3",link:"/v6.3/docs/"},{text:"6.2",link:"/v6.2/docs/"},{text:"6.1",link:"/v6.1/docs/"},{text:"5.3",link:"/old-version/old-version.html",target:"_blank"}]}],tutorials:[{text:"Tutorials",items:[{text:"NEXT",link:"/next/tutorials/"},{text:"7.0",link:"/v7.0/tutorials/"},{text:"6.3.2",link:"/v6.3.2/tutorials/"},{text:"6.3",link:"/v6.3/tutorials/"},{text:"6.2",link:"/v6.2/tutorials/"},{text:"6.1",link:"/v6.1/tutorials/"},{text:"5.3",link:"/old-version/old-version.html",target:"_blank"}]}]}}};t(338);Lo.component("EntandoRedirect",(function(){return t.e(184).then(t.bind(null,950))})),Lo.component("LandingPage",(function(){return Promise.all([t.e(0),t.e(34)]).then(t.bind(null,951))})),Lo.component("EntandoVersionLinks",(function(){return Promise.all([t.e(0),t.e(1),t.e(67)]).then(t.bind(null,952))})),Lo.component("Tracking",(function(){return t.e(185).then(t.bind(null,1450))})),Lo.component("CodeGroup",(function(){return Promise.all([t.e(0),t.e(70)]).then(t.bind(null,953))})),Lo.component("Badge",(function(){return Promise.all([t.e(0),t.e(68)]).then(t.bind(null,1451))})),Lo.component("CodeBlock",(function(){return Promise.all([t.e(0),t.e(69)]).then(t.bind(null,954))}));t(339);function js(e,n){var t="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!t){if(Array.isArray(e)||(t=Object(Jr.a)(e))||n&&e&&"number"==typeof e.length){t&&(e=t);var a=0,o=function(){};return{s:o,n:function(){return a>=e.length?{done:!0}:{done:!1,value:e[a++]}},e:function(e){throw e},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,r=!0,s=!1;return{s:function(){t=t.call(e)},n:function(){var e=t.next();return r=e.done,e},e:function(e){s=!0,i=e},f:function(){try{r||null==t.return||t.return()}finally{if(s)throw i}}}}var qs=t(340),Bs=[{},function(e){e.Vue.mixin({computed:{$dataBlock:function(){return this.$options.__data__block__}}})},{},{},function(e){e.Vue,e.options;var n=e.router,t=e.siteData,a=qs(t.pages,(function(e,n){if(n.frontmatter&&n.frontmatter.redirectFrom){var t,a=n.frontmatter.redirectFrom,o=js(Array.isArray(a)?a:[a]);try{for(o.s();!(t=o.n()).done;){var i=t.value;e.push({from:i,to:n.path})}}catch(e){o.e(e)}finally{o.f()}}}),[]);function o(e,n){return e.toLowerCase().replace(/\/$/,"")===n.toLowerCase().replace(/\/$/,"")}n.beforeEach((function(e,t,i){if(r=e.path,n.options.routes.some((function(e){return o(e.path,r)})))return i();var r,s,l=js(a);try{for(l.s();!(s=l.n()).done;){var d=s.value;if(o(e.path,d.from))return i(d.to)}}catch(e){l.e(e)}finally{l.f()}i()}))},function(e){var n=e.router;e.isServer||(window.Entando=window.Entando||{},window.Entando.versionedLink=function(){var e=o(regeneratorRuntime.mark((function e(t){var a,o,i,r,s,l,d;return regeneratorRuntime.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return a=window.location.pathname,o=a.indexOf("/v"),i=a.indexOf("/next/"),r=t,(o>=0||i>=0)&&(s=o>=0?o:i,l=a.indexOf("/",s+2),d=a.substring(s,l),r=d+t),e.prev=5,e.next=8,n.push(r);case 8:e.next=12;break;case 10:e.prev=10,e.t0=e.catch(5);case 12:case"end":return e.stop()}}),e,null,[[5,10]])})));return function(n){return e.apply(this,arguments)}}())},function(e){e.Vue.component("CodeCopy",Ds)}],Fs=[];function _s(e,n){return(_s=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}t(179),t(180);function Ks(e){return(Ks=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function Ws(e,n){if(n&&("object"===Sr(n)||"function"==typeof n))return n;if(void 0!==n)throw new TypeError("Derived constructors may only return object or undefined");return function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e)}function Gs(e){var n=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var t,a=Ks(e);if(n){var o=Ks(this).constructor;t=Reflect.construct(a,arguments,o)}else t=a.apply(this,arguments);return Ws(this,t)}}var Hs=function(e){!function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),n&&_s(e,n)}(t,e);var n=Gs(t);function t(){return us(this,t),n.apply(this,arguments)}return hs(t)}(function(){function e(){us(this,e),this.store=new Lo({data:{state:{}}})}return hs(e,[{key:"$get",value:function(e){return this.store.state[e]}},{key:"$set",value:function(e,n){Lo.set(this.store.state,e,n)}},{key:"$emit",value:function(){var e;(e=this.store).$emit.apply(e,arguments)}},{key:"$on",value:function(){var e;(e=this.store).$on.apply(e,arguments)}}]),e}());Object.assign(Hs.prototype,{getPageAsyncComponent:Wr,getLayoutAsyncComponent:Gr,getAsyncComponent:Hr,getVueComponent:zr});var zs={install:function(e){var n=new Hs;e.$vuepress=n,e.prototype.$vuepress=n}};t(117);function Ys(e){e.beforeEach((function(n,t,a){if(Vs(e,n.path))a();else if(/(\/|\.html)$/.test(n.path))if(/\/$/.test(n.path)){var o=n.path.replace(/\/$/,"")+".html";Vs(e,o)?a(o):a()}else a();else{var i=n.path+"/",r=n.path+".html";Vs(e,r)?a(r):Vs(e,i)?a(i):a()}}))}function Vs(e,n){var t=n.toLowerCase();return e.options.routes.some((function(e){return e.path.toLowerCase()===t}))}var Js={props:{pageKey:String,slotKey:{type:String,default:"default"}},render:function(e){var n=this.pageKey||this.$parent.$page.key;return Vr("pageKey",n),Lo.component(n)||Lo.component(n,Wr(n)),Lo.component(n)?e(n):e("")}},Xs={functional:!0,props:{slotKey:String,required:!0},render:function(e,n){var t=n.props,a=n.slots;return e("div",{class:["content__".concat(t.slotKey)]},a()[t.slotKey])}},Qs={computed:{openInNewWindowTitle:function(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},$s=(t(348),t(349),Object(Rs.a)(Qs,(function(){var e=this.$createElement,n=this._self._c||e;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports);function Zs(){return(Zs=o(regeneratorRuntime.mark((function e(n){var t,a,o,i;return regeneratorRuntime.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return t="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:Ns.routerBase||Ns.base,Ys(a=new Cr({base:t,mode:"history",fallback:!1,routes:Ls,scrollBehavior:function(e,n,t){return t||(e.hash?!Lo.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(e.hash)}:{x:0,y:0})}})),o={},e.prev=4,e.next=7,Promise.all(Bs.filter((function(e){return"function"==typeof e})).map((function(e){return e({Vue:Lo,options:o,router:a,siteData:Ns,isServer:n})})));case 7:e.next=12;break;case 9:e.prev=9,e.t0=e.catch(4),console.error(e.t0);case 12:return i=new Lo(Object.assign(o,{router:a,render:function(e){return e("div",{attrs:{id:"app"}},[e("RouterView",{ref:"layout"}),e("div",{class:"global-ui"},Fs.map((function(n){return e(n)})))])}})),e.abrupt("return",{app:i,router:a});case 14:case"end":return e.stop()}}),e,null,[[4,9]])})))).apply(this,arguments)}Lo.config.productionTip=!1,Lo.use(Cr),Lo.use(zs),Lo.mixin(function(e,n){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Lo;Pr(n),t.$vuepress.$set("siteData",n);var a=e(t.$vuepress.$get("siteData")),o=new a,i=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(o)),r={};return Object.keys(i).reduce((function(e,n){return n.startsWith("$")&&(e[n]=i[n].get),e}),r),{computed:r}}((function(e){return function(){function n(){us(this,n)}return hs(n,[{key:"setPage",value:function(e){this.__page=e}},{key:"$site",get:function(){return e}},{key:"$themeConfig",get:function(){return this.$site.themeConfig}},{key:"$frontmatter",get:function(){return this.$page.frontmatter}},{key:"$localeConfig",get:function(){var e,n,t=this.$site.locales,a=void 0===t?{}:t;for(var o in a)"/"===o?n=a[o]:0===this.$page.path.indexOf(o)&&(e=a[o]);return e||n||{}}},{key:"$siteTitle",get:function(){return this.$localeConfig.title||this.$site.title||""}},{key:"$canonicalUrl",get:function(){var e=this.$page.frontmatter.canonicalUrl;return"string"==typeof e&&e}},{key:"$title",get:function(){var e=this.$page,n=this.$page.frontmatter.metaTitle;if("string"==typeof n)return n;var t=this.$siteTitle,a=e.frontmatter.home?null:e.frontmatter.title||e.title;return t?a?a+" | "+t:t:a||"VuePress"}},{key:"$description",get:function(){var e=function(e){if(e){var n=e.filter((function(e){return"description"===e.name}))[0];if(n)return n.content}}(this.$page.frontmatter.meta);return e||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}},{key:"$lang",get:function(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}},{key:"$localePath",get:function(){return this.$localeConfig.path||"/"}},{key:"$themeLocaleConfig",get:function(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}},{key:"$page",get:function(){return this.__page?this.__page:function(e,n){for(var t=0;t<e.length;t++){var a=e[t];if(a.path.toLowerCase()===n.toLowerCase())return a}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}}]),n}()}),Ns)),Lo.component("Content",Js),Lo.component("ContentSlotsDistributor",Xs),Lo.component("OutboundLink",$s),Lo.component("ClientOnly",{functional:!0,render:function(e,n){var t=n.parent,a=n.children;if(t._isMounted)return a;t.$once("hook:mounted",(function(){t.$forceUpdate()}))}}),Lo.component("Layout",Gr("Layout")),Lo.component("NotFound",Gr("NotFound")),Lo.prototype.$withBase=function(e){var n=this.$site.base;return"/"===e.charAt(0)?n+e.slice(1):e},window.__VUEPRESS__={version:"1.9.5",hash:"3bf15678"},function(e){return Zs.apply(this,arguments)}(!1).then((function(e){var n=e.app;e.router.onReady((function(){n.$mount("#app")}))}))}]);